This file contains an up-to-date list of unimplemented features and
known bugs in the compiler.  This list is not meant to be complete as the
language is still being defined.  In particular, missing functions
from the standard modules are not enumerated.

Variables and Types
===================
  * Non-ASCII strings
  * Conversions from strings to other primitive types
  * Configuration parameters
  * Primitive type casts on arrays and sequences
  * Parameter folding of conditional expressions

  * bugs
    - Converting unsigned integers to complex
    - Unreliable const assignment error detection
    - Real literal initizalizer for real(32) type
    - Allow use before def of globals
    - Parameter folding on bools and uint<->int
       - true + true ==> true instead of 2
    - Using type aliases across modules
    - Using parameters and constants across modules
    - Iterators with parameter arguments

Modules
=======
  * The argv sequence
  * Accessing variables via explicit names, e.g., mod.x
  * Using modules not explicitly passed to the compiler

  * bugs
    - Using type aliases across modules
    - Using parameters and constants across modules

Functions
=========
  * Formal arguments in a tuple
  * Intents
  * Functions as variables and/or arguments to functions
  * Formal arguments of tuple type must match actual arguments exactly
  * Promotion over variable and setter functions does not work
    - s(p)(r) = 0  where s, p, and r are sequences of integers

  * bugs
    - More visible nested functions are not more specific
    - Return statements in type select statements
Future (deitz) [Error matching program output for functions/deitz/test_default_type]

Classes, Records, and Unions
============================
  * Nested classes and records
  * Chained constructor calls for derived classes
  * Shadowing base class fields
  * Inheriting from multiple classes
  * Garbage collection
  * Anonymous record literals
  * Type select on unions
  * Assignment between classes and records

  * bugs
    - Class field of array type specified indirectly via a type alias
    - Iterator methods in classes
    - Class field initialized with conditional expression

Tuples, Sequences, and Iterators
================================
  * Ignoring values via underscores
  * Implicit reductions in conditional, while, and select statements
  * The transpose, spread, and reshape functions
  * Indexing by indefinite arithmetic sequences
  * Zipper iteration bounds matching

  * bugs
    - Iterator methods in classes
    - Iterator with tuple return type such as rank*int
    - Iterators with parameter arguments
    - Iterators with parameter locals
    - Iterators with intents
    - Recursive iterators
    - Anonymous domain in iterator

Arrays and Domains
==================
  * Sparse arrays and domains
  * Opaque arrays and domains
  * Enumerated arrays and domains
  * Arrays of arrays
  * Index type bounds checking
  * Subdomains
  * Array promotion returns sequences

  * bugs
    - Indefinite domains of explicit tuple type
       - var td: domain((int, int))
    - Element-wise negation of components of the element type of arrays
       - var A: [1..4] complex; A.im = -A.im;
    - Array of sync/single variables
    
Generics
========

  * bugs
    - Generic functions without return statements in paths that will be
       eliminated via parameter folding
    - Type aliases in generic class defined by instantiated types

Parallelism and Synchronization
===============================
  * Atomic statements
  * Serial statements
  * User-defined reductions and scans
  * Forall loops and ordered forall loops are serialized
  * Reductions and scans are serialized
  * Array and sequence operations and assignment are serialized

  * bugs
    - Arrays of synchronization variables
    - Synchronization variables in the expression of a conditional statement
    - Begin blocks that use sync/single variables that are locals

Locality and Distributions
==========================
  * Locales
  * Distributions

Standard Library
================
  * bugs
    - log2(n):int != log2(n:int)

compiler
========

  * bugs
    - error messages are incomplete and/or inaccurate
    - help message printing config vars and their values
