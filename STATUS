============================
Chapel Implementation Status
============================

This file contains a list of unimplemented features and known bugs in
the Chapel implementation.  If you find additional bugs and
unimplemented features, or if you would like to request prioritization
of items in this file, please let us know at chapel_bugs@cray.com or
chapel_info@cray.com.  Please feel encouraged to err on the side of
mailing us with any issues you run into.


-------
General
-------

Unimplemented Features:
- Many error messages continue to be incorrect/confusing/unhelpful
  Workaround: Please ask us for help interpreting any that you struggle with
- Compiler and runtime errors don't always report useful line numbers
- Generated executable's command-line parsing is not as robust as one would like


--------------------------------
Variables, Types and Expressions
--------------------------------

Unimplemented Features:
- Configuration variables of tuple types

Bugs:
- Const arrays can currently be assigned -- should result in a compiler error
- Parameters in branches of conditional expressions are not implicitly coerced
  e.g., var x:uint;  if (t) then x else 1;  // 1 should be coerced to uint


-------
Modules
-------

Unimplemented Features:
- The argv array is unimplemented
- Using modules in files not named on the compiler's command-line is unsupported

Bugs:
- Two modules sharing the same name break compilation (whether legal or illegal)


---------
Functions
---------

Unimplemented Features:
- Functions as variables and/or arguments to functions
- Array arguments cannot have both their domain and element types queried
- Coercions of tuple argument components to match formals

Bugs:
- Analysis to find return statements along all paths in a function is incomplete
- Return statements in type select statements are not recognized correctly
- Illegal actual arguments to inout intents are not always caught
- Promoting var functions can result in a compilation error
- Var functions should be able to return array slices but cannot


----------------------------
Classes, Records, and Unions
----------------------------

Unimplemented Features:
- Constructors are not particularly well-supported
  - chained constructors for derived classes are not implemented
  - constructors for generic classes cause problems
  - constructing nested classes does not work consistently
- Multiple inheritance is not implemented
- Shadowing base class fields is not implemented
- Garbage collection is implemented only at a prototype level
- Anonymous record literals are not supported
- Type select on unions is not implemented
- Assignment between classes and records is unimplemented

Bugs:
- Class fields of array type specified using a type alias don't work
- Class fields of array types that are initialized can cause compile error
  Workaround: initialize field in initialize() method
- Class fields initialized with conditional expressions fail to compile
- Subclassing uninstantiated generic classes should be prohibited but is not


-----------------------------
Tuples, Ranges, and Iterators
-----------------------------

Unimplemented Features:
- Slicing strided ranges is not yet supported
- Zipper iteration over var iterators is not yet supported


------------------
Arrays and Domains
------------------

Unimplemented Features:
- The transpose, spread, and reshape functions
- Short-circuiting functions and conditional expressions cannot be promoted
- Arrays of arrays are not implemented
- Opaque domains and arrays are not implemented
- Index type bounds checking is not implemented
- Checking that subdomain are index subsets is not implemented
- Slicing strided domains and arrays is not implemented
- Sparse domains/arrays can't be sliced or used to slice dense domains/arrays
- Sparse domains don't support remove/-= methods

Bugs:
- Array promotion/forall expressions evaluate to 1D arrays
    e.g., foo(A) where A promotes foo() should result in an array of type:
          [A.domain] foo(A(i)).type but instead results in a 1D array
    e.g., [i in D] foo(i) should result in an array of type: [D] foo(i).type
          but instead results in a 1D array
- Associative domains of explicit heterogeneous tuple types don't work
    e.g., var td: domain((int, int));
  Workaround: name the tuple type
    e.g., type td_t = (int, int);  var td: domain(td_t);
- Mixing dimensional index types in a domain specification yields poor errors
    e.g., var m: uint, n: int;  ... [1..m, 1..n]
- Declaring an array using "var A: [i in D] real;" causes seg fault


--------
Generics
--------

Bugs:
- Type members in generic class defined by instantiated types


-------------------------------
Parallelism and Synchronization
-------------------------------

Unimplemented Features:
- Atomic statements
- Whole-array assignment does not work for arrays of sync variables
- User-defined reductions and scans
- Many concepts that should be parallel are executed sequentially:
  - forall loops, promoted calls, reductions, and scans
- If there are insufficient threads to spawn a task, the program halts


--------------------------
Locality and Distributions
--------------------------

Unimplemented Features:
- Executing using multiple locales
- Distributions


----------------
Input and Output
----------------

Unimplemented Features:
- a mechanism for controlling the precision/width of scalar values

Bugs:
- read()s of whole arrays are not working
  e.g., read(A);
  Workaround: use a loop and read in the elements one at a time
  e.g., for i in A.domain read(A(i));


-----------------
Standard Library
-----------------

Unimplemented Features:
- 32-bit math routines are unimplemented, causing coercion to 64-bit versions
