============================
Chapel Implementation Status
============================

This file contains a list of unimplemented features and known bugs in
the Chapel implementation.  If you find additional bugs and
unimplemented features, or if you would like to request prioritization
of items in this file, please let us know at chapel_bugs@cray.com or
chapel_info@cray.com.  Please feel encouraged to err on the side of
mailing us with any issues you run into.


-------
General
-------

Unimplemented Features:
- Many error messages continue to be incorrect/confusing/unhelpful
  Workaround: Please ask us for help interpreting any that you struggle with
- Compiler and runtime errors don't always report useful line numbers
  Workaround: Please ask us for help finding the correct error location


--------------------------------
Variables, Types and Expressions
--------------------------------

Unimplemented Features:
- Configuration variables of tuple types

Bugs:
- Const arrays can currently be assigned -- should result in a compiler error
- General expressions can (incorrectly) be used as type expressions


-------
Modules
-------

Unimplemented Features:
- The argv array is unimplemented
- Using modules in files not named on the compiler's command-line is unsupported

Bugs:
- symbol resolution for external modules is sometimes incorrect


---------
Functions
---------

Unimplemented Features:
- Functions as variables and/or arguments to functions
- Array arguments cannot have both their domain and element types queried

Bugs:
- Actual arguments passed by inout intent are not always checked for legality
- Analysis to find return statements along all paths in a function is incomplete
- Promoting var functions can result in an incorrect compilation error
- Var functions currently cannot return array slices
- Varargs functions cannot query both element type and number of elements


----------------------------
Classes, Records, and Unions
----------------------------

Unimplemented Features:
- Constructors are not particularly well-supported
  - chained constructors for derived classes are not implemented
  - constructors for generic classes cause problems
  - constructing nested classes does not work consistently
  Workaround: try using the default constructor and initialize() function
- Multiple inheritance is not implemented
- Shadowing base class fields is not implemented
- Garbage collection is implemented only at a prototype level
- Assignment between classes and records is unimplemented
- Anonymous record literals are not supported
- Type select on unions is not implemented

Bugs:
- Class fields initialized with conditional expressions fail to compile
- Subclassing uninstantiated generic classes should be prohibited but is not
- Where clauses in dynamic dispatch situations may not work properly
- No error message generated when constructors/initializers call methods


-----------------------------
Tuples, Ranges, and Iterators
-----------------------------

Unimplemented Features:
- Zipper iteration over var iterators is not yet supported

Bugs:
- nested var iterators can cause problems


------------------
Arrays and Domains
------------------

Unimplemented Features:
- Arrays of arrays are not implemented
- Opaque domains and arrays are not implemented
- The transpose, spread, and reshape functions are not implemented
- Short-circuiting functions and conditional expressions cannot be promoted
- index(D) bounds checking is not implemented
- Subdomain subset checking is not implemented
- Sparse domains/arrays can't be sliced or used to slice dense domains/arrays
- Sparse domains don't support remove/-= methods

Bugs:
- Array promotion/forall expressions evaluate to 1D arrays
    e.g., foo(A) where A promotes foo() should result in an array of type:
          [A.domain] foo(A(i)).type but instead results in a 1D array
    e.g., [i in D] foo(i) should result in an array of type: [D] foo(i).type
          but instead results in a 1D array
- Arrays sliced with unbounded ranges are not bounds-checked
- Records/classes with array members of recursive types do not work
  Workaround: use an explicit loop and indexing
- Mixing dimensional index types in a domain specification yields poor errors
    e.g., var m: uint, n: int;  ... [1..m, 1..n]
- Rank-change slicing a domain down to 0 dimensions causes problems


--------
Generics
--------


-------------------------------
Parallelism and Synchronization
-------------------------------

Unimplemented Features:
- Atomic statements are not implemented
- Data parallel concepts that should run concurrently are implemented serially
    e.g., forall loops, promoted calls, reductions, scans
- Tasks are not queued, so a program halts if there aren't sufficient threads


--------------------
Reductions and Scans
--------------------

Unimplemented Features:
- User-defined reductions and scans are not implemented

Bugs:
- Reductions/scans involving identifiers named 'r' can produce incorrect results


--------------------------
Locality and Distributions
--------------------------

Unimplemented Features:
- Executing general code using multiple locales
- Distributions


----------------
Input and Output
----------------

Unimplemented Features:
- a mechanism for controlling the output precision/width of scalar values
  Workaround: extern sprintf()

Bugs:
- read()s of whole arrays are not working
  e.g., read(A);
  Workaround: use a loop and read in the elements one at a time
  e.g., for i in A.domain read(A(i));


-----------------
Standard Library
-----------------

Unimplemented Features:
- 32-bit math routines are unimplemented, causing coercion to 64-bit versions
