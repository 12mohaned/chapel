============================
Chapel Implementation Status
============================

This file contains a list of unimplemented features and known bugs in
the Chapel implementation.  If you find additional bugs and
unimplemented features, or if you would like to request prioritization
of items in this file, please let us know at chapel_bugs@cray.com or
chapel_info@cray.com.  Please feel encouraged to err on the side of
mailing us with any issues you run into.


-------
General
-------

Unimplemented Features:

* Many error messages continue to be incorrect/confusing/unhelpful
  Workaround: Please ask us for help interpreting any that you struggle with

* Compiler and runtime errors don't always report useful line numbers

* Generated executable's command-line parsing is not as robust as one would like


--------------------------------
Variables, Types and Expressions
--------------------------------

Unimplemented Features:
* Non-ASCII strings
* Conversions from strings to other primitive types
* Parameter folding of conditional expressions
* Configuration variables of tuple types

Bugs:

* Const arrays can currently be assigned -- should result in a compiler error

* Parameters in branches of conditional expressions are not implicitly coerced
  e.g., var x:uint;  if (t) then x else 1;  // 1 should be coerced to uint

* Assigning nil to a list/record results in confusing error messages


-------
Modules
-------

Unimplemented Features:
* The argv array
* Using modules in files not named on the compiler's command-line

Bugs:
* Two modules sharing the same name break compilation (whether legal or illegal)


---------
Functions
---------

Unimplemented Features:
* Functions as variables and/or arguments to functions
* Array arguments cannot have both their domain and element types queried
* Coercions of tuple argument components to match formals
* Formal arguments of inferred type should be constrained by their default value

Bugs:

* Analysis to find return statements along all paths in a function is incomplete

* Return statements in type select statements are not recognized correctly

* Destructuring tuple arguments disables overloads of that function name
    e.g., def foo((a,b), c) breaks ability to create other overloads of foo()

* Actual arguments passed using inout intents are not checked for legality

* Promoting var functions can result in a compilation error

* Var functions should not be permitted to return locals or literals but can

* Setter functions should not be permitted to return anything, but currently can


----------------------------
Classes, Records, and Unions
----------------------------

Unimplemented Features:

* Constructors are not particularly well-supported
  - chained constructors for derived classes are not implemented
  - constructors for generic classes cause problems
  - constructing nested classes does not work consistently

* Multiple inheritance is not implemented

* Shadowing base class fields is not implemented

* Garbage collection is implemented only at a prototype level

* Anonymous record literals are not supported

* Type select on unions is not implemented

* Assignment between classes and records is unimplemented

Bugs:

* Class fields of array type specified using a type alias don't work

* Class fields of array types that are initialized can cause compile error
  Workaround: initialize field in initialize() method

* Class fields initialized with conditional expressions fail to compile

* Subclassing uninstantiated generic classes should be prohibited but is not


-----------------------------
Tuples, Ranges, and Iterators
-----------------------------

Unimplemented Features:
* Slicing strided ranges is not yet supported
* Zipper iteration over var iterators is not yet supported

------------------
Arrays and Domains
------------------

Unimplemented Features:
* The transpose, spread, and reshape functions
* Short-circuiting functions and conditional expressions cannot be promoted
* Arrays of arrays are not implemented
* Opaque domains and arrays are not implemented
* Index type bounds checking is not implemented
* Checking that subdomain are index subsets is not implemented
* Slicing strided domains and arrays is not implemented

Bugs:

* Array promotion/forall expressions evaluate to 1D arrays
    e.g., foo(A) where A promotes foo() should result in an array of type:
          [A.domain] foo(A(i)).type but instead results in a 1D array
    e.g., [i in D] foo(i) should result in an array of type: [D] foo(i).type
          but instead results in a 1D array

* Domains arguments are passed by const rather than by reference

* Sparse arrays can't be sliced with dense domains

* Associative domain index additions/deletions can result in an infinite loop

* Associative domains of explicit heterogeneous tuple types don't work
    e.g., var td: domain((int, int));
  Workaround: name the tuple type
    e.g., type td_d = (int, int);  var td: domain(td_t);

* Mixing dimensional index types in a domain specification yields poor errors
    e.g., var m: uint, n: int;  ... [1..m, 1..n]


--------
Generics
--------

Bugs:
* Type members in generic class defined by instantiated types


-------------------------------
Parallelism and Synchronization
-------------------------------

Unimplemented Features:
* Atomic statements
* Whole-array assignment to sync arrays does not work
* User-defined reductions and scans
* Forall loops and ordered forall loops are serialized
* Reductions and scans are serialized
* Array operations and assignment are serialized
* If there are insufficient threads to spawn a task, the program halts

Bugs:

* Applying op= style assignments to sync vars does not work
    e.g., var x: sync int = 0;   x += 1;
  Workaround: expand operator manually
    e.g., x = x + 1;


--------------------------
Locality and Distributions
--------------------------

Unimplemented Features:
* Executing using multiple locales
* Distributions


----------------
Input and Output
----------------

Unimplemented Features:
* a mechanism for controlling the precision/width of scalar values

Bugs:
* read()s of whole arrays are not working
    e.g., read(A);
  Workaround: use a loop and read in the elements one at a time
    e.g., for i in A.domain read(A(i));


-----------------
Standard Library
-----------------

Unimplemented Features:
* 32-bit math routines are unimplemented, causing coercion to 64-bit versions
