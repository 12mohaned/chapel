#include "mli_common_code.c"

//
// The definition of this is generated by the compiler.
//
int64_t chpl_mli_sdispatch(int64_t id, void* arg, void* res);

//
// A little bit of global context will do us good in the long run.
//
struct chpl_mli_context chpl_server;

void chpl_mli_server_init(struct chpl_mli_context* server) {
  if (server->context) { return; }

  server->context = zmq_ctx_new();
  server->main    = zmq_socket(server->context, ZMQ_REP);
  server->arg     = zmq_socket(server->context, ZMQ_SUB);
  server->res     = zmq_socket(server->context, ZMQ_PUB);
  
  return;
}

void chpl_mli_server_deinit(struct chpl_mli_context* server) {
  if (!server->context) { return; }

  // TODO: Set socket LINGER to 0 to prevent blocking.
  zmq_ctx_destroy(server->context);
  server->context = NULL;

  return;
}

//
// Server should drop down into this via injecting a call into the ast.
//
int chpl_mli_smain(int argc, char** argv) {
  int64_t function = -1;
  int64_t ack = 0;
  int execute = 1;
  int err = 0;

  // For the most part, looks just like client in reverse.
  chpl_mli_server_init(&chpl_server);

  // Just hardcode these connection values for now.  
  chpl_mli_connect(chpl_server.main, "localhost", "5555");
  chpl_mli_connect(chpl_server.arg, "localhost", "5555");
  chpl_mli_connect(chpl_server.res, "localhost", "5555");

  while (execute) {
    // Every transaction starts by reading an int64 off the wire.
    err = chpl_mli_pull(
              chpl_server.main,
              &function,
              sizeof(function),
              0);

    // TODO: Handle socket errors on inbound read.
    if (err < 0) {
      execute = 0;
      ack = CHPL_MLI_ERROR_SOCKET;
    }

    // TODO: For now, just terminate execution of the server upon error.
    if (execute && function < 0) {
      execute = 0;
      ack = CHPL_MLI_ERROR_SHUTDOWN;
    } else {
      ack = chpl_mli_sdispatch(function, chpl_server.arg, chpl_server.res);
    }

    // We should always reply so that the client does not block.
    err = chpl_mli_push(chpl_server.main, &ack, sizeof(ack), 0);

    // TODO: Handle socket errors on outbound push.
    if (err < 0) { ;;; }
  }

  // If we made it this far, we're free to exit.
  chpl_mli_server_deinit(&chpl_server);

  return 0;
}

