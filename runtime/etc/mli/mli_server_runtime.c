#include "mli_common_code.c"
#include <time.h>

//
// The definition of this is generated by the compiler.
// TODO: Make extern later?
//
int64_t chpl_mli_sdispatch(int64_t id);

//
// The definition of this is generated by the compiler.
// TODO: Make extern later?
//
void chpl_mli_server_set_conf(void);

struct chpl_mli_gen_conf {

  int debug;

};

//
// These can be set to TRUE by generated code via a generated setter.
//
struct chpl_mli_gen_conf chpl_server_conf = {
  .debug  = 0,
};

//
// A little bit of global context will do us good in the long run.
//
struct chpl_mli_context chpl_server;

void chpl_mli_server_init(struct chpl_mli_context* server) {
  if (server->context) { return; }

  server->context = zmq_ctx_new();
  server->main    = zmq_socket(server->context, ZMQ_REP);
  server->arg     = zmq_socket(server->context, ZMQ_SUB);
  server->res     = zmq_socket(server->context, ZMQ_PUB);
    
  return;
}

void chpl_mli_server_deinit(struct chpl_mli_context* server) {
  if (!server->context) { return; }

  // TODO: Set socket LINGER to 0 to prevent blocking.
  zmq_ctx_destroy(server->context);
  server->context = NULL;

  return;
}

//
// TODO: Write a more elegant wrapper around printf.
//
// Only valid in the context of the server main loop for now. Expects the
// "chpl_server_conf" global to be present.
//
#define chpl_mli_sdebugf(fmt, ...)              \
  do {                                          \
    if (!chpl_server_conf.debug) { break; }     \
      printf("%s ", "[MLI-Server]");            \
      printf(fmt, __VA_ARGS__);                 \
  } while (0)

//
// TODO
// 
// Server takes no arguments for now to make dropping into it easier. Later,
// we may want to pass it argc/argv, which will make things a bit more
// complicated with regards to AST transformations. But for now, don't pass
// it anything.
// --
//
void chpl_mli_smain(void) {
  int64_t function = -1;
  int64_t ack = 0;
  int execute = 1;
  int err = 0;
  clock_t before = clock();
  double seconds = 0;

  // Just hardcode the connection values for now.
  const char* ip = "localhost";
  const char* mainport = "5555";
  const char* argport = "5556";
  const char* resport = "5557";

  // Globals that the compiler can override.
  chpl_mli_server_set_conf();

  // For the most part, looks just like client in reverse.
  chpl_mli_server_init(&chpl_server);

  // TODO: Should we bind these ports in init (and close in deinit)?
  chpl_mli_bind(chpl_server.main, ip, mainport);
  chpl_mli_bind(chpl_server.arg, ip, argport);
  chpl_mli_bind(chpl_server.res, ip, resport);

  chpl_mli_sdebugf("Main port on: %s, %s\n", ip, mainport);
  chpl_mli_sdebugf("Arg port on: %s, %s\n", ip, argport);
  chpl_mli_sdebugf("Res port on: %s, %s\n", ip, resport);

  while (execute) {
    // Every transaction starts by reading an int64 off the wire.
    err = chpl_mli_pull(
              chpl_server.main,
              &function,
              sizeof(function),
              0);

    // TODO: Handle socket errors on inbound read.
    if (err < 0) {
      chpl_mli_sdebugf("Socket error on read: %d\n", err);
      execute = 0;
      ack = CHPL_MLI_ERROR_SOCKET;
    }

    // TODO: For now, just terminate execution of the server upon error.
    if (execute && function < 0) {
      chpl_mli_sdebugf("Shutdown, code: %lld\n", function);
      execute = 0;
      ack = CHPL_MLI_ERROR_SHUTDOWN;
    } else {
      chpl_mli_sdebugf("Dispatch on id: %lld\n", function);
      ack = chpl_mli_sdispatch(function);
    }

    // We should always reply so that the client does not block.
    chpl_mli_sdebugf("Responding with error: %s\n", chpl_mli_errstr(ack));
    err = chpl_mli_push(chpl_server.main, &ack, sizeof(ack), 0);

    // TODO: Handle socket errors on outbound push.
    if (err < 0) { chpl_mli_sdebugf("Socket error on write: %d\n", err); }
  }

  seconds = (double) (clock() - before) / (double) CLOCKS_PER_SEC;

  // If we made it this far, we're free to exit.
  chpl_mli_server_deinit(&chpl_server);

  chpl_mli_sdebugf("Graceful shutdown, time elapsed: %gs\n", seconds);

  return;
}

