<html>
<head>
<title>DParser for Python Documentation</title>
</head>
<body bgcolor="#ffffff">
<h1>DParser for Python Documentation</h1>
<p>
This page describes <a href="index.html">the Python interface to DParser</a>.  Please see <a href="http://dparser.sourceforge.net/d/manual.html">the DParser manual</a>
for more detailed information on DParser.
<ul>
<li><a href="py_dparser_manual.html#BI">basic ideas</a>
<li><a href="py_dparser_manual.html#AA">arguments to actions</a>
<li><a href="py_dparser_manual.html#ADP">arguments to dparser.Parser()</a>
<li><a href="py_dparser_manual.html#AP">arguments to dparser.Parser.parse()</a>
<li><a href="py_dparser_manual.html#PF">pitfalls and tips</a>
</ul>
<h2><A NAME="BI">Basic Ideas</a></h2>
<p>
A string placed as the first line of a Python function is the function's documentation string.  
Productions are input to DParser using these strings.  The syntax of the string is the same as that of a DParser production.
In order to let the interface know that you want it to use a specific function's documentation string 
as a production, begin that function's name with "d_".  The function then becomes an action that is executed 
when the production reduces.  For example,
<pre>
#...
def d_action1(t):
    "sentence : noun 'runs'"
    print 'found a sentence'
#...
</pre>
This code specifies an action, <b>d_action1</b> and a production, <b>sentence</b>, to DParser.  If your input contains
a <b>noun</b> (whatever you specify that to be) followed by <i>runs</i>, then DParser will call <b>d_action1</b>.

<p>
Each action takes at least one argument, an array.  The array consists of the return values of the elements
making up the production, or, for terminal elements, the string the terminal matched.  In the above example, this
array will contain the return value of <b>noun</b>'s action as the first element and the string <I>runs</I> as 
the second.  
<P>
Regular expression are specified by enclosing the regular expression in double quotes.  
<pre>
#...
def d_number(t):
    r'number : "[0-9]+"'             # number matches some number of the digits 0-9
    return int(t[0])             # turn the matched string into an integer
#...
</pre>
Make sure your documentation string is a Python raw string (precede it with the letter <b>r</b>) if it contains any <a href="http://www.python.org/doc/current/ref/strings.html">Python escape sequences</a>.
<P>
For more advanced features of productions, such as priorities and associativites, see <a href="http://dparser.sourceforge.net/d/manual.html">the DParser manual</a>.
<h2><A NAME="AA">Arguments to actions</a></h2>
All actions take at least one argument, an array, as described above.  
Other arguments are optional.  The interface recognizes which arguments you want based on the name you give the argument.  Possible
names are:
<dl><dt><b>spec</b>, <b>spec_only</b><dd>If an action takes <b>spec</b>, that action will be called for both speculative and final parses 
(otherwise, the action is only called for final parses).
The value of <b>spec</b> indicates whether the parse is final or speculative (1 is speculative, 0 is final).  
To reject a speculative parse, return dparser.Reject.
If an action takes <b>spec_only</b>, the action will be called only for speculative parses.  The return value of the 
action for the final parse will be the same Python object that was returned for the speculative parse.
<a href="test5.py">Complete example</a>.
<dt><b>g</b><dd>DParser's global state.  <b>g</b> is actually an array, the first element of which is the
global state.  (Using a one-element array in this manner allows the action to change the global state.)
<dt><b>s</b><dd>contains an array (a tree, really) of the strings that make up this reduction.  Useful if the purpose of your parser is to alter some text, leaving it mostly intact.  See <a href="test6.py">here</a> for a complete example.  
<dt><b>nodes</b><dd> 
an array of Python wrappers around the reduction's <b>D_ParseNode</b>s.  They contain information on line numbers and such.  See <a href="test7.py">here</a> for useful fields.
<dt><b>this</b><dd> the <b>D_ParseNode</b> for the current production.  (<b>$$</b> in DParser.)  Again, see <a href="test7.py">this example</a>.
<dt><b>parser</b><dd>
your parser (somtimes useful if you're dealing with multiple modules).
</dl>


<h2><A NAME="ADP">Arguments to dparser.Parser()</a></h2>
All arguments are optional.
<dl>
<dt><b>modules</b>:
	<dd>an array of modules containing the actions you want in your parser.  If this argument is not specified, the calling module will be used.
<dt><b>file_prefix</b>:<dd>prefix for the filename of the parse table cache and other such files.  Defaults to "d_parser_mach_gen"
</dl>

<h2><A NAME="AP">Arguments to dparser.Parser.parse()</a></h2>
The first argument to dparser.Parser.parse is always the string that is to be parsed.  All other arguments are optional.
<dl>
<dt><b>start_symbol</b>:
<dd>the start symbol.  Defaults to the topmost symbol defined. 
<dt><b>print_debug_info</b>:
        <dd>prints a list of actions that are called if non-zero.  Question marks indicate the action is speculative.
<dt><b>dont_fixup_internal_productions, dont_merge_epsilon_trees, commit_actions_interval, error_recovery</b>:
<dd>correspond to the members of <b>D_Parser</b> (see the DParser manual)
<dt><b>initial_skip_space_fn</b>:<dd>allows user-defined whitespace (as does the <b>whitespace</b> production,
and instead of the built-in, c-like whitespace parser).
Its argument is a <b>d_loc_t</b> structure.  This structure's member, <b>s</b>, is an index into the string that is being parsed.  Modify this index
to skip whitespace:
<pre>
#...
def whitespace(loc):
   while loc.s < len(loc.buf) and loc.buf[loc.s:loc.s+2] == ':)':    # make smiley face the whitespace
      loc.s = loc.s + 2
#...
Parser().parser('int:)var:)=:)2', initial_skip_space_fn = whitespace)
</pre>
<dt><b>syntax_error_fn</b>:<dd> called on a syntax error.  By default an exception is raised.  It is passed a <b>d_loc_t</b> structure (see <b>initial_ skip_space_fn</b>)
indicating the location of the error:
<pre>
#...
def syntax_error(loc):
    print 'syntax error, line:' + str(loc.line)
#...
Parser().parser('python is bad.', syntax_error_fn = syntax_error)
</pre>
<dt><b>ambiguity_fn</b>:<dd>resolves ambiguities.  It takes an array of <b>D_ParseNode</b>s and expects one of them to be returned.  By default a <b>dparser.AmbiguityException</b> is raised.
</dl>

<h2><A NAME="PF">Pitfalls and Tips</a></h2>
Let me know if you run into a pitfall or have a tip, and I will put it here.  Passing <b>print_debug_info=1</b> to <b>Parser.parse()</b> might help if you are stuck.
<dl><dt><b>Regular expressions:</b><dd>
DParser does not understand all of the regular expressions understood by the Python regular expression module.  Make sure you are using regular expressions DParser can understand.  
<p>Also, make sure your documentation string is a Python raw string (precede it with the letter <b>r</b>) if it contains any <a href="http://www.python.org/doc/current/ref/strings.html">Python escape sequences</a>.
<dt><b>DParser specifiers/declarations:</b><dd>DParser can be passed declarations in documentation strings.  For example,
<pre>
from dparser import Parser
def d_somefunc(t) : '${declare longest_match}'
#...
</pre>
(see the DParser manual for an explanation of specifiers and declarations.)
<dt><b>Multiple productions per action:</b><dd>You can put multiple productions (even your entire grammar) into one documentation string.  Just make sure to add semicolons after each production:
<pre>
from dparser import Parser

def d_grammar(t):
   '''sentence : noun verb;
      noun : 'dog' | 'cat';
      verb : 'run'
   '''
   print 'this function gets called for every reduction'

Parser().parse("dog run")
</pre>
