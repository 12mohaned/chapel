enum classVals = S | W | A | B | C | D | O;
const probSize: [S..O] integer = (32, 64, 256, 256, 512, 1024, 256);
const numIters: [S..O] integer = (4, 40, 4, 20, 20, 50, 4);
const checksum: [S..O] float = (0.0000530770700573, 0.00000000000000000250391406439, 0.000002433365309, 0.00000180056440132, 0.000000570674826298, 0.000000000158327506043, 0.0);
config const Class: classVals = S;
config const n: integer = probSize(Class);
config const nx: integer = n;
config const ny: integer = n;
config const nz: integer = n;
config const numLevels: integer = lg2(n);
config const nit: integer = numIters(Class);
config const verifyValue: float = checksum(Class);
config const warmup: boolean = true;
config const verbose: boolean = false;
config const debug: boolean = false;
type coeff = [0..3] float;
const Levels: domain(???) = [1..numLevels];
const Base: domain(???) = [1..nx, 1..ny, 1..nz];
const Hier: [var lvl: integer;:Levels] domain(???) = (Base by (-(2**(lvl-1))));
const Stencil: domain(???) = [(-1)..1, (-1)..1, (-1)..1];
var initTimer: timer;
var benchTimer: timer;
initTimer.start();
var V: [Base] float;
var U: [var lvl: integer;:Levels] [Hier(lvl)] float;
var R: [var lvl: integer;:Levels] [Hier(lvl)] float;
initializeMG();
inittime = warmupMG(V, U, R);
initTimer.stop();
benchTimer.start();
var rnm2: float = computeMG(V, U, R);
benchTimer.stop();
printResults(rnm2, initTimer.read(), benchTimer.read());
function initializeMG( V: ???;
 U: ???;
 R: ???): ??? {
writeln(" NAS Parallel Benchmarks 2.4 (Chapel version) - MG Benchmark");
writeln(" Size: ", nx, "x", ny, "x", nz);
writeln(" Iterations: ", nit);
writeln();
initArrays(V, U, R);
}


function warmupMG( V: ???;
 U: ???;
 R: ???): ??? {
if (warmup) {
mg3P(V, U, R);
resid(R(1), V, U(1));
initArrays(V, U, R);
}
}


function computeMG( V: ???;
 U: ???;
 R: ???): float {
resid(R(1), V, U(1));
norm2u3(R(1));
for var it: integer; in 1..nit {
mg3P(V, U, R);
resid(R(1), V, U(1));
}
rnm2 = norm2u3(R(1))(1);

return rnm2;
}


function printResults( rnm2: ???;
 inittime: ???;
 runtime: ???): ??? {
var verified: boolean;
if ((verifyValue!=0.0)) {
const epsilon: float = 0.00000001;
const delta: float = (rnm2-verifyValue);
if ((abs(delta)<=epsilon)) {
writeln(" VERIFICATION SUCCESSFUL ");
writeln(" L2 Norm is ", rnm2);
writeln(" Error is ", delta);
} else {
{
writeln(" VERIFICATION FAILED");
writeln(" L2 norm is ", rnm2);
writeln(" The correct L2 Norm is ", verifyValue);
}
}
} else {
{
verified = false;
writeln(" Problem size unknown");
writeln(" NO VERIFICATION PERFORMED");
}
}
writeln(" MG Benchmark Completed.");
writeln(" Size = ", nx, "x", ny, "x", nz);
writeln(" Iterations = ", nit);
writeln(" Time in seconds = ", runtime);
writeln(" Mop/s total = ???");
writeln(" Operation type = floating point");
write("Verification = ");
if (verified) {
writeln("   SUCCESSFUL");
} else {
{
writeln(" UNSUCCESSFUL");
}
}
writeln(" Version = 2.4");
}


function mg3P( V: ???;
 U: ???;
 R: ???): ??? {
for var lvl: integer; in 2..numLevels {
rprj3(R(lvl), R((lvl-1)));
}
U(numLevels) = 0.0;
psinv(U(numLevels), R(numLevels));
for var lvl: integer; in (2..(numLevels-1) by (-1)) {
U(lvl) = 0.0;
interp(U(lvl), U((lvl+1)));
resid(R(lvl), R(lvl), U(lvl));
psinv(U(lvl), R(lvl));
}
interp(U(1), U(2));
resid(R(1), V, U(1));
psinv(U(1), R(1));
}


function psinv( U: ???;
 R: ???): ??? {
state const c: coeff = initCValues();
state const c3d: [var i: integer;, var j: integer;, var k: integer;:Stencil] float = c((((i!=0)+(j!=0))+(k!=0)));
const RD: ??? = R.Domain;
const Rstr: ??? = R.stride;
U += [var ijk: integer;:RD] reduce by sum [var off: integer;:Stencil] (c3d*R((ijk+(Rstr*off))));
}


function resid( R: ???;
 V: ???;
 U: ???): ??? {
state const a: coeff = (((-8.0)/3.0), 0.0, (1.0/6.0), (1.0/12.0));
state const a3d: [var i: integer;, var j: integer;, var k: integer;:Stencil] float = a((((i!=0)+(j!=0))+(k!=0)));
const UD: ??? = U.Domain;
const Ustr: ??? = U.stride;
R = (V-[var ijk: integer;:UD] reduce by sum [var off: integer;:Stencil] (a3d*U((ijk+(Ustr*off)))));
}


function rprj3( S: ???;
 R: ???): ??? {
state const w: coeff = (0.5, 0.25, 0.125, 0.0625);
state const w3d: [var i: integer;, var j: integer;, var k: integer;:Stencil] float = w((((i!=0)+(j!=0))+(k!=0)));
const RD: ??? = R.Domain;
const Rstr: ??? = R.stride;
S = [var ijk: integer;:RD] reduce by sum [var off: integer;:Stencil] (w3d*R((ijk+(Rstr*off))));
}


function interp( R: ???;
 S: ???): ??? {
state const IDom: domain(???) = [(-1)..0, (-1)..0, (-1)..0];
state const IStn: [var i: integer;, var j: integer;, var k: integer;:IDom] domain(???) = (i..0, j..0, k..0);
state const w: [var ijk: integer;:IDom] float = (1.0/IStn.size());
const SD: ??? = S.Domain();
const Rstr: ??? = R.stride;
const Sstr: ??? = S.stride;
forall var ioff: integer; in IDom {
forall var ijk: integer; in SD R((ijk+(Rstr*ioff))) += (w(ioff)*reduce by sum [var off: integer;:IStn(ioff)] S((ijk+(Sstr*off))));
}
}


function norm2u3( R: ???): (float, float) {
const rnm2: ??? = sqrt((reduce by sum (R**2)/((nx*ny)*nz)));
const rnmu: ??? = reduce by max abs(R);

return (rnm2, rnmu);
}


function initArrays( V: ???;
 U: ???;
 R: ???): ??? {
zran3(V);
U(1) = 0.0;
V.outOfBounds(wrap);
U.outOfBounds(wrap);
R.outOfBounds(wrap);
}


function zran3( V: ???): ??? {
const ncharge: integer = 10;
var POS: [1..ncharge] index(Base);
var NEG: [1..ncharge] index(Base);
V = [var i: integer;, var j: integer;, var k: integer;:Base] longRandlc((((i-1)+((j-1)*nx))+(((k-1)*nx)*ny)));
for var i: integer; in 1..ncharge {
POS(i) = reduce by maxloc V;
NEG(i) = reduce by minloc V;
}
V = 0.0;
for var i: integer; in 1..ncharge {
V(POS(i)) = 1.0;
V(NEG(i)) = (-1.0);
}
}


function longRandlc( n: ???): float {
state const s: float = 314159265.0;
state const arand: float = (5.0**13);
var kk: integer = n;
var t1: float = s;
var t2: float = arand;
var t3: float;
while ((kk!=0)) {
var ik: integer = (kk/2);
if (((2*ij)!=kk)) {
t3 = randlc(t1, t2);
}
if ((kk>0)) {
t3 = randlc(t2, t2);
}
kk = k1;
}

return randlc(t1, arand);
}


function randlc( x: ???;
 a: ???): float {
state const r23: float = (0.5**23);
state const t23: float = (2**23);
state const r46: float = (0.5**46);
state const t46: float = (2**46);
var t1: float;
var t2: float;
var t3: float;
var t4: float;
var a1: float;
var a2: float;
var x1: float;
var x2: float;
var y: float;
t1 = (r23*x);
a1 = integer(t1);
a2 = (a-(t23*a1));
t1 = (r23*x);
x1 = integer(t1);
x2 = (x-(t23*x1));
t1 = ((a1*x2)+(a2*x1));
t2 = integer((r23*t1));
y = (t1-(t23*t2));
t3 = ((t23*y)+(a2*x2));
t3 = integer((r46*t3));
x = (t3-(t46*t4));

return (r46*x);
}


function initCValues( Class: ???): coeff {
if ((((Class==A)||(Class==S))||(Class==W))) {

return (((-3.0)/8.0), (1.0/32.0), ((-1.0)/64.0), 0.0);
} else {
{

return (((-3.0)/17.0), (1.0/33.0), ((-1.0)/61.0), 0.0);
}
}
}


function lg2( x: ???): integer {
var lg: integer = (-1);
while (x) {
x *= 2;
lg += 1;
}

return lg;
}


