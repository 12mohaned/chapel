use IO, Regexp;

/* A general purpose record reader/parser for channels.
   
   The assumptions on the programmer are:
   (1) The programmer has opended the file in the proper mode (chan)

   (2) The programmer has created a record (NOT a class) that can have an arbitrary
       number of 1D fields (i.e no subrecords, arrays etc).

   (3) The number of captures in the regex string provided, MUST have the number of
       fields in the record.

   (4) The order in which the fields in the record appear must be in the same order
       as the record being parsed. See test.chpl for an example of this.

  
  TODO/FIXME: 
  (a) Make it so that the reader can be something other then (false, dynamic,
      true)...
 */



class RecordReader {
  type t;                  // The record to read into 
  // See section 23.2.2 of the language spec for the types
  var myReader;
  //var myReader: channel(false, iokind.dynamic, true);   
  var matchRegexp: regexp; // To match on the channel with
  param num_fields = __primitive("num fields", t); // Number of fields in record

  proc RecordReader(type t, mRegexp: string, myReader) {
    //this.myReader    = myReader;
    matchRegexp = compile(mRegexp);
  }

  proc get() { 
    var rec: t; // create record
    for m in myReader.matches(matchRegexp, num_fields, 1) {
      for param n in 1..num_fields {
        var tmp = __primitive("field value by num", rec, n);
        var s: string;
        myReader.extractMatch(m(n + 1), s);
        __primitive("field value by num", rec, n) = s:tmp.type;
      }
    }
    return rec;
  }

  iter stream() { // Make a leader follower for this
    for m in myReader.matches(matchRegexp, num_fields) {
      var rec: t; // create record
      for param n in 1..num_fields { // Any way of getting number of gets to 1 here?
        var tmp = __primitive("field value by num", rec, n);
        var s: string;
        myReader.extractMatch(m(n + 1), s);
        __primitive("field value by num", rec, n) = s:tmp.type;
      }
      yield rec;
    }
  }
}

