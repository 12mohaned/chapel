===============================
Chapel implementation of miniMD
===============================

This directory contains a Chapel port of the "mini Molecular Dynamics" (miniMD) 
benchmark. (see http://mantevo.org/ for the C++ reference version 
and more details).

------
Status
------

The Chapel version of miniMD is a work-in-progress. To the best of our 
knowledge, the current form is an accurate implementation of miniMD. 
A number of improvements remain, see the TODOs section in this file.

-----
Files
-----

This directory's contents are as follows:
./
  miniMD.chpl           : entry point for miniMD, contains integration code
  helpers/
    initMD.chpl		: code to initialize and handle the system state
    forces.chpl		: implementations for EAM and LJ force computations
    thermo.chpl		: handles calculation of energy, temperature, pressure
    neighbor.chpl       : handles the calculation and updating of neighbor atoms

Makefile                : builds miniMD. 'make fast' builds an optimized version

  miniMD.*				: other files used in the Chapel testing system

  README					: this file


-----------------------------------
Compilation Options (config params)
-----------------------------------

The following are boolean config[uration] param[eter]s for miniMD 
that can be set on the chpl compiler command line using the flag:

  chpl -s<paramName>=[true|false] ...

  paramName   default   description

* printOriginal [false] : prints the same output as the c++ reference

* printPerf     [true]  : prints the total time of the computation

* printCorrect  [false] : only print the T/U/P information (without timestamp),
                          useful when automating correctness testing

printPerf is true by default by convention in the Chapel testing system.

Chapel-specific optimizations:

* Add the following to enable the BulkTransfer optimization:
  -sdebugBlockDistBulkTransfer -sdisableAliasedBulkTransfer=false

* tcmalloc has yielded significant performance improvements:
  As in the Chapel docs, do the following: export CHPL_MEM=tcmalloc

-------
Running
-------

If intending to run in a distributed fashion, the user will always need to 
run miniMD with the '-nl <number of nodes>' option. See Chapel documentation 
for more on setting up GASNET and compiling for multilocales.

-----------------
Execution Options
-----------------

use the '--help' flag to display a list of command line options (TODO)

---------
Callgraph
---------

* - global code

entry point
	-> inputFile
	-> * create force object
	-> * initialize problem bounds
	-> setupNeighbors
	-> initThermo
	-> * define bin bounds
	-> setupComms
		-> startBarrier
		-> stopBarrier
	-> * populate with atoms
		if generating
			-> create_atoms
				-> pmrand
				-> addatom
			-> create_velocity
		else
			-> * read from data file
			-> addatom
	proc main()
		-> buildNeighbors
			-> pbc
			-> binatoms
			-> communicateCopies
		-> printSim
		-> Force.compute
			-> forceBetween
		-> thermo.compute
			-> temperature
			-> energy
			-> pressure
		-> run
			-> initialIntegrate
			xor
				-> buildNeighbors
				-> communicateCopies
			-> Force.compute
			-> finalIntegrate
			-> thermo.compute
		-> Force.compute
		-> thermo.compute

----------
Vocabulary
----------

Some important vocabulary for understanding the code:
  - stencil: a fixed pattern that we use to refer to array elements 
             or data.

  - fluff: if the stencil needs to look at its nearest neighbors, then 
           on the edges of the array we will encounter an out-of-bounds 
           error. We can avoid this by extending the array's bounds 
           by the size of the stencil. The area outside of the portion 
           of the array we care about is called fluff.
---------
Debugging
---------

Some tips for resolving bugs when modifying/improving this code. These are 
mostly based off of experience, and have proved useful.

Problem size:
  I suggest testing with the arguments '--size 5 -nl 1' to start out with. If 
  you're having problems with 1 locale and such a small sample size, you're 
  going to have problems with more complex configurations. The advantages of 
  this smaller configuration are:
    less atom/bin debug output to sift through
    runs fairly quickly. Compile time is long enough, you don't want to wait
      to long for execution.
    while small, a size of 5 gives just enough to test -nl 2 as well.

A) This code currently relies on the condition that we only need to look at the 
nearest neighboring locale for ghost bins. This is influenced by simulation 
settings like problem size and cutoff. You can use the debug flag to add a line 
that writes the bin distribution and see what the program things it needs. 

B) Make sure neighbor lists are correct. Incorrect ghost positions, force 
computation, or binning can lead to bad neighbor lists. With a bad neighbor 
list, results get more and more off.

C) Inspect the position/velocity/force of atoms (requires correct reference)

* Incorrect T/U/P results -  If your force computation is wrong after the 0th 
iteration, the force computation is potentially wrong, and atoms didn't end up 
in their correct positions. If the 0th iteration is wrong, there's probably an 
issue with buildNeighbors.

* Segfaults / Bad array accesses - With incorrect code an atom can 'shoot' out 
of the problem space before boundary conditions can be re-asserted. 

-----
TODOS
-----

CORRECTNESS TODOs:
-----------------

* Due to legal concerns, we currently do not include input files for miniMD 
in our testing system. miniMD's EAM computation relies on such an input file.
To test and run with EAM you can download the C++ reference and copy the 
appropriate files into each of the subdirectories

* Ensure command-line options behave in the same way as in c++

PERFORMANCE TODOs:
------------------

* Identify sections of code that can benefit from a local {} assertion.

* A global 'perBinSpace' is a bit of a bottleneck. Is there a better way to 
do this?

* Look into high memory usage and leaks (the latter of which falls more onto 
the compiler)

* Compiler and runtime improvements may yield additional performance increases.

MISCELLANEOUS TODOs:
--------------------

* Naming isn't the best.

* Are comments clear enough?

* yaml output?
