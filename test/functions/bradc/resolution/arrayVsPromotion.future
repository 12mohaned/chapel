feature request: promotion is less specific than generic

My intuition is that function calls that rely on promotion
should always be lower priority than those that do not,
even if they use generics.



Here's some related conversation with Steve:

Steve:
> This proposal is in contrast to overload resolution in C#, C++, and Java.
> I don't believe there is any precedence for choosing one function over
> another even if an argument in the unchosen function is a better match
> than an argument in the chosen function.  For these reasons, I'm not
> convinced that we should walk down this path.

Brad:
Sure, but those languages don't have a concept of promotion so I wouldn't
use this as an excuse for not exploring the idea further.  We provide
promotion as a concept for convenience and intuitiveness.  If using
promotion becomes significantly less useful because it causes ambiguities to
abound in common cases that provide a certain amount of intuition then its
power is significantly reduced.

(I'm not saying we're there necessarily, just trying to keep the discussion
alive).


Steve:
> On the other hand, the algorithmic change may be fairly straightforward
> and may not require any major hierarchical change.  After coming up with
> the candidate functions (those visible functions that could be selected by
> function resolution), if there are any candidate functions that do not
> require promotion, then summarily reject any candidate functions that do
> require promotion.  Thus non-promotion is favored over promotion.
> 
> But this other hand will probably lead to trouble:
> 
> Given
> 
>  def g(x: int, y: int)
>  def g(x: [] int, y)
> 
> the call g(A, 2) resolves to the second function because it does not
> require promotion.  But given
> 
>  def g(x: int, y: int, z: int)
>  def g(x: [] int, y, z: int)
> 
> the call g(A, 2, A) is ambiguous because both functions require promotion
> and the second function's first argument is more specific but the first
> function's second argument is more specific.

Brad:
So what if the rule said that when a single actual results in promotion for
every candidate, the functions are equally attractive from the point of view
of that argument and it doesn't affect the promotion-based elimination.
Given the "promotion should be avoided if another option exists" principle,
this would mean that the third argument wouldn't make either more
attractive, the promotion of the first would eliminate the first function,
and we'd end up with the second being more attractive.

Obviously, if a third function was added:

  def g(x: int, y: int, z: [] int);

then we would get an ambiguity, which seems intuitive.


FWIW, nothing I'm doing is hinging on this, but I do think it's an
interesting exploration given how surprising it was to me to see the list of
candidates for *(range,int) and it seeming obvious to me that the one that
didn't result in promotion matched.  Similarly, I think your three-argument
g() example above seems obvious.  Once we add in my third
version of g() (or simply have a two-function ambiguity like:

        def f(x: int, y: [] int);
        def f(x: [] int, y: int);

then I agree that throwing our hands up is the right thing to do).