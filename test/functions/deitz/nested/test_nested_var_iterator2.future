bug: Constant propagation is improperly applied when chpl_here_alloc() is used to allocate the iterator class data.

The expected output is 2, the actual output is 1.  Here's an extract from the
generated code:

/* test_nested_var_iterator2.chpl:1 */
static void foo(void) {
  int64_t x;
  _ref_int64_t T = NULL;
  _ic_bar _ic_ = NULL;
  _ref_int64_t x2 = NULL;
  x = 0;
  T = &x;
  _ic_ = chpl_here_alloc8(_ic_, 27, 11, "test_nested_var_iterator2.chpl");
  ((object)(_ic_))->chpl__cid = chpl__cid__ic_bar;
  (_ic_)->more = 1;
  (_ic_)->F0_x = T;
  x2 = (_ic_)->F0_x;
  *(x2) = 2;
  chpl_mem_free(((void*)(_ic_)), 4, "test_nested_var_iterator2.chpl");
  writeln3(1);
  return;
}

It can easily be observed that a constant "1" has been generated as the argument
to writeln3().  It is hard to see how changing the allocator could have affected
whether this substitution was made.  But this is clearly a bug in inlining or
constant value propagation.

Examining the code, i becomes an alias for x in the "for" statement.  This is
handled correctly in the body of the iterator, but not in the body of the loop.
Since the variables (x and y) declared inside foo are visible within bar, optimization
that is ignorant of the implementation of bar must assume that they are both
volatile.  If the body of bar is inlined into foo, then x and i should be folded
into the same symbol.  In that case, constant propagation can be applied, the
body of the function will be greatly simplified, and the correct answer will be
printed.

Basically:
  ref i = x; // i can be replaced by x wherever it appears.
  x = 1;
  x = 2;
  y = x;
  writeln(y);
devolves to 
  writeln(2);

