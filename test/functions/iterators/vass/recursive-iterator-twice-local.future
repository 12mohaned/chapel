bug: compiler crashes with an improper AST when the program defines two recursive leader iterators

This test essentially contains two (renamed and slightly simplified) copies of:

  functions/deitz/iterators/leader_follower/test_recursive_leader3.chpl

The issue, discovered by Tom, is that the lowerIterators pass
creates these two functions when there is a recursive iterator:

  chpl__copyRecursiveIteratorArgumentBundle
  chpl__freeRecursiveIteratorArgumentBundle

whose _loopBodyFnArgs argument contains a reference to the iterator
argument bundle.

Only a single copy of each of these is created. The type of the
_loopBodyFnArgs argument is that for the first iterator that causes
these methods to be created.

So when these methods are invoked for the second iterator that needs them,
it passes its own argument bundle, whose type does not match that for
the first iterator, resulting in a violation of an AST invariant,
which is cheerfully reported by the compiler as:

  error: actual formal type mismatch [expr.cpp:2587]

Interestingly, the bodies of these methods are already created
to handle multiple iterator bundle types, so it is only the header
that is an issue.

BACKGROUND

Recursive iterator inlining takes the body of the iterator and turns
this into a function that is installed the global function table.  The
body is then referred to by its function index.  As with other
functions in that table, the arguments are bundled into a class, so
they can be referred to through a single void*.  Code in the caller
bundles up the args, and code in a wrapper function unbundles the args
so they can be passed to the actual body function seriatim.

The global function table was created a while back to replace function
pointers for functions that can be called across locales. See:

  ftableMap/ftableVec
  PRIM_FTABLE_CALL
  r15370
  r16348

To make it more concrete, consider the test test_recursive_leader3.chpl.
Here is an exerpt from the AST after lowerIterators, compiled with
--no-local (without --fast), where 'bar' is the name of a parallel iterator:

  type _fn_arg_bundle[1079410] var _arg1[1079436]:_ref(_ir_bar)[743010]

  function chpl__copyRecursiveIteratorArgumentBundle[1079451](arg _loopBodyFn[1079453]:int(64)[70], arg _loopBodyFnArgs[1079455]:_fn_arg_bundle[1079410]) : _fn_arg_bundle[1079410]
  {
    var _tmp[1079457]:_fn_arg_bundle[1079410]
    .....
    if (_loopBodyFn == 0)
    {
      ... handle the case where the function index == 0
      (1079494 'move' _tmp[1079457](1079491 'cast' _fn_arg_bundle[1079410] _tmp[1079466]))
    }
    if (_loopBodyFn == 1)
    {
      ... handle the case where the function index == 1
      (1081603 'move' _tmp[1079457](1081600 'cast' _fn_arg_bundle[1079410] _tmp[1081520]))
    }
    (1079462 return _tmp[1079457])
  }

  function _rec_iter_fn_bar[1079406](arg _ic[1079680]:_ic_bar[743481], arg _loopBodyFn[1079696]:int(64)[70], arg _loopBodyFnArgs[1079698]:_fn_arg_bundle[1079410]) : void[17]
  {
    .....
          var _tmp[1081470]:int(64)[70]
          var _tmp[1081471]:_fn_arg_bundle[1079410]
          _tmp[1081470] gets _loopBodyFn
          _tmp[1081471] gets _loopBodyFnArgs
          (1081490 'move' _tmp[1081482](1081486 call chpl__copyRecursiveIteratorArgumentBundle[1079451] _tmp[1081470] _tmp[1081471]))
          (1081495 'move' _tmp[1081484](1081492 'cast' _fn_arg_bundle[1079410] _tmp[1081482]))
    .....
  }

Here, the type of _tmp[1081471] is specific to the iterator in whose
context the call to chpl__copyRecursiveIteratorArgumentBundle() occurs.
So if there were several such iterators, there would be an argument
mismatch. recursive-iterator-twice.chpl is expected to illustrate that.
