bug: function resolution with nested classes

Function resolution is getting messed up by scope resolving methods.


Brad wonders:

looks to me that the reported error (for the second call to foo()) is
correct since I is not a subclass of either B or E.  However, I would
expect the first function call to foo() to result in an error and it
doesn't seem to).


David answers:

My expectation was that inner class objects would have access to the fields
and methods of the outer objects they were nested in through implicit
outerThis pointers.  Objects of class I would then have access to both of
the outerThis.outerThis...fun() methods, and function resolution would have
to resolve between the two.  Since the E.fun(int, int) doesn't match the
actuals for the second fun() call, it should be discarded as a candidate and
the B.fun(int, real) version should be selected instead.

Then function resolution goes:
1) find all functions/methods in my scope that match call site name (if I
have an outerThis chain pointer leading to it, it's in my scope)
2) Discard any functions where the actual types can't coerce to the formal
types.
3) If more than one function is left, find the version(s) with fewest
coercions needed
4) If still more than one function is left, pick the nearest in scope
(fewest outerThis pointer accesses required)

If you disagree with this explanation of how it should work, then the
deep_nest test should error for both of the fun() calls.  Making it not able
to match either fun() definition would probably be a fair bit easier to
implement than my above explanation, but given my understanding and perhaps
also lack of understanding, I believe the above is the "correct" way to do
it.


Brad concludes:

I see, so the point is that since an inner class can only be used within an
instance of a parent class, every inner class instance has a unique outer
parent class instance and so methods on those outer classes have a logical
"this" object to use, even though it won't be the inner class' "this".  That
makes sense to me if we can make it work.
