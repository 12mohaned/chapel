bug: sparse domains in classes no longer work

This test worked in our last release (v0.5.608), but not in
our current one due to a nil pointer dereference.  It seems
that this is because the field initialization mechanism
has changed and relies on the ability to call a domain
class' buildEmptyDomain() method with a nil this reference.
The arithmetic domain is special-cased to make this work,
but because the sparse domain wasn't (and has value information)
it was choking.  Other domain types don't have value information
so don't require special-casing.

While the buildEmptyDomain() can easily be specialized to
work for sparseInClass.chpl (for example, by making the
parentDom nil), this breaks in a test like this one that
refers to the parentDom field -- that bogus nil entry gets
propagated to the actual domain field rather than getting
dropped on the floor like it should.

-----------------

Here are some general thoughts I have on this issue tonight:

I'm worried that the _set_field() approach isn't sound for domains, but that
because we're not distributed, we're not picking up on it yet.  In
particular, I'm worried that value information in a domain is getting lost
as a result of this mechanism.  As an example, consider what it would do for
an argument domain y with distribution value "myDist":

        pragma "inline" def _set_field(x, y) {
          var xx: x.type;
          xx = y;
          return xx;
        }

First, var xx is going to be declared to be a generic arithmetic domain
(i.e., buildEmptyDomain() is going to be called with a nil "this" pointer),
causing its dist field to be filled in as SingleLocaleDistribution().

Then it's assigned y, which causes y's indices to be copied into xx, but not
any of the implementing class' value information (appropriate for user
assignments, but possibly not for this initialization trick).

Then it's returned -- I'm not precisely clear on what happens after this
point, but I suspect that xx is the value given to the field of the class,
which is to say that its distribution will be SingleLocaleDistribution()
rather than whatever it was meant to be in the declaration -- and that we're
not seeing this in practice because we don't actually use distributions in
any interesting way.


In my sparse case, what I'm seeing is that any bogus value information that
I provide in the this == nil case of buildEmptyDomain() is getting
propagated into the field rather than dropped on the floor.  I assume that
this is due to the above flow, though I could be missing something subtle.


So, leaving tonight and knowing what little I know, it seems as though the
general set_field() strategy isn't likely to work for domains at least as
currently implemented, due to the loss of value information in the domain
descriptor.

