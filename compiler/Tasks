======
TODOS:
======

Implementation List
-------------------

1 = highest priority
2 = medium priority
3 = lowest (domans and arrays)
4 = long-term


Priority 1 Tasks
----------------

* Insert symbols for every primitive literal, change DefaultValue to a VarSymbol

* (Steve) unify union types and sum types (?)

* (Roxana) Attach a Type* type to Expr and remove typeInfo()

* (Steve) implement constructed classes, unify ClassType and RecordType under
  StructuredType into one type, call it ClassType or something simple

* (Steve) compile-time (param) constant-folding

* (John) get rid of nondeterminism introduced by hashing-on-pointers
   structures (and try to capture an instance of front-end
   nondeterminism to eliminate it as well)

X (Steve) rename "implements" to something else.  Move to class header?

X (Steve) implement class inheritance

X (Steve) restructure verify pass; build out verify() routines on AST classes

X (Steve) Change all Exprs to have Expr on the end.  Standardize names
  of classes

X (John) add PrimitiveType class -- move integers, floats, strings, and such
  here

X (Steve) Remove NoOpStmt -- replace with empty block statement - complete

X (Roxana) Remove UserInitExpr - complete

X (John) Remove CastLikeExpr - complete

X (John) Remove SizeofExpr - complete

X (John) Convert VarSymbol::aspect into a Cast expression and remove it

X (Roxana) Remove Type::getType() - complete

X (Steve) remove ForwardingSymbol (?)

X (Steve) Remove BinOp, UnOp, AssignOp.  Rename ParenOpExpr, CallExpr

X (Steve) Remove FnCall

X (John) Replace VarInitExpr with some symbol sentinel - complete

X (Roxana) Rename DefaultVal to DefaultValue - complete

X (Steve) Unify WithExpr and UseExpr which have similar forms

Priority 2 Tasks
----------------

* (Steve/John*) remove error reporting from low-level code -- propagate errors to
  high-level (*I've done a first cut at the analysis changes -- john)

* (John) Implement MemberAccess Setter Getter transform in AST.
  Remove MemberAccessExpr.  This will be eliminated pre-analysis
  anyway.  Store it as a CallExpr of a function named '.'

* Restructure FnSymbol/FnType to reflect division into implementation,
  type, prototype, signature.  Store signatures as degenerate function
  type.

* Implement record passing by reference and insert explicit copies in
  and out of functions when necessary -- eliminate PARAM_REF(?)

* for ?t make DefExpr::exprType a DefExpr

* create dispatch hierarchy and subtype hierarchy (classes appear in
  both; value types only appear in the subtype hierarchy)

* implement visibility of methods/nested functions correctly (if we're
  in a method, function names bind to methods; if we're in a function,
  binds to functions?  Or maybe I'm summarizing this incorrectly...see
  discussion above)

* (Steve) go through compiler passes and sort through, unify, refactor

* implement constant folding for "parameter" and check that +,- etc. are
  not overloaded for primitive types (e.g. integer)

X (John) implement nil to behave as we discussed



Priority 3 Tasks
----------------

* Implement the forIterator/forallIterator function.

* implement domains and arrays


Priority 4 Tasks
----------------

* Unify compiler switches.

* unify error reporting systems

4C explore Doxygen -- or have someone else (Cameron?) do it for us.

* add gcov/gperf abilities into nightly testing

* Chapel mode for emacs

* record literals

* get rid of UserType after instantiation?

* implement function closures ("x => f(1)")

* implement primitives of different widths

* add some sort of "noinit" keyword to the language to specify that
  types and variables should be left uninitialized when declared

* implement topological sorting of symbols (ensuring that functions
  don't use default values too early, e.g.)

* implement class constructors so that all members are initialized
  with default values to prevent against read-before-write problems.

* support assignment to value members in a class type specification
  (between the colon and equals) -- maybe generate a warning for this
  case indicating that the expression will be evaluated, used as a
  type constraint, and dropped on the floor?

X (Brad) add delta summary information into testing mails sent out

X (Brad) stop squelching core dumps when developer flag is used
