======
TODOS:
======

* Read about Scala

* switch passlist to list of function pointers; wrap current Pass
   classes in functions

* rewrite traverse() method to use get_ast_children -- keep public
   interface/use of Traversal the same, but change mechanism to be
   shared with get_ast_children

* remove post-process symbol/type

* remove SymtabTraversal pass -- replace with function call that calls
   collect symbols?
   - maintain the ability to pretty-print Symboltable

* explore switching to Subversion

* put all traversal interfaces into traversal.h, all pass interfaces
   into pass.h rather than having a header for each of these things.

* document what needs to be done when new classes added to AST, new
   fields added to AST classes

* (John) add means of iterating over ALists using an external cursor
   (re-entrant iterators) in addition to what we currently have.
   Rewrite for_alist macro to use re-entrant versions.

* add support for allocating records as structs rather than
   pointers-to-structs (and flag/switch for switching back to current
   scheme)

* temporary normalization for all CallExprs; unifying/regrouping
   initial passes; "verify canonical form" pass; automatically have
   things that are inserted which are not in the canonical form
   converted into the canonical form automagically.

* add support for interpreter

* optag change in CallExprs -- only store OP_ field once we've
   determined it's a built-in function

* construct proposal for what we should support in where expressions
   to make our lives easier, leverage advantages of Scala

* typecheck that exprType resolves to a type (before analysis)
   and types as arguments (after analysis)

* changes/canonicalizations to DefExpr
   - fix storage of initializer to support overloaded assignment
     by introducing temporaries

* move DefExprs out of ClassType and into something like the init
   function

* make sure we have current understanding of nil implementation
   strategy implemented
   - introduce write function for nilType
   - can Symbol resolution be done in the context of the wrapper
     function?

* different DefExpr fields for different symbol types?
   - for ArgSymbol, move defaultValue into its own field

* re-implement union types

* flesh out and complete specification
   - send out location to whole list
   - edits go through editor, others can yell if they disagree

* get rid of like -- replace with .type
   - support ability to declare multiple variables of the same type

* make default constructor name of class rather than "initialize"

* things on the way towards moving ahead with arrays
   - DefExpr
   - indexing function in a general way
     -

* instantiation recursion error if something is instantiated too
   many times (flag to change threshold)

* pramga unravel

* (Steve) unify union types and sum types (?)

* decide on means for determining expression types pre- and
   post-analysis?  (e.g., attach Type* to Expr?  typeInfo()?  Something
   else?)

* compile-time (parameter) constant-folding

* (John) get rid of nondeterminism introduced by hashing-on-pointers
   structures (and try to capture an instance of front-end
   nondeterminism to eliminate it as well)

* (Steve) report errors at high level

* Restructure FnSymbol/FnType to reflect division into implementation,
  type, prototype, signature.  Store signatures as degenerate function
  type.

* Overloaded assignment on records not used consistently

* Copies in/out for arguments not always done (records as a specific
   example of this)

* for ?t make DefExpr::exprType a DefExpr (verify)

* create subtype hierarchy in high-level, or reuse low-level's
   
* create dispatch hierarchy and subtype hierarchy (classes appear in
  both; value types only appear in the subtype hierarchy)

* (Steve) go through compiler passes and sort through, unify, refactor

* implement constant folding for "parameter" and check that +,- etc. are
  not overloaded for primitive types (e.g. integer)

* some visibility of methods/functions bugs, due to shadowing (John
   has test cases) 
   - Scala doesn't have this problem because they instantiate
     everything ahead of time, single dispatch, ...
   
* implement nil to behave as we discussed

* strengthen implementation of domains and arrays
   - initialization is working by accident
   - constrained to be rank 2 currently 
   
* check that compiler switches are unifying

* Implement the forIterator/forallIterator function.

* implement domains and arrays

* record literals

* get rid of UserType after instantiation?

* unify error reporting systems

* explore Doxygen

* add gcov/gperf abilities into nightly testing

* Chapel mode for emacs

* implement function closures ("x => f(1)")

* implement primitives of different widths

* add some sort of "noinit" keyword to the language to specify that
  types and variables should be left uninitialized when declared

* implement topological sorting of symbols (ensuring that functions
  don't use default values too early, e.g.)

* implement class constructors so that all members are initialized
  with default values to prevent against read-before-write problems.

* support assignment to value members in a class type specification
  (between the colon and equals) -- maybe generate a warning for this
  case indicating that the expression will be evaluated, used as a
  type constraint, and dropped on the floor?
