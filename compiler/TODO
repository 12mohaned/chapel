** Front End

- handle global scope for :: 
- handle david's generics stuff
- how to support 'with' when the type isn't given??
- document and do examples for functions returning lvals
- handle goto, return etc. in gen_if1
- merge structually equivalent types (same type_kind) unless internal doesn't match
- set Fun::has_return in ast.cpp
- when taking a reference, varaible cannot be put into SSU form
- prevent SUM types from being formed when boxing is different (??)
- remove SUM types from implements etc.
- check handling of inheritance
- handle bulltin constants so that they default to the default size (?? done?)
- make the dispatch tables visibility specific ???
- figure out why adding $right 5200 to 'new' causes problems
- add ast arg to if1_send
- fixup methods "self" and "super" variables to work correctly
- describe type hierarchy.  symbols < a symbol < functions with symbol as name
    classes as a separate hierarchy tied into the object hierarchy

         ObjectClass
         / |
   Object  |
      |    |
      |  AClass
      | /  |
      A    |
      |    |
      |  BClass
      | /
      B
- describe vector ranks: vectors: #[1] is rank 0
- AST rewrite to change '=' to '==' in expressions and to
  make sure no other assignments are in expressions. (??)
- automatically build constructors for classes
  -- remove ast->sym != sym_init checks

** Language features

- handle vector initializers more precisely and more efficiently
- support complex32 complex64 etc.
- handle mismatched number of arguments (e.g. entry_set_compatiblity, matching etc).
- support applications with more than required arguments as multiple-calls
  (add_application_constraints)
- subclass tuple for argument-tuple to add things like named arguments etc.
- structural types in matching
- setters?
 fix negative integers in 'index' in vector-type

** Incrementalism

- finish cdb.cpp reading and writing
- implement fa.cpp check_es_db
- look at sumarization techniques (research)

** Alias Analysis

- research methods: Andersens, Steensgaard, Das
- research proving user annotations correct: Jeffry Foster, Alex Aiken
- implement basic alias analysis
- research "must alias" analysis
- implement "must alias" analysis
- implement user annotation analysis ??

** Flow Analysis

- deal with "tuple" having having "has" for all possible tuples
- constant propogation and folding in fa.cpp.  Deal with indexing tuples
    with those constants.  Probably make a Sym per constant instance and use
    in creation sets....
- declare type violations when boxing is different
- fix dispatch to take the most specific method for any given
    set of arguments
- use simple_inline_calls to accelerate analysis
- remove useless pnodes from all_PNodes ??
- build has_map... must be filled with selectors (connonical names)
    convert things with multiple possible ->in to selectors...
- handle vararg functions
- preload the various as_CreationSet and atype's ?
- add concept of extending a function with additional cases.... this
    to handle 'apply-style' polymorphism
- add pattern matching
- add ->extends to Sym_t which refers to previously scoped functions with the same name
    and handle with apply ??
- use a map for symbols -> elements of a sym_tuple
- fix fa_dump_types to recognize nested functions
- fixup coerce_type to handle subtyping... used in v.g
- handle recursively analyzing setters for setter confluces on instance variables
- use clone.h basic_type to pre-split entry-sets ?? recursion could be a problem ... no more than 1 deep
- add complex restrictions for pattern arguments (structural types) & 
    clear those complex restrictions in clear_results
    - probably by recursing down the actual argument and checking
       if it matches. Maybe cache the results as well: true/false/maybe
- add simple type restrictions to non-pattern arguments in analyze_edge
- look into fa.cpp split() for phi nodes and maybe instance variables/globals
    (research: Dolby)
- collect together elements of es-cs recursion so that we can verify that the corresponding
   cs is part of the es-cs loop for the es being split
- debug type inference when dead code elimination is off.... or remove
  the flag
- optimize function dispatch
- make_top_edge should call with the appropriate arguments.
  - should store the top level pnode in the database (somewhere)
- handle constants in vector_application
- do we need the power of the creation_point in add_var_constraints?
- differentiate abstract ATypes (which have a single CreationSet and no defs)
  from concrete ones
- check rank for multi-dimensional array accesses... generally support these
    better
- handle large array constants precisely
- how to handle 
value complex1(T) {
      with T : float;
      var real : T;
      var imag : T;
      complex1(r : T, i : T) : real(r), imag(i) {}
}
and make T the same for i & r... need to add constraints so
that they are the same and implement a special merge for
numeric types which uses coerce_num
- handle recursive functions and cs-es recursion.
  need to assign edges to existing EntrySets to close
  the recursive loop.  Should do this after computing
  the full set of setters so as not to get into trouble.
  How to ensure termination???
- need a partial order for functions such that any two functions
  which could apply to the same arguments are total ordered
  Left first.  
- figure out why can't remove lvalue test from Var_is_local

** Cloning

- splice_in_clone should fixup the IF1/CFG/SSU/AVARS etc.
- hash SUM types in clone.cpp concretize_types
- implements, includes, contraints for cloned types

** Other

- remove dom.h is_dominated_by and replace with dfs_pred/succ implementation
- remove recursion from rename_edge (amoung others)
- verify CDG nesting code
- when building types if t->type != t remove it if t->type is present
- deal with "class_static"
- use inlining to simplify the program graph so that SSU conversion
  is more effective (??)
- redo SSU conversion after simple inlining
- constant folding for exponential (**)

** 

- handle structural types other than tuple
- handle matching/destructuring in return values
- implement #match
- hash folded constants... has constants on type + binary image
- handle currying within tuples
- casting?
- off by 1 on line # of pnodes?
- generalize/obviate forced splitting of "new_object"
- default arguments --- need to make a closure for each subset of 
  arguments which computes defaults and calls the underlying function.
  Probably with callbacks into the AST.
- curry functions: handle SEND where the whole set of arguments doesn't
  resolve... perhaps just don't group arguments in the front end.
- extend "is_functional" in if1.cpp

