\sekshun{Tuples}
\label{Tuples}
\index{tuples}

A tuple is an ordered set of components that allows for the
specification of a light-weight record with anonymous fields.

\subsection{Tuple Expressions}
\label{Tuple_Expressions}

A tuple expression is a comma-separated list of at least two
expressions that is enclosed in parentheses.  The number of
expressions is the size of the tuple and the types of the expressions
determine the component types of the tuple.  A single expression in
parentheses is a \sntx{parenthesized-expression} discussed
in~\rsec{Parenthesized_Expressions}.  A 1-tuple expression can be
created by defining a function that takes a variable number of
arguments as described in~\rsec{Variable_Length_Argument_Lists}.

The syntax of a tuple expression is given by:
\begin{syntax}
tuple-expression:
  ( expression , expression-list )

expression-list:
  expression
  expression , expression-list
\end{syntax}

\begin{example}
The statement
\begin{chapel}
var x = (1, 2);
\end{chapel}
defines a variable \chpl{x} that is a 2-tuple containing the values
\chpl{1} and \chpl{2}.
\end{example}

\subsection{Tuple Type Definitions}
\label{Tuple_Type_Definitions}
\index{tuples!types}

A tuple type is a comma-separated list of at least two types.  The
number of types in the list defines the size of the tuple, which is
part of the tuple's type.  The syntax of a tuple type is given by:
\begin{syntax}
tuple-type:
  ( type-specifier , type-list )
  homogeneous-tuple-type

type-list:
  type-specifier
  type-specifier , type-list
\end{syntax}

\begin{example}
Given a tuple expression \chpl{(1, 2)}, the type of the tuple value is
\chpl{(int, int)}, referred to as a 2-tuple of integers.
\end{example}

The \sntx{homogeneous-tuple-type} specifies a tuple type where all of
the type components are identical.  This special syntax is described
in~\rsec{Homogeneous_Tuples}.

If one type is delimited by parentheses, the parentheses are ignored.
Specifying a 1-tuple type can be accomplished using the syntax for
homogeneous tuples in~\rsec{Homogeneous_Tuples} by specifying 1 for
the integral parameter.

\subsection{Tuple Assignment}
\label{Tuple_Assignment}
\index{assignment!tuples}
\index{tuples!assignment}

In tuple assignment, the components of the tuple on the left-hand
side of the assignment operator are each assigned the components of
the tuple on the right-hand side of the assignment.  The assignments
are simultaneous so that each component expression on the right-hand
side is fully evaluated before being assigned to the left-hand side.

\subsection{Tuple Operators}
\label{Tuple_Operators}
\index{tuples!operators}

The arithmetic ~(\rsec{Arithmetic_Operators}), bitwise
~(\rsec{Bitwise_Operators}), shift ~(\rsec{Shift_Operators}), and
relational ~(\rsec{Relational_Operators}) operators are also defined
over tuples.

With the exception of relational operators, operations applied to two
tuples result in element-by-element application of the operation.

Relational operators over tuples apply in an "alphabetical" manner.
Each component is compared to the corresponding component or to the
scalar value until the relation is found to be true or false.

\begin{example}
In the code:
\begin{chapel}
var x = ("c", "h", "p", "l") > ("c", "h", "a", "t"); 
\end{chapel}
The value of \chpl{x} is \chpl{true}. After comparing \chpl{"c"} to
\chpl{"c"}, and \chpl{"h"} to \chpl{"h"}, \chpl{"p"} is found to be
greater than \chpl{"a"}, so the expression is \chpl{true}. 
\end{example}

\subsection{Tuple Destructuring}
\label{Tuple_Destructuring}
\index{tuples!destructuring}

When a tuple expression appears on the left-hand side of an assignment
statement, the expression on the right-hand side is said to be {\em
destructured}.  The components of the tuple on the right-hand side are
assigned to each of the component expressions on the left-hand side.
This assignment is simultaneous in that the right-hand side is
evaluated before the assignments are made.
\begin{example}
Given two variables of the same type, x and y, they can be swapped by
the following single assignment statement:
\begin{chapel}
(x, y) = (y, x);
\end{chapel}
\end{example}

\subsubsection{Variable Declarations in a Tuple}
\label{Variable_Declarations_in_a_Tuple}
\index{tuples!variable declarations}

Variables can be defined in a tuple to facilitate capturing the values
from a function that returns a tuple.  The extension to the syntax of
variable declarations is as follows:
\begin{syntax}
tuple-variable-declaration-statement:
  `config'[OPT] variable-kind tuple-variable-declaration ;

tuple-variable-declaration:
  ( tuple-identifier-list ) type-part[OPT] initialization-part
  ( tuple-identifier-list ) type-part

tuple-identifier-list:
  tuple-identifier
  tuple-identifier , tuple-identifier-list

tuple-identifier:
  identifier
  ( tuple-identifier-list )
\end{syntax}
The identifiers defined within the \sntx{tuple-identifier-list} are declared
to be new variables in the scope of the statement.  The
\sntx{type-part} and/or \sntx{initialization-part} defines a tuple
that is destructured when assigned to the new variables. The shape of the
\sntx{tuple-identifier-list} must match the shape of any specified
\sntx{type-part} or \sntx{initialization-part}.

\subsubsection{Ignoring Values with Underscore}
\label{Ignoring_Values_with_Underscore}
\index{_@\chpl{_}}

If an underscore appears as a component in a tuple expression in a
destructuring context, the expression on the right-hand side is
ignored, though it is still evaluated.

\subsection{Homogeneous Tuples}
\label{Homogeneous_Tuples}
\index{tuples!homogeneous}

A homogeneous tuple is a special-case of a general tuple where the
types of the components are identical.  Homogeneous tuples have fewer
restrictions for how they can be indexed~(\rsec{Tuple_Indexing}).

\subsubsection{Declaring Homogeneous Tuples}
\label{Declaring_Homogeneous_Tuples}

\index{* (tuples)@\chpl{*} tuples}

A homogeneous tuple type may be specified with the following syntax:
\begin{syntax}
homogeneous-tuple-type:
  integer-parameter-expression * type-specifier

integer-parameter-expression:
  expression
\end{syntax}
The homogeneous tuple type specification is syntactic sugar for the
type explicitly replicated a number of times equal to the
\sntx{integer-parameter-expression}.
\begin{example}
The following types are equivalent:
\begin{center}
\chpl{3*int} \hspace{2pc} \chpl{(int, int, int)}
\end{center}
\end{example}

\subsection{Tuple Indexing}
\label{Tuple_Indexing}
\index{tuples!indexing}

A tuple may be indexed into by an integer.  Indexing a tuple is
accomplished by treating the tuple as a function and passing an
integer to it as an argument.

The result of indexing a tuple by integer $k$ is the value of the
$k$th component.  If the tuple is not homogeneous, the tuple can only
be indexed by an integer parameter.  This ensures that the type of the
indexing expression is statically known.

\subsection{Formal Arguments of Tuple Type}
\label{Formal_Arguments_of_Tuple_Type}

\index{formal arguments!tuples}

This section of the specification is forthcoming.  In particular, it
is expected that tuple arguments will allow for implicit conversions
on the components rather than treating the arguments as if they are
records.

\subsubsection{Formal Argument Declarations in a Tuple}
\label{Formal_Argument_Declarations_in_a_Tuple}
\index{formal arguments!tuples}

Formal argument declarations can be grouped into a tuple similarly to
variable declarations to facilitate passing the result of a function that
returns a tuple directly to another function.
