\sekshun{Generics}
\label{Generics}

Chapel supports generic functions and types that are parameterizable
over both types and parameters.  The generic functions and types look
similar to non-generic functions and types already discussed.

\subsection{Generic Functions}
\label{Generic_Functions}

A function is generic if any of the following conditions hold:
\begin{itemize}
\item
Some formal argument is specified with an intent of \chpl{type} or
\chpl{param}.
\item
Some formal argument has no specified type and no default value.
\item
Some formal argument is specified with a queried type.
\item
The type of some formal argument is a generic type, e.g., \chpl{seq}.
\item
The type of some formal argument is an array type where either the
element type is queried or omitted or the domain is queried or
omitted.
\end{itemize}
These conditions are discussed in the next sections.

\subsubsection{Formal Type Arguments}
\label{Formal_Type_Arguments}

If a formal argument is specified with intent \chpl{type}, then a type
must be passed to the function at the call site.  A copy of the
function is instantiated for each unique type that is passed to this
function at a call site.  The formal argument has the semantics of a
type alias.
\begin{example}
The following code defines a function that takes two types at the call
site and returns a 2-tuple of sequences where the element types of the
two sequences are defined by the two type arguments:
\begin{chapel}
def buildTupleOfSeqs(type t, type tt)
  return (seq(t), seq(tt));
\end{chapel}
This function is instantiated with ``normal'' function call syntax
where the arguments are types:
\begin{chapel}
var tupleOfSeqs = buildTupleOfSeqs(int, string);
tupleOfSeqs(1) #= 1;
tupleOfSeqs(2) #= "hello";
\end{chapel}
\end{example}

\subsubsection{Formal Parameter Arguments}
\label{Formal_Parameter_Arguments}

If a formal argument is specified with intent \chpl{param}, then a
parameter must be passed to the function at the call site.  A copy of
the function is instantiated for each unique parameter that is passed
to this function at a call site.  The formal argument is a parameter.
\begin{example}
The following code defines a function that takes an integer parameter
\chpl{p} at the call site as well as a regular actual argument of
integer type \chpl{x}.  The function returns a homogeneous tuple of
size \chpl{p} where each component in the tuple has the value of
\chpl{x}.
\begin{chapel}
def fillTuple(param p: int, x: int) {
  var result: p*int;
  for param i in 1..p do
    result(i) = x;
  return result;
}
\end{chapel}
The function call \chpl{fillTuple(3, 3)} returns a 3-tuple where each
component contains the value \chpl{3}.
\end{example}

\subsubsection{Formal Arguments without Types}
\label{Formal_Arguments_without_Types}

If the type of a formal argument is omitted, the type of the formal
argument is taken to be the type of the actual argument passed to the
function at the call site.  A copy of the function is instantiated for
each unique actual type.
\begin{example}
The example from the previous section can be extended to be generic on
a parameter as well as the actual argument that is passed to it by
omitting the type of the formal argument \chpl{x}.  The following code
defines a function that returns a homogeneous tuple of size \chpl{p}
where each component in the tuple is initialized to \chpl{x}:
\begin{chapel}
def fillTuple(param p: int, x) {
  var result: p*x.type;
  for param i in 1..p do
    result(i) = x;
  return result;
}
\end{chapel}
In this function, the type of the tuple is taken to be the type of the
actual argument.  The call \chpl{fillTuple(3, 3.14)} returns a 3-tuple
of real values \chpl{(3.14, 3.14, 3.14)}.  The return type is
\chpl{(real, real, real)}.
\end{example}

\subsubsection{Formal Arguments with Queried Types}
\label{Formal_Arguments_with_Queried_Types}

If the type of a formal argument is specified as a queried type, the
type of the formal argument is taken to be the type of the actual
argument passed to the function at the call site.  A copy of the
function is instantiated for each unique actual type.  The queried
type has the semantics of a type alias.
\begin{example}
The example from the previous section can be rewritten to use a
queried type for clarity:
\begin{chapel}
def fillTuple(param p: int, x: ?t) {
  var result: p*t;
  for param i in 1..p do
    result(i) = x;
  return result;
}
\end{chapel}
\end{example}

\subsubsection{Formal Arguments of Generic Type}
\label{Formal_Arguments_of_Generic_Type}

If the type of a formal argument is a generic type, the type of the
formal argument is taken to be the type of the actual argument passed
to the function at the call site with the constraint that the type of
the actual argument is an instantiation of the generic type.  A copy
of the function is instantiated for each unique actual type.
\begin{example}
The following code defines a function that takes an actual argument
that is a sequence and outputs the elements in a sequence without any
space between the elements.  The function is generic on the element
type of the sequence.
\begin{chapel}
def output(s: seq) {
  for e in s do
    write(e);
}
\end{chapel}
\end{example}

\subsubsection{Formal Arguments of Generic Array Types}
\label{Formal_Arguments_of_Generic_Array_Types}

If the type of a formal argument is an array where either the domain
or the element type is queried or omitted, the type of the formal
argument is taken to be the type of the actual argument passed to the
function at the call site.  If the domain is omitted, the domain of
the formal argument is taken to be the domain of the actual argument.

\subsection{Function Visibility in Generic Functions}
\label{Function_Visibility_in_Generic_Functions}

Function visibility in generic functions is altered depending on the
instantiation.  When resolving function calls made within visible
functions, the visible functions are taken from any call site at which
the function is instantiated for each particular instantiation.

\subsection{Generic Types}
\label{Generic_Types}

A class or record is generic if any of the following conditions hold:
\begin{itemize}
\item
The class contains a specified or unspecified type alias.
\item
The class contains a field that is a parameter.
\item
The class contains a field that has no type and no initialization
expression.
\item
The class contains a field where the type of the field is generic.
\end{itemize}

\subsubsection{Type Aliases in Generic Types}
\label{Type_Aliases_in_Generic_Types}

Type aliases defined in a class or a record can be unspecified type
aliases; type aliases that are not bound to a type.  If a class or
record contains an unspecified type alias, the aliased type must be
specified whenever the type is used.

A type alias defined in a class or record is accessed as if it were a
field.  Moreover, it becomes an argument with intent \chpl{type} to
the default constructor for that class or record.  This makes the
default constructor generic.  When the default constructor is
instantiated, the type is instantiated where the type bound to the
type alias is set to be the type passed to the default constructor.

\begin{example}
The following code defines a class called \chpl{Node} that implements
a linked list data structure.  It is generic over the type of the
element contained in the linked list.
\begin{chapel}
class Node {
  type elt_type;
  var data: elt_type;
  var next: Node(elt_type);
}
\end{chapel}
The call \chpl{Node(real, 3.14)} creates a node in the linked list
that contains the value \chpl{3.14}.  The \chpl{next} field is set to
nil.  The type specifier \chpl{Node} is a generic type and cannot be
used to deefine a variable.  The type specifier \chpl{Node(real)}
denotes the type of the \chpl{Node} class instantiated over
\chpl{real}.  Note that the type of the \chpl{next} field is specified
as \chpl{Node(elt_type)}; the type of \chpl{next} is the same type as
the type of the object that it is a field of.
\end{example}

\subsubsection{Parameters in Generic Types}
\label{Parameters_in_Generic_Types}

Parameters defined in a class or record do not require an
initialization expression.  If they do not have an initialization
expression, the parameter must be specified whenever the type is used.

A parameter defined in a class or record is accessed as if it were a
field.  This access returns a parameter.  Parameters defined in
classes or records become arguments with intent \chpl{param} to the
default constructor for that class or record.  This makes the default
constructor generic.  When the default constructor is instantiated,
the type is instantiated where the parameter is bound to the parameter
passed to the default constructor.

\begin{example}
The following code defines a class called \chpl{IntegerTuple} that is
generic over an integer parameter which defines the number of
components in the class.
\begin{chapel}
class IntegerTuple {
  param size: int;
  var data: size*int;
}
\end{chapel}
The call \chpl{IntegerTuple(3)} creates an instance of the
\chpl{IntegerTuple} class that is instantiated over parameter
\chpl{3}.  The field \chpl{data} becomes a 3-tuple of integers.  The
type of this class instance is \chpl{IntegerTuple(3)}.  The type
specified by \chpl{IntegerTuple} is a generic type.
\end{example}

\subsubsection{Fields without Types}
\label{Fields_without_Types}

If a field in a class or record has no specified type or
initialization expression, the class or record is generic over the
type of that field.  The field must be specified when the class or
record is constructed or specified.  The field becomes an argument to
the default constructor that has no specified type and no default
value.  This makes the default constructor generic.  When the default
constructor is instantiated, the type is instantiated where the type
of the field becomes the type of the actual argument passed to the
default constructor.

\begin{example}
The following code defines another class called \chpl{Node} that
implements a linked list data structure.  It is generic over the type
of the element contained in the linked list.  This code does not
specify the element type directly in the class as a type alias but
rather leaves omits the type from the \chpl{data} field.
\begin{chapel}
class Node {
  var data;
  var next: Node(data) = nil;
}
\end{chapel}
A node with integer element type can be defined in the call to the
constructor.  The call \chpl{Node(1)} defines a node with the value
\chpl{1}.  The code
\begin{chapel}
var list = Node(1);
list.next = Node(2);
\end{chapel}
defines a two-element list with nodes containing the values \chpl{1}
and \chpl{2}.
\end{example}

\subsubsection{Fields of Generic Types}
\label{Fields_of_Generic_Types}

If a field in a class or record is specified to have a generic type,
then the class or record is generic over the type of this field and
the type of the field is constrained to be an instantiation of the
field's specified generic type.

\subsubsection{Generic Methods}
\label{Generic_Methods}

All methods bound to generic classes or records are generic over the
implicit \chpl{this} argument and any other argument that is generic.

\subsubsection{The {\em elt\_type} Type}
\label{The_em_elt_type_Type}

The common idiom of parameterizing a collection-oriented data type by
a single element type has special syntactic support given by
\begin{syntax}
of-type:
  type `of' type
\end{syntax}
This syntax is a short-hand for passing the second type by name
\chpl{elt_type} as the only argument to the first type.  Given the
definition of \chpl{Node} in the example
in~\rsec{Type_Aliases_in_Generic_Types}, one can specify the type
\chpl{Node(real)} or \chpl{Node(elt_type=real)} by writing \chpl{Node
of real}.

\subsection{Where Expressions}
\label{Where_Expressions}

The instantiation of a generic function can be constrained by {\em
where clauses}.  A where clause is specified in the definition of a
function~(\rsec{Function_Definitions}).  When a function is
instantiated, the expression in the where clause must be a parameter
expression and must evaluate to either \chpl{true} or \chpl{false}.
If it evaluates to \chpl{false}, the instantiation is rejected and the
function is not a possible candidate for function resolution.
Otherwise, the function is instantiated.
\begin{example}
Given two overloaded function definitions
\begin{chapel}
def foo(x) where x.type == int { $\ldots$ }
def foo(x) where x.type == real { $\ldots$ }
\end{chapel}
the call foo(3) resolves to the first definition because when the
second function is instantiated the where clause evaluates to false.
\end{example}

\subsection{Example: A Generic Stack}
\label{Example_Generic_Stack}

\begin{chapel}
\include(../test/release/examples/genericStack.chpl)
\end{chapel}
