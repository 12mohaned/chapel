#!/usr/bin/perl
#

#if ($#ARGV > -1) {
#    if ($#ARGV == 0 && $ARGV[0] eq "verbose") {
#        $verbose = 1;
#    } else {
#        die "usage: collect_syntax.pl [verbose]\n";
#    }
#}
$verbose = 1;

`rm -f Syntax.tex`;
$i = 0;
@texs = `ls *.tex`;
foreach $tex (@texs) {
    chomp $tex;
    $readSyntax = 0;
    $rule = "";
    @lines = `cat $tex`;
    foreach $line (@lines) {
        if ($line =~ /^\\begin\{syntax\}/) {
            die "unmatched begin of syntax block" if ($readSyntax == 1);
            $readSyntax = 1;
        } elsif ($line =~ /^\\end\{syntax\}/) {
            die "unmatched end of syntax block" if ($readSyntax == 0);
            $readSyntax = 0;
            if ($tex eq "Lexical_Structure.tex") {
                $lexes{$i++} = $rule;
            } else {
                $rules{$i++} = $rule;
            }
            $rule = "";
        } elsif ($readSyntax == 1) {
            if ($line =~ /^\s*$/) {
                if ($tex eq "Lexical_Structure.tex") {
                    $lexes{$i++} = $rule;
                } else {
                    $rules{$i++} = $rule;
                }
                $rule = "";
            } else {
                $rule .= $line;
            }
        }
    }
}

open FILE, ">Syntax.tex";
print FILE "%%\n";
print FILE "%% Do not modify this file.  This file is automatically\n";
print FILE "%% generated by collect_syntax.pl.\n";
print FILE "%%\n\n";
print FILE "\\sekshun{Collected Lexical and Syntax Productions}\n";
print FILE "\\label{Syntax}\n\n";
print FILE "This appendix collects the syntax productions listed throughout the specification.  There are no new syntax productions in this appendix.  The productions are listed alphabetically for reference.\n\n";
print FILE "\\subsection{Lexical productions}\n\n";
$last = "";
foreach $rule (sort values %lexes) {
    $prefix = $last;
    if ($prefix =~ m/(.*:)/) {
        if ($rule =~ m/^$1/) {
            if (!($rule eq $last)) {
                print "Syntax rules do not match\n";
                print "$last$rule";
            }
            $duplicate = 1;
        }
    }
    if ($duplicate == 0) {
        print FILE "\\begin{syntax}\n";
        print FILE "$rule";
        print FILE "\\end{syntax}\n\n";
    }
    $duplicate = 0;
    $last = $rule;
}
print FILE "\\subsection{Syntax productions}\n\n";
$last = "";
foreach $rule (sort values %rules) {
    $prefix = $last;
    if ($prefix =~ m/(.*:)/) {
        if ($rule =~ m/^$1/) {
            if (!($rule eq $last)) {
                print "Syntax rules do not match\n";
                print "$last$rule";
            }
            $duplicate = 1;
        }
    }
    if ($duplicate == 0) {
        print FILE "\\begin{syntax}\n";
        print FILE "$rule";
        print FILE "\\end{syntax}\n\n";
    }
    $duplicate = 0;
    $last = $rule;
}
close FILE;

print "Collected $i grammar rules in Syntax.tex\n"; # counts duplicates

if ($verbose) {
    foreach $rule (values %lexes) {
        $rules{$i++} = $rule;
    }

    foreach $rule (values %rules) {
        if ($rule =~ m/^(.*):/) {
            $counts{$1} = 1;
        }
    }

    foreach $rule (sort values %rules) {
        if ($rule =~ m/^(.*):/) {
            $rule =~ s/\`.*\'//g;
            $rule =~ s/\[OPT\]//g;
            $rule =~ s/^.*://g;
            $rule =~ s/one\ of//g;
            $rule =~ s/[^\-\w\ ]//g;
            $rule =~ s/\s-/\ /g;
            $rule =~ s/\s+/\ /g;
            $rule =~ s/^\s+//g;
            @prefixes = split /\ /, $rule;
            foreach $prefix (@prefixes) {
                if ($counts{$prefix} < 1) {
                    print "error: used but not defined: $prefix\n";
                } else {
                    $counts{$prefix} += 1;
                }
            }
        }
    }

    foreach $prefix (sort keys %counts) {
        $counts{$prefix}--;
        if ($counts{$prefix} < 1) {
            print "error: defined but not used: $prefix\n";
        }
#        print "$counts{$prefix}: $prefix\n";
    }
}
