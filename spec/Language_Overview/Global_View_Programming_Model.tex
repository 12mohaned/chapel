Parallel programming models can be divided into two types of models:
{\em fragmented} and {\em global-view}.  Fragmented programming models
require programmers to express algorithms on a task-by-task basis so that
the tasks can execute in parallel.  Global-view programming models
allow programmers to express a parallel algorithm as a whole, similar to
a serial algorithm.  The compiler and runtime libraries identify and assign
tasks to run in parallel across processors.  Chapel provides a global-view 
programming model.

The global-view programming model is is able:
\begin{itemize}
\item to operate on distributed data structures monolithically as 
though they were local to the executing thread's memory, and 
\item to express parallelism within a single source text without requiring 
multiple executables to be run simultaneously. 
\end{itemize}
While the global-view programming model can be implemented on any distributed memory 
machine, specific architectures provide an ideal target for this model.  
Global-view models map particularly well to architectures that 
support a global address space, DGAS and PGAS memory segments, a high performance 
network, lightweight synchronization, and latency-tolerant processors.  This 
synergy results in improved performance as compared to implementations on less-
productive architectures.

We believe that the dominance of the fragmented programming model is the primary
inhibitor of parallel programmability today, and therefore recommend that new
productivity-oriented languages focus on supporting a global view of parallel
programming.  




