\sekshun{Expressions}
\label{Expressions}

This section defines expressions in Chapel.  Forall expressions are
described in~\rsec{Forall_Expressions}.

The syntax for an expression is given by:
\begin{syntax}
expression:
  literal-expression
  variable-expression
  member-access-expression
  call-expression
  query-expression
  cast-expression
  lvalue-expression
  unary-expression
  binary-expression
  let-expression
  if-expression
  for-expression
  open-interval-expression
  parallel-expression
  reduce-expression
  scan-expression
  module-access-expression
  tuple-expression
  tuple-destructuring-expression
  locale-access-expression
\end{syntax}

The expressions that create and limit
parallelism, \sntx{parallel-expression}, are discussed
in~\rsec{Parallelism_and_Synchronization}.  Reductions and
scans, \sntx{reduce-expression} and \sntx{scan-expression}, are
defined in~\rsec{Reductions_and_Scans}.  Module access
expressions, \sntx{module-access-expression}, are defined
in~\rsec{Explicit_Naming}.  Tuple
expressions, \sntx{tuple-expression}, are defined
in~\rsec{Tuple_Expressions}.  Tuple destructuring
expressions, \sntx{tuple-destructuring-expression}, are defined
in~\rsec{Variable_Length_Argument_Lists}.  Locale access
expressions, \sntx{locale-access-expression}, are defined
in~\rsec{Querying_the_Locale_of_a_Variable}.

\subsection{Literal Expressions}
\label{Literal_Expressions}

A literal value for any of the built-in types is a literal expression.
These are defined where the type is defined.  The list of literal
values is given by the following syntax:
\begin{syntax}
literal-expression:
  bool-literal
  integer-literal
  real-literal
  imaginary-literal
  string-literal
  range-literal
\end{syntax}

\subsection{Variable Expressions}
\label{Variable_Expressions}

A use of a variable is itself an expression.  The syntax of a variable
expression is given by:
\begin{syntax}
variable-expression:
  identifier
\end{syntax}

\subsection{Call Expressions}
\label{Call_Expressions}
\index{function calls}

The syntax to call a function is given by:
\begin{syntax}
call-expression:
  expression ( named-expression-list )
  expression [ named-expression-list ]
  parenthesesless-function-identifier

named-expression-list:
  named-expression
  named-expression , named-expression-list

named-expression:
  expression
  identifier = expression

parenthesesless-function-identifier:
  identifier
\end{syntax}

A \sntx{call-expression} is resolved to a particular function
according to the algorithm for function resolution described
in~\rsec{Function_Resolution}.

Functions can be called using either parentheses or brackets.  The
only difference in the call has to do with promotion and is discussed
in~\rsec{Tensor_Product_Promotion}.

Functions that are defined without parentheses are called without
parentheses where the symbol is resolved.  Functions with parentheses
are discussed in~\rsec{Functions_without_Parentheses}.

A \sntx{named-expression} is an expression that may be optionally
named.  The optional \sntx{identifier} represents a named actual
argument described in~\rsec{Named_Arguments}.

\subsubsection{Indexing Expressions}
\label{Indexing_Expressions}
\index{indexing}

Indexing into arrays, tuples, and domains shares the same syntax of a
call expression.  Indexing, at its core, is nothing more than a call
to the indexing function defined on these types.

\subsubsection{Member Access Expressions}
\label{Member_Access_Expressions}
\index{member access}

Member access expressions are call expressions to members of classes,
records, or unions.  The syntax for a member access is given by:
\begin{syntax}
member-access-expression:
  expression . identifier
\end{syntax}
The member access may be an access of a field or a function inside a
class, record, or union.

\subsection{The Query Expression}
\label{The_Query_Expression}
\index{?@\chpl{?}}

A query expression is used to query a type or value within a formal
argument type expression.  The syntax of a query expression is given
by:
\begin{syntax}
query-expression:
  ? identifier
\end{syntax}
Querying is restricted to querying the type of a formal argument, the
element type of an formal argument that is an array, the domain of a
formal argument that is an array, the size of a primitive type, or a
type or parameter field of a formal argument type.
\begin{example}
The following code defines a generic function where the type of the
first parameter is queried and stored in the type alias \chpl{t} and
the domain of the second argument is queried and stored in the
variable \chpl{D}:
\begin{chapel}
def foo(x: ?t, y: [?D] t) {
  for i in D do
    y[i] = x;
}
\end{chapel}
The type alias \chpl{t} is used to specify the element type of
array \chpl{y}.  Arrays passed to this function must have element
type \chpl{y}.  The body of the function iterates over the domain
of \chpl{y} captured in variable \chpl{D} and assigns the value of
argument \chpl{x} to each element in array \chpl{y}.
\end{example}

There is an expectation that query expressions will be allowed in more
places in the future.

\subsection{Casts}
\label{Casts}
\index{casts}

A cast is specified with the following syntax:
\begin{syntax}
cast-expression:
  expression : type-specifier
\end{syntax}
The expression is converted to the specified type.  Except for the
casts listed below, casts are restricted to valid explicit
conversions~(\rsec{Explicit_Conversions}).

The following cast has a special meaning and does not correspond to an
explicit conversion:
\begin{itemize}
\item \index{complex!casts from tuples}
  A cast from a 2-tuple to \chpl{complex} converts the 2-tuple into a
  complex where the first component becomes the real part and the
  second component becomes the imaginary part.  The size of the
  complex is determined from the size of the components based on
  implicit conversions.
\end{itemize}

\subsection{LValue Expressions}
\label{lvalue}
\index{lvalue}

An {\em lvalue} is an expression that can be used on the left-hand
side of an assignment statement or on both sides of a swap statement,
that can be passed to a formal argument of a function that has \chpl{out} or 
\chpl{inout} intent, or that can be returned by a variable function.  Valid 
lvalue expressions include the following:
\begin{itemize}
\item
 Variable expressions.
\item
 Member access expressions.
\item
 Call expressions of variable functions.
\item
 Indexing expressions.
\end{itemize}

LValue expressions are given by the following syntax:
\begin{syntax}
lvalue-expression:
  variable-expression
  member-access-expression
  call-expression
\end{syntax}
The syntax is more relaxed than the definition above.  For example, not
all \sntx{call-expression}s are lvalues.

\subsection{Operator Precedence and Associativity}
\label{Operator_Precedence_and_Associativity}
\index{operators!precedence}
\index{operators!associativity}

The following table summarizes the precedence of operators and their
associativity.  Operators listed earlier have higher precedence than
those listed later.
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf operators} & {\bf associativity} & {\bf use} \\
\hline
\verb@.@ & left & member access \\
\verb@() []@ & left & function call, index expression \\
\verb@**@ & right & exponentiation \\
unary \verb@+ - ~@ & right & sign and bitwise negation \\
\verb@:@ & left & cast\\
\verb@* / %@ & left & multiply, divide, and modulus \\
\verb@+ -@ & left & plus and minus \\
\verb@&@ & left & bitwise and \\
\verb@^@ & left & bitwise xor \\
\verb@<< >>@ & left & shift left and shift right \\
\verb@|@ & left & bitwise or \\
\verb@<= >= < >@ & left & ordered comparison \\
\verb@== !=@ & left & equality comparison \\
\verb@!@ & right & logical negation \\
\verb@&&@ & left & logical and \\
\verb@||@ & left & logical or \\
\verb@..@ & left & ranges \\
\verb@in@ & left & forall expressions \\
\verb@by@ & left & striding ranges and domains \\
\verb@if@ & left & conditional expressions \\
\verb@reduce scan@ & left & reductions and scans\\
\verb@,@ & left & comma separated expressions \\
\hline
\end{tabular}
\end{center}

\begin{rationale}
In determining the relative precedence of exponentiation, unary plus
and minus, and casts, we encountered a circularity in intuition.  The
following three examples show our intuition about how these
expressions should be parenthesized:
\begin{center}
\begin{tabular}{lcl}
\chpl{-2**4} & wants & \chpl{-(2**4)} \\
\chpl{-2:uint} & wants & \chpl{(-2):uint} \\
\chpl{2:uint**4:uint} & wants & \chpl{(2:uint)**(4:uint)} \\
\end{tabular}
\end{center}
Following this, we would make exponentiation take precedence over
unary plus and minus, unary plus and minus take precedence over casts,
and casts take precedence over exponentiation.  Assuming that a
precedence wheel is more complicated than a precedence table, we
dropped a want to give
\begin{center}
\begin{tabular}{lcl}
\chpl{2:uint**4:uint} & needs & \chpl{((2:uint)**4):uint} \\
\end{tabular}
\end{center}
\end{rationale}

\subsection{Operator Expressions}
\label{Binary_Expressions}
\label{Unary_Expressions}

The application of operators to expressions is itself an expression.
The syntax of a unary expression is given by:
\begin{syntax}
unary-expression:
  unary-operator expression

unary-operator: one of
  + - ~ !
\end{syntax}

The syntax of a binary expression is given by:
\begin{syntax}
binary-expression:
  expression binary-operator expression

binary-operator: one of
  + - * / % ** & | ^ << >> && || == != <= >= < >
\end{syntax}

The operators are defined in subsequent sections.

\subsection{Arithmetic Operators}
\label{Arithmetic_Operators}
\index{operators!arithmetic}

This section describes the predefined arithmetic operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}).

All arithmetic operators are implemented over integral types of size
32 and 64 bits only.  For example, adding two 8-bit integers is done
by first converting them to 32-bit integers and then adding the 32-bit
integers.  The result is a 32-bit integer.

\subsubsection{Unary Plus Operators}
\label{Unary_Plus_Operators}
\index{+ (unary)@\chpl{+} (unary)}

The unary plus operators are predefined as follows:
\begin{chapel}
def +(a: int(32)): int(32)
def +(a: int(64)): int(64)
def +(a: uint(32)): uint(32)
def +(a: uint(64)): uint(64)
def +(a: real(32)): real(32)
def +(a: real(64)): real(64)
def +(a: real(128)): real(128)
def +(a: imag(32)): imag(32)
def +(a: imag(64)): imag(64)
def +(a: imag(128)): imag(128)
def +(a: complex(32)): complex(32)
def +(a: complex(64)): complex(64)
def +(a: complex(128)): complex(128)
\end{chapel}
For each of these definitions, the result is the value of the operand.

\subsubsection{Unary Minus Operators}
\label{Unary_Minus_Operators}
\index{- (unary)@\chpl{-} (unary)}

The unary minus operators are predefined as follows:
\begin{chapel}
def -(a: int(32)): int(32)
def -(a: int(64)): int(64)
def -(a: uint(64))
def -(a: real(32)): real(32)
def -(a: real(64)): real(64)
def -(a: real(128)): real(128)
def -(a: imag(32)): imag(32)
def -(a: imag(64)): imag(64)
def -(a: imag(128)): imag(128)
def -(a: complex(32)): complex(32)
def -(a: complex(64)): complex(64)
def -(a: complex(128)): complex(128)
\end{chapel}
For each of these definitions that return a value, the result is the
negation of the value of the operand.  For integral types, this
corresponds to subtracting the value from zero.  For real and
imaginary types, this corresponds to inverting the sign.  For complex
types, this corresponds to inverting the signs of both the real and
imaginary parts.

It is an error to try to negate a value of type \chpl{uint(64)}.  Note
that negating a value of type \chpl{uint(32)} first converts the type
to \chpl{int(64)} using an implicit conversion.

\subsubsection{Addition Operators}
\label{Addition_Operators}
\index{+@\chpl{+}}

The addition operators are predefined as follows:
\begin{chapel}
def +(a: int(32), b: int(32)): int(32)
def +(a: int(64), b: int(64)): int(64)
def +(a: uint(32), b: uint(32)): uint(32)
def +(a: uint(64), b: uint(64)): uint(64)
def +(a: uint(64), b: int(64))
def +(a: int(64), b: uint(64))

def +(a: real(32), b: real(32)): real(32)
def +(a: real(64), b: real(64)): real(64)
def +(a: real(128), b: real(128)): real(128)

def +(a: imag(32), b: imag(32)): imag(32)
def +(a: imag(64), b: imag(64)): imag(64)
def +(a: imag(128), b: imag(128)): imag(128)

def +(a: complex(64), b: complex(64)): complex(64)
def +(a: complex(128), b: complex(128)): complex(128)
def +(a: complex(256), b: complex(256)): complex(256)

def +(a: real(32), b: imag(32)): complex(64)
def +(a: imag(32), b: real(32)): complex(64)
def +(a: real(64), b: imag(64)): complex(128)
def +(a: imag(64), b: real(64)): complex(128)
def +(a: real(128), b: imag(128)): complex(256)
def +(a: imag(128), b: real(128)): complex(256)

def +(a: real(32), b: complex(64)): complex(64)
def +(a: complex(64), b: real(32)): complex(64)
def +(a: real(64), b: complex(128)): complex(128)
def +(a: complex(128), b: real(64)): complex(128)
def +(a: real(128), b: complex(256)): complex(256)
def +(a: complex(256), b: real(128)): complex(256)

def +(a: imag(32), b: complex(64)): complex(64)
def +(a: complex(64), b: imag(32)): complex(64)
def +(a: imag(64), b: complex(128)): complex(128)
def +(a: complex(128), b: imag(64)): complex(128)
def +(a: imag(128), b: complex(256)): complex(256)
def +(a: complex(256), b: imag(128)): complex(256)
\end{chapel}
For each of these definitions that return a value, the result is the
sum of the two operands.

It is a compile-time error to add a value of type \chpl{uint(64)} and
a value of type \chpl{int(64)}.

Addition over a value of real type and a value of imaginary type
produces a value of complex type.  Addition of values of complex type
and either real or imaginary types also produces a value of complex
type.

\subsubsection{Subtraction Operators}
\label{Subtraction_Operators}
\index{-@\chpl{-}}

The subtraction operators are predefined as follows:
\begin{chapel}
def -(a: int(32), b: int(32)): int(32)
def -(a: int(64), b: int(64)): int(64)
def -(a: uint(32), b: uint(32)): uint(32)
def -(a: uint(64), b: uint(64)): uint(64)
def -(a: uint(64), b: int(64))
def -(a: int(64), b: uint(64))

def -(a: real(32), b: real(32)): real(32)
def -(a: real(64), b: real(64)): real(64)
def -(a: real(128), b: real(128)): real(128)

def -(a: imag(32), b: imag(32)): imag(32)
def -(a: imag(64), b: imag(64)): imag(64)
def -(a: imag(128), b: imag(128)): imag(128)

def -(a: complex(64), b: complex(64)): complex(64)
def -(a: complex(128), b: complex(128)): complex(128)
def -(a: complex(256), b: complex(256)): complex(256)

def -(a: real(32), b: imag(32)): complex(64)
def -(a: imag(32), b: real(32)): complex(64)
def -(a: real(64), b: imag(64)): complex(128)
def -(a: imag(64), b: real(64)): complex(128)
def -(a: real(128), b: imag(128)): complex(256)
def -(a: imag(128), b: real(128)): complex(256)

def -(a: real(32), b: complex(64)): complex(64)
def -(a: complex(64), b: real(32)): complex(64)
def -(a: real(64), b: complex(128)): complex(128)
def -(a: complex(128), b: real(64)): complex(128)
def -(a: real(128), b: complex(256)): complex(256)
def -(a: complex(256), b: real(128)): complex(256)

def -(a: imag(32), b: complex(64)): complex(64)
def -(a: complex(64), b: imag(32)): complex(64)
def -(a: imag(64), b: complex(128)): complex(128)
def -(a: complex(128), b: imag(64)): complex(128)
def -(a: imag(128), b: complex(256)): complex(256)
def -(a: complex(256), b: imag(128)): complex(256)
\end{chapel}
For each of these definitions that return a value, the result is the
value obtained by subtracting the second operand from the first
operand.

It is a compile-time error to subtract a value of type \chpl{uint(64)}
from a value of type \chpl{int(64)}, and vice versa.

Subtraction of a value of real type from a value of imaginary type,
and vice versa, produces a value of complex type.  Subtraction of
values of complex type from either real or imaginary types, and vice
versa, also produces a value of complex type.

\subsubsection{Multiplication Operators}
\label{Multiplication_Operators}
\index{*@\chpl{*}}

The multiplication operators are predefined as follows:
\begin{chapel}
def *(a: int(32), b: int(32)): int(32)
def *(a: int(64), b: int(64)): int(64)
def *(a: uint(32), b: uint(32)): uint(32)
def *(a: uint(64), b: uint(64)): uint(64)
def *(a: uint(64), b: int(64))
def *(a: int(64), b: uint(64))

def *(a: real(32), b: real(32)): real(32)
def *(a: real(64), b: real(64)): real(64)
def *(a: real(128), b: real(128)): real(128)

def *(a: imag(32), b: imag(32)): real(32)
def *(a: imag(64), b: imag(64)): real(64)
def *(a: imag(128), b: imag(128)): real(128)

def *(a: complex(64), b: complex(64)): complex(64)
def *(a: complex(128), b: complex(128)): complex(128)
def *(a: complex(256), b: complex(256)): complex(256)

def *(a: real(32), b: imag(32)): imag(32)
def *(a: imag(32), b: real(32)): imag(32)
def *(a: real(64), b: imag(64)): imag(64)
def *(a: imag(64), b: real(64)): imag(64)
def *(a: real(128), b: imag(128)): imag(128)
def *(a: imag(128), b: real(128)): imag(128)

def *(a: real(32), b: complex(64)): complex(64)
def *(a: complex(64), b: real(32)): complex(64)
def *(a: real(64), b: complex(128)): complex(128)
def *(a: complex(128), b: real(64)): complex(128)
def *(a: real(128), b: complex(256)): complex(256)
def *(a: complex(256), b: real(128)): complex(256)

def *(a: imag(32), b: complex(64)): complex(64)
def *(a: complex(64), b: imag(32)): complex(64)
def *(a: imag(64), b: complex(128)): complex(128)
def *(a: complex(128), b: imag(64)): complex(128)
def *(a: imag(128), b: complex(256)): complex(256)
def *(a: complex(256), b: imag(128)): complex(256)
\end{chapel}
For each of these definitions that return a value, the result is the
product of the two operands.

It is a compile-time error to multiply a value of type \chpl{uint(64)} and
a value of type \chpl{int(64)}.

Multiplication of values of imaginary type produces a value of real
type.  Multiplication over a value of real type and a value of
imaginary type produces a value of imaginary type.  Multiplication of
values of complex type and either real or imaginary types produces a
value of complex type.

\subsubsection{Division Operators}
\label{Division_Operators}
\index{/@\chpl{/}}

The division operators are predefined as follows:
\begin{chapel}
def /(a: int(32), b: int(32)): int(32)
def /(a: int(64), b: int(64)): int(64)
def /(a: uint(32), b: uint(32)): uint(32)
def /(a: uint(64), b: uint(64)): uint(64)
def /(a: uint(64), b: int(64))
def /(a: int(64), b: uint(64))

def /(a: real(32), b: real(32)): real(32)
def /(a: real(64), b: real(64)): real(64)
def /(a: real(128), b: real(128)): real(128)

def /(a: imag(32), b: imag(32)): real(32)
def /(a: imag(64), b: imag(64)): real(64)
def /(a: imag(128), b: imag(128)): real(128)

def /(a: complex(64), b: complex(64)): complex(64)
def /(a: complex(128), b: complex(128)): complex(128)
def /(a: complex(256), b: complex(256)): complex(256)

def /(a: real(32), b: imag(32)): imag(32)
def /(a: imag(32), b: real(32)): imag(32)
def /(a: real(64), b: imag(64)): imag(64)
def /(a: imag(64), b: real(64)): imag(64)
def /(a: real(128), b: imag(128)): imag(128)
def /(a: imag(128), b: real(128)): imag(128)

def /(a: real(32), b: complex(64)): complex(64)
def /(a: complex(64), b: real(32)): complex(64)
def /(a: real(64), b: complex(128)): complex(128)
def /(a: complex(128), b: real(64)): complex(128)
def /(a: real(128), b: complex(256)): complex(256)
def /(a: complex(256), b: real(128)): complex(256)

def /(a: imag(32), b: complex(64)): complex(64)
def /(a: complex(64), b: imag(32)): complex(64)
def /(a: imag(64), b: complex(128)): complex(128)
def /(a: complex(128), b: imag(64)): complex(128)
def /(a: imag(128), b: complex(256)): complex(256)
def /(a: complex(256), b: imag(128)): complex(256)
\end{chapel}
For each of these definitions that return a value, the result is the
quotient of the two operands.

It is a compile-time error to divide a value of type \chpl{uint(64)} by
a value of type \chpl{int(64)}, and vice versa.

Division of values of imaginary type produces a value of real type.
Division over a value of real type and a value of imaginary type
produces a value of imaginary type.  Division of values of complex
type and either real or imaginary types produces a value of complex
type.

\subsubsection{Modulus Operators}
\label{Modulus_Operators}
\index{\%@\chpl{\%}}

The modulus operators are predefined as follows:
\begin{chapel}
def %(a: int(32), b: int(32)): int(32)
def %(a: int(64), b: int(64)): int(64)
def %(a: uint(32), b: uint(32)): uint(32)
def %(a: uint(64), b: uint(64)): uint(64)
def %(a: uint(64), b: int(64))
def %(a: int(64), b: uint(64))
\end{chapel}
For each of these definitions that return a value, the result is the
remainder when the first operand is divided by the second operand.

It is a compile-time error to take the remainder of a value of
type \chpl{uint(64)} and a value of type \chpl{int(64)}, and vice
versa.

There is an expectation that the predefined modulus operators will be
extended to handle real, imaginary, and complex types in the future.

\subsubsection{Exponentiation Operators}
\label{Exponentiation_Operators}
\index{**@\chpl{**}}

The exponentiation operators are predefined as follows:
\begin{chapel}
def **(a: int(32), b: int(32)): int(32)
def **(a: int(64), b: int(64)): int(64)
def **(a: uint(32), b: uint(32)): uint(32)
def **(a: uint(64), b: uint(64)): uint(64)
def **(a: uint(64), b: int(64))
def **(a: int(64), b: uint(64))

def **(a: real(32), b: real(32)): real(32)
def **(a: real(64), b: real(64)): real(64)
def **(a: real(128), b: real(128)): real(128)
\end{chapel}
For each of these definitions that return a value, the result is the
value of the first operand raised to the power of the second operand.

It is a compile-time error to take the exponent of a value of
type \chpl{uint(64)} by a value of type \chpl{int(64)}, and vice
versa.

There is an expectation that the predefined exponentiation operators
will be extended to handle imaginary and complex types in the future.

\subsection{Bitwise Operators}
\label{Bitwise_Operators}
\index{operators!bitwise}

This section describes the predefined bitwise operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}.

\subsubsection{Bitwise Complement Operators}
\label{Bitwise_Complement_Operators}
\index{\~@\chpl{\~}}

The bitwise complement operators are predefined as follows:
\begin{chapel}
def ~(a: bool): bool
def ~(a: int(32)): int(32)
def ~(a: int(64)): int(64)
def ~(a: uint(32)): uint(32)
def ~(a: uint(64)): uint(64)
\end{chapel}
For each of these definitions, the result is the bitwise complement of
the operand.

\subsubsection{Bitwise And Operators}
\label{Bitwise_And_Operators}
\index{&@\chpl{&}}

The bitwise and operators are predefined as follows:
\begin{chapel}
def &(a: bool, b: bool): bool
def &(a: int(32), b: int(32)): int(32)
def &(a: int(64), b: int(64)): int(64)
def &(a: uint(32), b: uint(32)): uint(32)
def &(a: uint(64), b: uint(64)): uint(64)
def &(a: uint(64), b: int(64))
def &(a: int(64), b: uint(64))
\end{chapel}
For each of these definitions that return a value, the result is
computed by applying the logical and operation to the bits of the
operands.

It is a compile-time error to apply the bitwise and operator to a
value of type \chpl{uint(64)} and a value of type \chpl{int(64)}, and
vice versa.

\subsubsection{Bitwise Or Operators}
\label{Bitwise_Or_Operators}
\index{|@\chpl{|}}

The bitwise or operators are predefined as follows:
\begin{chapel}
def |(a: bool, b: bool): bool
def |(a: int(32), b: int(32)): int(32)
def |(a: int(64), b: int(64)): int(64)
def |(a: uint(32), b: uint(32)): uint(32)
def |(a: uint(64), b: uint(64)): uint(64)
def |(a: uint(64), b: int(64))
def |(a: int(64), b: uint(64))
\end{chapel}
For each of these definitions that return a value, the result is
computed by applying the logical or operation to the bits of the
operands.

It is a compile-time error to apply the bitwise or operator to a value
of type \chpl{uint(64)} and a value of type \chpl{int(64)}, and vice
versa.

\subsubsection{Bitwise Xor Operators}
\label{Bitwise_Xor_Operators}
\index{^@\chpl{^}}

The bitwise xor operators are predefined as follows:
\begin{chapel}
def ^(a: bool, b: bool): bool
def ^(a: int(32), b: int(32)): int(32)
def ^(a: int(64), b: int(64)): int(64)
def ^(a: uint(32), b: uint(32)): uint(32)
def ^(a: uint(64), b: uint(64)): uint(64)
def ^(a: uint(64), b: int(64))
def ^(a: int(64), b: uint(64))
\end{chapel}
For each of these definitions that return a value, the result is
computed by applying the XOR operation to the bits of the operands.

It is a compile-time error to apply the bitwise xor operator to a
value of type \chpl{uint(64)} and a value of type \chpl{int(64)}, and
vice versa.

\subsection{Shift Operators}
\label{Shift_Operators}
\index{<<@\chpl{<<}}
\index{>>@\chpl{>>}}

This section describes the predefined shift operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}.

The shift operators are predefined as follows:
\begin{chapel}
def <<(a: int(32), b): int(32)
def >>(a: int(32), b): int(32)
def <<(a: int(64), b): int(64)
def >>(a: int(64), b): int(64)
def <<(a: uint(32), b): uint(32)
def >>(a: uint(32), b): uint(32)
def <<(a: uint(64), b): uint(64)
def >>(a: uint(64), b): uint(64)
\end{chapel}
The type of the second actual argument must be any integral type.

The \chpl{<<} operator shifts the bits of \chpl{a} left by the
integer \chpl{b}.  The new low-order bits are set to zero.

The \chpl{>>} operator shifts the bits of \chpl{a} right by the
integer \chpl{b}.  When \chpl{a} is negative, the new high-order bits
are set to one; otherwise the new high-order bits are set to zero.

The value of \chpl{b} must be non-negative.

\subsection{Logical Operators}
\label{Logical_Operators}
\index{operators!logical}

This section describes the predefined logical operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}).

\subsubsection{The Logical Negation Operator}
\label{Logical_Negation_Operators}
\index{!@\chpl{!}}

The logical negation operator is predefined as follows:
\begin{chapel}
def !(a: bool): bool
\end{chapel}
The result is the logical negation of the operand.

\subsubsection{The Logical And Operator}
\label{Logical_And_Operators}
\index{&&@\chpl{&&}}

The logical and operator is predefined over bool type.  It returns
true if both operands evaluate to true; otherwise it returns false.
If the first operand evaluates to false, the second operand is not
evaluated and the result is false.

The logical and operator over expressions \chpl{a} and \chpl{b} given
by
\begin{chapel}
a && b
\end{chapel}
is evaluated as the expression
\begin{chapel}
if isTrue(a) then isTrue(b) else false
\end{chapel}

The function \chpl{isTrue} is predefined over bool type as follows:
\begin{chapel}
def isTrue(a:bool) return a;
\end{chapel}
Overloading the logical and operator over other types is accomplished
by overloading the \chpl{isTrue} function over other types.

\subsubsection{The Logical Or Operator}
\label{Logical_Or_Operators}
\index{||@\chpl{||}}

The logical or operator is predefined over bool type.  It returns
true if either operand evaluate to true; otherwise it returns false.
If the first operand evaluates to true, the second operand is not
evaluated and the result is true.

The logical or operator over expressions \chpl{a} and \chpl{b} given
by
\begin{chapel}
a || b
\end{chapel}
is evaluated as the expression
\begin{chapel}
if isTrue(a) then true else isTrue(b)
\end{chapel}

The function \chpl{isTrue} is predefined over bool type as described
in~\rsec{Logical_And_Operators}.  Overloading the logical or operator
over other types is accomplished by overloading the \chpl{isTrue}
function over other types.

\subsection{Relational Operators}
\label{Relational_Operators}
\index{operators!relational}

This section describes the predefined relational operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}.

\subsubsection{Ordered Comparison Operators}
\label{Ordered_Comparison_Operators}

\index{<@\chpl{<}}
The ``less than'' comparison operators are predefined as follows:
\begin{chapel}
def <(a: int(32), b: int(32)): bool
def <(a: int(64), b: int(64)): bool
def <(a: uint(32), b: uint(32)): bool
def <(a: uint(64), b: uint(64)): bool
def <(a: real(32), b: real(32)): bool
def <(a: real(64), b: real(64)): bool
def <(a: real(128), b: real(128)): bool
def <(a: imag(32), b: imag(32)): bool
def <(a: imag(64), b: imag(64)): bool
def <(a: imag(128), b: imag(128)): bool
\end{chapel}
The result of \chpl{a < b} is true if \chpl{a} is less than \chpl{b};
otherwise the result is false.

\index{>@\chpl{>}}
The ``greater than'' comparison operators are predefined as follows:
\begin{chapel}
def >(a: int(32), b: int(32)): bool
def >(a: int(64), b: int(64)): bool
def >(a: uint(32), b: uint(32)): bool
def >(a: uint(64), b: uint(64)): bool
def >(a: real(32), b: real(32)): bool
def >(a: real(64), b: real(64)): bool
def >(a: real(128), b: real(128)): bool
def >(a: imag(32), b: imag(32)): bool
def >(a: imag(64), b: imag(64)): bool
def >(a: imag(128), b: imag(128)): bool
\end{chapel}
The result of \chpl{a > b} is true if \chpl{a} is greater
than \chpl{b}; otherwise the result is false.

\index{<=@\chpl{<=}}
The ``less than or equal to'' comparison operators are predefined as
follows:
\begin{chapel}
def <=(a: int(32), b: int(32)): bool
def <=(a: int(64), b: int(64)): bool
def <=(a: uint(32), b: uint(32)): bool
def <=(a: uint(64), b: uint(64)): bool
def <=(a: real(32), b: real(32)): bool
def <=(a: real(64), b: real(64)): bool
def <=(a: real(128), b: real(128)): bool
def <=(a: imag(32), b: imag(32)): bool
def <=(a: imag(64), b: imag(64)): bool
def <=(a: imag(128), b: imag(128)): bool
\end{chapel}
The result of \chpl{a <= b} is true if \chpl{a} is less than or equal
to \chpl{b}; otherwise the result is false.

\index{>=@\chpl{>=}}
The ``greater than or equal to'' comparison operators are predefined
as follows:
\begin{chapel}
def >=(a: int(32), b: int(32)): bool
def >=(a: int(64), b: int(64)): bool
def >=(a: uint(32), b: uint(32)): bool
def >=(a: uint(64), b: uint(64)): bool
def >=(a: real(32), b: real(32)): bool
def >=(a: real(64), b: real(64)): bool
def >=(a: real(128), b: real(128)): bool
def >=(a: imag(32), b: imag(32)): bool
def >=(a: imag(64), b: imag(64)): bool
def >=(a: imag(128), b: imag(128)): bool
\end{chapel}
The result of \chpl{a >= b} is true if \chpl{a} is greater than or
equal to \chpl{b}; otherwise the result is false.

\subsubsection{Equality Comparison Operators}
\label{Equality_Comparison_Operators}
\index{==@\chpl{==}}
\index{!=@\chpl{!=}}

The equality comparison operators are predefined over bool and the
numeric types as follows:
\begin{chapel}
def ==(a: int(32), b: int(32)): bool
def ==(a: int(64), b: int(64)): bool
def ==(a: uint(32), b: uint(32)): bool
def ==(a: uint(64), b: uint(64)): bool
def ==(a: real(32), b: real(32)): bool
def ==(a: real(64), b: real(64)): bool
def ==(a: real(128), b: real(128)): bool
def ==(a: imag(32), b: imag(32)): bool
def ==(a: imag(64), b: imag(64)): bool
def ==(a: imag(128), b: imag(128)): bool
def ==(a: complex(64), b: complex(64)): bool
def ==(a: complex(128), b: complex(128)): bool
def ==(a: complex(256), b: complex(256)): bool
\end{chapel}
The result of \chpl{a == b} is true if \chpl{a} and \chpl{b} contain
the same value; otherwise the result is false.  The result of \chpl{a
\!= b} is equivalent to \chpl{\!(a == b)}.

The equality comparison operators are predefined over classes as
follows:
\begin{chapel}
def ==(a: object, b: object): bool
def !=(a: object, b: object): bool
\end{chapel}
The result of \chpl{a == b} is true if \chpl{a} and \chpl{b} reference
the same storage location; otherwise the result is false.  The result
of \chpl{a \!= b} is equivalent to \chpl{\!(a == b)}.

Default equality comparison operators are generated for records if the
user does not define them.  These operators are described
in~\rsec{Record_Comparison_Operators}.

The equality comparison operators are predefined over strings as
follows:
\begin{chapel}
def ==(a: string, b: string): bool
def !=(a: string, b: string): bool
\end{chapel}
The result of \chpl{a == b} is true if the sequence of characters
in \chpl{a} matches exactly the sequence of characters in \chpl{b};
otherwise the result is false.  The result of \chpl{a \!= b} is
equivalent to \chpl{\!(a == b)}.

\subsection{Miscellaneous Operators}
\label{Miscellaneous_Operators}

This section describes several miscellaneous operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}.

\subsubsection{The String Concatenation Operator}
\label{The_String_Concatenation_Operator}
\index{+@\chpl{+}}

The string concatenation operator is predefined as follows:
\begin{chapel}
def +(a: string, b: string): string
\end{chapel}
The result is the concatenation of \chpl{a} followed by \chpl{b}.
\begin{example}
Since integers can be implicitly converted to strings, an integer can
be appended to a string using the string concatenation operator.  The
code
\begin{chapel}
"result: "+i
\end{chapel}
where \chpl{i} is an integer appends the value of \chpl{i} to the
string literal.  If \chpl{i} is \chpl{3}, then the resulting string
would be \chpl{"result: 3"}.
\end{example}

\subsubsection{The Arithmetic Domain By Operator}
\label{The_Arithmetic_Domain_By_Operator}
\index{by@\chpl{by}}

The operator \chpl{by} is predefined on arithmetic domains.  It is
described in~\rsec{Strided_Arithmetic_Domains_and_Arrays}.

\subsubsection{The Range By Operator}
\label{The_Range_By_Operator}
\index{by@\chpl{by}}

The operator \chpl{by} is predefined on ranges.  It is
described in~\rsec{Strided_Ranges}.

\subsection{Let Expressions}
\label{Let_Expressions}
\index{let@\chpl{let}}

A let expression allows variables to be declared at the expression
level and used within that expression.  The syntax of a let expression
is given by:
\begin{syntax}
let-expression:
  `let' variable-declaration-list `in' expression
\end{syntax}
The scope of the variables is the let-expression.
\begin{example}
Let expressions are useful for defining variables in the context of
expression.  In the code
\begin{chapel}
  let x: real = a*b, y = x*x in 1/y
\end{chapel}
the value determined by \chpl{a*b} is computed and converted to type
real if it is not already a real.  The square of the real is then
stored in \chpl{y} and the result of the expression is the reciprocal
of that value.
\end{example}

\subsection{Conditional Expressions}
\label{Conditional_Expressions}
\index{conditional!expression}
\index{if@\chpl{if}}
\index{then@\chpl{then}}
\index{else@\chpl{else}}

A conditional expression is given by the following syntax:
\begin{syntax}
if-expression:
  `if' expression `then' expression `else' expression
  `if' expression `then' expression
\end{syntax}
The conditional expression is evaluated in two steps.  First, the
expression following the \chpl{if} keyword is evaluated.  Then, if the
expression evaluated to true, the expression following the \chpl{then}
keyword is evaluated and taken to be the value of this expression.
Otherwise, the expression following the \chpl{else} keyword is
evaluated and taken to be the value of this expression.  In both
cases, the unselected expression is not evaluated.

The `else' keyword can be omitted only when the conditional expression
is immediately nested inside a forall expression.  Such an expression
is used to filter predicates as described
in~\rsec{Filtering_Predicates_For} and~\rsec{Filtering_Predicates_Forall}.

\subsection{For Expressions}
\label{For_Expressions}
\index{for@\chpl{for}}

A for expression is given by the following syntax:
\begin{syntax}
for-expression:
  `for' index-expression `in' iterator-expression `do' expression
  `for' iterator-expression `do' expression
\end{syntax}
The for expression evaluates a loop in the context of an expression
and has the semantics of calling an iterator that yields the evaluated
expressions on each iteration.

\subsubsection{Filtering Predicates in For Expressions}
\label{Filtering_Predicates_For}
\index{for expressions!and conditional expressions}

A conditional expression that is immediately enclosed in a for
expression does not require an else-part.  Such a conditional
expression filters the evaluated expressions and only returns an
expression if the condition holds.

\subsection{Open Interval Expressions}
\label{Open_Interval}
\index{ranges!open interval}

%% move to section that discusses square tuples and domains when that
%% section is written.

Chapel's \emph{open interval notation} uses the following syntax:
\begin{syntax}
open-interval-expression:
  [ expression )
  [ expression-list )
\end{syntax}

This notation is a loose adaptation of mathematical notation for open
(upper) intervals in which the upper bound is not included in the
range.  For an argument range expression characterized by $l$, $h$,
and $s$, this syntax produces a range characterized by $l$, $h-1$ and
$s$.  For arithmetic domains or multiple ranges, the result is an
arithmetic domain where each range defining the arithmetic domain has
been truncated.

\begin{rationale}
While this operator is pure syntactic sugar for subtracting one from a
range's upper bound, it is provided as a concession to C programmers
and others who prefer 0-based indexing to avoid having to write
declare ranges (and domains) using \chpl{0..n-1} all the time.  In its
place, [0..n) can be used.

Open intervals are not supported on lower bounds or on both upper and
lower bounds due to the syntactic ambiguities that they can result in
combined with the fact that these cases are not as important as the
above for 0-based programming.
\end{rationale}

\begin{openissue}
This open-interval notation is a contentious issue and thoughts on
whether this should remain in the language or not are encouraged.  One
issue is the lack of generality due to the lack of support for lower
open intervals.  A second issue is the mismatch in parenthesis and
brackets which generates warnings in some editors and is considered
aesthetically awkward by many users.  There also remains a question as
to how much this really simplifies the code.
\end{openissue}
