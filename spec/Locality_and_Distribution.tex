\sekshun{Locality and Distribution}
\label{Locality_and_Distribution}

\begin{status}
Programs can currently only run on a single locale.  The abstractions
described here are not yet implemented.
\end{status}

Chapel provides high-level abstractions that allow programmers to
exploit locality by defining the affinity of data and computation.
This is accomplished by associating both data objects and computations
with abstract {\em locales}. To provide a higher-level mechanism,
Chapel allows a mapping from domains to locales to be specified. This
mapping is called a {\em distribution} and it guides that placement of
variables associated with arrays and the placement of subcomputations
defined over the domain.

\index{local}
\index{remote}
Throughout this section, the term {\em local} refers to data that is
associated with the locale that a computation is running on and {\em
remote} refers to data that is not. We assume that there is some
execution overhead associated with accessing data that may be remote
compared to data known to be local.

\subsection{Locales}
\label{Locales}
\index{locales}

A locale abstracts a processor or node in a parallel computer system,
or the basic component in the computer system where local memory can
be accessed uniformly.

\subsubsection{The Locale Type}
\label{The_Locale_Type}
\index{locale@\chpl{locale}}

The identifier \chpl{locale} is a primitive type that abstracts a
locale as described above.  Both data and computations can be
associated with a value of locale type. The only operators defined
over locales are the equality and inequality comparison operators.

\subsubsection{Locale Methods}
\label{Locale_Methods}
\index{Locales!methods}

The locale type supports the following methods:

\begin{protohead}
def locale.numCores: int;
\end{protohead}
\begin{protobody}
Returns the number of processor cores available on a given locale.
\end{protobody}

\begin{protohead}
use Memory;
def locale.physicalMemory(unit: MemUnits=Bytes, type retType=int(64)): retType;
\end{protohead}
\begin{protobody}
Returns the amount of physical memory available on a given locale in
terms of the specified memory units (Bytes, KB, MB, or GB) using a
value of the specified return type.
\end{protobody}

\subsubsection{Predefined Locales Array}
\label{Predefined_Locales_Array}
\index{Global@\chpl{Global}}
\index{Locales@\chpl{Locales}}
\index{numLocales@\chpl{numLocales}}
\index{execution environment}

A predefined configuration variable defines the {\em execution
environment} for a program.  This environment is defined by the
following definitions:
\begin{chapel}
config const numLocales: int;
const Locales: [1..numLocales] locale;
const Global: locale;
\end{chapel}
The environment consists of constants which are fixed when the program
begins execution.  The variable \chpl{Global} holds a special value
of \chpl{locale} type that can be distinct from the values stored
in \chpl{Locales}. This value is used to denote an object or
computation that has no defined affinity.

When a program starts, a single computation is executing.  It is
running on the locale given by \chpl{Locales(1)}.

\subsubsection{Querying the Locale of a Variable}
\label{Querying_the_Locale_of_a_Variable}
\index{locale@\chpl{locale}}

Every variable \chpl{v} is associated with some locale which can be
queried using the following syntax:
\begin{syntax}
locale-access:
  expression . `locale'
\end{syntax}
When the \sntx{expression} is a class type, the locale is where the
object is located rather than where the \sntx{expression} may be
located.

\subsection{Specifying Locales for Computation}
\label{Specifying_Locales_for_Computation}

When execution is proceeding on some locale, a computation can be
associated with a different locale in two ways: via distributions as
discussed in~\rsec{Distributions} or with an \sntx{on-statement} as
discussed below.

\subsubsection{On}
\label{On}
\index{on@\chpl{on}}

The on statement controls on which locale a computation or data should
be placed.  The syntax of the on statement is given by
\begin{syntax}
on-statement:
  `on' expression `do' statement
  `on' expression block-level-statement
\end{syntax}
If the \sntx{expression} is a value of \chpl{locale} type,
the \sntx{statement} or \sntx{block-level-statement} is executed on
the locale specified directly by the expression.  Otherwise, the
expression must be a variable and the locale is taken to be the locale
where the variable is located.  Execution continues after
the \chpl{on-statement} after execution of the \sntx{statement}
or \sntx{block-level-statement} completes.

\index{Global@\chpl{Global}}
If the locale that the \sntx{expression} refers to is equal
to \chpl{Global}, then the locale is unspecified and is determined by
the runtime and/or compiler.

\begin{example}
A common idiom is to use \chpl{on} in conjunction with \chpl{forall}
to access an array decomposed over multiple locales.  The code
\begin{chapel}
forall i in D do on A(i) {
  // some computation
}
\end{chapel}
executes each iteration of the forall loop on the locale where the
element of \chpl{A(i)} is located.
\end{example}

By default, when new variables and data objects are created, they are
created in the locale where the computation is running.  This locale
can be changed by using the \chpl{on} keyword.  Variables can be
defined within an \sntx{on-statement} to define them on a particular
locale.

\subsubsection{On and Iterators}
\label{On_and_Iterators}
\index{iterators!on@\chpl{on}}

When a loop iterates over an iterator, on-statements inside the
iterator control where the corresponding loop body is executed.

\begin{example}
An iterator over a distributed tree might include an iterator over the
nodes as defined in the following code:
\begin{chapel}
class Tree {
  var left, right: Tree;
  def nodes {
    on this yield this;
    if left then
      forall t in left.nodes do
        yield t;
    if right then
      forall t in right.nodes do
        yield t;
  }
}
\end{chapel}
Given this code and a binary tree of type \chpl{Tree} stored in
variable \chpl{tree}, then we can use the nodes iterator to iterate
over the tree with the following code:
\begin{chapel}
forall t in tree.nodes {
  // body executed on t as specified in nodes
}
\end{chapel}
Here, each instance of the body of the \chpl{forall} loop is executed
on the locale where the corresponding object \chpl{t} is located.
This is specified in the \chpl{nodes} iterator where the \chpl{on}
keyword is used.  In the case of zipper or tensor product iteration,
the location of execution is taken from the first iterator.  This can
be overridden by explicitly using \chpl{on} in the body of the loop or
by reordering the product of iteration.
\end{example}

\subsection{Distributions}
\label{Distributions}
\index{distributions}

A mapping from domain index values to locales is called a {\em
distribution}.

\subsubsection{Distributed Domains}
\label{Distributed_Domains}

\index{domains!distributed}
A domain for which a distribution is specified is referred to as a
{\em distributed domain}.  A domain supports a method, \chpl{locale},
that maps index values in the domain to locales that correspond to the
domain's distribution.

Iteration over a distributed domain implicitly executes the control
computation in the domain of the associated locale.  Similarly, when
iterating over the elements of an array defined over a distributed
domain, the controlled computations are determined by the distribution
of the domain.  If there are conflicting distributions in product
iterations, the locale of the computation is taken to be the first
component in the product.

\begin{example}
If \chpl{D} is a distributed domain, then in the code
\begin{chapel}
forall d in D {
  // body
}
\end{chapel}
the body of the loop is executed in the locale where the
index \chpl{d} maps to by the distribution of \chpl{D}.
\end{example}

\subsubsection{Distributed Arrays}
\label{Distributed_Arrays}
\index{arrays!distributed}

Arrays defined over a distributed domain will have the element
variables stored on the locale determined by the distribution.  Thus,
if \chpl{d} is an index of distributed domain \chpl{D} and \chpl{A} is
an array defined over that domain, then \chpl{A(d).locale} is the
locale to which \chpl{d} maps to according to \chpl{D}.

\subsubsection{Undistributed Domains and Arrays}
\label{Undistributed_Domains_and_Arrays}

If a domain or an array does not have a distributed part, the domain
or array is not distributed and exists only on the locale on which it
is defined.

\subsection{Standard Distributions}
\label{Standard_Distributions}

Standard distributions include the following:
\begin{itemize}
\item The block distribution \chpl{Block}
\item The cyclic distribution \chpl{Cyclic}
\item The block-cyclic distribution \chpl{BlockCyclic}
\item The cut distribution \chpl{Cut}
\end{itemize}

A design goal is that all standard distributions are defined with the
same mechanisms that user-defined
distributions~(\rsec{User_Defined_Distributions}) are defined with.

\subsection{User-Defined Distributions}
\label{User_Defined_Distributions}

This section is forthcoming.
