\sekshun{Language Overview}
\label{Language_Overview}

\subsection{Motivating Principles}

\subsection{Getting Started}

The Chapel version of "hello, world" is given below.
\begin{chapel}
def main() {
  writeln("hello, world");
}
\end{chapel}
Chapel program files end with the extension \chpl{.chpl}.  
If this program were stored in a file called \chpl{helloworld.chpl},
the program would contain one module, \chpl{helloworld}, which is implicitly
named from the name of the file.  The keyword \chpl{def} indicates that 
\chpl{main} is a function, and that the definition of \chpl{main} will 
follow.  The function call to \chpl{writeln} will output the string
literal argument \chpl{hello, world}.

To compile and run this program, execute the following
commands at the system prompt:
\begin{verbatim} 
> chpl helloworld.chpl
> ./a.out
\end{verbatim}
The following output is shown:
\begin{verbatim}
> hello, world
\end{verbatim}

\subsection{Example: Jacobi}

\begin{numberedchapel}
def jacobi(A: [?ADomain] real) {
  const BigDomain = ADomain.expand(1);
  var Temp: [BigDomain] real;
  const highRow = ADomain(1).high;

  Temp[highRow+1, ADomain(2)] = 1.0;

  if (verbose) {
    writeln("Initial configuration:");
    writeln(A, "\n");
  }

  var iteration = 0,
      delta: real;

  do {
    Temp[ADomain] = A;

    forall (i,j) in ADomain do
      A(i,j) = (Temp(i-1,j) + Temp(i+1,j) + Temp(i,j-1) + Temp(i,j+1)) / 4.0;

    delta = max reduce abs(Temp[ADomain] - A);

    iteration += 1;

    if (verbose) {
      writeln("iteration: ", iteration);
      writeln(A);
      writeln("delta: ", delta, "\n");
    }
  } while (delta > epsilon);

  return (delta, iteration);
}
\end{numberedchapel}

\subsection{Example: Norm}

\begin{numberedchapel}
module Norm{
  enum normType {norm1, norm2, normInf, normFrob};

  def norm(x: [], p: normType) where x.rank == 1 {
    select (p) {
      when norm1 do return + reduce abs(x);
      when norm2 do return sqrt(+ reduce (x*x));
      when normInf do return max reduce abs(x);
      when normFrob do halt("From-norm not defined for 1D arrays");
      otherwise halt("Unexpected norm type");
    }
  }

  def norm(x:[?D], p: normType) where x.rank == 2 {
    select (p) {
      when norm1 do
        return max reduce [j in D(2)] (+ reduce abs(x[D(1), j]));

      when norm2 do
        halt("Haven't implemented 2-norm for 2D arrays yet");

      when normInf do
        return max reduce [i in D(1)] (+ reduce abs(x[i, D(2)]));

      when normFrob do return sqrt(+ reduce abs(x));

      otherwise halt("Unexpected norm type");
    }
  }

  def norm(x:[?D], p: normType) where x.rank > 2 {
    compilerError("Norms not implemented for array ranks > 2D");
  }

  def norm(x: []) {
    select (x.rank) {
      when 1 do return norm(x, norm2);
      when 2 do return norm(x, normFrob);
      otherwise compilerError("Norms not implemented for array ranks > 2D");
    }
  }
}
\end{numberedchapel}

\subsection{Example: Producer-Consumer}
The following example demonstrates a simple producer and consumer program.
The program contains a \chpl{sync} variable and a \chpl{begin} statement 
in order to implement two concurrent threads that execute in step with each other.
The new thread that is forked by the \chpl{begin} statement will be referred to as
the {\em consumer thread}.  The continuing thread will be referred to as the
{\em producer thread}.  Execution control switches between the
producer and consumer threads as the state of the sync variable \chpl{s} 
changes when it is read and written to.  The Chapel code for this example is given below.

\begin{numberedchapel}
use Time;

config var numIterations: int = 5;
config var sleepTime: uint = 2;

var s: sync int;

begin {  // fork consumer computation
  for c in 1..numIterations do
    writeln("consumer got ", s);
}

// producer computation
for p in 1..numIterations {
  sleep(sleepTime);
  s = p;
}
\end{numberedchapel}

The program uses the \chpl{sleep} function in line 15, which is provided in the
standard Chapel module, \chpl{Time}.  So, the first line, \chpl{use Time}, 
is needed to include the \chpl{Time} module when resolving 
function calls in this program.  

The two variables, \chpl{numIterations} and \chpl{sleepTime}, control
the number of iterations for the loops in the two threads
and the amount of time in seconds for the producer thread to sleep each iteration,
respectively.  Lines three and four give the declarations of these variables.
The variable \chpl{numIterations} is declared to be an integer and is initialized
to the default value 5.  The variable \chpl{sleepTime} is declared to be an 
unsigned integer and is initialized to the default value 2.  
Both of these variables are 32 bits, the default size of \chpl{int} and \chpl{uint} types.
The \chpl{config} keyword in front of these two variable declarations 
indicates that these are configuration variables.  Configuration variables 
can be set to override their default values at program execution time, through the 
use of command line switches.  For example, to change the number of iterations to 10
and to change the number of seconds to sleep to 5, the following execution command 
may be used:
\begin{verbatim}
> a.out --numIterations=10 --sleepTime=5
\end{verbatim}

In line six, the variable \chpl{s} is declared to be a \chpl{sync} variable 
of type \chpl{int}.  Sync variables have extra state associated with them to 
indicate whether they are logically {\em full} or {\em empty}.  Since \chpl{s}
is not initialized, its state is empty at the beginning of the program's execution.
A sync variable
is intended to be accessed by multiple concurrent threads, each of which may
change the contents and state of the variable.  A sync variable
can be read when its state is full.  Attempts to read an empty sync variable from one
thread will suspend execution until another thread changes its state to full.  Once the 
thread is able to read a sync variable, its state is atomically set to empty.  
Conversely, a sync variable can be written only when its state is empty.  Attempts
to write to a full sync variable will suspend until its state is empty.  Once the variable
is written to, the state is atomically set to full.  Sync variables are useful
to coordinate operations between threads.  In this program, \chpl{s} is used
to alternate execution between the producer and consumer threads.

The remainder of the code defines the consumer and producer threads.
The \chpl{begin} statement in line 8 forks a new
thread for the consumer operations.  This consumer thread executes the \chpl{for}
loop in lines 9 and 10.  This loop is indexed by \chpl{c}, which iterates over
the arithmetic sequence \chpl{1..numIterations}.  The variable \chpl{c} is a new
variable defined for the scope of the loop.  Its type is inferred to be integer from
the integer arithmetic sequence that follows.  During each iteration of the \chpl{for}
loop, the \chpl{writeln} function is called which outputs the string
literal \chpl{"consumer got "} and the value of the sync variable \chpl{s}, 
followed by a line break.  In order to print the value stored in \chpl{s}, the
sync variable is read only when its state is full.  Once \chpl{s} is successfully
read, its state will be set to empty.  The next iteration follows, and the 
thread will suspend execution until the state of \chpl{s} is made full again.
Since the consumer thread only reads \chpl{s}, it will be the producer thread
that changes the states of \chpl{s} to full.

The producer thread executes the \chpl{for} loop in lines 14 through 17.  This
loop is indexed by \chpl{p} which iterates over the same arithmetic sequence
as the consumer thread.  Like \chpl{c}, \chpl{p} is inferred to be an integer.
During each iteration of this \chpl{for} loop, the \chpl{sleep} function is
called with the argument\chpl{sleepTime}.  This \chpl{sleep} function is provided
in the \chpl{Time} standard module, and it causes the producer thread to
\chpl{sleepTime} seconds.  After returning from the \chpl{sleep} function, 
the producer thread assigns \chpl{s} to be the iteration number \chpl{p}.  
Because \chpl{s} is a sync variable, this assigment is executed only when the state of 
\chpl{s} is empty.  Once \chpl{s} is written, its state is changed to full and the
next iteration of the producer loop follows.  Since the producer thread only
writes \chpl{s}, it will be the consumer thread that changes the state of
\chpl{s} to empty allowing the next iteration to write its iteration number
to \chpl{s}.

When this program executes, a thread is forked for the consumer thread.
However, the consumer thread cannot read \chpl{s} before it has been written
to.  So, execution begins with the producer thread which assigns the value
\chpl{1} to \chpl{s} after calling the sleep function.  Once \chpl{s} has the
value \chpl{1}, the consumer thread can read it and print it.  Execution
switches back and forth between the producer and consumer threads for
\chpl{numIterations}.  

Running the program with the default 
values for \chpl{numIterations} or \chpl{sleepTime} results in: 
\begin{verbatim}
consumer got 1
consumer got 2
consumer got 3
consumer got 4
consumer got 5
\end{verbatim}
Each line is printed after a delay of \chpl{sleepTime} seconds.


\subsection{Example: Generic Stacks}

\subsubsection{Generic Stack with Linked List Implementation}

\begin{numberedchapel}
// A class that is used by the generic stack to implement nodes for a
// linked-list implementation.
class MyNode {
  type itemType;              // type of item
  var item: itemType;         // item in node
  var next: MyNode(itemType); // reference to next node (same type)
}

// A stack class that is generic over the type of data that it
// contains.  The implementation uses a linked list implemented with
// the node class above.
record Stack {
  type itemType;             // type of items
  var top: MyNode(itemType); // top node on stack linked list

  // push method: add an item to the top of the stack
  def push(item: itemType) {
    top = MyNode(itemType, item, top);
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    var oldTop = top;
    top = top.next;
    return oldTop.item;
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return top == nil;
}
\end{numberedchapel}

\subsubsection{Generic Stack with Array Implementation}

\begin{numberedchapel}
// A stack class that is generic over the type of data that it
// contains.  The implementation uses an array to store the elements
// in the stack.
record Stack {
  type itemType;            // type of items
  var numItems: int = 0;    // number of items in the stack
  var data: [1..2] itemType; // array of items

  // push method: add an item to the top of the stack
  // note: the array is doubled if it is full
  def push(item: itemType) {
    var height = data.numElements;
    if numItems == height then
      data.domain = [1..height*2];
    data(numItems+1) = item;
    numItems += 1;
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    numItems -= 1;
    return data(numItems+1);
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return numItems == 0;
}
\end{numberedchapel}
