\sekshun{Language Overview}
\label{Language_Overview}

\subsection{Motivating Principles}

\subsection{Getting Started}

The Chapel version of "hello, world" is given below.
\begin{chapel}
def main() {
  writeln("hello, world");
}
\end{chapel}
Chapel program files end with the extension \chpl{.chpl}.  
If this program were stored in a file called \chpl{helloworld.chpl},
the program would contain one module, \chpl{helloworld}, which is implicitly
named from the name of the file.  The keyword \chpl{def} indicates that 
\chpl{main} is a function, and that the definition of \chpl{main} will 
follow.  The function call to \chpl{writeln} will output the string
literal argument \chpl{hello, world}.

To compile and run this program, execute the following
commands at the system prompt:
\begin{verbatim} 
> chpl helloworld.chpl
> ./a.out
\end{verbatim}
The following output is shown:
\begin{verbatim}
> hello, world
\end{verbatim}

\subsection{Example: Jacobi}
The following example Chapel program solves a system of finite difference
equations for the Laplace equation using the Jacobi method.  This program 
demonstrates the use
of domains and arrays, as well as introducing the syntax for commonly used
Chapel statements.

\begin{numberedchapel}
config var n = 5,
           epsilon = 0.00001,
           verbose = false;

def main() {
  const ProblemSpace = [1..n, 1..n],
        BigDomain = [0..n+1, 0..n+1];

  var A, Temp: [BigDomain] real = 0.0;

  A[n+1, 1..n] = 1.0;

  if (verbose) {
    writeln("Initial configuration:");
    writeln(A, "\n");
  }

  var iteration = 0,
      delta: real;

  do {
    forall (i,j) in ProblemSpace do
      Temp(i,j) = (A(i-1,j) + A(i+1,j) + A(i,j-1) + A(i,j+1)) / 4.0;

    delta = max reduce abs(Temp[ProblemSpace] - A[ProblemSpace]);
    A[ProblemSpace] = Temp[ProblemSpace];

    iteration += 1;

    if (verbose) {
      writeln("iteration: ", iteration);
      writeln(A);
      writeln("delta: ", delta, "\n");
    }
  } while (delta > epsilon);

  writeln("Jacobi computation complete.");
  writeln("Delta is ", delta, " (< epsilon = ", epsilon, ")");
  writeln("# of iterations: ", iteration);
}
\end{numberedchapel}

The program consists of a \chpl{main} function and a three variable declarations
global to \chpl{main}.  The three variables, \chpl{n}, \chpl{epsilon} and
\chpl{verbose} are configuration variables, as indicated by the \chpl{config}
keyword, and they are set to default initial values.  None of these variables
contain a type in their declaration.  Instead the types of these variables are
inferred from their initial values:  \chpl{n} is an integer, \chpl{epsilon} is
a floating point type, and \chpl{verbose} is a boolean type.  Configuration 
variables may be set 
to other values at program execution through command line switches.  For example,
to change the value of \chpl{verbose} so that more printing is enabled, 
the following command would be used:
\begin{verbatim}
> ./a.out --verbose=true
\end{verbatim}  

There are two arrays in this example, \chpl{A} and \chpl{Temp},  
which are used in each iteration of the \chpl{do while} loop in lines 21-35.  
At the completion of this loop, \chpl{A} contains the resulting solution.
The extra \chpl{Temp} array is needed since the Jacobi iteration in lines 22 and 23 
requires that 
all entries be computed before the array is updated with new entries.  
The two arrays are declared using \chpl{BigDomain}.  
When the \chpl{Temp} array is updated in the \chpl{forall} loop in lines 22 and 23, 
and the \chpl{A} array is updated in line 26, \chpl{ProblemSpace} is used.  
Both \chpl{BigDomain} and \chpl{ProblemSpace} are {\em domains}.  
Domains are fundamental Chapel constructs which store information about how data
is stored and iterated over.  Using domains results in clean code for which the 
compiler can effectively identify parallelism and optimizations.  

Domains are sets of indices which may be distributed
across multiple processors indicating how data and parallel work should
be divided among the processors.  An array is a mapping from the domain
to a collection of variables.  An array is thus defined using a domain, distributing
the entries of the array according to the domain's distribution.
When a domain is used as the iterator in a \chpl{for} or 
\chpl{forall} statement, the iterations are distributed among processors
according to the domain's distribution.  There are five kinds of domains in
the Chapel language:  {\em arithmetic}, {\em sparse}, {\em indefinite}, 
{\em opaque} and {\em enumerated}.  More information about domains and
arrays is given in~\rsec{Domains_and_Arrays}. 

In this example, both domains are declared to be \chpl{const}, indicating
that the values for the domains remain constant during the execution of
the program.  
\chpl{ProblemSpace} is an arithmetic domain, defined to be the set 
of two-dimensional indices, with each dimension spanning from \chpl{1} to \chpl{n}.  
\chpl{BigDomain} is also an arithmetic domain, defined to be a two-dimensional 
set of indices, which each dimension spanning from \chpl{0} to \chpl{n+1}.  Thus, 
\chpl{BigDomain} is essentially the \chpl{ProblemSpace} domain with additional 
boundary rows and columns.  By defining \chpl{ProblemSpace} to be the interior
points of the larger grid, \chpl{BigDomain}, the Jacobi computation can be cleanly 
specified in one line, line 23, for just the interior points, 
eliminating the need to write special case computations for the boundary points.

The arrays, \chpl{A} and \chpl{Temp} are declared to be of type \chpl{real} and
are initialized to zero.  Because they are defined using \chpl{BigDomain}, the
arrays are of size \chpl{n+2} $\times$ \chpl{n+2}. In line 11, row \chpl{n+1}
of \chpl{A} is set to \chpl{1.0}.  In line 26, \chpl{A} is assigned the values
of \chpl{Temp} for the entries corresponding to the \chpl{ProblemSpace} domain.
Note that the array declaration in line 9 and
the array assignments in lines 11 and 26 show how to assign values to all or to
some slice of entries in an array.

In the \chpl{do while} loop, each iteration contains parallel computations:
a \chpl{forall} loop and a \chpl{max reduce} reduction operation.  The \chpl{forall}
loop uses the \chpl{ProblemSpace} domain as the iterator.  Each iteration
is indexed by a tuple of indices \chpl{(i,j)}, which avoids the use of
a nest of two loops, one loop for the index \chpl{i} and one loop for the
index{j}.  The compiler determines how this loop is made parallel, according
to the default distribution for the \chpl{ProblemSpace} domain.   Similarly,
the compiler will execute the reduction in line 25 in parallel, according
to the \chpl{ProblemSpace} domain distribution.  The resulting value of
the reduction, which is the maximum absolute value of the difference between
\chpl{Temp} and \chpl{A}, is stored in \chpl{delta}.  Once \chpl{delta} is
less than or equal to the value in \chpl{epsilon}, the \chpl{do while} loop 
exits.

The program ends with output, indicating that the computation is complete
and giving information about convergence.  Optionally, according to the
value of \chpl{verbose}, more output may be given before and during the
computation of the Jacobi iteration.  Calls to the function \chpl{writeln}
produce the output.  Each \chpl{writeln} call
produces a line of output, followed by a line return.  The string \chpl{"\n"}
results in  an additional line return, as in line 34 of the program.

\subsection{Example: Norm}

\begin{numberedchapel}
module Norm{
  enum normType {norm1, norm2, normInf, normFrob};

  def norm(x: [], p: normType) where x.rank == 1 {
    select (p) {
      when norm1 do return + reduce abs(x);
      when norm2 do return sqrt(+ reduce (x*x));
      when normInf do return max reduce abs(x);
      when normFrob do halt("From-norm not defined for 1D arrays");
      otherwise halt("Unexpected norm type");
    }
  }

  def norm(x:[?D], p: normType) where x.rank == 2 {
    select (p) {
      when norm1 do
        return max reduce [j in D(2)] (+ reduce abs(x[D(1), j]));

      when norm2 do
        halt("Haven't implemented 2-norm for 2D arrays yet");

      when normInf do
        return max reduce [i in D(1)] (+ reduce abs(x[i, D(2)]));

      when normFrob do return sqrt(+ reduce abs(x));

      otherwise halt("Unexpected norm type");
    }
  }

  def norm(x:[?D], p: normType) where x.rank > 2 {
    compilerError("Norms not implemented for array ranks > 2D");
  }

  def norm(x: []) {
    select (x.rank) {
      when 1 do return norm(x, norm2);
      when 2 do return norm(x, normFrob);
      otherwise compilerError("Norms not implemented for array ranks > 2D");
    }
  }
}
\end{numberedchapel}

\subsection{Example: Producer-Consumer}
The following example demonstrates a simple producer and consumer program.
The program contains a \chpl{sync} variable and a \chpl{begin} statement 
in order to implement two concurrent computations, or threads, that execute 
in step with each other.
The new computation that is created with the \chpl{begin} statement will 
be referred to as the {\em consumer computation}.  The continuing computation
will be referred to as the
{\em producer computation}.  Execution control switches between the
producer and consumer computations as the state of the sync variable \chpl{s} 
changes when it is read and written to.  The Chapel code for this example is given below.

\begin{numberedchapel}
use Time;

config var numIterations: int = 5;
config var sleepTime: uint = 2;

var s: sync int;

begin {  // fork consumer computation
  for c in 1..numIterations do
    writeln("consumer got ", s);
}

// producer computation
for p in 1..numIterations {
  sleep(sleepTime);
  s = p;
}
\end{numberedchapel}

The program uses the \chpl{sleep} function in line 15, which is provided in the
standard Chapel module, \chpl{Time}.  So, the first line, \chpl{use Time}, 
is needed to include the \chpl{Time} module when resolving 
function calls in this program.  

Lines three and four give the declarations and initial default values
for the two variables, \chpl{numIterations} and \chpl{sleepTime}.
Both of these variables are 32 bits, the default size of \chpl{int} and \chpl{uint} types.
The \chpl{config} keyword in front of these two variable declarations 
indicates that these are configuration variables.  Configuration variables 
can be set to override their default values at program execution time, through the 
use of command line switches.  For example, to change the number of iterations to 10
and to change the number of seconds to sleep to 5, the following execution command 
may be used:
\begin{verbatim}
> a.out --numIterations=10 --sleepTime=5
\end{verbatim}

In line six, the variable \chpl{s} is declared to be a \chpl{sync} variable 
of type \chpl{int}.  Sync variables have extra state associated with them to 
indicate whether they are logically {\em full} or {\em empty}.  Since \chpl{s}
is not initialized, its state is empty at the beginning of the program's execution.
A sync variable
is intended to be accessed by multiple concurrent computations, each of which may
change the contents and state of the variable.  A sync variable
can be read when its state is full.  Attempts to read an empty sync variable from one
computation will suspend execution until another computation changes its state to full.  
Once a sync variable is able to be read, its state is atomically set to empty.  
Conversely, a sync variable can be written only when its state is empty.  Attempts
to write to a full sync variable will suspend until its state is empty.  Once the variable
is written to, the state is atomically set to full.  Sync variables are useful
to coordinate operations between computations.  In this program, \chpl{s} is used
to synchronize the exchange of data between the producer and consumer computations.

The remainder of the code defines the consumer and producer computations.
The \chpl{begin} statement in line 8 creates a new computation to execute the \chpl{for}
loop in lines 9 and 10.  This loop is indexed by \chpl{c}, which iterates over
the arithmetic sequence \chpl{1..numIterations}.  The variable \chpl{c} is a new
variable defined for the scope of the loop.  Its type is inferred to be integer from
the integer arithmetic sequence that follows.  During each iteration of the \chpl{for}
loop, the \chpl{writeln} function is called which outputs the string
literal \chpl{"consumer got "} and the value of the sync variable \chpl{s}, 
followed by a line break.  In order to print the value stored in \chpl{s}, the
sync variable is read only when its state is full.  Once \chpl{s} is successfully
read, its state will be set to empty.  The next iteration follows, and the 
consumer computations will suspend execution until the state of \chpl{s} is 
made full again.  Since the consumer computation only reads \chpl{s}, it will be 
the producer computation that changes the states of \chpl{s} to full.

The producer computation executes the \chpl{for} loop in lines 14 through 17.  This
loop is indexed by \chpl{p} which iterates over the same arithmetic sequence
as the consumer computation.  Like \chpl{c}, \chpl{p} is inferred to be an integer.
During each iteration of this \chpl{for} loop, the \chpl{sleep} function is
called with the argument\chpl{sleepTime}.  This \chpl{sleep} function is provided
in the \chpl{Time} standard module, and it causes the producer computation to
\chpl{sleepTime} seconds.  After returning from the \chpl{sleep} function, 
the producer computation assigns \chpl{s} to be the iteration number \chpl{p}.  
Because \chpl{s} is a sync variable, this assigment is executed only when the state of 
\chpl{s} is empty.  Once \chpl{s} is written, its state is changed to full and the
next iteration of the producer loop follows.  Since the producer computation only
writes \chpl{s}, it will be the consumer computation that changes the state of
\chpl{s} to empty allowing the next iteration to write its iteration number
to \chpl{s}.

When this program executes, a consumer computation is created with the \chpl{begin}
statement.
However, the consumer computation cannot read \chpl{s} before it has been written
to.  So, execution begins with the producer computation which assigns the value
\chpl{1} to \chpl{s} after calling the sleep function.  Once \chpl{s} has the
value \chpl{1}, the consumer computation can read it and print it.  Execution
switches back and forth between the producer and consumer computation for
\chpl{numIterations}.  

Running the program with the default 
values for \chpl{numIterations} or \chpl{sleepTime} results in: 
\begin{verbatim}
consumer got 1
consumer got 2
consumer got 3
consumer got 4
consumer got 5
\end{verbatim}
Each line is printed after a delay of \chpl{sleepTime} seconds.


\subsection{Example: Generic Stacks}

\subsubsection{Generic Stack with Linked List Implementation}

\begin{numberedchapel}
// A class that is used by the generic stack to implement nodes for a
// linked-list implementation.
class MyNode {
  type itemType;              // type of item
  var item: itemType;         // item in node
  var next: MyNode(itemType); // reference to next node (same type)
}

// A stack class that is generic over the type of data that it
// contains.  The implementation uses a linked list implemented with
// the node class above.
record Stack {
  type itemType;             // type of items
  var top: MyNode(itemType); // top node on stack linked list

  // push method: add an item to the top of the stack
  def push(item: itemType) {
    top = MyNode(itemType, item, top);
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    var oldTop = top;
    top = top.next;
    return oldTop.item;
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return top == nil;
}
\end{numberedchapel}

\subsubsection{Generic Stack with Array Implementation}

\begin{numberedchapel}
// A stack class that is generic over the type of data that it
// contains.  The implementation uses an array to store the elements
// in the stack.
record Stack {
  type itemType;            // type of items
  var numItems: int = 0;    // number of items in the stack
  var data: [1..2] itemType; // array of items

  // push method: add an item to the top of the stack
  // note: the array is doubled if it is full
  def push(item: itemType) {
    var height = data.numElements;
    if numItems == height then
      data.domain = [1..height*2];
    data(numItems+1) = item;
    numItems += 1;
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    numItems -= 1;
    return data(numItems+1);
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return numItems == 0;
}
\end{numberedchapel}
