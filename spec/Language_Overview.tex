\sekshun{Language Overview}
\label{Language_Overview}

In HPC applications, the current dominant parallel programming paradigm 
is characterized by a localized
view of the computation combined with explicit control
over message passing, as exemplified by a combination
of Fortran or C/C++ with MPI. Such a fragmented memory
model provides the programmer with full control over data
distribution and communication, at the expense of productivity,
conciseness, and clarity.

Chapel is a new parallel programming language that 
strives to improve the programmability of parallel computer systems.
It provides a higher level of expression 
than current parallel languages do and it improves the separation between 
algorithmic expression and data structure implementation details. 

Chapel supports a global-view parallel programming model at a high level by 
supporting abstractions for data parallelism, task parallelism, and nested parallelism. 
It supports optimization for the locality of data and computation in the program 
via abstractions for data distribution and data-driven placement of subcomputations. 
It supports code reuse and generality via object-oriented concepts and generic 
programming features. While Chapel borrows concepts from many preceding languages, 
its parallel concepts are most closely based on ideas from High-Performance Fortran 
(HPF), ZPL, and the Cray MTA's extensions to Fortran/C. 

The key features of the Chapel language for productive parallel programming are as 
follows: 
\begin{itemize}
\item {\bf Locale type} - an opaque type used for organizing and referring to 
units of machine locality.
\item {\bf Domains} - first-class index sets that can potentially be distributed 
between multiple locales.  Domains are Chapel's primary vehicle for global-view 
data parallelism.
\item {\bf Arrays} - generalized support for distributed data aggregates, including 
dynamic multidimensional rectilinear arrays, potentially strided and/or sparse 
in each dimension; associative arrays; set- and graph-based arrays.
\item {\bf User-defined distributions} - a capability for users to specify the 
low-level distributed implementation of domains and arrays orthogonally 
to the computations that operate on these concepts.
\item {\bf \chpl{forall} loops and iterators} - concepts for specifying parallel 
iteration in a manner that separates algorithm and implementation.
\item {\bf Index types} - types representing domain indices to support code 
clarity and bounds-checking optimizations.    
\item {\bf User-defined reductions and scans} - a framework for expressing parallel 
prefix operations over data aggregates cleanly and efficiently.
\item {\bf \chpl{cobegin} and \chpl{begin} statements} - statement types for 
supporting task-parallel computations.
\item {\bf Sync and single-assignment variables} - variable types that support 
synchronization between parallel tasks.
\item {\bf Atomic sections} - compound statements that support atomic execution 
from the perspective of other threads.
\item {\bf \chpl{On} clauses} - specifications that support explicit placement of 
data values and computation on the machine's locales.
\item {\bf Value and reference classes} - object-oriented software containers 
that support encapsulation of state and the separation of interfaces from 
implementations.
\item {\bf Function and operator overloading, multiple dispatch, pass-by-argument name, 
default argument values} - concepts that support modern and productive function call 
capabilities.
\item {\bf Type variables and latent types} - capabilities for writing algorithms 
independently of types to support code reuse, exploratory programming, and 
generic functions and data structures.
\item {\bf Modules} - software containers for namespace management and programming 
in-the-large.
\item {\bf Other features for productive programming} - tuples, type-safe unions, 
sequences, etc.
\end{itemize}

\subsection{Motivating Principles}
\label{Motivating_Principles}

Chapel pushes the state-of-the-art in parallel programming
by focusing on productivity and not just performance. In particular
Chapel combines the goal of highest possible
object code performance with that of programmability
by supporting a high level interface resulting in
shorter time-to-solution and reduced application development
cost. The design of Chapel is guided by four key
areas of programming language technology: global-view programming,
locality-awareness, object-orientation, and generic
programming.

\subsubsection{Global View Programming Model}
\label{Global_View_Programming_Model}

Parallel programming models can be divided into two types of models:
{\em fragmented} and {\em global-view}.  Fragmented programming models
require programmers to express algorithms on a task-by-task basis so that
the tasks can execute in parallel.  Global-view programming models
allow programmers to express a parallel algorithm as a whole, similar to
a serial algorithm.  The compiler and runtime libraries identify and assign
tasks to run in parallel across processors.  Chapel provides a global-view 
programming model.

The global-view programming model is is able:
\begin{itemize}
\item to operate on distributed data structures monolithically as 
though they were local to the executing thread's memory, and 
\item to express parallelism within a single source text without requiring 
multiple executables to be run simultaneously. 
\end{itemize}
While the global-view programming model can be implemented on any distributed memory 
machine, specific architectures provide an ideal target for this model.  
Global-view models map particularly well to architectures that 
support a global address space, DGAS and PGAS memory segments, a high performance 
network, lightweight synchronization, and latency-tolerant processors.  This 
synergy results in improved performance as compared to implementations on less-
productive architectures.

We believe that the dominance of the fragmented programming model is the primary
inhibitor of parallel programmability today, and therefore recommend that new
productivity-oriented languages focus on supporting a global view of parallel
programming.  





\subsubsection{Locality Aware Programming}
\label{Locality_Aware_Programming}

Locality-aware programming, in the style of HPF and
ZPL, provides distribution of shared data structures without
requiring a fragmentation of control structure. The programmer
reasons about load-balance and locality by specifying
the placement of data objects and threads.

\subsubsection{Object-Oriented Programming}
\label{Object-Oriented_Programming}

Object-oriented programming helps in managing complexity
by separating common function from specific implementation
to facilitate reuse.

\subsubsection{Generic Programming}
\label{Generic_Programming}

Generic programming and type-inference simplify the
type systems presented to users. High-performance computing
requires type systems to provide data structure details
that allow for efficient implementation. Generic programming
avoids the need for explicit specification of such
details when they can be inferred from the source or from
specialization of program templates.

\subsection{Basic Language Features}
\label{Basic_Language_Features}

Chapel is an imperative programming language.  The basic concepts of the
language should be familiar to users of C, Fortran, Java, Modula and Ada.
However, the syntax of the Chapel language does not directly build upon any of 
these existing languages.   Programmers should start afresh when programming in 
Chapel and not be limited to the constructs of existing languages.

\subsubsection{Getting Started}

Consider the classic first program.  The program file,
\chpl{helloworld.chpl} contains:
\begin{chapel}
def main() {
  writeln("hello, world");
}
\end{chapel}

The syntax of this simple program somewhat resembles C.  There are a
few items to note.
The program contains one module, \chpl{helloworld}, which is implicitly
named from the name of the file.  The keyword \chpl{def} indicates that the
definition of a function follows.

To compile and run this program, execute the following
commands at the system prompt:
\begin{verbatim}
> chpl helloworld.chpl
> ./a.out
\end{verbatim}
The following output is shown:
\begin{verbatim}
> hello, world
\end{verbatim}

\subsubsection{Programs and Modules}
\label{Programs_and_Modules}

All Chapel code is organized using \emph{modules} which serve as code
containers to help manage code complexity as programs grow in size.
One module may ``\chpl{use}'' another, giving it access to that
module's public global symbols.  In the following example, the
standard Chapel module \chpl{Types} is used.  This module contains
the \chpl{numBits} function that returns the size of a Chapel numeric
type in bits. 
%% test:  modulesexample.chpl
\begin{chapel}
use Types;

writeln("The default size of Chapel integers is ",numBits(int)," bits.");
\end{chapel}
The output of this example is:
\begin{verbatim}
The default size of Chapel integers is 32 bits.
\end{verbatim}

For convenience in exploratory programming,
explicit module declarations are not required.  If code is specified 
without a module declaration, the code's
filename is used as the module name for the code that it contains.

All Chapel programs must define a single subroutine named
\fnname{main()} that specifies the entry point for the program.  
This entry point is executed by a single logical thread.

Chapel provides standard modules for bit level operations, computing
random numbers and quering the system time.  See~\rsec{Standard_Modules}
for more details about these modules and how to use them.

\subsubsection{Data Types and Variables}
\label{Data_Types_and_Variables}

The following example demonstrates some variable declarations in Chapel.
\begin{chapel}
config const n = 10;

var x = 1.0,
    y = n:real,
    z: real;
\end{chapel}

The constant \chpl{n} can be set at runtime, as indicated by \chpl{config}, 
or it is set to its default value of \chpl{10}.  It is inferred to be of 
type \chpl{int} from this integer default value.  Similarly, \chpl{x} and 
\chpl{y} are inferred to be of type \chpl{real}.  The variable \chpl{x}
is initialized to \chpl{1.0} and the variable \chpl{y} is initialized to
the value of \chpl{n}, converted from an integer value to a real value.
The variable \chpl{z} has an explicit type declaration.  
Because \chpl{z} is not initialized, it has a default intial value of \chpl{0.0}.

Variable declarations in Chapel include the kind of variable, the variable's
name, type and initial value.  A variable's initialization may be omitted, 
in which case it will be initialized to an value dependent on its definition for 
safety (\eg, ``zero'' for numerical types).  Alternatively, a variable's type 
may be omitted, in which case it will be inferred from its
initializer.

There are three kinds of variables in Chapel specified by the following 
keywords:  \chpl{var}, \chpl{const},
and \chpl{param}.  The optional keyword \chpl{config} may precede
any of these variable keywords.  The \chpl{var} keyword indicates that a
variable is truly ``variable'' and may be modified throughout its
lifetime.  The \chpl{const} keyword indicates that a variable is a
constant, meaning that it \emph{must} be initialized and that its
value cannot change during its lifetime.  Unlike many languages,
Chapel's constant initializers need not be known at compile-time.  The
\chpl{param} keyword is used to define a \emph{parameter}, which is a
compile-time constant.  Parameter values are
required in certain language contexts, such as when specifying a
scalar type's bit-width or an array's rank.  In other contexts,
parameter values can be used to assert to the compiler that a
variable's value is known and unchanging.

Labeling a variable declaration with the optional \chpl{config}
keyword allows its value to be specified on the command line of the
compiler-generated executable (for \chpl{config const} and
\chpl{config var} declarations), or on the command-line of the
compiler itself (for \chpl{config param} declarations).

Variable declarations may also be specified in a variety of
comma-separated ways which allow multiple variables to share the same
variable-kind, type definition or initializer.  

Chapel has support for boolean, integer and floating point primitive types,
including the support for unsigned integers and complex types.  There is
also support for strings as primitive types.  The following table
lists the set of primitive types.  For each type, the default size and
all possible sizes are given.

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf Type} & {\bf Default Size} & {\bf Supported Sizes}  \\
\hline
\begin{chapel}
int
\end{chapel}
& 32 bits & 
\begin{chapel}
int(8)
int(16) 
int(32) 
int(64) 
\end{chapel} \\
\hline
\begin{chapel}
uint
\end{chapel}
& 32 bits & 
\begin{chapel}
uint(8)
uint(16) 
uint(32) 
uint(64) 
\end{chapel} \\
\hline
\begin{chapel}
real
\end{chapel}
& 64 bits & 
\begin{chapel}
real(32)
real(64)
real(128)
\end{chapel} \\
\hline
\begin{chapel}
imag
\end{chapel} 
& 64 bits & 
\begin{chapel}
imag(32) 
imag(64)
imag(128)
\end{chapel} \\
\hline
\begin{chapel}
complex
\end{chapel}
& 128 bits & 
\begin{chapel}
complex(64)
complex(128)
complex(256)
\end{chapel} \\
\hline
\begin{chapel}
bool
\end{chapel} 
& 1 bit & 
\begin{chapel}
bool
\end{chapel}  \\
\hline
\begin{chapel}
string
\end{chapel}
& unbounded & 
\begin{chapel}
string 
\end{chapel} \\
\hline
\end{tabular}
\end{center}

%% Should locale be listed in the above table?

Chapel is a type-safe language.  When assigning from one type to another, explicit 
casts are often required by the compiler.  Details of implicit and explicit
conversions are discussed in~\rsec{Conversions}.

%% Not sure how much to say about coercions and conversions here.

Beyond these primitive types, there is support for enumerated types, tuples and
unions.  Additionally, arrays, domains, sequences, classes and records are
used in variable declarations as type definitions.

Chapel supports the ability to created named type definitions using
the \chpl{type} keyword.  Like parameter variables, type definitions
must be known at compile-time.  The example below demonstrates a use of a type
definition.

\begin{chapel}
type elemType = real(32);
var alpha: elemType;
\end{chapel}

The first line of the example code defines the identifier 
\typename{elemType} to be
an alias for a \chpl{real(32)}---Chapel's 32-bit floating point type.
The identifier \typename{elemType} may be used to specify a variable's
definition or anywhere else that a type is allowed.  

\subsubsection{Statements and Expressions}
\label{Statements_and_Expressions}

Examples of Chapel statements are given in the following table.

\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Statement} & {\bf Example} \\
\hline
Block Statement &
\begin{chapel} % test:  block.chpl
var tau, s, c: real;
const a = 2.0;
const b = 5.5;

{
tau = -a/b;
s = 1/sqrt(1 + tau*tau);
c = s*tau;
}
writeln("Givens rotation = ", s, " ", c);
\end{chapel} \\
\hline
Expression Statement & 
\begin{chapel} % test:  expstmt.chpl
var denom = 1.0;
var x: real;

testForZero(denom);
testForZero(x);
testForZero(0.0);

def testForZero(x: real) {
  if (x == 0.0) then halt("Value is zero.");
  else writeln("Non-zero value.  Continuing.");   
}
\end{chapel} \\
\hline
Assignment Statement & 
\begin{chapel} % test: assign.chpl
var i: int;

i = 0;
i = i + 1;
i += 1;
writeln(i);
\end{chapel} \\
\hline
Conditional Statement &
\begin{chapel} % test:  cond.chpl
const D = [1..5];
var x, y: [D] real;
var alpha = 2.0;

[i in D] y(i) = 3.0*i;
scale(x, y, alpha);
writeln(x);

def scale(x, y, alpha: real) {
  if (x.numElements != y.numElements) {
    writeln("Error:  Input vectors are not the same length.");
    return;
  }
  if (alpha == 0.0) {
    x = 0.0;
  } else if (alpha == 1.0) {
    x = y;
  } else {
    x = alpha*y;
  }
}
\end{chapel} \\
\hline
Select Statement &
\begin{chapel} % test:  select.chpl
const D = [1..5];
var A: [D] real;

[i in D] A(i) = i;

writeln(getvalue("first",A));
writeln(getvalue("last",A));
writeln(getvalue("middle",A));

def getvalue(pos:string,y) {
  var x = 0.0;
  select pos {
    when "first" do x = y(1);
    when "last" do x = y(y.numElements);
    when "middle" do x = y((y.numElements/2):int + y.numElements%2);
    otherwise writeln("Unrecognized element position");
  }
  return x;
}
\end{chapel} \\
\hline
\end{tabular}

\begin{tabular}{|l|l|}
\hline
{\bf Statement} & {\bf Example} \\
\hline
While and Do While Loops &
\begin{chapel} % test: while.chpl
var t = 11;

writeln("Scope of do while loop:");
do {
  t += 1;
  writeln(t);
} while (t <= 10);

t = 11;
writeln("Scope of while loop:");
while (t <= 10) {
  t += 1;
  writeln(t);
}
\end{chapel} \\
\hline
For Loop &
\begin{chapel} % test: for.chpl
const D = [1..5];
var A: [D] real;

[i in D] A(i) = -i*i;
writeln(norm1(A));

def norm1(x) {
  var norm = 0.0;
  for i in x.domain {
    norm += abs(x(i));
  }
  return norm;
}
\end{chapel} \\
\hline
Use Statement &
\begin{chapel} % test:  use.chpl
use Time;
var programTimer:Timer;

programTimer.start();
writeln("Write one line.");
programTimer.stop();
writeln(programTimer.accumulated);
\end{chapel} \\
\hline
Type Select Statement &
\begin{chapel} % test:  typeselect.chpl
var x = 32, y = 15.5;
var z: int(8);
var coord = (0.0,0.0);
var yes: bool;

writetype(x);
writetype(y);
writetype(z);
writetype(coord);
writetype(yes);
writetype("no");

def writetype(x) {
  type select x {
    when int do writeln("Integer type");
    when uint do writeln("Unsigned integer type");
    when real do writeln("Real type");
    when complex do writeln("Complex type");
    when string do writeln("String type");
    when bool do writeln("Boolean type");
    otherwise writeln("Non-primitive type");
  }
}
\end{chapel} \\
\hline
Empty Statement &
\begin{chapel}
;
\end{chapel} \\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Expression} & {\bf Example} \\
\hline
Query Expression &
\begin{chapel} % query.chpl
writeln(sumOfThree(1,2,3));
writeln(sumOfThree(4.0,5.0,3.0));

def sumOfThree(x: ?t, y:t, z:t):t {
   var sum: t;

   sum = x + y + z;
   return sum;
}
\end{chapel} \\
\hline
Casts &
\begin{chapel} % casts.chpl
var x, y: complex;
x = 2.56 + 9.0i;
y = (3.12, 8.7): complex;
var z = (4.2, 6.1);

writeln(x);
writeln(y);
writeln(z);

var m = 2: int(64);
var n = 2;
var i = 1;
var j = 1;

while (n > 0) do {
  n *= 2;
  i += 1;
}
while (m > 0) do {
  m *= 2;
  j += 1;
}

writeln("For 32-bit integers, 2 ** (",i,") overflows.");
writeln("For 64-bit integers, 2 ** (",j,") overflows.");
\end{chapel} \\
\hline
Let Expression &
\begin{chapel} % let.chpl
quadsol(3.0,8.0,5.0);
quadsol(3.0,4.0,5.0);

def quadsol(a:real, b:real, c:real) {
  writeln("The solution of ",a,"x^2 + ",b,"x + ",c," = 0 is:");
  if (b*b > 4.0*a*c) {
    var x:  (real, real);

    x = let temp1 = sqrt(b*b - 4.0*a*c), temp2 = 2.0*a in
        ((-b + temp1)/temp2, (-b - temp1)/temp2);

    writeln(x);
  } else {
    var x: (complex, complex);

    x = let temp1 = sqrt(4.0*a*c - b*b)/(2.0*a), temp2 = -b/(2.0*a) in
        ((temp2,temp1):complex,(temp2,-temp1):complex);

    writeln(x);
  }
}
\end{chapel} \\
\hline
Conditional Expression &
\begin{chapel} % condexp.chpl
writehalf(8);
writehalf(21);
writehalf(1000);

def writehalf(i: int) {
  var half = if (i % 2) then i/2 +1 else i/2;
  writeln("Half of ",i," is ",half);
}
\end{chapel} \\
\hline
\end{tabular}
\end{center}

\subsubsection{Structured Data Types}
\label{Structured_Data_Types}

\subsubsection{Functions and Methods}
\label{Functions_and_Methods}

\subsubsection{Sequences and Iterators}
\label{Sequences_and_Iterators}


\subsubsection{Arrays and Domains}
\label{Arrays_and_Domains}

In Chapel, arrays are reference types that are declared using domains.
\begin{chapel}
const VectorD: domain(1) = [1..m];
var A, B, C: [VectorD] real;

A = B + alpha * C;
\end{chapel}

The first line declares a constant named \chpl{VectorD} that
is defined to be a \chpl{domain}---a first-class representation of an
index space, potentially distributed across the memories of multiple
locales.  In this instance, the index space is declared to be
1-dimensional, describing indices $\{ 1, 2, \ldots, m \}$.
The next line uses the \chpl{VectorD} domain to declare three
arrays \chpl{A}, \chpl{B}, and \chpl{C} of type \chpl{real}.  The
domain's index set defines the size and shape of these arrays. 
The final line uses whole-array syntax to specify the elementwise 
multiplications, additions, and assignments.  

Whole-array operations like this one are implicitly parallel, if the \chpl{VectorD}
domain were distributed across a set of processors.  For example, 
a block distribution of \chpl{VectorD} would be specified as follows.    
\begin{chapel}
const VectorD: domain(1) distributed(Block) = [1..m];
\end{chapel}
Each processor would perform the operations for the array elements that it owns, 
as defined by \chpl{VectorD}'s distribution since that was the domain
used to define all three arrays.

\subsection{Parallel Features}
\label{Parallel_Features}


\subsubsection{Data Parallel Constructs}
\label{Data_Parallel_Constructs}


\subsubsection{Task Parallel Constructs}
\label{Task_Parallel_Constructs}


\subsubsection{Exploiting Data Locality}
\label{Exploiting_Data_Locality}


\subsubsection{Synchronizing and Serializing Tasks}
\label{Synchronizing_and_Serializing_Tasks}


\subsection{Data Distributions}
\label{Data_Distributions}

