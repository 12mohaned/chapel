\sekshun{Language Overview}
\label{Language_Overview}

\subsection{Motivating Principles}

\subsection{Getting Started}

The Chapel version of "hello, world" is given below.
\begin{chapel}
def main() {
  writeln("hello, world");
}
\end{chapel}
Chapel program files end with the extension \chpl{.chpl}.  
If this program were stored in a file called \chpl{helloworld.chpl},
the program would contain one module, \chpl{helloworld}, which is implicitly
named from the name of the file.  The keyword \chpl{def} indicates that 
\chpl{main} is a function, and that the definition of \chpl{main} will 
follow.  The function call to \chpl{writeln} will output the string
literal argument \chpl{hello, world}.

To compile and run this program, execute the following
commands at the system prompt:
\begin{verbatim} 
> chpl helloworld.chpl
> ./a.out
\end{verbatim}
The following output is shown:
\begin{verbatim}
> hello, world
\end{verbatim}

\subsection{Example: Jacobi}
The following example Chapel program solves a system of finite difference
equations for the Laplace equation using the Jacobi method.  This program 
demonstrates the use
of domains and arrays, as well as introducing the syntax for commonly used
Chapel statements.

\begin{numberedchapel}
config var n = 5,
           epsilon = 0.00001,
           verbose = false;

def main() {
  const ProblemSpace = [1..n, 1..n],
        BigDomain = [0..n+1, 0..n+1];

  var A, Temp: [BigDomain] real = 0.0;

  A[n+1, 1..n] = 1.0;

  if (verbose) {
    writeln("Initial configuration:");
    writeln(A, "\n");
  }

  var iteration = 0,
      delta: real;

  do {
    forall (i,j) in ProblemSpace do
      Temp(i,j) = (A(i-1,j) + A(i+1,j) + A(i,j-1) + A(i,j+1)) / 4.0;

    delta = max reduce abs(Temp[ProblemSpace] - A[ProblemSpace]);
    A[ProblemSpace] = Temp[ProblemSpace];

    iteration += 1;

    if (verbose) {
      writeln("iteration: ", iteration);
      writeln(A);
      writeln("delta: ", delta, "\n");
    }
  } while (delta > epsilon);

  writeln("Jacobi computation complete.");
  writeln("Delta is ", delta, " (< epsilon = ", epsilon, ")");
  writeln("# of iterations: ", iteration);
}
\end{numberedchapel}

The program consists of a \chpl{main} function and a three variable declarations
global to \chpl{main}.  The three variables, \chpl{n}, \chpl{epsilon} and
\chpl{verbose} are configuration variables, as indicated by the \chpl{config}
keyword, and they are set to default initial values.  None of these variables
contain a type in their declaration.  Instead the types of these variables are
inferred from their initial values:  \chpl{n} is an integer, \chpl{epsilon} is
a floating point type, and \chpl{verbose} is a boolean type.  Configuration 
variables may be set 
to other values at program execution through command line switches.  For example,
to change the value of \chpl{verbose} so that more printing is enabled, 
the following command would be used:
\begin{verbatim}
> ./a.out --verbose=true
\end{verbatim}  

There are two arrays in this example, \chpl{A} and \chpl{Temp},  
which are used in each iteration of the \chpl{do while} loop in lines 21-35.  
At the completion of this loop, \chpl{A} contains the resulting solution.
The extra \chpl{Temp} array is needed since the Jacobi iteration in lines 22 and 23 
requires that 
all entries be computed before the array is updated with new entries.  
The two arrays are declared using \chpl{BigDomain}.  
When the \chpl{Temp} array is updated in the \chpl{forall} loop in lines 22 and 23, 
and the \chpl{A} array is updated in line 26, \chpl{ProblemSpace} is used.  
Both \chpl{BigDomain} and \chpl{ProblemSpace} are {\em domains}.  
Domains are fundamental Chapel constructs which store information about how data
is stored and iterated over.  Using domains results in clean code for which the 
compiler can effectively identify parallelism and optimizations.  

Domains are sets of indices which may be distributed
across multiple processors indicating how data and parallel work should
be divided among the processors.  An array is a mapping from the domain
to a collection of variables.  An array is thus defined using a domain, distributing
the entries of the array according to the domain's distribution.
When a domain is used as the iterator in a \chpl{for} or 
\chpl{forall} statement, the iterations are distributed among processors
according to the domain's distribution.  There are five kinds of domains in
the Chapel language:  {\em arithmetic}, {\em sparse}, {\em indefinite}, 
{\em opaque} and {\em enumerated}.  More information about domains and
arrays is given in~\rsec{Domains_and_Arrays}. 

In this example, both domains are declared to be \chpl{const}, indicating
that the values for the domains remain constant during the execution of
the program.  
\chpl{ProblemSpace} is an arithmetic domain, defined to be the set 
of two-dimensional indices, with each dimension spanning from \chpl{1} to \chpl{n}.  
\chpl{BigDomain} is also an arithmetic domain, defined to be a two-dimensional 
set of indices, which each dimension spanning from \chpl{0} to \chpl{n+1}.  Thus, 
\chpl{BigDomain} is essentially the \chpl{ProblemSpace} domain with additional 
boundary rows and columns.  By defining \chpl{ProblemSpace} to be the interior
points of the larger grid, \chpl{BigDomain}, the Jacobi computation can be cleanly 
specified in one line, line 23, for just the interior points, 
eliminating the need to write special case computations for the boundary points.

The arrays, \chpl{A} and \chpl{Temp} are declared to be of type \chpl{real} and
are initialized to zero.  Because they are defined using \chpl{BigDomain}, the
arrays are of size \chpl{n+2} $\times$ \chpl{n+2}. In line 11, row \chpl{n+1}
of \chpl{A} is set to \chpl{1.0}.  In line 26, \chpl{A} is assigned the values
of \chpl{Temp} for the entries corresponding to the \chpl{ProblemSpace} domain.
Note that the array declaration in line 9 and
the array assignments in lines 11 and 26 show how to assign values to all or to
some slice of entries in an array.

In the \chpl{do while} loop, each iteration contains parallel computations:
a \chpl{forall} loop and a \chpl{max reduce} reduction operation.  The \chpl{forall}
loop uses the \chpl{ProblemSpace} domain as the iterator.  Each iteration
is indexed by a tuple of indices \chpl{(i,j)}, which avoids the use of
a nest of two loops, one loop for the index \chpl{i} and one loop for the
index{j}.  The compiler determines how this loop is made parallel, according
to the default distribution for the \chpl{ProblemSpace} domain.   Similarly,
the compiler will execute the reduction in line 25 in parallel, according
to the \chpl{ProblemSpace} domain distribution.  The resulting value of
the reduction, which is the maximum absolute value of the difference between
\chpl{Temp} and \chpl{A}, is stored in \chpl{delta}.  Once \chpl{delta} is
less than or equal to the value in \chpl{epsilon}, the \chpl{do while} loop 
exits.

The program ends with output, indicating that the computation is complete
and giving information about convergence.  Optionally, according to the
value of \chpl{verbose}, more output may be given before and during the
computation of the Jacobi iteration.  Calls to the function \chpl{writeln}
produce the output.  Each \chpl{writeln} call
produces a line of output, followed by a line return.  The string \chpl{"\n"}
results in  an additional line return, as in line 34 of the program.

\subsection{Example: Norm}
The following example defines a module \chpl{Norm} with generic functions 
that compute vector and matrix norms.  For vectors, the 1-norm, 2-norm
and infinity norm are implemented in this module.  For matrices, the 1-norm,
infinity norm and Frobenius norm are provided.   
The module uses a variable of enumerated type \chpl{normType} to indicate the choice
of norm, and it defines separate functions for \chpl{norm} based on the
the dimension, or \chpl{rank}, of the input array, or the number of formal
arguments used in the \chpl{norm} function call.  
When the \chpl{Norm} module is used, the user may call 
\chpl{norm(x)} or \chpl{norm(x,normType)} where
\chpl{x} is any array and \chpl{normType} is the enumerated type as defined
in the \chpl{Norm} module.  
The following program gives the definition of the \chpl{Norm} module followed
by a module which tests \chpl{Norm}, demonstrating different calls to the \chpl{norm}
function.

\begin{numberedchapel}
module Norm{
  enum normType {norm1, norm2, normInf, normFrob};

  def norm(x, p: normType) where x.rank == 1 {
    select (p) {
      when norm1 do return + reduce abs(x);
      when norm2 do return sqrt(+ reduce (abs(x)*abs(x)));
      when normInf do return max reduce abs(x);
      when normFrob do halt("From-norm not defined for 1D arrays");
      otherwise halt("Unexpected norm type");
    }
  }

  def norm(x:[?D], p: normType) where x.rank == 2 {
    select (p) {
      when norm1 do
        return max reduce [j in D(2)] (+ reduce abs(x[D(1), j]));

      when norm2 do
        halt("Haven't implemented 2-norm for 2D arrays yet");

      when normInf do
        return max reduce [i in D(1)] (+ reduce abs(x[i, D(2)]));

      when normFrob do return sqrt(+ reduce (abs(x)*abs(x)));

      otherwise halt("Unexpected norm type");
    }
  }

  def norm(x, p: normType) where x.rank > 2 {
    compilerError("Norms not implemented for array ranks > 2D");
  }

  def norm(x) {
    select (x.rank) {
      when 1 do return norm(x, norm2);
      when 2 do return norm(x, normFrob);
      otherwise compilerError("Norms not implemented for array ranks > 2D");
    }
  }
}

module TestNorm {
  use Norm;

  def testNorm(arr) {
    var testType = if (arr.rank == 1) then "vector" else "matrix";
    writeln("Test of ", testType, " norms.  Array = ");
    writeln(arr);
    writeln("1-norm = ", norm(arr, norm1));
    if (arr.rank == 1) then
      writeln("2-norm = " , norm(arr, norm2));
    writeln("infinity norm = ", norm(arr, normInf));
    if (arr.rank == 2) then
      writeln("frobenius norm = ", norm(arr, normFrob));
    writeln("default norm = ", norm(arr));
    writeln();
  }

  def main() {
    const D1 = [1..4];
    var a:[D1] real;
    a = 2.0;
    testNorm(a);

    const D2 = [1..2,1..2];
    var b:[D2] real;
    b = 2.0;
    testNorm(b);
  }
}
\end{numberedchapel}

After the definition of the \chpl{Norm} module, a \chpl{TestNorm} module
is defined in lines 44 - 72, giving an example of how the \chpl{norm} functions are used.
On line 45, \chpl{use Norm}, indicates that the \chpl{Norm} module is to be
used when resolving functions in the \chpl{TestNorm} module.  A \chpl{testNorm}
function is defined, taking \chpl{arr} as an argument.  Based on \chpl{arr.rank},
all of the valid norm options are tested, along with the generic \chpl{norm(arr)}
function call.  The \chpl{main} function defines an example vector and matrix.
The domain \chpl{D1} is a one-dimensional domain, indexed
from \chpl{1} to \chpl{4}.  This domain is used to define the vector
\chpl{a}.  The domain \chpl{D2} is a two-dimensional domain, indexed from \chpl{1}
to \chpl{4} in each dimension.  This domain is used to define the matrix \chpl{b}.
Both \chpl{a} and \chpl{b} are initialized to \chpl{2.0} and passed to
\chpl{testNorm}.

The output of this program is given below.  Note that the first set
of norms is computed for a vector and the second set are computed for
a matrix. Even though the vector and matrix in this example contain
the same number of elements with the same values, the computed norms
are different between the vector and the matrix.  Thus, different
functions are used to compute the norms, depending on the whether the
input is a vector or matrix.

\begin{verbatim}
Test of vector norms.  Array = 
2.0 2.0 2.0 2.0
1-norm = 8.0
2-norm = 4.0
infinity norm = 2.0
default norm = 4.0

Test of matrix norms.  Array = 
2.0 2.0
2.0 2.0
1-norm = 4.0
infinity norm = 4.0
frobenius norm = 4.0
default norm = 4.0
\end{verbatim}

The \chpl{Norm} module begins with defining \chpl{normType} to be an
enumerated type with constant values \chpl{norm1}, \chpl{norm2}, 
\chpl{normInf}, \chpl{normFrob}.
For three of the four \chpl{norm} function definitions (see lines 4, 14, 31), 
one of the formal arguments is of \chpl{normType}, indicating which type of norm 
is to be computed.  If \chpl{norm} is called without the \chpl{normType} argument,
then the default norm for vectors is the 2-norm (see line 37) and the default
norm for matrices is the Frobenius norm (see line 38).  

The first \chpl{norm} function is defined for vectors.  This definition
begins with line 4:
\begin{chapel}
  def norm(x, p: normType) where x.rank == 1 {
\end{chapel}
The function definition contains a \chpl{where x.rank == 1} clause, indicating that
this version of \chpl{norm} is be used when the input array \chpl{x}
has just one dimension, and is thus, a vector.  The arguments for this version
of \chpl{norm} are \chpl{x} of non-specified type and \chpl{p} of \chpl{normType}.  
Since all norm types for vectors can be computed with whole array operations, there 
is no need to specify a domain type for \chpl{x}.

The body of the vector version of the \chpl{norm} function is a \chpl{select} statement on
\chpl{p} in lines 5 -11.  For the first three cases of the select statement,
when \chpl{p} is \chpl{norm1}, \chpl{norm2} or chpl{normInf},
a reduction operator is used to compute the value that is returned. 
The 1-norm of a vector is the sum of the absolute values of the entries of \chpl{x},
which can be computed with the sum reduction expression, \chpl{ + reduce abs(x)}.
The 2-norm of a vector is the sum of the squares of the absolute values of
the entries of \chpl{x}, which can be computed with the sum reduction expression,
\chpl{ + reduce (abs(x)*abs(x))}.
The infinity norm of a vector is the maximum entry of \chpl{x} in absolute value,
which can be computed with the maximum reduction expression \chpl{max reduce abs(x)}.
Reduction and scan expressions are discussed in more detail 
in~\rsec{Reductions_and_Scans}.  The last two cases of the select statement result
in the program halting, outputting the string that is passed to the \chpl{halt}
function.  Since the Frobenius norm is not defined for vectors, the program
will halt when \chpl{p} is \chpl{normFrob}.  The \chpl{otherwise} clause will
result in the program halting if any other value is passed in for \chpl{p}.

The second \chpl{norm} function is defined for matrices.  This definition begins
with line 14:
\begin{chapel}
  def norm(x:[?D], p: normType) where x.rank == 2 {
\end{chapel}
This version of the function will be used when \chpl{x} is a matrix,
that is the \chpl{rank} of the array \chpl{x} is \chpl{2}.  The arguments
for this version of \chpl{norm} are \chpl{x} and \chpl{p}, as in the previous
vector version.  For the matrix version, however, the domain of \chpl{x} is
needed to express the  norm computations.  So, the domain type is queried and set to 
\chpl{D} with the expression \chpl{[?D]}.  

The body of this version of \chpl{norm}
is a select statement on \chpl{p} in lines 15 - 28.  The \chpl{norm1} case, 
the 1-norm of a matrix, is the maximum absolute column sum, which is computed 
with the expression 
\begin{chapel}
max reduce [j in D(2)] (+ reduce abs(x[D(1), j])).
\end{chapel}
This expression is the maximum reduction of a \chpl{forall} loop, which computes
a sum reduction for each iteration.  
It uses \chpl{D(1)} and \chpl{D(2)}, which are the first and second dimension,
respectively, of the domain \chpl{D}.  The shorthand version of a \chpl{forall}
loop is used, \chpl{[j in D(2)]}, indicating that
for all \chpl{j in D(2)}, the sum
of the absolute values across the rows, \chpl{+ reduce abs(x[D(1), j])}, is computed. 
Then, the maximum value of these \chpl{j} absolute column sums is computed with
\chpl{max reduce}.  The \chpl{norm2} case, the 2-norm of a matrix, is not
implemented.  This case will halt with a message indicating this unimplemented
status.  The \chpl{normInf} case, the infinity norm of a matrix, is the maximum
absolute row sum.  This norm is computed similarly to the 1-norm, using the maximum
reduction of a chpl{forall} loop, 
\begin{chapel}
max reduce [i in D(1)] (+ reduce abs(x[i, D(2)])).  
\end{chapel}
For all \chpl{i in D(1)}, the sum of the absolute values across columns,
\chpl{+ reduce abs(x[i, D(2)])} is computed.  Then the maximum value of these
\chpl{i} absolute row sums is computed with \chpl{max reduce}.  The \chpl{normFrob}
case which is the Frobenius norm of a matrix, is the same computation as the
2-norm of a vector.  The Frobenius norm is the square root of the sum of the
squares of absolute values of all entries in the matrix.  The final case of
the select statement, the \chpl{otherwise} clause, halts with a message that
the norm type is unexpected.

The third version of the \chpl{norm} function with arguments \chpl{x}
and \chpl{p}, given in lines 31 - 33, is for the case where \chpl{x.rank > 2}.
In this case, a compiler error is defined using the \chpl{compilerError}
function.  For more information about user-defined compiler errors, 
see~\rsec{User-Defined_Compiler_Errors}.

The fourth and final version of the \chpl{norm} function is given in lines
35 - 41.  This version has one formal argument, \chpl{x}, omitting the norm
type.  It calls the other \chpl{norm} functions with default values for 
\chpl{normType}.  For vectors, the default norm is defined to be the 2-norm.
For matrices, the default norm is defined to be the Frobenius norm.  This 
version of \chpl{norm} is a select statement on \chpl{x.rank}.  When the rank 
is 1, the result of the function call \chpl{norm(x, norm2)} is returned.  
When the rank is 2, the result of the function call \chpl{norm(x, normFrob)}. 
The \chpl{otherwise} clause gives a compiler error.

\subsection{Example: Producer-Consumer}
The following example demonstrates a simple producer and consumer program.
The program contains a \chpl{sync} variable and a \chpl{begin} statement 
in order to implement two concurrent computations, or threads, that execute 
in step with each other.
The new computation that is created with the \chpl{begin} statement will 
be referred to as the {\em consumer computation}.  The continuing computation
will be referred to as the
{\em producer computation}.  Execution control switches between the
producer and consumer computations as the state of the sync variable \chpl{s} 
changes when it is read and written to.  The Chapel code for this example is given below.

\begin{numberedchapel}
use Time;

config var numIterations: int = 5;
config var sleepTime: uint = 2;

var s: sync int;

begin {  // fork consumer computation
  for c in 1..numIterations do
    writeln("consumer got ", s);
}

// producer computation
for p in 1..numIterations {
  sleep(sleepTime);
  s = p;
}
\end{numberedchapel}

The program uses the \chpl{sleep} function in line 15, which is provided in the
standard Chapel module, \chpl{Time}.  So, the first line, \chpl{use Time}, 
is needed to include the \chpl{Time} module when resolving 
function calls in this program.  

Lines three and four give the declarations and initial default values
for the two variables, \chpl{numIterations} and \chpl{sleepTime}.
Both of these variables are 32 bits, the default size of \chpl{int} and \chpl{uint} types.
The \chpl{config} keyword in front of these two variable declarations 
indicates that these are configuration variables.  Configuration variables 
can be set to override their default values at program execution time, through the 
use of command line switches.  For example, to change the number of iterations to 10
and to change the number of seconds to sleep to 5, the following execution command 
may be used:
\begin{verbatim}
> a.out --numIterations=10 --sleepTime=5
\end{verbatim}

In line six, the variable \chpl{s} is declared to be a \chpl{sync} variable 
of type \chpl{int}.  Sync variables have extra state associated with them to 
indicate whether they are logically {\em full} or {\em empty}.  Since \chpl{s}
is not initialized, its state is empty at the beginning of the program's execution.
A sync variable
is intended to be accessed by multiple concurrent computations, each of which may
change the contents and state of the variable.  A sync variable
can be read when its state is full.  Attempts to read an empty sync variable from one
computation will suspend execution until another computation changes its state to full.  
Once a sync variable is able to be read, its state is atomically set to empty.  
Conversely, a sync variable can be written only when its state is empty.  Attempts
to write to a full sync variable will suspend until its state is empty.  Once the variable
is written to, the state is atomically set to full.  Sync variables are useful
to coordinate operations between computations.  In this program, \chpl{s} is used
to synchronize the exchange of data between the producer and consumer computations.

The remainder of the code defines the consumer and producer computations.
The \chpl{begin} statement in line 8 creates a new computation to execute the \chpl{for}
loop in lines 9 and 10.  This loop is indexed by \chpl{c}, which iterates over
the arithmetic sequence \chpl{1..numIterations}.  The variable \chpl{c} is a new
variable defined for the scope of the loop.  Its type is inferred to be integer from
the integer arithmetic sequence that follows.  During each iteration of the \chpl{for}
loop, the \chpl{writeln} function is called which outputs the string
literal \chpl{"consumer got "} and the value of the sync variable \chpl{s}, 
followed by a line break.  In order to print the value stored in \chpl{s}, the
sync variable is read only when its state is full.  Once \chpl{s} is successfully
read, its state will be set to empty.  The next iteration follows, and the 
consumer computations will suspend execution until the state of \chpl{s} is 
made full again.  Since the consumer computation only reads \chpl{s}, it will be 
the producer computation that changes the states of \chpl{s} to full.

The producer computation executes the \chpl{for} loop in lines 14 through 17.  This
loop is indexed by \chpl{p} which iterates over the same arithmetic sequence
as the consumer computation.  Like \chpl{c}, \chpl{p} is inferred to be an integer.
During each iteration of this \chpl{for} loop, the \chpl{sleep} function is
called with the argument\chpl{sleepTime}.  This \chpl{sleep} function is provided
in the \chpl{Time} standard module, and it causes the producer computation to
\chpl{sleepTime} seconds.  After returning from the \chpl{sleep} function, 
the producer computation assigns \chpl{s} to be the iteration number \chpl{p}.  
Because \chpl{s} is a sync variable, this assigment is executed only when the state of 
\chpl{s} is empty.  Once \chpl{s} is written, its state is changed to full and the
next iteration of the producer loop follows.  Since the producer computation only
writes \chpl{s}, it will be the consumer computation that changes the state of
\chpl{s} to empty allowing the next iteration to write its iteration number
to \chpl{s}.

When this program executes, a consumer computation is created with the \chpl{begin}
statement.
However, the consumer computation cannot read \chpl{s} before it has been written
to.  So, execution begins with the producer computation which assigns the value
\chpl{1} to \chpl{s} after calling the sleep function.  Once \chpl{s} has the
value \chpl{1}, the consumer computation can read it and print it.  Execution
switches back and forth between the producer and consumer computation for
\chpl{numIterations}.  

Running the program with the default 
values for \chpl{numIterations} or \chpl{sleepTime} results in: 
\begin{verbatim}
consumer got 1
consumer got 2
consumer got 3
consumer got 4
consumer got 5
\end{verbatim}
Each line is printed after a delay of \chpl{sleepTime} seconds.


\subsection{Example: Generic Stacks}

\subsubsection{Generic Stack with Linked List Implementation}

\begin{numberedchapel}
// A class that is used by the generic stack to implement nodes for a
// linked-list implementation.
class MyNode {
  type itemType;              // type of item
  var item: itemType;         // item in node
  var next: MyNode(itemType); // reference to next node (same type)
}

// A stack class that is generic over the type of data that it
// contains.  The implementation uses a linked list implemented with
// the node class above.
record Stack {
  type itemType;             // type of items
  var top: MyNode(itemType); // top node on stack linked list

  // push method: add an item to the top of the stack
  def push(item: itemType) {
    top = MyNode(itemType, item, top);
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    var oldTop = top;
    top = top.next;
    return oldTop.item;
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return top == nil;
}
\end{numberedchapel}

\subsubsection{Generic Stack with Array Implementation}

\begin{numberedchapel}
// A stack class that is generic over the type of data that it
// contains.  The implementation uses an array to store the elements
// in the stack.
record Stack {
  type itemType;            // type of items
  var numItems: int = 0;    // number of items in the stack
  var data: [1..2] itemType; // array of items

  // push method: add an item to the top of the stack
  // note: the array is doubled if it is full
  def push(item: itemType) {
    var height = data.numElements;
    if numItems == height then
      data.domain = [1..height*2];
    data(numItems+1) = item;
    numItems += 1;
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    numItems -= 1;
    return data(numItems+1);
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return numItems == 0;
}
\end{numberedchapel}
