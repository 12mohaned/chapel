\sekshun{Language Overview}
\label{Language_Overview}

\subsection{Motivating Principles}

Chapel is a new programming language being developed by
Cray Inc. as part of DARPA's High Productivity Computing Systems 
(HPCS) program to improve the productivity
of programming parallel systems.  There are four main motivating
principles for the design of the Chapel language.

\paragraph{General Parallel Programming}

Chapel's first motivating principle is to support general parallel
programming through the use of high-level language abstractions
for expressing parallelism.  Chapel supports a 
\emph{global-view programming model} that raises the level of
abstraction for the expression of both data and control flow as
compared to parallel programming models currently used in production.

In Chapel, a \emph{locale} is an abstraction for the processing
unit of the target architecture.  Locales are to be defined such that
a locale's threads will all have similar access times to any
specific memory address.  For example, a locale in a commodity cluster 
could be defined to be a single core of a processor, a multicore
processor or an SMP node of multiple processors.

\emph{Global-view data structures} are arrays and other data
aggregates whose sizes and indices are expressed globally in spite of
the fact that their implementations may distribute them across the
memories of multiple locales.  This
contrasts with most parallel languages used in practice, which tend to
require users to partition distributed data aggregates into
per-processor chunks, either manually or using language abstractions.
As a simple example, to create a 0-based vector with $n$ elements
distributed between $p$ locales, a language like Chapel that supports
global-view data structures allows the user to declare the array to
contain $n$ elements and to refer to the array using the indices $0
\ldots n-1$.  In contrast, most traditional approaches require the
user to declare the array as $p$ chunks of $n/p$ elements each and to
specify and manage inter-processor communication and synchronization
explicitly (and the details can be messy if $p$ does not divide $n$
evenly).  Moreover, the chunks are typically accessed using local
indices on each processor (\eg,~$0..n/p$), requiring the user to
explicitly translate between logical indices and those used by the
implementation.

A \emph{global view of control} means that a user's program commences
execution with a single logical thread of control and then introduces
additional parallelism through the use of certain language concepts.
All parallelism in Chapel is implemented via multithreading, though
these threads are created via high-level language concepts and managed
by the compiler and runtime, rather than through explicit
fork/join-style programming.  An impact of this approach is that
Chapel can express parallelism that is more general than the Single
Program, Multiple Data~(SPMD) model that today's most common parallel
programming approaches use as the basis for their programming and
execution models.  Chapel's general support for parallelism does not
preclude users from coding in an SPMD style if they wish.


Supporting general parallel programming also means targeting a broad
range of parallel architectures.  Chapel is designed to target a wide
spectrum of HPC hardware including clusters of commodity processors
and SMPs; vector, multithreading, and multicore processors; custom
vendor architectures; distributed-memory, shared-memory, and shared
address space architectures; and networks of any topology.  Our
portability goal is to have any legal Chapel program run correctly on
all of these architectures, and for Chapel programs that express
parallelism in an architecturally-neutral way to perform reasonably on
all of them.  Naturally, Chapel programmers can tune their codes to
more closely match a particular machine's characteristics, though
doing so may cause the program to be a poorer match for other
architectures.

\paragraph{Control of Locality}

A second principle in Chapel is to allow the user to optionally and
incrementally specify where data and computation should be placed on
the physical machine.  We consider this control over program locality
to be essential for achieving scalable performance on large machine
sizes.  Such control contrasts with shared-memory programming models
which present the user with a flat memory model.  It also contrasts
with SPMD-based programming models in which such details are
explicitly specified by the programmer on a process-by-process basis
via the multiple cooperating program instances.

\paragraph{Object-Oriented Programming (OOP)}

A third principle in Chapel is support for object-oriented
programming.  OOP has been instrumental in raising productivity in the
mainstream programming community due to its encapsulation of related
data and functions into a single software component, its support for
specialization and reuse, and its use as a clean mechanism for
defining and implementing interfaces.  Chapel supports objects in
order to make these benefits available in a parallel language setting,
and to provide a familiar paradigm for members of the mainstream
programming community.  Chapel supports traditional reference-based
classes as well as value classes that are assigned and passed by
value.

Chapel does not require the programmer to use an object-oriented style
in their code, so that traditional Fortran and C programmers in the
HPC community need not adopt a new programming paradigm in order to
use Chapel effectively.  Many of Chapel's standard library
capabilities are implemented using objects, so such programmers may
need to utilize a method-invocation style of syntax to use these
capabilities.  However, using such libraries does not necessitate
broader adoption of OOP methodologies.

\paragraph{Generic Programming}

Chapel's fourth principle is support for generic programming and
polymorphism.  These features allow code to be written in a style that
is generic across types, making it applicable to variables of multiple
types, sizes, and precisions.  The goal of these features is to
support exploratory programming as in popular interpreted and
scripting languages, and to support code reuse by allowing algorithms
to be expressed without explicitly replicating them for each possible
type.  This flexibility at the source level is implemented by having
the compiler create versions of the code for each required type
signature rather than by relying on dynamic typing which would result
in unacceptable runtime overheads for the HPC community.

Chapel's first two principles are designed to provide support for
general, performance-oriented parallel programming through high-level
abstractions.  The second two principles are supported to help narrow
the gulf that exists between parallel programming languages and
mainstream programming and scripting languages.


\subsection{Getting Started}

\paragraph{Hello World} 
A Chapel version of the standard ``hello world'' computation is given
here:
\begin{chapel}
writeln("Hello, world!"); //writes Hello, world! to stdout
\end{chapel}
\noindent This program contains a single line of code that makes a
call to the standard \chpl{writeln} subroutine, passing it a string
literal argument, \chpl{"Hello, world\!"}.  This call causes the string
to be printed to the console when the program is executed.

\paragraph{Chapel Programs}
In general, Chapel programs define code using one or more named
\emph{modules}, each of which supports top-level initialization code
that is invoked the first time the module is used.  Programs also
define a single entry point via a subroutine named \chpl{main}.  To
facilitate exploratory programming, Chapel allows programmers to
define modules using files rather than an explicit module declaration,
and to omit the program entry point when the program only has a single
user module.  

Chapel code is stored in files with the extension \chpl{.chpl}.
Assuming the ``hello world'' program is stored in a file called 
\chpl{hello.chpl}, it
would define a single user module, \chpl{hello}, whose name is taken
from the filename.  Since the file defines a module, the top-level
code in the file defines the module's initialization code.  And since
the program is composed of the single \chpl{hello} module, it need not
define an entry point.  Thus, when the program is executed, the single
\chpl{hello} module will be initialized by executing its top-level
code, invoking the call to \chpl{writeln()}, and printing out the
message.

\paragraph{Comments} 
There are two ways of providing comments in Chapel source code.
Inserting ``\chpl{//}'' indicates that a comment follows, through to  
the end of that line.  Using ``\chpl{/*}'' indicates the start of a comment that
may span multiple lines.  In this case, the comment must be
explicitly ended with ``\chpl{*/}''.
\begin{chapel}
// Comments on a single line
/* Comments
   between lines */
\end{chapel}

\paragraph{Compiling and Running} 
To compile and run the ``hello world'' program, execute the 
following commands at the system prompt:
\begin{commandline} 
> chpl -o hello hello.chpl
> ./hello
\end{commandline}
The following output will be printed to the console:
\begin{commandline}
> Hello, world!
\end{commandline}

\subsection{Types}
Chapel is a strongly typed language.  Each variable must be declared
with a type specification or with an assignment to an initial value from which
the type can be inferred.  

In addition, each variable is initialized
when it is declared.  If an initial value is not specified, then the variable
is initialized to a default initial value according to its type. 
\subsubsection{Primitive Types}
Chapel provides primitive data types for signed and unsigned integers, 
real, imaginary and complex floating point numbers, booleans and strings.
The following table provides information about the names of these data
types in Chapel, and their default sizes and initial values.
If the size of the integer and floating point data types are not specified, 
then the default size is used.  When declaring variables, if an initial
value is not supplied then the default initial value for that variable's 
type is used. 
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
{\bf Type} & {\bf Default Size} & {\bf Types with Specified Sizes} & {\bf Default Initial Value}\\
\hline
\chpl{int} & 32 bits &
\chpl{int(8)}, \chpl{int(16)}, \chpl{int(32)}, \chpl{int(64)} &
\chpl{0} \\
\hline
\chpl{uint} & 32 bits &
\chpl{uint(8)}, \chpl{uint(16)}, \chpl{uint(32)}, \chpl{uint(64)} &
\chpl{0} \\
\hline
\chpl{real} & 64 bits &
\chpl{real(32)}, \chpl{real(64)}, \chpl{real(128)} &
\chpl{0.0} \\
\hline
\chpl{imag} & 64 bits &
\chpl{imag(32)}, \chpl{imag(64)}, \chpl{imag(128)} &
\chpl{0.0i} \\
\hline
\chpl{complex} & 128 bits &
\chpl{complex(64)}, \chpl{complex(128)}, \chpl{complex(256)} &
\chpl{0.0 + 0.0i} \\
\hline
\chpl{bool} & 1 bit & &
\chpl{false} \\
\hline
\chpl{string} & unbounded & &
\chpl{""} \\
\hline
\end{tabular}
\end{center}

\subsubsection{Non-Primitive Types}
The non-primitive types are listed in the table below, along
with their default initial values for variables of that type. 
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Type} & {\bf Default Initial Value}\\
\hline
\chpl{enum} & first enum constant \\
\hline
\chpl{class} & {\tt nil} \\
\hline
\chpl{record} & default constructed record \\
\hline
\chpl{range} & empty range:  \chpl{(1..0)} \\
\hline
\chpl{domain} & empty range for each dimension \\
\hline
\chpl{array} & default initial values of element types \\
\hline
\chpl{tuple} & default initial values of component types \\
\hline
\chpl{locale} & ordered list of processor ids assigned at job launch \\
\hline
\chpl{file} &  \chpl{(filename = , path = ., mode = r)}\\
\hline
\end{tabular}
\end{center}

The paragraphs below give a brief description and example for each
type.

\paragraph{Enumerated Types}
An enumerated type defines an ordered set of named constants.
By default, these constants have a default coercion to an
integral value, starting with zero for the first constant. 
An integral value may be assigned to one or more of the constants
to override the default behavior. 

\begin{example}
\begin{chapel}
enum day {sun = 1, mon, tue, wed, thu, fri, sat};
var d: day = wed;

writeln(d, " is day number ", d:int, " of the week");
\end{chapel}

This example would output:
\begin{commandline}
wed is day number 4 of the week
\end{commandline}
\end{example}

\paragraph{Tuple Types}
Tuples are ordered sets of components.  They can contain
elements of all the same type or of multiple types.
\begin{chapel}
var pt: (int,real); //pt is mixed tuple, init to (0,0.0)
var z: 3*int; //z is tuple of ints, init to (0,0,0)
\end{chapel}

\paragraph{Classes}
Classes are data structures with fields and methods.  They
are assigned by reference.
\begin{chapel}
class circle {
  var radius: real;
  def area {
    param pi = 3.14;
    return pi*(radius**2);
  }
}
var x = circle(radius=1.0);
\end{chapel}

\paragraph{Records}
Records are similar to classes but are assigned by
value.
\begin{chapel}
record point {
  var x,y: real;
}
var p = point(0.0,1.0);
\end{chapel}

\paragraph{Ranges}
Ranges define arithmetic sequences.
\begin{chapel}
var span1D: range = 1..n;
var D = [span1D,span1D];
\end{chapel}

\paragraph{Domains and Arrays}
Domains specify an index set.  Arrays are declared with domains.
Arrays and domains may
be arithmetic, sparse, indefinite, enumerated or opaque.
\begin{chapel}
const D2: domain(2) = [1..n, 1..n];
var A, B, C: [D2] real;
\end{chapel}
Domains can be specified with a distribution, defining how the
data is distributed across a set of processors.
\begin{chapel}
const DistD2: domain(2) distributed(Block) = [1..n, 1..n];
var A, B, C: [DistD2] real;
\end{chapel}

Arrays are passed by reference to functions
where they may be modified.  Assignment of arrays is by value.

Subdomains may be
defined to specify a subset of the domain's indices. Subarrays may be defined
with subdomains or ranges to specify part of an array.
\begin{chapel}
writeln(A(1..2,1..2)); //writes first 2x2 block of A
\end{chapel}

\paragraph{The Locale Type}
\paragraph{The File Type}
Chapel provides a built-in \chpl{file} type to handle input and
output to files.  The \chpl{file} type contains the
fields:  \chpl{filename}, \chpl{path}, and \chpl{mode}.
The \chpl{file} type supports the following methods:
\chpl{open}, \chpl{close}, \chpl{read}, \chpl{write} and \chpl{writeln}.

\paragraph{The Type Alias}
A type alias may defined for any type.  When used, it has the
same meaning as using the aliased type directly.
\begin{chapel}
type elemType = real(32);
var alpha: elemType; //alpha is 32-bit real
\end{chapel}

\subsection{Variables}
\paragraph{Variable Kinds}
There are three kinds of Chapel variables: \chpl{var},
\chpl{const} (runtime constants), \chpl{param} (compile time constants).

\paragraph{Variable Declarations}
Variable declarations include a type specification, an assignment
to an initial value or both.
\begin{chapel}
var x: real = 1.0; //x is real, init to 1.0
var y, z: real; //y, z are real, init to 0.0

var n = 10; //n inferred to be int, init to 10
const size = n; //size is runtime constant int,
                //set to 10
\end{chapel}

\paragraph{Configuration Variables}
The keyword \chpl{config} may precede any global variable
declaration, indicating that the variable may be set at
compile time or runtime.
\begin{chapel}
config const n = 100;
config param debug:bool;
\end{chapel}
To set configuration variables at runtime, use ``\chpl{--}''
followed by the variable name and value on the execution
command line.
\begin{commandline}
> ./a.out --n=1000
\end{commandline}
To set configuration variables at compile time, use
``\chpl{-s}'' followed by the variable name and value on the
compiler command line.
\begin{commandline}
> chpl testprogram.chpl -s debug=true
\end{commandline}

\paragraph{Synchronization Variables}
Single variables are assigned once.  Using a single variable
before it is assigned, suspends the computation until another
task assigns a value to it.
Sync variables are similar to single variables,
but permit multiple assignments to that variable. Sync
variables have a {\em full} or {\em empty} state associated
with them that is modified when read and written to and control
access to these variables between threads of computation.
\begin{chapel}
var x: single int;
var y: sync real;
\end{chapel}

\subsection{Operators}
\paragraph{Operator Precedence}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf Operators} & {\bf Associativity} & {\bf Use} \\
\hline
\verb@.@ & left & member access \\
\verb@() []@ & left & function call, index expression \\
\verb@**@ & right & exponentiation \\
unary \verb@+ - ~@ & right & sign and bitwise negation \\
\verb@:@ & left & cast\\
\verb@* / %@ & left & multiply, divide, and modulus \\
\verb@+ -@ & left & plus and minus \\
\verb@&@ & left & bitwise and \\
\verb@^@ & left & bitwise xor \\
\verb@<< >>@ & left & shift left and shift right \\
\verb@|@ & left & bitwise or \\
\verb@<= >= < >@ & left & ordered comparison \\
\verb@== !=@ & left & equality comparison \\
\verb@!@ & right & logical negation \\
\verb@&&@ & left & logical and \\
\verb@||@ & left & logical or \\
\verb@..@ & left & ranges  \\
\verb@in@ & left & forall expressions \\
\verb@by@ & left & striding sequences \\
\verb@if@ & left & conditional expressions \\
\verb@reduce scan@ & left & reductions and scans\\
\verb@,@ & left & comma separated expressions \\
\hline
\end{tabular}
\end{center}

\paragraph{Assignment Operators}
Supported assignment operators:
\begin{chapel}
 = += -= *= /= %= **= &= |= ^= &&= ||= <<= >>=
\end{chapel}

\paragraph{The Swap Operator}
The swap operator, \chpl{<=>} swaps the values between
the left and right-hand side expressions.
\begin{chapel}
x <=> y; //swaps the value in x with the value in y
\end{chapel}

\paragraph{The Array Alias Operator}
The array alias operator, \chpl{=>}, creates an alias
to an array or an array slice.
\begin{chapel}
A11 => A(block1,block1);
\end{chapel}

\paragraph{Scans and Reductions}

\subsection{Statements and Expressions}
\paragraph{Block Statement}
Chapel statements are separated by a semi-colon.  A block
of statements is delimited by braces, \{ \}.  Variables
declared within a block statement are local to that block.

\paragraph{Begin and Co-begin Statements}
The cobegin statement is used to create parallelism within
a block statement.  All statements within the block statement
are executed concurrently.
\begin{chapel}
cobegin {
  init(A);
  init(B);
}
\end{chapel}
The \chpl{begin} statement spawns a computation to execute a
statement.
\begin{chapel}
begin {
  while(!done) do work(x);
}
otherwork(x);
done = true;
\end{chapel}
\paragraph{For Loop Statements}
Serial loops are designated by the \chpl{for} keyword.
\begin{chapel}
for i in 1..n {
  norm1 += abs(x(i));
}
\end{chapel}

Parallel loops are specified using \chpl{forall} or
the shorthand bracket notation.
\begin{chapel}
forall ind in D {
  A(ind) = x*y;
}
[ind in D] A(ind) = x*y; //equivalent to above loop
\end{chapel}
\paragraph{While Loops}
Chapel provide two types of \chpl{while} loops.
\begin{chapel}
do {
  t += 1;
} while (t <= 10);

while (t <= 10) {
  t += 1;
}
\end{chapel}
\paragraph{Conditional Statement}
The Chapel conditional statement uses the standard 
\chpl{if}--\chpl{then}--\chpl{else} structure.  When
the then clause is a block of statements, delimited with
`\{' and `\}', the \chpl{then} keyword may be omitted.
\begin{chapel}
if (a == 0.0) then x = 0.0;
else x = a*y;
if (b != 0.0) {
  z = b*x;
}
\end{chapel}
\paragraph{Select Statement}
Chapel provides a \chpl{select} statement that allows the option of
executing different statement blocks, depending on the value of the
select variable.
\begin{chapel}
select pos {
  when "first" do x = y(1);
  when "last" do x = y(n);
  when "middle" do x = y(((n/2):int) + n%2);
  otherwise writeln("invalid position");
}
\end{chapel}
\paragraph{Type Select Statement}
The \chpl{type select} statement allows the choice of
executing different statement blocks depending on the type
of the select variable.
\begin{chapel}
type select ind {
  when int do y = x(ind);
  when real, uint do y = x(ind:int);
  otherwise y = 0.0;
}
\end{chapel}
\paragraph{Query Expression}
The query expression uses a \chpl{?} to indicate that the type of the
preceding variable be queried and assigned to the following variable.
\begin{chapel}
def sumOfThree(x: ?t, y:t, z:t):t {
   return x + y + z;
}
\end{chapel}
\paragraph{Let Expression}
The \chpl{let}--\chpl{in} expression defines variables to
be used only in the expression following the \chpl{in} keyword.
\begin{chapel}
x = let t1 = sqrt(b*b - 4.0*a*c), t2 = 2.0*a
    in ((-b + t1)/t2, (-b - t1)/t2);
\end{chapel}
\paragraph{Conditional Expression}
Chapel provides a conditional expression that can be evaluated
and then assigned.
\begin{chapel}
var half = if (i % 2) then i/2 +1 else i/2;
\end{chapel}

\subsection{Functions}
\paragraph{Function Definitions}
Functions are defined with a name and a list of function
arguments.  Optionally, intent types, return types and a
where clause can be specified.
\begin{chapel}
def area(x:real, y:real): real {
  return x*y;
}
\end{chapel}

\paragraph{Function Intents}
The intents of function arguments can be specified as \chpl{in},
\chpl{out} or \chpl{inout}.

If the intent is omitted, then the
argument has a blank intent, copying in the value using the assignment
operator.
Arguments with a blank intent cannot be assigned within a function.
Arrays and domains are an exception.  They are always passed by reference
and may be modified within a function.
Domains can be passed only with a blank intent.

\paragraph{Generic Functions}
Generic functions contain formal arguments that do not have
a specified type.
\begin{chapel}
def absSum(x:[?D]) {
  var sum: x.type;
  for i in D do sum += abs(x(i));
  return sum;
}
\end{chapel}
This routine, \chpl{absSum}, can be called
with arrays of any type for which an \chpl{abs} function is
defined.

\paragraph{Chapel Standard Functions}

\subsection{Iterators}
Iterators are defined similarly to functions, except that
they are defined with the keyword \chpl{iterator} and they
contain a \chpl{yield} statement.
\begin{chapel}
iterator evens(n) {
  for i in 1..n do yield (i,2*i);
}
\end{chapel}
Iterators may be called in \chpl{for} and \chpl{forall} loop
statements.  For each iteration of the loop, a value from the
iterator is yielded and the body of the loop executed.
\begin{chapel}
for (i,i2) in evens(m) {
  x(i) = y(i2);
}
\end{chapel}


\subsection{Input and Output}
\paragraph{File I/O}

\paragraph{Chapel Standard I/O Functions}
Chapel provides built-in functions \chpl{write} and \chpl{writeln}
to write to \chpl{stdout}, and the built-in function \chpl{read}
that reads from \chpl{stdin}.

\paragraph{Default I/O Methods for Chapel Types}
Default \chpl{read} and \chpl{write} methods are provided for all
Chapel types.


\subsection{Additional Parallel Support}
\paragraph{Data Distributions}
\paragraph{Data Locality}
\paragraph{Parallel vs. Serial Computations}

\subsection{Example Chapel Programs}

To introduce the Chapel language, four short example codes are presented and
discussed.  Each example highlights certain Chapel features, showing how they are used
in the context of a program.  These examples do not cover all of Chapel's features.
They are intended to introduce the user to many of the basic serial features that are
currently supported in the compiler and to demonstrate how to program with 
these features.  As more features are supported in the Chapel compiler, more 
examples will be added to this section.

All examples in this section are included with the release of the Chapel compiler.

\subsubsection{Jacobi Method}
\index{Jacobi method!example}

\paragraph{Description}
The following example Chapel program solves a system of finite difference
equations for the Laplace equation using the Jacobi method.  The program uses
two-dimensional arrays, \chpl{X} and \chpl{XNew}, to store and calculate the approximate
solution.  At each iteration, the next approximation for the solution at 
each grid point, \chpl{XNew(i,j)} is calculated by computing the average of 
the four neighboring grid points,
\chpl{X(i-1,j)}, \chpl{X(i,j-1)}, \chpl{X(i+1,j)}, and \chpl{X(i,j+1)}.  
After all entries in \chpl{XNew} are computed, \chpl{X} is assigned \chpl{XNew}
and convergence is tested.  If convergence has not been reached, the next
approximation is calculated, and so on until the convergence test is met.

\paragraph{Chapel Features}
This program demonstrates how {\em arrays} \index{arrays} 
are declared and used.  In Chapel, 
arrays are declared using {\em domains} \index{domains}.  
Domains are sets of indices which may be distributed
across multiple processors indicating how data and parallel work should
be divided among the processors.  An array is a mapping from the domain
to a collection of variables.  An array is thus defined using a domain, distributing
the entries of the array according to the domain's distribution.
Domains may also be used to define array {\em slices} and as {\em iterators}.
There are five kinds of domains in
the Chapel language:
\index{domains!types}
  {\em arithmetic}, {\em sparse}, {\em indefinite},
{\em opaque} and {\em enumerated}.  This example program uses arithmetic domains
and arrays.  

\paragraph{Code Listing}
The Chapel code for this example follows.  
\begin{numberedchapel}
config var n = 5,                      // size of nxn grid (*\label{jac_config_start}*)
           epsilon = 0.00001,          // convergence tolerance
           verbose = false;            // control for amount of output (*\label{jac_config_end}*)

def main() {                       (*\label{jac_main}*)
  const ProblemSpace = [1..n, 1..n],   // domain for interior points(*\label{problem_space}*)
        BigDomain = [0..n+1, 0..n+1];  // domain with boundary points(*\label{big_domain}*)

  var X, XNew: [BigDomain] real = 0.0; // X holds approximate solution (*\label{a_temp_decl}*)
                                       // XNew is work array

  X[n+1, 1..n] = 1.0;                 (*\label{a_init_last_row}*)

  if (verbose) {                      (*\label{verbose_init_start}*)
    writeln("Initial configuration:");
    writeln(X, "\n");
  }                                   (*\label{verbose_init_end}*)

  var iteration = 0,                  // iteration counter (*\label{jac_var_start}*)
      delta: real;                    // covergence measure (*\label{jac_var_end}*)

  do {                                (*\label{jac_do_start}*)
    forall (i,j) in ProblemSpace do   (*\label{jac_forall}*)
      XNew(i,j) = (X(i-1,j) + X(i+1,j) + X(i,j-1) + X(i,j+1)) / 4.0; (*\label{jac_iter}*)

    delta = max reduce abs(XNew[ProblemSpace] - X[ProblemSpace]); (*\label{jac_reduce}*)
    X[ProblemSpace] = XNew[ProblemSpace]; (*\label{jac_update_X}*)

    iteration += 1; (*\label{jac_advance_iteration}*)

    if (verbose) {  (*\label{verbose_iter_start}*)
      writeln("iteration: ", iteration);
      writeln(X);
      writeln("delta: ", delta, "\n");
    }               (*\label{verbose_iter_end}*)
  } while (delta > epsilon);          (*\label{jac_do_end}*)

  writeln("Jacobi computation complete.");  (*\label{jac_output_start}*)
  writeln("Delta is ", delta, " (< epsilon = ", epsilon, ")");
  writeln("# of iterations: ", iteration); (*\label{jac_output_end}*)
}
\end{numberedchapel}

\paragraph{Execution and Output}
Compiling and running this program gives the following output:
{\small
\begin{verbatim}
> ./a.out
Jacobi computation complete.
Delta is 9.92124e-06 (< epsilon = 1e-05)
# of iterations: 60
\end{verbatim}}

It is possible to run a different sized problem, to use a different
convergence tolerance, or enable more output without recompiling this
program.  There are three variables defined in lines~\ref{jac_config_start} - 
\ref{jac_config_end}, 
\chpl{n}, \chpl{epsilon} and \chpl{verbose}, which are {\em configuration variables}
\index{variables!configuration}
\index{config@\chpl{config}}
and can be set at the time of program execution through command line switches.
Executing the following command line sequence,
{\small
\begin{verbatim}
> ./a.out --verbose=true --n=2 --epsilon=0.01
\end{verbatim}}
results in overriding the default values for \chpl{verbose}, \chpl{n} and
\chpl{epsilon}, producing the following output.
{\small
\begin{verbatim}
Initial configuration:
0.0 0.0 0.0 0.0
0.0 0.0 0.0 0.0
0.0 0.0 0.0 0.0
0.0 1.0 1.0 0.0

iteration: 1
0.0 0.0 0.0 0.0
0.0 0.0 0.0 0.0
0.0 0.25 0.25 0.0
0.0 1.0 1.0 0.0
delta: 0.25

iteration: 2
0.0 0.0 0.0 0.0
0.0 0.0625 0.0625 0.0
0.0 0.3125 0.3125 0.0
0.0 1.0 1.0 0.0
delta: 0.0625

iteration: 3
0.0 0.0 0.0 0.0
0.0 0.09375 0.09375 0.0
0.0 0.34375 0.34375 0.0
0.0 1.0 1.0 0.0
delta: 0.03125

iteration: 4
0.0 0.0 0.0 0.0
0.0 0.109375 0.109375 0.0
0.0 0.359375 0.359375 0.0
0.0 1.0 1.0 0.0
delta: 0.015625

iteration: 5
0.0 0.0 0.0 0.0
0.0 0.117188 0.117188 0.0
0.0 0.367188 0.367188 0.0
0.0 1.0 1.0 0.0
delta: 0.0078125

Jacobi computation complete.
Delta is 0.0078125 (< epsilon = 0.01)
# of iterations: 5
\end{verbatim}}

\paragraph{Implementation Details}
This example program begins with the declaration of the three configuration
variables.  Note that these variables do not contain a type in their declaration: 
\begin{chapel}
config var n = 5,
           epsilon = 0.00001,
           verbose = false;
\end{chapel}
Instead the types of these variables are inferred \index{type inference} 
from their initial values: \chpl{n} is an integer, \chpl{epsilon} is a real
type, and \chpl{verbose} is a boolean type.  In Chapel, if a variable declaration
contains an initialization expression, it is optional to include a type specification.
More details about variable declarations are given in~\rsec{Variable_Declarations}.

After the configuration variables are declared, the \chpl{main} function
is defined.  The first two lines of \chpl{main} define two arithmetic domains:
\index{domains!arithmetic}
\begin{chapel}
def main() {                       
  const ProblemSpace = [1..n, 1..n],
        BigDomain = [0..n+1, 0..n+1];
\end{chapel}
Both domains are declared to be \chpl{const}, indicating
that the values for the domains remain constant during the execution of
the program.  They are defined using arithmetic sequences, and are, thus,
arithmetic domains.  Because the domains are initialized in their declaration,
it is not necessary to specify that they are of domain type.  In this case,
\chpl{: domain(2)} was omitted from both domain declarations.  
\chpl{BigDomain} is essentially the \chpl{ProblemSpace} 
domain with additional 
boundary rows and columns.  By defining \chpl{ProblemSpace} to be the interior
points of the larger grid, \chpl{BigDomain}, the Jacobi computation can be cleanly 
specified in one line, line~\ref{jac_iter}, for just the interior points, 
eliminating the need to write special case computations for the boundary points.

After the domains are declared, the arrays are declared using \chpl{BigDomain},
and the last row of \chpl{X} is set to one.
\begin{chapel}
  var X, XNew: [BigDomain] real = 0.0;

  X[n+1, 1..n] = 1.0;
\end{chapel}
Because they are defined using \chpl{BigDomain}, the
arrays \chpl{X} and \chpl{XNew} are of size \chpl{n+2} $\times$ \chpl{n+2}.  
They are declared to be of type \chpl{real} and all elements of the arrays
are initialized to zero.  When an array is assigned a scalar value, as in the
initialization to zero, each element of the array is assigned
\index{arrays!assignment} the scalar value.  
In the following line, the notation \chpl{n+1, 1..n} indicates a {\em slice}
\index{arrays!slicing}
of the array \chpl{X} is to be assigned the value one.  Each entry in this slice,
which is the last row of \chpl{X}, is set to one.

Lines~\ref{verbose_init_start} - \ref{verbose_init_end} print the initial 
configuration of the problem, if \chpl{verbose}
is set to true.  
\begin{chapel}
  if (verbose) {                      
    writeln("Initial configuration:");
    writeln(X, "\n");
  }                                   
\end{chapel}
The \chpl{writeln} \index{writeln@\chpl{writeln}} function outputs strings and values
of variables that are passed as arguments, followed by a line return.
When an array is passed as an argument, it is output is row-major order with linefeeds
after each row.  \index{write!default methods}
Including the character string, \chpl{"\\n"} inserts an 
additional line return.


Lines~\ref{jac_var_start} - \ref{jac_var_end} 
contain the remaining variable declarations:
\begin{chapel}
  var iteration = 0,
      delta: real;
\end{chapel}
The variable \chpl{delta} must be specified to be of type \chpl{real} since
it does not have an initialization expression.

The computational loop in lines~\ref{jac_do_start} - \ref{jac_do_end}  
performs the Jacobi method.
This loop is executed until \chpl{delta} is less than or equal to \chpl{epsilon}.
Each iteration of the \chpl{do while} loop computes the next approximate
solution using a \chpl{forall} loop.   
\begin{chapel}
  do{
    forall (i,j) in ProblemSpace do
      XNew(i,j) = (X(i-1,j) + X(i+1,j) + X(i,j-1) + X(i,j+1)) / 4.0;
\end{chapel}
This loop 
uses the \chpl{ProblemSpace} domain as an {\em iterator}\index{iterators}.  Iterators
for loops provide a value or a set of values to be used in each iteration
of the loop.  In this case, each iteration 
is indexed by a {\em tuple} \index{tuples} of indices \chpl{(i,j)}, which avoids the use of
a nest of two loops, one loop for the index \chpl{i} and one loop for the
index \chpl{j}.  The compiler determines how this loop is made parallel, according
to the default distribution for the \chpl{ProblemSpace} domain.   
Note that the \chpl{ProblemSpace} domain is the set of interior points of 
\chpl{X}'s domain.  All of the references to \chpl{X} in this loop are
defined, and do not go out of bounds.  

After the next approximate solution is computed and stored in \chpl{XNew},
the change between \chpl{XNew} and \chpl{X}, for just the interior points, is 
calculated and stored in \chpl{delta}:  
\begin{chapel}
    delta = max reduce abs(XNew[ProblemSpace] - X[ProblemSpace]);
\end{chapel}
The {\em built-in reduction}\index{reductions}, \chpl{max reduce}
computes the maximum value of the expression that follows it.  In this case
the expression is the computed array of absolute values of the difference
between the \chpl{XNew} and \chpl{X} arrays.  If
\chpl{XNew} and \chpl{X} are distributed, then this reduction is computed in 
parallel accordingly.  The use of \chpl{ProblemSpace} with these two arrays
indicates that the slice \index{arrays! slicing} of the arrays corresponding 
to the interior points are to be used in this calculation.

Next, \chpl{X} is updated with the new approximate solution and the iteration
number is advanced.  
\begin{chapel}
    X[ProblemSpace] = XNew[ProblemSpace]; 

    iteration += 1; 
\end{chapel}
The domain \chpl{ProblemSpace} is used in the assignment
of \chpl{XNew} to \chpl{X}, updating only the slice of \chpl{X} corresponding
to the interior points of the array.

The remaining part of the loop optionally provides output about the iteration.
\begin{chapel}
    if (verbose) {  
      writeln("iteration: ", iteration);
      writeln(X);
      writeln("delta: ", delta, "\n");
    }               
  } while (delta > epsilon);       
\end{chapel}
If \chpl{verbose} is set to true, then information about
the current approximate solution and \chpl{delta} is output.  Then, \chpl{delta}
is compared to the convergence tolerance, \chpl{epsilon}.  If \chpl{delta} is
not small enough, then the \chpl{do
while} loop continues.  Otherwise, the loop exits.  

The program ends with three lines of output.
\begin{chapel}
  writeln("Jacobi computation complete.");  
  writeln("Delta is ", delta, " (< epsilon = ", epsilon, ")");
  writeln("# of iterations: ", iteration); 
}
\end{chapel}
Information about the convergence is given, printing the values
for \chpl{epsilon} and the iteration counter.

\subsubsection{Matrix and Vector Norms}

\paragraph{Description}
The following example contains a module \chpl{Norm} which provides  
\chpl{norm} functions that compute either a vector or matrix norm, depending
on the rank of the array that is passed as the argument.  There are four
norm type options:  1-norm, 2-norm, infinity norm and Frobenius norm.  For vectors,  
all four options are implemented in this module.  
For matrices, all options but the 2-norm are provided.   
The module uses a variable of enumerated type \chpl{normType} to 
indicate the choice of norm.

\paragraph{Chapel Features}
\index{modules}
\index{functions}
\index{functions!generic}
\index{generics!functions}
This example demonstrates the definition and use of modules, generic functions
\index{generics!functions} and function overloading \index{functions!overloading}.
When the \chpl{Norm} module is used, the user may call 
\chpl{norm(x)} or \chpl{norm(x,normType)} where
\chpl{x} is any array and \chpl{normType} is the {\em enumerated type} as defined
in the \chpl{Norm} module.  The \chpl{norm} function is {\em overloaded} with
four separate function definitions for \chpl{norm}, based on the
the rank of the input array, or the number of formal
arguments used in the \chpl{norm} function call.  Each of these four function
definitions is a {\em generic} function, not specifying the type of the array
argument \chpl{x}.  Generic functions allow for code reuse and readability.

\paragraph{Program Listing}
The following program gives the definition of the \chpl{Norm} module followed
by a module which tests \chpl{Norm}, demonstrating different calls to the \chpl{norm}
function.

\begin{numberedchapel}
module Norm{                                    (*\label{norm_start}*)
  enum normType {norm1, norm2, normInf, normFrob}; (*\label{norm_enum}*)

  def norm(x: [], p: normType) where x.rank == 1 { (*\label{vec_start}*)
  // vector norm routine
    select (p) {                                   (*\label{vec_select_start}*)
      when norm1 do return + reduce abs(x);        (*\label{vec_norm1}*)
      when norm2 do return sqrt(+ reduce (abs(x)*abs(x)));  (*\label{vec_norm2}*)
      when normInf do return max reduce abs(x);  (*\label{vec_normInf}*)
      when normFrob do return sqrt(+ reduce (abs(x)*abs(x)));(*\label{vec_normFrob}*)
      otherwise halt("Unexpected norm type"); (*\label{vec_unexp}*)
    } (*\label{vec_select_end}*)
  } (*\label{vec_end}*)

  def norm(x: [?D], p: normType) where x.rank == 2 { (*\label{mat_start}*)
  // matrix norm routine
    select (p) {                                     (*\label{mat_select_start}*)
      when norm1 do                                  (*\label{mat_norm1_1}*)
        return max reduce [j in D(2)] (+ reduce abs(x[D(1), j])); (*\label{mat_norm1_2}*)

      when norm2 do  (*\label{mat_norm2_1}*)
        halt("Haven't implemented 2-norm for 2D arrays yet"); (*\label{mat_norm2_2}*)

      when normInf do  (*\label{mat_normInf_1}*)
        return max reduce [i in D(1)] (+ reduce abs(x[i, D(2)])); (*\label{mat_normInf_2}*)

      when normFrob do return sqrt(+ reduce (abs(x)*abs(x))); (*\label{mat_normFrob}*)

      otherwise halt("Unexpected norm type"); (*\label{mat_unexp}*)
    } (*\label{mat_select_end}*)
  } (*\label{mat_end}*)

  def norm(x: [], p: normType) where x.rank > 2 { (*\label{large_rank_start}*)
    compilerError("Norms not implemented for array ranks > 2D"); (*\label{comp_err_1}*)
  } (*\label{large_rank_end}*)

  def norm(x: []) { (*\label{norm_default_start}*)
  // default norm routine
    select (x.rank) { (*\label{default_select_start}*)
      when 1 do return norm(x, norm2);  (*\label{default_vec}*)
      when 2 do return norm(x, normFrob); (*\label{default_mat}*)
      otherwise compilerError("Norms not implemented for array ranks > 2D"); (*\label{comp_err_2}*)
    }   (*\label{default_select_end}*)
  }  (*\label{norm_default_end}*)
} (*\label{norm_end}*)

module TestNorm { (*\label{test_mod_start}*)
  use Norm;  (*\label{use_norm}*)

  def testNorm(arr: []) { (*\label{test_start}*)
    // test all possible norms of arr
    var testType = if (arr.rank == 1) then "vector" else "matrix"; 
    writeln("Test of ", testType, " norms.  Array = ");
    writeln(arr);
    writeln("1-norm = ", norm(arr, norm1));
    if (arr.rank == 1) then
      writeln("2-norm = " , norm(arr, norm2));
    writeln("infinity norm = ", norm(arr, normInf));
    writeln("frobenius norm = ", norm(arr, normFrob));
    writeln("default norm = ", norm(arr)); (*\label{default_call}*)
    writeln();
  } (*\label{test_end}*)

  def main() {  (*\label{test_main_start}*)
    // test vector norms:
    const D1 = [1..4];  (*\label{test_d1_def}*)
    var a:[D1] real;    (*\label{test_a_def}*)
    a = 2.0;            (*\label{test_a_init}*)
    testNorm(a);        (*\label{testnorm_a_call}*)

    // test matrix norms:
    const D2 = [1..2,1..2];  (*\label{test_d2_def}*)
    var b:[D2] real;         (*\label{test_b_def}*)
    b = 2.0;                 (*\label{test_b_init}*)
    testNorm(b);             (*\label{testnorm_b_call}*)
  }            (*\label{test_main_end}*)
}              (*\label{test_mod_end}*)
\end{numberedchapel}

\paragraph{Execution and Output}
After the definition of the \chpl{Norm} module, a \chpl{TestNorm} module
is defined in lines~\ref{test_mod_start} - \ref{test_mod_end}, giving 
an example of how the \chpl{norm} functions can be used in a program.

On line~\ref{use_norm} , \chpl{use Norm}, indicates that the \chpl{Norm} module is to be
used when resolving functions in the \chpl{TestNorm} module.  A \chpl{testNorm}
function is defined, taking \chpl{arr} as an argument.  Based on \chpl{arr.rank},
all of the valid norm options are tested, along with the generic \chpl{norm(arr)}
function call.  This \chpl{testNorm} function is called to test two arrays, \chpl{a}
and \chpl{b}.  The array \chpl{a} is a one-dimensional array, as defined by the
domain \chpl{D1}.  The array \chpl{b} is a two-dimensional array, as defined by
the domain \chpl{D2}.  Each array has a total of four elements, and each
is initialized to 2.0.  

The output of this program is given below.  The first set
of norms is computed for \chpl{a} which is a vector and the second set 
is computed for \chpl{b} which is
a matrix. Even though the vector and matrix in this example contain
the same number of elements with the same values, some of the computed norms
are different between the vector and the matrix.  Thus, different
implementations of the norm functions are used to compute the norms, 
depending on the whether the input is a vector or matrix.

{\small
\begin{verbatim}
Test of vector norms.  Array = 
2.0 2.0 2.0 2.0
1-norm = 8.0
2-norm = 4.0
infinity norm = 2.0
frobenius norm = 4.0
default norm = 4.0

Test of matrix norms.  Array = 
2.0 2.0
2.0 2.0
1-norm = 4.0
infinity norm = 4.0
frobenius norm = 4.0
default norm = 4.0
\end{verbatim}}

\paragraph{Implementation Details}
The \chpl{Norm} module begins with defining \chpl{normType} to be an
enumerated type \index{enumerated types} with constant values \chpl{norm1}, \chpl{norm2}, 
\chpl{normInf}, \chpl{normFrob}.
For three of the four \chpl{norm} function definitions (see lines~\ref{vec_start},
\ref{mat_start}, \ref{large_rank_start}), 
one of the formal arguments is of \chpl{normType}, indicating which type of norm 
is to be computed.  If \chpl{norm} is called without the \chpl{normType} argument,
then the default norm for vectors is the 2-norm (see line~\ref{default_vec}) and 
the default norm for matrices is the Frobenius norm (see line~\ref{default_mat}).  

The first \chpl{norm} function is defined for vectors.  This definition
begins with line~\ref{vec_start}:
\begin{chapel}
  def norm(x: [], p: normType) where x.rank == 1 {
\end{chapel}
The function definition contains a \chpl{where x.rank == 1} clause, indicating that
this version of \chpl{norm} is to be used when the input array \chpl{x}
has just one dimension, and is thus, a vector.  The arguments for this version
of \chpl{norm} are \chpl{x} of generic array type and \chpl{p} of \chpl{normType}.  
Since all norm types for the vector case can be computed with whole array 
operations, there 
is no need to specify a domain type for \chpl{x}.  It is good practice to
specify \chpl{x} as an array type by using \chpl{: []} since the \chpl{norm}
function is only defined for arrays.  The compiler can detect errors if other,
non-array types are passed as arguments to \chpl{norm} \index{arrays!as formal arguments}.

The body of the vector version of the \chpl{norm} function is a \chpl{select} 
statement \index{select@\chpl{select}} on
\chpl{p} in lines~\ref{vec_select_start} - \ref{vec_select_end}.  
\begin{chapel}
select (p) {                                   
      when norm1 do return + reduce abs(x);   
      when norm2 do return sqrt(+ reduce (abs(x)*abs(x)));  
      when normInf do return max reduce abs(x);  
      when normFrob do return sqrt(+ reduce (abs(x)*abs(x)));
      otherwise halt("Unexpected norm type"); 
    } 
\end{chapel}
For the first four cases of the select statement,
when \chpl{p} is \chpl{norm1}, \chpl{norm2}, \chpl{normInf} or \chpl{normFrob}
a reduction operator is used along with \chpl{abs(x)} to compute the value 
that is returned.  The \chpl{abs} function is promoted over the \chpl{x} array, 
computing the absolute values of each entry of \chpl{x}.  
The 1-norm of a vector is the sum of the absolute values of the entries of \chpl{x},
computed with the sum reduction expression, \chpl{ + reduce abs(x)}.  
The 2-norm of a vector is the sum of the squares of the absolute values of
the entries of \chpl{x}, computed with the sum reduction expression,
\chpl{ + reduce (abs(x)*abs(x))}.
The infinity norm of a vector is the maximum entry of \chpl{x} in absolute value,
which can be computed with the maximum reduction expression \chpl{max reduce abs(x)}.
The Frobenius norm of a vector is the same computation as the 2-norm of a vector.

The last case of the select statement, the otherwise clause, results
in the program halting, outputting the string that is passed to the \chpl{halt}
function indicating that \chpl{p} has an unexpected value.   

The second \chpl{norm} function is defined for matrices.  This definition begins
with line~\ref{mat_start}:
\begin{chapel}
  def norm(x: [?D], p: normType) where x.rank == 2 {
\end{chapel}
This version of the function will be used when \chpl{x} is a matrix,
that is the \chpl{rank} of the array \chpl{x} is \chpl{2}.  The arguments
for this version of \chpl{norm} are \chpl{x} of generic array type and \chpl{p}
of \chpl{normType}.  For this matrix version, the domain of \chpl{x} is
needed to express the  norm computations.  So, the domain type is {\em queried} 
and set to \chpl{D} with the expression \chpl{[?D]}.  

The body of the matrix version of \chpl{norm}
is a select statement on \chpl{p} in lines~\ref{mat_select_start} - \ref{mat_select_end}.
The \chpl{norm1} case, 
the 1-norm of a matrix, is the maximum absolute column sum of the matrix. 
\begin{chapel}
      when norm1 do           
        return max reduce [j in D(2)] (+ reduce abs(x[D(1), j])); 
\end{chapel}
The return expression is the maximum reduction of a \chpl{forall} loop, which computes
a sum reduction for each iteration.  
It uses \chpl{D(1)} and \chpl{D(2)}, which are the first and second dimension,
respectively, of the domain \chpl{D}.  The shorthand version of a \chpl{forall}
loop is used, \chpl{[j in D(2)]}, indicating that
for all \chpl{j in D(2)}, the sum
of the absolute values across the rows, \chpl{+ reduce abs(x[D(1), j])}, is computed. 
Then, the maximum value of these \chpl{j} absolute column sums is computed with
\chpl{max reduce}.  

The \chpl{norm2} case, the 2-norm of a matrix, is not
implemented.  Since the 2-norm of a matrix $A$ is the square root of the maximum
eigenvalue of the matrix $A^TA$ (or $A^HA$ in the case where $A$ is complex),
this norm has not been included in this simple example code.
This case will halt with a message indicating this unimplemented
status.  

The \chpl{normInf} case, the infinity norm of a matrix, is the maximum
absolute row sum.  
\begin{chapel}
      when normInf do  
        return max reduce [i in D(1)] (+ reduce abs(x[i, D(2)])); 
\end{chapel}
For all \chpl{i in D(1)}, the sum of the absolute values across columns,
\chpl{+ reduce abs(x[i, D(2)])} is computed.  Then the maximum value of these
\chpl{i} absolute row sums is computed with \chpl{max reduce}.  

The \chpl{normFrob}
case which is the Frobenius norm of a matrix, is the same computation as the
2-norm of a vector.  
\begin{chapel}
      when normFrob do return sqrt(+ reduce (abs(x)*abs(x))); 
\end{chapel}
The Frobenius norm is the square root of the sum of the
squares of absolute values of all entries in the matrix.  

The final case of
the select statement, the \chpl{otherwise} clause, halts with a message that
the norm type is unexpected.

The third version of the \chpl{norm} function with arguments \chpl{x}
and \chpl{p}, given in lines~\ref{large_rank_start} - \ref{large_rank_end} 
is for the case where \chpl{x.rank > 2}.
The module was designed to only compute norms of vectors and matrices.  
Calling the \chpl{norm} function with three-dimensional or higher arrays 
should give an error at compile time.  In this case, an appropriate compiler error 
is given using the \chpl{compilerError} function.  
\begin{chapel}
    compilerError("Norms not implemented for array ranks > 2D"); 
\end{chapel}
For more information about 
user-defined compiler errors, see~\rsec{User-Defined_Compiler_Errors}.

The final version of the \chpl{norm} function is given in 
lines~\ref{norm_default_start} - \ref{norm_default_end}.
\begin{chapel}
  def norm(x: []) { 
    select (x.rank) { 
      when 1 do return norm(x, norm2);  
      when 2 do return norm(x, normFrob); 
      otherwise compilerError("Norms not implemented for array ranks > 2D"); 
    }   
  }  
\end{chapel}
This version has one formal argument, \chpl{x}, allowing the user to 
omit the norm type.  It calls the other \chpl{norm} functions with default values for 
\chpl{normType}.  For vectors, the default norm is defined to be the 2-norm.
For matrices, the default norm is defined to be the Frobenius norm.  This 
version of \chpl{norm} is a select statement on \chpl{x.rank}.  Depending
on the rank of \chpl{x}, the \chpl{norm} function is called with the
appropriate default norm type or a compiler error is given.

\subsubsection{Simple Producer-Consumer Program}
\paragraph{Description}
The following example demonstrates a simple producer and consumer program.
The {\em producer computation} sets the value of a sync variable and the 
{\em consumer computation} prints the value of the same variable.

\paragraph{Chapel Features}
The program contains a \chpl{begin} statement \index{begin@\chpl{begin}}
to implement two concurrent computations, and a \chpl{sync} variable 
\index{synchronization variables}
to coordinate between the two.
Sync variables have extra state associated with them to
indicate whether they are logically {\em full} or {\em empty}.  
A sync variable
is intended to be accessed by multiple concurrent computations, each of which may
change the contents and state of the variable.  A sync variable
can be read when its state is full.  Attempts to read an empty sync variable from one
computation will suspend execution until another computation changes its state to full.
Once a sync variable is able to be read, its state is atomically set to empty.
Conversely, a sync variable can be written only when its state is empty.  Attempts
to write to a full sync variable will suspend until its state is empty.  Once the variable
is written to, the state is atomically set to full.  In addition, there are
functions that read and write sync variables which override this default behavior.
More information about sync variables and their functions is in~\rsec{Sync_Variables}
and~\rsec{Functions_on_Synchronization_Variables}.

\paragraph{Program Listing}
The Chapel code for this example is given below.

\begin{numberedchapel}
use Time;                           (*\label{use_time}*)

config var numIterations: int = 5,  (*\label{prodcons_var_1}*)
           sleepTime: uint = 2;     (*\label{prodcons_var_2}*)

var s: sync int;                    (*\label{prodcons_var_3}*)

begin { // create consumer computation (*\label{consumer_start}*)
  for c in 1..numIterations do         (*\label{consumer_for_1}*)
    writeln("consumer got ", s);       (*\label{consumer_for_2}*)
}                                      (*\label{consumer_end}*)

// producer computation
for p in 1..numIterations {            (*\label{producer_start}*)
  sleep(sleepTime);   (*\label{sleep_call}*)
  s = p;
}                                      (*\label{producer_end}*)
\end{numberedchapel}

\paragraph{Execution and Output}
When this program executes, a consumer computation is created with the \chpl{begin}
statement.
However, the consumer computation cannot read \chpl{s} before it has been written
to.  So, execution begins with the producer computation which assigns the value
\chpl{1} to \chpl{s} after calling the \chpl{sleep} function\footnote{The call to
the \chpl{sleep} function 
is used to mimic some amount of computational time.  It is not necessary to use
a sleep function when synchronizing between concurrent computations.}.   
Once \chpl{s} has the
value \chpl{1}, the consumer computation can read it and print it.  Execution
switches back and forth between the producer and consumer computation for
\chpl{numIterations}.

Running the program with the default
values for \chpl{numIterations} results in:
{\small
\begin{verbatim}
consumer got 1
consumer got 2
consumer got 3
consumer got 4
consumer got 5
\end{verbatim}}
Each line is printed after a delay of \chpl{sleepTime} seconds.

Since the variables \chpl{numIterations} and \chpl{sleepTime} are 
{\em configuration variables}, \index{configuration variables} they can 
be reset at execution time.
For example, to change the number of iterations to 10
and to change the number of seconds to sleep to 5, the following execution command
may be used:
{\small
\begin{verbatim}
> a.out --numIterations=10 --sleepTime=5
\end{verbatim}}

\paragraph{Implementation Details}
The program uses the \chpl{sleep} function in line~\ref{sleep_call}, which is 
provided in the
standard Chapel module, \chpl{Time}.  So, the first line, \chpl{use Time}, 
is needed to include the \chpl{Time} module when resolving 
function calls in this program.  

Lines~\ref{prodcons_var_1} - \ref{prodcons_var_2} give the declarations 
and initial default values
for the two variables, \chpl{numIterations} and \chpl{sleepTime}.
The \chpl{config} keyword in front of these two variable declarations 
indicates that these are configuration variables.  Configuration variables 
can be set to override their default values at program execution time, through the 
use of command line switches.  

In line~\ref{prodcons_var_2}, the variable \chpl{s} is 
declared to be a \chpl{sync} variable 
of type \chpl{int}.  Since \chpl{s}
is not initialized, its state is empty at the beginning of the program's execution.
The variable \chpl{s} will be used
to synchronize the exchange of data between the producer and consumer computations.

The remainder of the code defines the consumer and producer computations.
The new computation that is created with the \chpl{begin} statement will
be referred to as the consumer computation.  The continuing computation
will be referred to as the
producer computation.  Execution control switches between the
producer and consumer computations as the state of the sync variable \chpl{s}
changes when it is read and written to.

The \chpl{begin} statement in line~\ref{consumer_start} creates a 
new computation to execute the \chpl{for}
loop in lines~\ref{consumer_for_1} - \ref{consumer_for_2}.  
\begin{chapel}
begin {                                
  for c in 1..numIterations do        
    writeln("consumer got ", s);     
}                                   
\end{chapel}
This loop is indexed by \chpl{c}, which iterates over
the arithmetic sequence \chpl{1..numIterations}.  The variable \chpl{c} is a new
variable defined for the scope of the loop.  Its type is inferred to be integer from
the integer arithmetic sequence that follows.  During each iteration of the \chpl{for}
loop, the \chpl{writeln} function is called which outputs the string
literal \chpl{"consumer got "} and the value of the sync variable \chpl{s}, 
followed by a line break.  In order to print the value stored in \chpl{s}, the
sync variable is read only when its state is full.  Once \chpl{s} is successfully
read, its state will be set to empty.  The next iteration follows, and the 
consumer computation will suspend execution until the state of \chpl{s} is 
made full again.  Since the consumer computation only reads \chpl{s}, it will be 
the producer computation that changes the states of \chpl{s} to full.

The producer computation executes the \chpl{for} loop in lines~\ref{producer_start} -
\ref{producer_end}.  
\begin{chapel}
for p in 1..numIterations {            
  sleep(sleepTime);   
  s = p;
}      
\end{chapel}
This
loop is indexed by \chpl{p} which iterates over the same arithmetic sequence
as the consumer computation.  Like the index \chpl{c}, \chpl{p} is inferred to 
be an integer.
During each iteration of this \chpl{for} loop, the \chpl{sleep} function is
called with the argument\chpl{sleepTime}.  This \chpl{sleep} function is provided
in the \chpl{Time} standard module, and it causes the producer computation to
\chpl{sleepTime} seconds.  After returning from the \chpl{sleep} function, 
the producer computation assigns \chpl{s} to be the iteration number \chpl{p}.  
Because \chpl{s} is a sync variable, this assigment is executed only when the state of 
\chpl{s} is empty.  Once \chpl{s} is written, its state is changed to full and the
next iteration of the producer loop follows.  Since the producer computation only
writes \chpl{s}, it will be the consumer computation that changes the state of
\chpl{s} to empty allowing the next iteration to write its iteration number
to \chpl{s}.

The program terminates after \chpl{numIterations} of both the consumer and
producer loops.

\subsubsection{Generic Stack Implementations}
\paragraph{Description}
Two implementations of a generic stack type, \chpl{Stack}, are given below.  The first
defines \chpl{Stack} to be a linked list of \chpl{MyNode} objects.  In
the second implementation, \chpl{Stack} is an array.  Both implementations of
\chpl{Stack} define the methods, \chpl{push}, 
\chpl{pop} and \chpl{isEmpty}. 

\paragraph{Chapel Features}
These examples demonstrate {\em classes} \index{classes} and {\em records}\index{record}.  
Chapel classes and records
are both structured data types containing fields and methods.
Classes are reference types while records are value types.
The examples also
use the {\em unspecified type alias} \index{type aliases} \chpl{itemType} 
as the generic type for the items
in the stack and define generic stack methods.  To use either version,
a type for \chpl{itemType} must be specified when \chpl{Stack} is instantiated.
More information about type aliases can be found 
in~\rsec{Type_Aliases_in_Generic_Types}.  The array implementation of
the generic stack demonstrates
the association of arrays to domains \index{arrays! association to domains}.  In this example, the array's size is
doubled by reassigning its domain to one that is twice in size.

\paragraph{Sample Stack}
A simple example of how this generic stack can be used:
\begin{chapel}
var stack1: Stack(string);
stack1.push("one");
stack1.push("two");
stack1.push("three");
writeln(stack1.pop());
writeln(stack1.pop());
writeln(stack1.pop());
\end{chapel}
In this simple example, the variable \chpl{stack1} is declared to be a
stack of string type.
By specifying \chpl{string} as an input, the default constructor for \chpl{Stack}
will initialize the type alias for the generic stack to be a string.
The strings, \chpl{"one"}, \chpl{"two"} and \chpl{"three"}
are pushed on \chpl{stack1}, and then three items are popped off of \chpl{stack1},
in the reverse order from how they were put on the stack.
The output of this example is:
{\small
\begin{verbatim}
three
two
one
\end{verbatim}}

\paragraph{Linked List Implementation}
This implementation of a generic stack defines a {\em class},
\chpl{MyNode} and a {\em record}, \chpl{Stack}.  In the following
code, the reference pointers of \chpl{MyNode} objects are used to point to
the top of the stack and to point between items in the stack,
thus implementing the stack as a linked list.

\begin{numberedchapel}
class MyNode {                      (*\label{mynode_class_start}*)
  type itemType;                    (*\label{mynode_itemtype}*)
  var item: itemType;               (*\label{mynode_item}*)
  var next: MyNode(itemType);       (*\label{mynode_next}*)
}                                   (*\label{mynode_class_end}*)

record Stack {                      (*\label{stack_list_start}*)
  type itemType;                    (*\label{stack_list_itemtype}*)
  var top: MyNode(itemType);        (*\label{stack_list_top}*)

  def push(item: itemType) {        (*\label{stack_list_push_start}*)
    top = MyNode(itemType, item, top); (*\label{stack_list_push_top}*)
  }                                 (*\label{stack_list_push_end}*)

  def pop() {                       (*\label{stack_list_pop_start}*)
    if isEmpty then                 (*\label{stack_list_pop_empty_1}*)
      halt("attempt to pop an item off an empty stack"); (*\label{stack_list_empty_2}*)
    var oldTop = top;               (*\label{stack_list_pop_oldtop}*)
    top = top.next;                 (*\label{stack_list_pop_newtop}*)
    return oldTop.item;             (*\label{stack_list_pop_return}*)
  }                                 (*\label{stack_list_pop_end}*)

  def isEmpty return top == nil;   (*\label{stack_list_isempty}*)
}                                  (*\label{stack_list_end}*)
\end{numberedchapel}

\paragraph{Linked List Implementation Details}
The code begins with a definition of the \chpl{MyNode} class in 
lines~\ref{mynode_class_start} - \ref{mynode_class_end}.  
\begin{chapel}
class MyNode {                      
  type itemType;                   
  var item: itemType;             
  var next: MyNode(itemType);    
\end{chapel}
Objects of type \chpl{MyNode} are used to store the generic items in the stack
as a linked list.  There are three fields in \chpl{MyNode}:  \chpl{itemType}, 
\chpl{item} and
\chpl{next}.  \chpl{MyNode} objects are instantiated within \chpl{Stack} to
have the same \chpl{itemType} as the \chpl{Stack}.  The \chpl{item} field
holds the data and \chpl{next} is a pointer to the next \chpl{MyNode} object
in the linked list.

The \chpl{Stack} record contains two fields:
\begin{chapel}
record Stack {                      
  type itemType;                   
  var top: MyNode(itemType);      
\end{chapel}
When \chpl{Stack} is instantiated, a type is specified for the type
alias, \chpl{itemType}.  The \chpl{top} field is a pointer to the top
of the stack, which is a \chpl{MyNode} object of \chpl{itemType}.  When
the stack is first instantiated, \chpl{top} is set to nil.  To 
add and remove items from the stack, the \chpl{push} and \chpl{pop} 
methods are used.

The \chpl{push} method is given in lines~\ref{stack_list_push_start} -
\ref{stack_list_push_end}.  This method adds an item to the top of the stack
by resetting \chpl{top} to point to a new \chpl{MyNode} object.  This new
top object stores the added item and sets its \chpl{next} field to the previous
\chpl{top} object of the stack.
\begin{chapel}
  def push(item: itemType) {        
    top = MyNode(itemType, item, top); 
  }                                 
\end{chapel}
The default constructor for \chpl{MyNode} is called to create a new
object with \chpl{itemType} and \chpl{top} fields
of the \chpl{Stack} instance on which \chpl{pop} is called, and the
formal argument \chpl{item} of the \chpl{pop} function call.
To reference
fields of an instance of a structured type, \chpl{this} is used.
In this case, \chpl{this.top} and \chpl{this.itemType} are 
implicit in the uses of \chpl{top} and \chpl{itemType}. 

The \chpl{pop} method is given in lines~\ref{stack_list_pop_start} -
\ref{stack_list_pop_end}.  
\begin{chapel}
  def pop() {           
    if isEmpty then   
      halt("attempt to pop an item off an empty stack"); 
    var oldTop = top;               
    top = top.next;                
    return oldTop.item;           
  }                              
\end{chapel}
This method returns the item at the top of
the stack and resets \chpl{top} to point to the next object in the stack.
First, a call to the \chpl{Stack} method \chpl{isEmpty} is made to 
determine if the stack is
empty.  If it is, the program halts with a message indicating that 
an attempt was made to pop an item off of an empty stack.  Otherwise,
\chpl{top} is reset, and the appropriate item is returned.
In this method, \chpl{this.isEmpty} and \chpl{this.top} are implicit when
\chpl{isEmpty} and \chpl{top} are used.
The memory of the \chpl{oldTop} object is freed, through automatic
garbage collection.

The \chpl{isEmpty} method, which is used to check if the stack
is empty in the \chpl{pop} method, is defined to be:
\begin{chapel}
  def isEmpty return top == nil;   
\end{chapel}

\paragraph{Array Implementation}
The following implementation of a generic stack uses the array,
\chpl{data}, to store the generic items in the stack, and the
counter, \chpl{numItems}, to track the
number of items in the stack and to indicate the index of
the top item of the stack.  The number of items in the stack
and the size of \chpl{data} are checked when a new item is pushed
on the stack.  If necessary, the size of \chpl{data} is doubled.
This example demonstrates how the size of an array is increased 
by increasing its domain.

\begin{numberedchapel}
record Stack {                     (*\label{stack_array_start}*)
  type itemType;                   (*\label{stack_array_itemtype}*)
  var numItems: int = 0;           (*\label{stack_array_numitems}*)
  var data: [1..2] itemType;       (*\label{stack_array_data}*)

  def push(item: itemType) {       (*\label{stack_array_push_start}*)
    var height = data.numElements;  (*\label{stack_array_push_height}*)
    if numItems == height then      (*\label{stack_array_push_check_height}*)
      data.domain = [1..height*2];  (*\label{stack_array_push_incr_dom}*)
    data(numItems+1) = item;        (*\label{stack_array_push_new_item}*)
    numItems += 1;                  (*\label{stack_array_push_num_incr}*)
  }                                 (*\label{stack_array_push_end}*)

  def pop() {                       (*\label{stack_array_pop_start}*)
    if isEmpty then                 (*\label{stack_array_pop_empty_1}*)
      halt("attempt to pop an item off an empty stack"); (*\label{stack_array_pop_empty_2}*)
    numItems -= 1;                  (*\label{stack_array_pop_num_dec}*)
    return data(numItems+1);        (*\label{stack_array_pop_return}*)
  }                                 (*\label{stack_array_pop_end}*)

  def isEmpty return numItems == 0; (*\label{stack_array_isempty}*)
}                                   (*\label{stack_array_end}*)
\end{numberedchapel}

\paragraph{Array Implementation Details}
There are three fields defined for this \chpl{Stack} record, \chpl{itemType},
an integer variable, \chpl{numItems} and an array \chpl{data} of \chpl{itemType}.
When first instantiated,
the stack is empty and \chpl{numItems} is initialized to zero.   The \chpl{data}
array is declared with an anonymous one-dimensional domain, \chpl{[1..2]}.

The same three methods, \chpl{push}, \chpl{pop}, and \chpl{isEmpty} are
defined for this array implementation.  Like the linked list implementation,
there are no explicit references to \chpl{this} when accessing fields and
methods.

In \chpl{push}, lines~\ref{stack_array_push_start}
- \ref{stack_array_push_end}, \chpl{item} is stored in the \chpl{data(numItems+1)}
and the \chpl{numItems} counter is incremented.  
\begin{chapel}
  def push(item: itemType) {       
    var height = data.numElements;  
    if numItems == height then     
      data.domain = [1..height*2];
    data(numItems+1) = item;        
    numItems += 1;                 
  }                               
\end{chapel}
Before \chpl{item} can be added
to the stack, the size of \chpl{data} must be checked to determine if the array's size
needs to be increased to accomodate another item being added to the stack.
The method \chpl{numElements} is predefined for arrays, returning the total
number of elements in an array.  The variable \chpl{height} is set to the
total number of elements in \chpl{data}, which is the size of the current array
allocated to store items in the stack.
If the number of items in the stack, \chpl{numItems} equals
\chpl{height}, then more storage in \chpl{data} is needed.  To increase the
size of an array, the size of its domain is increased.
By reseting \chpl{data}'s
domain to a domain of twice the size, the array \chpl{data} itself is now doubled in size,
and more items can be pushed onto the stack. 

In \chpl{pop}, the top item in the stack, as indicated by the \chpl{numItem} counter,
is returned, if the stack is not empty.
\begin{chapel}
  def pop() {                       
    if isEmpty then                
      halt("attempt to pop an item off an empty stack"); 
    numItems -= 1;                  
    return data(numItems+1);       
  }
\end{chapel}
The \chpl{pop} method first checks to see if the stack is empty.  If it is, the program
halts indicating that there was an attempt to pop an item off of an empty stack.
Otherwise, the \chpl{numItems} counter is decremented and \chpl{data(numItems+1)}
is returned as the popped item.  

The \chpl{isEmpty} method checks to see if
the stack is empty, that is if \chpl{numItems} equals zero.
\begin{chapel}
  def isEmpty return numItems == 0; 
\end{chapel}

