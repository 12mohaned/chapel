\sekshun{Language Overview}
\label{Language_Overview}

\subsection{Motivating Principles}

\paragraph{General Parallel Programming}

Chapel's first motivating principle is to support general parallel
programming through the use of high-level language abstractions that
result in multithreaded execution.  Chapel does this by supporting a
\emph{global-view programming model} that raises the level of
abstraction for the expression of both data and control flow as
compared to parallel programming models currently used in production.

\emph{Global-view data structures} are arrays and other data
aggregates whose sizes and indices are expressed globally in spite of
the fact that their implementations may distribute them across the
memories of multiple nodes or \emph{locales}.\footnote{A \emph{locale}
  in Chapel is a unit of the target architecture that supports
  computation and data storage.  Locales are defined for an
  architecture such that a locale's threads will all have similar
  access times to any specific memory address.  For commodity
  clusters, each of their (single-core) processors, multicore
  processors, or SMP nodes would be considered a locale.}  This
contrasts with most parallel languages used in practice, which tend to
require users to partition distributed data aggregates into
per-processor chunks, either manually or using language abstractions.
As a simple example, to create a 0-based vector with $n$ elements
distributed between $p$ locales, a language like Chapel that supports
global-view data structures allows the user to declare the array to
contain $n$ elements and to refer to the array using the indices $0
\ldots n-1$.  In contrast, most traditional approaches require the
user to declare the array as $p$ chunks of $n/p$ elements each (and
the details can be messy if $p$ does not divide $n$ evenly).
Moreover, the chunks are typically accessed using local indices on
each processor (\eg,~$0..n/p$), requiring the user to explicitly
translate between logical indices and those used by the
implementation.
%  HPF and ZPL are two other recent parallel languages that support
%global-view data structures, though in a more restricted form than
%Chapel.

A \emph{global view of control} means that a user's program commences
execution with a single logical thread of control and then introduces
additional parallelism through the use of certain language concepts.
All parallelism in Chapel is implemented via multithreading, though
these threads are created via high-level language concepts and managed
by the compiler and runtime, rather than through explicit
fork/join-style programming.  An impact of this approach is that
Chapel can express parallelism that is more general than the Single
Program, Multiple Data~(SPMD) model that today's most common parallel
programming approaches use as the basis for their programming and
execution models.
%Examples include Co-Array Fortran,
%Unified Parallel~C~(UPC), Titanium, HPF, ZPL, SHMEM, and typical uses
%of MPI~\cite{CAF, UPCBook, Titanium, HPFBook, ZPL, SHMEM, MPIBook,
%  MPI2Book}.  Our multithreaded execution model is perhaps most
%similar to that which is supported by the Cilk language or the Cray
%MTA's runtime libraries~\cite{CilkRef, MTAThreads}.  Moreover,
Chapel's general support for parallelism does not preclude users
from coding in an SPMD style if they wish.


Supporting general parallel programming also means targeting a broad
range of parallel architectures.  Chapel is designed to target a wide
spectrum of HPC hardware including clusters of commodity processors
and SMPs; vector, multithreading, and multicore processors; custom
vendor architectures; distributed, shared, and shared address space
memory architectures; and networks of any topology.  Our portability
goal is to have any legal Chapel program run correctly on all of these
architectures, and for Chapel programs that express parallelism in an
architecturally-neutral way to perform reasonably on all of them.
Naturally, Chapel programmers can tune their codes to more closely
match a particular machine's characteristics, though doing so may
cause the program to be a poorer match for other architectures.  

\paragraph{Control of Locality}

A second principle in Chapel is to allow the user to optionally and
incrementally specify where data and computation should be placed on
the physical machine.  We consider this control over program locality
to be essential for achieving scalable performance on large machine
sizes given current architectural trends.  Such control contrasts with
shared-memory programming models which present the user with a flat
memory model.  It also contrasts with SPMD-based programming models in
which such details are explicitly specified by the programmer on a
process-by-process basis via the multiple cooperating program
instances.

\paragraph{Object-Oriented Programming}

A third principle in Chapel is support for object-oriented
programming~(OOP), which has been instrumental in raising productivity
in the mainstream programming community.  Chapel supports traditional
reference-based classes as well as value classes.  The programmer is
not required to use an object-oriented style in their code, so that
traditional Fortran and C programmers need not adopt a new programming
paradigm in order to use Chapel effectively.  Many of Chapel's
standard library capabilities are implemented using objects, so such
programmers may need to utilize a method-invocation style of syntax to
use these capabilities.  However, using such libraries does not
necessitate broader adoption of OOP methodologies.

\paragraph{Generic Programming}

Chapel's fourth principle is support for generic programming and
polymorphism.  These features allow code to be written in a style that
is generic across types, making it applicable to variables of multiple
types, sizes, and precisions.  The goal of these features is to
support exploratory programming as in popular interpreted and
scripting languages, and to support code reuse by allowing algorithms
to be expressed without explicitly replicating them for each possible
type.  This flexibility at the source level is implemented by having
the compiler create versions of the code for each required type
signature rather than by relying on dynamic typing which would result
in unacceptable runtime overheads for the HPC community.

Chapel's first two principles are designed to provide support for
general, performance-oriented parallel programming through high-level
abstractions.  The second two principles are supported to help narrow
the gulf that exists between parallel programming languages and
mainstream programming and scripting languages.


\subsection{Getting Started}

A Chapel version of the standard ``hello world'' computation is given
here:
\begin{chapel}
writeln("Hello, world!");
\end{chapel}
\noindent This program contains a single line of code that makes a
call to the standard \chpl{writeln} subroutine, passing it a string
literal argument, \chpl{"Hello, world!"}.  This call causes the string
to be printed to the console when the program is executed.

In general, Chapel programs define code using one or more named
\emph{modules}, each of which supports an initialization routine that
is invoked the first time the module is used.  Programs also define a
single entry point via a subroutine named \chpl{main}.  To facilitate
exploratory programming, Chapel allows programmers to define modules
using files rather than an explicit module declaration, to write
module setup code at the module scope rather than in an explicit
initialization routine, and to omit the program entry point when the
program only has a single user module.  This example takes advantage
of all three features.

Chapel code is stored in files with the extension \chpl{.chpl}.
Assuming this program is stored in a file called \chpl{hello.chpl}, it
would define a single user module, \chpl{hello}, whose name is taken
from the filename.  Since the module contains no initialization
routine, it can contain executable code at the top level which will
serve as its initialization code.  And since the program is composed
of the single \chpl{hello} module, it need not define an entry point.
Thus, when the program is executed, the single \chpl{hello} module
will be initialized by executing its top-level code, invoking the call
to \chpl{writeln()}, and printing out the message.

To compile and run this program, execute the following commands at the
system prompt:
\begin{verbatim} 
> chpl -o hello hello.chpl
> ./hello
\end{verbatim}
The following output will be printed to the console:
\begin{verbatim}
> Hello, world!
\end{verbatim}

\subsection{Example: Jacobi}
The following example Chapel program solves a system of finite difference
equations for the Laplace equation using the Jacobi method.  The program uses
two-dimensional arrays, \chpl{A} and \chpl{Temp}, to store and calculate the approximate
solution.  At each iteration, the next approximation for the solution at 
each grid point, \chpl{Temp(i,j)} is calculated by computing the average of 
the four neighboring grid points,
\chpl{A(i-1,j)}, \chpl{A(i,j-1)}, \chpl{A(i+1,j)}, and \chpl{A(i,j+1)}.  
After all entries in \chpl{Temp} are computed, \chpl{A} is assigned to \chpl{Temp}
and convergence is tested.  If convergence has not been reached, the next
approximation is calculated, and so on until the convergence test is met.

This program demonstrates how arrays are declared and used.  In Chapel, 
arrays are declared using {\em domains}.  In this example, \chpl{BigDomain} is
used in the declaration of \chpl{A} and \chpl{Temp}.
Domains are sets of indices which may be distributed
across multiple processors indicating how data and parallel work should
be divided among the processors.  An array is a mapping from the domain
to a collection of variables.  An array is thus defined using a domain, distributing
the entries of the array according to the domain's distribution.
A domain may also be used as the iterator in a \chpl{for} or
\chpl{forall} statement, in which case the iterations are distributed among processors
according to the domain's distribution.  There are five kinds of domains in
the Chapel language:  {\em arithmetic}, {\em sparse}, {\em indefinite},
{\em opaque} and {\em enumerated}.  This example program uses arithmetic domains
and arrays.  More information about domains and arrays is given in~\rsec{Domains_and_Arrays}.

The Chapel code for this example follows.  
\begin{numberedchapel}
config var n = 5,                  (*\label{jac_config_start}*)
           epsilon = 0.00001,
           verbose = false;        (*\label{jac_config_end}*)

def main() {                       (*\label{jac_main}*)
  const ProblemSpace = [1..n, 1..n],  (*\label{problem_space}*)
        BigDomain = [0..n+1, 0..n+1]; (*\label{big_domain}*)

  var A, Temp: [BigDomain] real = 0.0; (*\label{a_temp_decl}*)

  A[n+1, 1..n] = 1.0;                 (*\label{a_init_last_row}*)

  if (verbose) {                      (*\label{verbose_init_start}*)
    writeln("Initial configuration:");
    writeln(A, "\n");
  }                                   (*\label{verbose_init_end}*)

  var iteration = 0,                  (*\label{jac_var_start}*)
      delta: real;                    (*\label{jac_var_end}*)

  do {                                (*\label{jac_do_start}*)
    forall (i,j) in ProblemSpace do   (*\label{jac_forall}*)
      Temp(i,j) = (A(i-1,j) + A(i+1,j) + A(i,j-1) + A(i,j+1)) / 4.0; (*\label{jac_iter}*)

    delta = max reduce abs(Temp[ProblemSpace] - A[ProblemSpace]); (*\label{jac_reduce}*)
    A[ProblemSpace] = Temp[ProblemSpace]; (*\label{jac_update_A}*)

    iteration += 1; (*\label{jac_advance_iteration}*)

    if (verbose) {  (*\label{verbose_iter_start}*)
      writeln("iteration: ", iteration);
      writeln(A);
      writeln("delta: ", delta, "\n");
    }               (*\label{verbose_iter_end}*)
  } while (delta > epsilon);          (*\label{jac_do_end}*)

  writeln("Jacobi computation complete.");  (*\label{jac_output_start}*)
  writeln("Delta is ", delta, " (< epsilon = ", epsilon, ")");
  writeln("# of iterations: ", iteration); (*\label{jac_output_end}*)
}
\end{numberedchapel}

Compiling and running this program gives the following output:
\begin{verbatim}
> ./a.out
Jacobi computation complete.
Delta is 9.92124e-06 (< epsilon = 1e-05)
# of iterations: 60
\end{verbatim}

It is possible to run a different sized problem, to use a different
convergence tolerance, or enable more output without recompiling this
program.  There are three variables defined in lines~\ref{jac_config_start} - 
\ref{jac_config_end}, 
\chpl{n}, \chpl{epsilon} and \chpl{verbose} which are configuration variables,
as indicated by the \chpl{config} keyword, 
and can be set at the time of program execution through command line switches.
Executing the following command line sequence,
\begin{verbatim}
> ./a.out --verbose=true --n=2 --epsilon=0.01
\end{verbatim}
results in overriding the default values for \chpl{verbose}, \chpl{n} and
\chpl{epsilon}, producing the following output.
\begin{verbatim}
Initial configuration:
0.0 0.0 0.0 0.0
0.0 0.0 0.0 0.0
0.0 0.0 0.0 0.0
0.0 1.0 1.0 0.0

iteration: 1
0.0 0.0 0.0 0.0
0.0 0.0 0.0 0.0
0.0 0.25 0.25 0.0
0.0 1.0 1.0 0.0
delta: 0.25

iteration: 2
0.0 0.0 0.0 0.0
0.0 0.0625 0.0625 0.0
0.0 0.3125 0.3125 0.0
0.0 1.0 1.0 0.0
delta: 0.0625

iteration: 3
0.0 0.0 0.0 0.0
0.0 0.09375 0.09375 0.0
0.0 0.34375 0.34375 0.0
0.0 1.0 1.0 0.0
delta: 0.03125

iteration: 4
0.0 0.0 0.0 0.0
0.0 0.109375 0.109375 0.0
0.0 0.359375 0.359375 0.0
0.0 1.0 1.0 0.0
delta: 0.015625

iteration: 5
0.0 0.0 0.0 0.0
0.0 0.117188 0.117188 0.0
0.0 0.367188 0.367188 0.0
0.0 1.0 1.0 0.0
delta: 0.0078125

Jacobi computation complete.
Delta is 0.0078125 (< epsilon = 0.01)
# of iterations: 5
\end{verbatim}

Also, it is important to note that none of these three configuration variables contain a 
type in their declaration: 
\begin{chapel}
config var n = 5,
           epsilon = 0.00001,
           verbose = false;
\end{chapel}
Instead the types of these variables are inferred 
from their initial values: \chpl{n} is an integer, \chpl{epsilon} is a floating point
type, and \chpl{verbose} is a boolean type.  In Chapel, if a variable declaration
contains an initialization expression, it is optional to include a type specification.
More details about variable declarations are given in~\rsec{Variable_Declarations}.

After the configuration variables are declared, the \chpl{main} function
is defined.  The first two lines of \chpl{main} define two arithmetic domains:
\begin{chapel}
  const ProblemSpace = [1..n, 1..n],
        BigDomain = [0..n+1, 0..n+1];
\end{chapel}
Both domains are declared to be \chpl{const}, indicating
that the values for the domains remain constant during the execution of
the program.  They are defined using arithmetic sequences, and are, thus,
arithmetic domains.  Because the domains are initialized in their declaration,
it is not necessary to specify that they are of domain type.  In this case,
\chpl{: domain(2)} was omitted from both domain declarations.  
\chpl{BigDomain} is essentially the \chpl{ProblemSpace} 
domain with additional 
boundary rows and columns.  By defining \chpl{ProblemSpace} to be the interior
points of the larger grid, \chpl{BigDomain}, the Jacobi computation can be cleanly 
specified in one line, line~\ref{jac_iter}, for just the interior points, 
eliminating the need to write special case computations for the boundary points.

After the domains are declared, the arrays are declared using \chpl{BigDomain},
and the last row of \chpl{A} is set to one.
\begin{chapel}
  var A, Temp: [BigDomain] real = 0.0;

  A[n+1, 1..n] = 1.0;
\end{chapel}
The arrays, \chpl{A} and \chpl{Temp} are declared to be of type \chpl{real} and
are initialized to zero.  Because they are defined using \chpl{BigDomain}, the
arrays are of size \chpl{n+2} $\times$ \chpl{n+2}. 

Lines~\ref{verbose_init_start} - \ref{verbose_init_end} print the initial 
configuration of the problem, if \chpl{verbose}
is set to true.  Lines~\ref{jac_var_start} - \ref{jac_var_end} 
contain the remaining variable declarations:
\begin{chapel}
  var iteration = 0,
      delta: real;
\end{chapel}
The variable \chpl{delta} must be specified to be of type \chpl{real} since
it does not have an initialization expression.

The computational loop in lines~\ref{jac_do_start} - \ref{jac_do_end}  
performs the Jacobi method.
This loop is executed until \chpl{delta} is less than or equal to \chpl{epsilon}.
\begin{chapel}
  do {
    forall (i,j) in ProblemSpace do
      Temp(i,j) = (A(i-1,j) + A(i+1,j) + A(i,j-1) + A(i,j+1)) / 4.0;

    delta = max reduce abs(Temp[ProblemSpace] - A[ProblemSpace]);
    A[ProblemSpace] = Temp[ProblemSpace];

    iteration += 1;

    if (verbose) {
      writeln("iteration: ", iteration);
      writeln(A);
      writeln("delta: ", delta, "\n");
    }
  } while (delta > epsilon);
\end{chapel}
Each iteration of the \chpl{do while} loop computes the next approximate
solution using a \chpl{forall} loop.  This loop 
uses the \chpl{ProblemSpace} domain as the iterator.  The \chpl{ProblemSpace}
domain is the set of interior points of \chpl{A}'s domain. 
All of the references to \chpl{A} in the loop are
defined, and do not go out of bounds.  Each iteration 
is indexed by a tuple of indices \chpl{(i,j)}, which avoids the use of
a nest of two loops, one loop for the index \chpl{i} and one loop for the
index \chpl{j}.  The compiler determines how this loop is made parallel, according
to the default distribution for the \chpl{ProblemSpace} domain.   

After the next approximate solution is computed and stored in \chpl{Temp},
the change between \chpl{Temp} and \chpl{A}, for just the interior points, is 
calculated and stored in \chpl{delta}:  
\begin{chapel}
    delta = max reduce abs(Temp[ProblemSpace] - A[ProblemSpace]);
\end{chapel}
The reduction, \chpl{max reduce}
computes the maximum value of the expression that follows it.  If
\chpl{Temp} and \chpl{A} are distributed, then this reduction is computed in 
parallel accordingly.  

Next, \chpl{A} is updated with the new approximate solution and the iteration
number is advanced.  If \chpl{verbose} is set to true, then information about
the current approximate solution and \chpl{delta} is output.  If \chpl{delta}
is greater than the convergence tolerance, \chpl{epsilon}, then the \chpl{do
while} loop continues.  Otherwise, the loop exits.  
The program ends with output, indicating that the computation is complete
and giving information about convergence.  

\subsection{Example: Norm}
The following example contains a module \chpl{Norm} which defines  
\chpl{norm} functions that compute either a vector or matrix norm, depending
on the rank of the array that is passed as the argument.  There are three
norm type options for vector and matrix norm calculations.  For vectors,  
the 1-norm, 2-norm and infinity norm are implemented in this module.  
For matrices, the 1-norm, infinity norm and Frobenius norm are provided.   
The module uses a variable of enumerated type \chpl{normType} to indicate the choice
of norm.

When the \chpl{Norm} module is used, the user may call 
\chpl{norm(x)} or \chpl{norm(x,normType)} where
\chpl{x} is any array and \chpl{normType} is the enumerated type as defined
in the \chpl{Norm} module.  The \chpl{norm} function is overloaded with
four separate function definitions for \chpl{norm}, based on the
the dimension, or \chpl{rank}, of the input array, or the number of formal
arguments used in the \chpl{norm} function call.  Each of these four function
definitions is a {\em generic} function, not specifying the type of the array
argument \chpl{x}.  Generic functions allow for code reuse and readability.

The following program gives the definition of the \chpl{Norm} module followed
by a module which tests \chpl{Norm}, demonstrating different calls to the \chpl{norm}
function.

\begin{numberedchapel}
module Norm{
  enum normType {norm1, norm2, normInf, normFrob};

  def norm(x: [], p: normType) where x.rank == 1 {
    select (p) {
      when norm1 do return + reduce abs(x);
      when norm2 do return sqrt(+ reduce (abs(x)*abs(x)));
      when normInf do return max reduce abs(x);
      when normFrob do halt("From-norm not defined for 1D arrays");
      otherwise halt("Unexpected norm type");
    }
  }

  def norm(x: [?D], p: normType) where x.rank == 2 {
    select (p) {
      when norm1 do
        return max reduce [j in D(2)] (+ reduce abs(x[D(1), j]));

      when norm2 do
        halt("Haven't implemented 2-norm for 2D arrays yet");

      when normInf do
        return max reduce [i in D(1)] (+ reduce abs(x[i, D(2)]));

      when normFrob do return sqrt(+ reduce (abs(x)*abs(x)));

      otherwise halt("Unexpected norm type");
    }
  }

  def norm(x: [], p: normType) where x.rank > 2 {
    compilerError("Norms not implemented for array ranks > 2D");
  }

  def norm(x: []) {
    select (x.rank) {
      when 1 do return norm(x, norm2);
      when 2 do return norm(x, normFrob);
      otherwise compilerError("Norms not implemented for array ranks > 2D");
    }
  }
}

module TestNorm {
  use Norm;

  def testNorm(arr: []) {
    var testType = if (arr.rank == 1) then "vector" else "matrix";
    writeln("Test of ", testType, " norms.  Array = ");
    writeln(arr);
    writeln("1-norm = ", norm(arr, norm1));
    if (arr.rank == 1) then
      writeln("2-norm = " , norm(arr, norm2));
    writeln("infinity norm = ", norm(arr, normInf));
    if (arr.rank == 2) then
      writeln("frobenius norm = ", norm(arr, normFrob));
    writeln("default norm = ", norm(arr));
    writeln();
  }

  def main() {
    const D1 = [1..4];
    var a:[D1] real;
    a = 2.0;
    testNorm(a);

    const D2 = [1..2,1..2];
    var b:[D2] real;
    b = 2.0;
    testNorm(b);
  }
}
\end{numberedchapel}

After the definition of the \chpl{Norm} module, a \chpl{TestNorm} module
is defined in lines 44 - 72, giving an example of how the \chpl{norm} functions are used.
On line 45, \chpl{use Norm}, indicates that the \chpl{Norm} module is to be
used when resolving functions in the \chpl{TestNorm} module.  A \chpl{testNorm}
function is defined, taking \chpl{arr} as an argument.  Based on \chpl{arr.rank},
all of the valid norm options are tested, along with the generic \chpl{norm(arr)}
function call.  The \chpl{main} function defines an example vector and matrix.
The domain \chpl{D1} is a one-dimensional domain, indexed
from \chpl{1} to \chpl{4}.  This domain is used to define the vector
\chpl{a}.  The domain \chpl{D2} is a two-dimensional domain, indexed from \chpl{1}
to \chpl{4} in each dimension.  This domain is used to define the matrix \chpl{b}.
Both \chpl{a} and \chpl{b} are initialized to \chpl{2.0} and passed to
\chpl{testNorm}.

The output of this program is given below.  Note that the first set
of norms is computed for a vector and the second set are computed for
a matrix. Even though the vector and matrix in this example contain
the same number of elements with the same values, the computed norms
are different between the vector and the matrix.  Thus, different
functions are used to compute the norms, depending on the whether the
input is a vector or matrix.

\begin{verbatim}
Test of vector norms.  Array = 
2.0 2.0 2.0 2.0
1-norm = 8.0
2-norm = 4.0
infinity norm = 2.0
default norm = 4.0

Test of matrix norms.  Array = 
2.0 2.0
2.0 2.0
1-norm = 4.0
infinity norm = 4.0
frobenius norm = 4.0
default norm = 4.0
\end{verbatim}

The \chpl{Norm} module begins with defining \chpl{normType} to be an
enumerated type with constant values \chpl{norm1}, \chpl{norm2}, 
\chpl{normInf}, \chpl{normFrob}.
For three of the four \chpl{norm} function definitions (see lines 4, 14, 31), 
one of the formal arguments is of \chpl{normType}, indicating which type of norm 
is to be computed.  If \chpl{norm} is called without the \chpl{normType} argument,
then the default norm for vectors is the 2-norm (see line 37) and the default
norm for matrices is the Frobenius norm (see line 38).  

The first \chpl{norm} function is defined for vectors.  This definition
begins with line 4:
\begin{chapel}
  def norm(x: [], p: normType) where x.rank == 1 {
\end{chapel}
The function definition contains a \chpl{where x.rank == 1} clause, indicating that
this version of \chpl{norm} is be used when the input array \chpl{x}
has just one dimension, and is thus, a vector.  The arguments for this version
of \chpl{norm} are \chpl{x} of generic array type and \chpl{p} of \chpl{normType}.  
Since all norm types for vectors can be computed with whole array operations, there 
is no need to specify a domain type for \chpl{x}.  It is good practice to
specify \chpl{x} as an array type by using \chpl{: []} since the \chpl{norm}
function is only defined for arrays.  The compiler can detect errors if other,
non-array types are passed as arguments to \chpl{norm}.


The body of the vector version of the \chpl{norm} function is a \chpl{select} statement on
\chpl{p} in lines 5 -11.  For the first three cases of the select statement,
when \chpl{p} is \chpl{norm1}, \chpl{norm2} or chpl{normInf},
a reduction operator is used to compute the value that is returned. 
The 1-norm of a vector is the sum of the absolute values of the entries of \chpl{x},
which can be computed with the sum reduction expression, \chpl{ + reduce abs(x)}.
The 2-norm of a vector is the sum of the squares of the absolute values of
the entries of \chpl{x}, which can be computed with the sum reduction expression,
\chpl{ + reduce (abs(x)*abs(x))}.
The infinity norm of a vector is the maximum entry of \chpl{x} in absolute value,
which can be computed with the maximum reduction expression \chpl{max reduce abs(x)}.
Reduction and scan expressions are discussed in more detail 
in~\rsec{Reductions_and_Scans}.  The last two cases of the select statement result
in the program halting, outputting the string that is passed to the \chpl{halt}
function.  Since the Frobenius norm is not defined for vectors, the program
will halt when \chpl{p} is \chpl{normFrob}.  The \chpl{otherwise} clause will
result in the program halting if any other value is passed in for \chpl{p}.

The second \chpl{norm} function is defined for matrices.  This definition begins
with line 14:
\begin{chapel}
  def norm(x: [?D], p: normType) where x.rank == 2 {
\end{chapel}
This version of the function will be used when \chpl{x} is a matrix,
that is the \chpl{rank} of the array \chpl{x} is \chpl{2}.  The arguments
for this version of \chpl{norm} are \chpl{x} of generic array type and \chpl{p}
of \chpl{normType}.  For this matrix version, the domain of \chpl{x} is
needed to express the  norm computations.  So, the domain type is queried and set to 
\chpl{D} with the expression \chpl{[?D]}.  

The body of the matrix version of \chpl{norm}
is a select statement on \chpl{p} in lines 15 - 28.  The \chpl{norm1} case, 
the 1-norm of a matrix, is the maximum absolute column sum, which is computed 
with the expression 
\begin{chapel}
max reduce [j in D(2)] (+ reduce abs(x[D(1), j])).
\end{chapel}
This expression is the maximum reduction of a \chpl{forall} loop, which computes
a sum reduction for each iteration.  
It uses \chpl{D(1)} and \chpl{D(2)}, which are the first and second dimension,
respectively, of the domain \chpl{D}.  The shorthand version of a \chpl{forall}
loop is used, \chpl{[j in D(2)]}, indicating that
for all \chpl{j in D(2)}, the sum
of the absolute values across the rows, \chpl{+ reduce abs(x[D(1), j])}, is computed. 
Then, the maximum value of these \chpl{j} absolute column sums is computed with
\chpl{max reduce}.  The \chpl{norm2} case, the 2-norm of a matrix, is not
implemented.  This case will halt with a message indicating this unimplemented
status.  The \chpl{normInf} case, the infinity norm of a matrix, is the maximum
absolute row sum.  This norm is computed similarly to the 1-norm, using the maximum
reduction of a chpl{forall} loop, 
\begin{chapel}
max reduce [i in D(1)] (+ reduce abs(x[i, D(2)])).  
\end{chapel}
For all \chpl{i in D(1)}, the sum of the absolute values across columns,
\chpl{+ reduce abs(x[i, D(2)])} is computed.  Then the maximum value of these
\chpl{i} absolute row sums is computed with \chpl{max reduce}.  The \chpl{normFrob}
case which is the Frobenius norm of a matrix, is the same computation as the
2-norm of a vector.  The Frobenius norm is the square root of the sum of the
squares of absolute values of all entries in the matrix.  The final case of
the select statement, the \chpl{otherwise} clause, halts with a message that
the norm type is unexpected.

The third version of the \chpl{norm} function with arguments \chpl{x}
and \chpl{p}, given in lines 31 - 33, is for the case where \chpl{x.rank > 2}.
The module was designed to only compute norms of vectors and matrices.  
Calling the \chpl{norm} function with three-dimensional or higher arrays 
should give an error at compile time.  In this case, an appropriate compiler error 
is given using the \chpl{compilerError} function.  For more information about 
user-defined compiler errors, see~\rsec{User-Defined_Compiler_Errors}.

The fourth and final version of the \chpl{norm} function is given in lines
35 - 41.  This version has one formal argument, \chpl{x}, omitting the norm
type.  It calls the other \chpl{norm} functions with default values for 
\chpl{normType}.  For vectors, the default norm is defined to be the 2-norm.
For matrices, the default norm is defined to be the Frobenius norm.  This 
version of \chpl{norm} is a select statement on \chpl{x.rank}.  When the rank 
is 1, the result of the function call \chpl{norm(x, norm2)} is returned.  
When the rank is 2, the result of the function call \chpl{norm(x, normFrob)}. 
The \chpl{otherwise} clause gives a compiler error.

\subsection{Example: Producer-Consumer}
The following example demonstrates a simple producer and consumer program.
The program contains a \chpl{sync} variable and a \chpl{begin} statement 
in order to implement two concurrent computations, or threads, that execute 
in step with each other.
The new computation that is created with the \chpl{begin} statement will 
be referred to as the {\em consumer computation}.  The continuing computation
will be referred to as the
{\em producer computation}.  Execution control switches between the
producer and consumer computations as the state of the sync variable \chpl{s} 
changes when it is read and written to.  The Chapel code for this example is given below.

\begin{numberedchapel}
use Time;

config var numIterations: int = 5;
config var sleepTime: uint = 2;

var s: sync int;

begin {  // fork consumer computation
  for c in 1..numIterations do
    writeln("consumer got ", s);
}

// producer computation
for p in 1..numIterations {
  sleep(sleepTime);
  s = p;
}
\end{numberedchapel}

The program uses the \chpl{sleep} function in line 15, which is provided in the
standard Chapel module, \chpl{Time}.  So, the first line, \chpl{use Time}, 
is needed to include the \chpl{Time} module when resolving 
function calls in this program.  

Lines three and four give the declarations and initial default values
for the two variables, \chpl{numIterations} and \chpl{sleepTime}.
Both of these variables are 32 bits, the default size of \chpl{int} and \chpl{uint} types.
The \chpl{config} keyword in front of these two variable declarations 
indicates that these are configuration variables.  Configuration variables 
can be set to override their default values at program execution time, through the 
use of command line switches.  For example, to change the number of iterations to 10
and to change the number of seconds to sleep to 5, the following execution command 
may be used:
\begin{verbatim}
> a.out --numIterations=10 --sleepTime=5
\end{verbatim}

In line six, the variable \chpl{s} is declared to be a \chpl{sync} variable 
of type \chpl{int}.  Sync variables have extra state associated with them to 
indicate whether they are logically {\em full} or {\em empty}.  Since \chpl{s}
is not initialized, its state is empty at the beginning of the program's execution.
A sync variable
is intended to be accessed by multiple concurrent computations, each of which may
change the contents and state of the variable.  A sync variable
can be read when its state is full.  Attempts to read an empty sync variable from one
computation will suspend execution until another computation changes its state to full.  
Once a sync variable is able to be read, its state is atomically set to empty.  
Conversely, a sync variable can be written only when its state is empty.  Attempts
to write to a full sync variable will suspend until its state is empty.  Once the variable
is written to, the state is atomically set to full.  Sync variables are useful
to coordinate operations between computations.  In this program, \chpl{s} is used
to synchronize the exchange of data between the producer and consumer computations.

The remainder of the code defines the consumer and producer computations.
The \chpl{begin} statement in line 8 creates a new computation to execute the \chpl{for}
loop in lines 9 and 10.  This loop is indexed by \chpl{c}, which iterates over
the arithmetic sequence \chpl{1..numIterations}.  The variable \chpl{c} is a new
variable defined for the scope of the loop.  Its type is inferred to be integer from
the integer arithmetic sequence that follows.  During each iteration of the \chpl{for}
loop, the \chpl{writeln} function is called which outputs the string
literal \chpl{"consumer got "} and the value of the sync variable \chpl{s}, 
followed by a line break.  In order to print the value stored in \chpl{s}, the
sync variable is read only when its state is full.  Once \chpl{s} is successfully
read, its state will be set to empty.  The next iteration follows, and the 
consumer computations will suspend execution until the state of \chpl{s} is 
made full again.  Since the consumer computation only reads \chpl{s}, it will be 
the producer computation that changes the states of \chpl{s} to full.

The producer computation executes the \chpl{for} loop in lines 14 through 17.  This
loop is indexed by \chpl{p} which iterates over the same arithmetic sequence
as the consumer computation.  Like \chpl{c}, \chpl{p} is inferred to be an integer.
During each iteration of this \chpl{for} loop, the \chpl{sleep} function is
called with the argument\chpl{sleepTime}.  This \chpl{sleep} function is provided
in the \chpl{Time} standard module, and it causes the producer computation to
\chpl{sleepTime} seconds.  After returning from the \chpl{sleep} function, 
the producer computation assigns \chpl{s} to be the iteration number \chpl{p}.  
Because \chpl{s} is a sync variable, this assigment is executed only when the state of 
\chpl{s} is empty.  Once \chpl{s} is written, its state is changed to full and the
next iteration of the producer loop follows.  Since the producer computation only
writes \chpl{s}, it will be the consumer computation that changes the state of
\chpl{s} to empty allowing the next iteration to write its iteration number
to \chpl{s}.

When this program executes, a consumer computation is created with the \chpl{begin}
statement.
However, the consumer computation cannot read \chpl{s} before it has been written
to.  So, execution begins with the producer computation which assigns the value
\chpl{1} to \chpl{s} after calling the sleep function.  Once \chpl{s} has the
value \chpl{1}, the consumer computation can read it and print it.  Execution
switches back and forth between the producer and consumer computation for
\chpl{numIterations}.  

Running the program with the default 
values for \chpl{numIterations} or \chpl{sleepTime} results in: 
\begin{verbatim}
consumer got 1
consumer got 2
consumer got 3
consumer got 4
consumer got 5
\end{verbatim}
Each line is printed after a delay of \chpl{sleepTime} seconds.


\subsection{Example: Generic Stacks}

\subsubsection{Generic Stack with Linked List Implementation}

\begin{numberedchapel}
// A class that is used by the generic stack to implement nodes for a
// linked-list implementation.
class MyNode {
  type itemType;              // type of item
  var item: itemType;         // item in node
  var next: MyNode(itemType); // reference to next node (same type)
}

// A stack class that is generic over the type of data that it
// contains.  The implementation uses a linked list implemented with
// the node class above.
record Stack {
  type itemType;             // type of items
  var top: MyNode(itemType); // top node on stack linked list

  // push method: add an item to the top of the stack
  def push(item: itemType) {
    top = MyNode(itemType, item, top);
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    var oldTop = top;
    top = top.next;
    return oldTop.item;
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return top == nil;
}
\end{numberedchapel}

\subsubsection{Generic Stack with Array Implementation}

\begin{numberedchapel}
// A stack class that is generic over the type of data that it
// contains.  The implementation uses an array to store the elements
// in the stack.
record Stack {
  type itemType;            // type of items
  var numItems: int = 0;    // number of items in the stack
  var data: [1..2] itemType; // array of items

  // push method: add an item to the top of the stack
  // note: the array is doubled if it is full
  def push(item: itemType) {
    var height = data.numElements;
    if numItems == height then
      data.domain = [1..height*2];
    data(numItems+1) = item;
    numItems += 1;
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    numItems -= 1;
    return data(numItems+1);
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return numItems == 0;
}
\end{numberedchapel}
