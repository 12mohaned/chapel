\sekshun{Language Overview}
\label{Language_Overview}

\subsection{Motivating Principles}

\subsection{Getting Started}

Consider the classic first program.  The program file,
\chpl{helloworld.chpl} contains:
\begin{chapel}
def main() {
  writeln("hello, world");
}
\end{chapel}

The syntax of this simple program somewhat resembles C.  There are a
few items to note.
The program contains one module, \chpl{helloworld}, which is implicitly
named from the name of the file.  The keyword \chpl{def} indicates that the
definition of a function follows.

To compile and run this program, execute the following
commands at the system prompt:
\begin{verbatim} 
> chpl helloworld.chpl
> ./a.out
\end{verbatim}
The following output is shown:
\begin{verbatim}
> hello, world
\end{verbatim}

\subsection{Example: Jacobi}

\subsection{Example: Norm}

\subsection{Example: Producer-Consumer}
The following example demonstrates a simple producer and consumer operation.
The program contains a \chpl{sync} variable and a \chpl{begin} statement 
in order to implement two concurrent threads that execute in step with each other.
The consumer thread writes the value of the \chpl{sync} variable \chpl{s} at 
each iteration.  It reads the value of \chpl{s} when it is ready to be read
and leaves it in a state to be written.  The producer thread sleeps for
the indicated amount of time and then assigns \chpl{s} to be the iteration
number.  It writes the iteration number to \chpl{s} when it is ready to be written
and leaves it in a state to be read.  Execution control switches between the
two threads as the state of \chpl{s} changes when it is read and written to.

\begin{numberedchapel}
use Time;

config var numIterations: int = 5;
config var sleepTime: uint = 2;

var s: sync int;

begin {  // fork consumer computation
  for c in 1..numIterations do
    writeln("consumer got ", s);
}

// producer computation
for p in 1..numIterations {
  sleep(sleepTime);
  s = p;
}
\end{numberedchapel}

This program uses the \chpl{sleep} function in line 15, which is provided in the
standard Chapel module, \chpl{Time}.  The first line of the code \chpl{use Time} 
indicates that the \chpl{Time} module is to be used when resolving function calls in 
this program.  

The two variables, \chpl{numIterations} and \chpl{sleepTime}, control
the number of iterations for the loops in the producer and consumer threads
and the amount of time in seconds for the producer thread to sleep each iteration,
respectively.  Lines three and four give the declarations of these variables.
The variable \chpl{numIterations} is declared to be an integer and is initialized
to the default value 5.  The variable \chpl{sleepTime} is declared to be an 
unsigned integer and is initialized to the default value 2.  
Both of these variables are 32 bits, the default size of \chpl{int} and \chpl{uint} types.
The \chpl{config} keyword indicates that these are configuration variable 
declarations.  Configuration variables can be set at run-time, through command 
command line switches.  For example, to change the number of iterations to 10
and to change the number of seconds to sleep to 5, the following execution command 
may be used:
\begin{verbatim}
> a.out --numIterations=10 --sleepTime=5
\end{verbatim}

\subsection{Example: Generic Stacks}

\subsubsection{Generic Stack with Linked List Implementation}

\begin{numberedchapel}
// A class that is used by the generic stack to implement nodes for a
// linked-list implementation.
class MyNode {
  type itemType;              // type of item
  var item: itemType;         // item in node
  var next: MyNode(itemType); // reference to next node (same type)
}

// A stack class that is generic over the type of data that it
// contains.  The implementation uses a linked list implemented with
// the node class above.
record Stack {
  type itemType;             // type of items
  var top: MyNode(itemType); // top node on stack linked list

  // push method: add an item to the top of the stack
  def push(item: itemType) {
    top = MyNode(itemType, item, top);
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    var oldTop = top;
    top = top.next;
    return oldTop.item;
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return top == nil;
}
\end{numberedchapel}

\subsubsection{Generic Stack with Array Implementation}

\begin{numberedchapel}
// A stack class that is generic over the type of data that it
// contains.  The implementation uses an array to store the elements
// in the stack.
record Stack {
  type itemType;            // type of items
  var numItems: int = 0;    // number of items in the stack
  var data: [1..2] itemType; // array of items

  // push method: add an item to the top of the stack
  // note: the array is doubled if it is full
  def push(item: itemType) {
    var height = data.numElements;
    if numItems == height then
      data.domain = [1..height*2];
    data(numItems+1) = item;
    numItems += 1;
  }

  // pop method: remove an item from the top of the stack
  // note: it is a runtime error if the stack is empty
  def pop() {
    if isEmpty? then
      halt("attempt to pop an item off an empty stack");
    numItems -= 1;
    return data(numItems+1);
  }

  // isEmpty? method: true if the stack is empty; otherwise false
  def isEmpty? return numItems == 0;
}
\end{numberedchapel}
