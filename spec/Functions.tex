\sekshun{Procedures}
\label{Procedures}
\index{procedures}
\index{procedures!call site}
\index{call site}
\index{procedures!formal argument}
\index{formal argument}
\index{procedures!actual argument}
\index{actual argument}

A \emph{procedure} is a code abstraction that can be invoked by a call
expression.
A procedure has zero or more \emph{formal arguments}, or simply
\emph{formals}. Upon a procedure call each formal is associated
with the corresponding \emph{actual argument}, or simply
\emph{actual}. Actual arguments are provided as part of the call
expression, or at the the \emph{call site}.
% TODO - move into a footnote?
Direct and indirect recursion is supported.

\index{procedures}
\index{procedures!non-iterator}
\index{procedures!operator}
\index{operators}
%VASS - this paragraph and index entries; also check the above
% emphasize that this chapter is about non-iterator procedures
A \emph{non-iterator procedure} completes and returns to
the call site exactly once, returning no result, a single result, or
multiple results aggregated in a tuple. A procedure can also be an
\emph{iterator}, which can generate, or \emph{yield}, multiple results (in
sequence and/or in parallel). A procedure (either a non-iterator procedure or an
iterator) can be a \emph{method} if it is bound to a type (often a
class). An \emph{operator} in this chapter is a procedure
with a special name that can be invoked using infix notation,
i.e., via a unary or binary expression.
This chapter defines non-iterator, non-method procedures as well as operators. However, most of its contents
apply to iterators and methods as well.

Procedures are presented as follows:
\begin{itemize}
\item non-iterator procedures (this chapter)
\item operators \rsec{Procedure_Definitions}, \rsec{Binary_Expressions}
\item iterators \rsec{Iterators}
\item methods (when bound to a class) \rsec{Class_Methods}
\item procedure calls \rsec{Procedure_Calls}
\item various aspects of defining a procedure
      \rsec{Procedure_Definition_Aspects__Start}--\rsec{Procedure_Definition_Aspects__End}
\item determining the procedure to invoke for a given call site:
      procedure and operator overloading \rsec{Procedure_Overloading},
      procedure resolution \rsec{Procedure_Resolution}
\end{itemize}


\section{Procedure Calls}
\label{Procedure_Calls}
\index{procedure calls}
\index{procedures!calls}

The syntax to call a non-method procedure is given by:
\begin{syntax}
call-expression:
  expression ( named-expression-list )
  expression [ named-expression-list ]
  parenthesesless-procedure-identifier

named-expression-list:
  named-expression
  named-expression , named-expression-list

named-expression:
  expression
  identifier = expression

parenthesesless-procedure-identifier:
  identifier
\end{syntax}


A \sntx{call-expression} is resolved to a particular procedure
according to the algorithm for procedure resolution described
in~\rsec{Procedure_Resolution}.

Procedures can be called using either parentheses or brackets.  The
only difference in the call has to do with promotion and is discussed
in~\rsec{Promotion}.

Procedures that are defined without parentheses must be called without
parentheses as defined by scope resolution.  Procedures without
parentheses are discussed in~\rsec{Procedures_without_Parentheses}.

A \sntx{named-expression} is an expression that may be optionally
named.  It provides
\index{actual argument}
\index{procedures!actual argument}
an actual argument to the procedure being called.
The optional \sntx{identifier} refers to a named formal
argument described in~\rsec{Named_Arguments}.

Calls to methods are defined in Section~\rsec{Class_Method_Calls}.


\section{Procedure Definitions}
\label{Procedure_Definitions}
\label{Procedure_Definition_Aspects__Start}
\index{procedures!declarations, non-iterator non-method}

\index{proc@\chpl{proc}}
Procedures that are not iterators or methods are defined by declarations
with the following syntax:
\begin{syntax}
procedure-declaration-statement:
  `proc' procedure-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT]
    procedure-body

procedure-name:
  identifier
  operator-name


operator-name: one of
  + $ $ $ $ - $ $ $ $ * $ $ $ $ / $ $ $ $ % $ $ $ $ ** $ $ $ $ ! $ $ $ $ == $ $ $ $ != $ $ $ $ <= $ $ $ $ >= $ $ $ $ < $ $ $ $ > $ $ $ $ << $ $ $ $ >> $ $ $ $ & $ $ $ $ | $ $ $ $ ^ $ $ $ $ ~

argument-list:
  ( formals[OPT] )

formals:
  formal
  formal , formals

formal:
  formal-intent[OPT] identifier formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] identifier formal-type[OPT] variable-argument-expression
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] variable-argument-expression

formal-type:
  : type-specifier
  : ? identifier[OPT]

default-expression:
  = expression

variable-argument-expression:
  ... expression
  ... ? identifier[OPT]
  ...

formal-intent: one of
  `in' `out' `inout' `param' `type'

return-intent: one of
  `var' `const' `param' `type'

return-type:
  : type-specifier

where-clause:
  `where' expression

procedure-body:
  block-statement
  return-statement
\end{syntax}

%% This should be in the order that the sections appear in this
%% chapter (if they appear in this chapter).

Procedures do not require parentheses if they have no arguments.  Such
procedures are described in~\rsec{Procedures_without_Parentheses}.

Formal arguments can be grouped together using a tuple notation as
described in~\rsec{Formal_Argument_Declarations_in_a_Tuple}.

Default expressions allow for the omission of actual arguments at the
call site, resulting in the implicit passing of a default value.
Default values are discussed in~\rsec{Default_Values}.

The intents \chpl{in}, \chpl{out}, and \chpl{inout} are discussed
in~\rsec{Intents}.  The intents \chpl{param} and \chpl{type} make
a procedure generic and are discussed in~\rsec{Generic_Procedures}.  If the
formal argument's type is omitted, generic, or prefixed with a question
mark, the procedure is also generic and is discussed
in~\rsec{Generic_Procedures}.

Procedures can take a variable number of arguments.  Such procedures are
discussed in~\rsec{Variable_Length_Argument_Lists}.

The \sntx{return-intent} can be used to indicate
a variable procedure \rsec{Variable_Procedures},
or a parameter procedure \rsec{Parameter_Procedures},
or a type procedure \rsec{Type_Procedures}.
By default, or if the \sntx{return-intent} is \chpl{const},
the procedure returns a value that cannot be used as an lvalue.
% TODO: define lvalue and rvalue
% (see also section{LValue Expressions})

\begin{openissue}
Parameter and type procedures are supported. Parameter and type
iterators are currently not supported.
\end{openissue}

The \sntx{return-type} is optional and is discussed in~\rsec{Return_Types}.
A type procedure may not specify a return type.

The optional \sntx{where-clause} is only applicable if the procedure is
generic.  It is discussed in~\rsec{Where_Expressions}.

Procedure and operator overloading is supported in Chapel and is
discussed in~\rsec{Procedure_Overloading}.
Operator overloading is supported on the operators listed
above (see \sntx{operator-name}).


\section{Procedures without Parentheses}
\label{Procedures_without_Parentheses}
\index{procedures!procedures without parentheses}

Procedures do not require parentheses if they have empty argument
lists.  Procedures declared without parentheses around empty argument
lists must be called without parentheses.

\begin{chapelexample}{procedure-no-parens.chpl}
Given the definitions
\begin{chapel}
proc foo { writeln("In foo"); }
proc bar() { writeln("In bar"); }
\end{chapel}
\begin{chapelpost}
foo;
bar();
\end{chapelpost}
\begin{chapeloutput}
In foo
In bar
\end{chapeloutput}
the procedure \chpl{foo} can be called by writing \chpl{foo} and the
procedure \chpl{bar} can be called by writing \chpl{bar()}.  It is an
error to use parentheses when calling \chpl{foo} or omit them
when calling \chpl{bar}.
\end{chapelexample}


\section{Formal Arguments}
\label{Formal_Arguments}
\index{formal argument}
\index{procedures!formal argument}

Chapel supports an intuitive formal argument passing mechanism.  An
actual argument is passed by value unless it is an array or domain, in
which case it is passed by reference.

Intents~(\rsec{Intents}) may be used to override the default
argument passing mechanism.  This may result in assignments to and from
the formal argument during a procedure call.  For example, when passing an array by
intent \chpl{in}, the actual argument array will be copied into the formal argument
for use within the procedure.

\subsection{Named Arguments}
\label{Named_Arguments}
\index{named arguments}
\index{procedures!named arguments}
\index{formal arguments!naming}

A formal argument can be named at the call site to explicitly map an
actual argument to a formal argument.

\begin{chapelexample}{named-args.chpl}
In the code
\begin{chapel}
proc foo(x: int, y: int) { writeln(x); writeln(y); }

foo(x=2, y=3);
foo(y=3, x=2);
\end{chapel}
\begin{chapeloutput}
2
3
2
3
\end{chapeloutput}
named argument passing is used to map the actual arguments to the
formal arguments.  The two procedure calls are equivalent.
\end{chapelexample}

Named arguments are sometimes necessary to disambiguate calls or
ignore arguments with default values.  For a procedure that has many
arguments, it is sometimes good practice to name the arguments at the
call site for compiler-checked documentation.

\subsection{Default Values}
\label{Default_Values}
\index{default values}
\index{procedures!default argument values}
\index{formal arguments!defaults}

Default values can be specified for a formal argument by appending the
assignment operator and a default expression to the declaration of the
formal argument.  If the actual argument is omitted from the procedure
call, the default expression is evaluated when the procedure call is
made and the evaluated result is passed to the formal argument as if
it were passed from the call site.

\begin{chapelexample}{default-values.chpl}
In the code
\begin{chapel}
proc foo(x: int = 5, y: int = 7) { writeln(x); writeln(y); }

foo();
foo(7);
foo(y=5);
\end{chapel}
\begin{chapeloutput}
5
7
7
7
5
5
\end{chapeloutput}
default values are specified for the formal arguments \chpl{x}
and \chpl{y}.  The three calls to \chpl{foo} are equivalent to the
following three calls where the actual arguments are
explicit: \chpl{foo(5, 7)}, \chpl{foo(7, 7)}, and \chpl{foo(5, 5)}.
The example \chpl{foo(y=5)} shows how to use a named argument
for \chpl{y} in order to use the default value for \chpl{x} in the
case when \chpl{x} appears earlier than \chpl{y} in the formal
argument list.
\end{chapelexample}


\section{Intents}
\label{Intents}
\index{intents}
\index{procedures!argument intents}

Intents allow the actual arguments to be copied to a formal argument
and also to be copied back.

\subsection{The Blank Intent}
\label{The_Blank_Intent}
\index{intents!blank}

If the intent is omitted, it is called a blank intent.  In such a
case, the value is copied from the actual to the formal.  Thus
class instances are passed by reference and records are passed by value.
Furthermore, a formal that has blank intent
cannot be assigned within the procedure.

The exception to this rule is made for formals of array, domain, \chpl{sync},
and \chpl{single} types. Arguments of these types are passed by reference
and can be modified within the procedure.

\subsection{The In Intent}
\label{The_In_Intent}
\index{in@\chpl{in}}
\index{intents!in@\chpl{in}}

If \chpl{in} is specified as the intent, the actual argument is copied
to the formal argument by value.
The formal may also be assigned to within
the procedure.  This assignment is not reflected back at the call site.

If an array is passed to a formal argument that has \chpl{in} intent,
a copy of the array is made.  Changes to the elements
within the array formal are thus not reflected back at the call site.

\subsection{The Out Intent}
\label{The_Out_Intent}
\index{out@\chpl{out}}
\index{intents!out@\chpl{out}}

If \chpl{out} is specified as the intent, the actual argument is
ignored when the call is made, but after the call, the formal argument
is assigned to the actual argument at the call site.  The actual
argument must be a valid lvalue.  The formal argument can be assigned
to and read from within the procedure.

The formal argument cannot not be generic and is treated as a variable
declaration. It is initialized to the default value for its type,
unless it has a default expression.

\subsection{The Inout Intent}
\label{The_Inout_Intent}
\index{inout@\chpl{inout}}
\index{intents!inout@\chpl{inout}}

If \chpl{inout} is specified as the intent, the actual argument is
both passed to the formal argument as if the \chpl{in} intent applied
and then copied back as if the \chpl{out} intent applied.  The formal
argument can be generic and takes its type from the actual argument.
The formal argument can be assigned to and read from within the
procedure.


\section{Variable Number of Arguments}
\label{Variable_Length_Argument_Lists}
\index{procedures!variable number of arguments}

Procedures can be defined to take a variable number of arguments
by using a variable argument expression for a formal argument.
That formal can have any intent; it can be a type argument
but cannot be a parameter argument.
This allows the call site to
pass a different number of actual arguments.  There must be at least
one actual argument corresponding to a variable-argument-expression formal.

If the variable argument expression contains an identifier prepended by a
question mark, the number of actual arguments can vary, and the identifier
will be bound to an integer parameter value indicating the number of
arguments at a given call site.
If the variable argument expression contains an expression without
a question mark, that expression must evaluate to an integer parameter value
requiring the call site to pass that number of arguments to the
procedure.

Within the procedure, the value of a formal argument that is marked with a
variable argument expression is a tuple of the values of the actual arguments.

\begin{chapelexample}{varargs.chpl}
The code
\begin{chapel}
proc mywriteln(x ...?k) {
  for param i in 1..k do
    writeln(x(i));
}
\end{chapel}
\begin{chapelpost}
mywriteln("hi", "there");
mywriteln(1, 2.0, 3, 4.0);
\end{chapelpost}
\begin{chapeloutput}
hi
there
1
2.0
3
4.0
\end{chapeloutput}
defines a generic procedure called \chpl{mywriteln} that takes a
variable number of arguments of any type and then writes them out on
separate lines.  The parameter for-loop~(\rsec{Parameter_For_Loops})
is unrolled by the compiler so that \chpl{i} is a parameter, rather
than a variable.  This needs to be a parameter for-loop because the
expression \chpl{x(i)} will have a different type on each iteration.
The type of \chpl{x} can be specified in the formal argument list to
ensure that the actuals all have the same type.
\end{chapelexample}

\begin{chapelexample}{varargs-with-type.chpl}
Either or both the number of variable arguments and their types can be
specified.  For example, a basic procedure to sum the values of three
integers can be wrtten as
\begin{chapel}
proc sum(x: int...3) return x(1) + x(2) + x(3);
\end{chapel}
\begin{chapelpost}
writeln(sum(1, 2, 3));
writeln(sum(-1, -2, -3));
\end{chapelpost}
\begin{chapeloutput}
6
-6
\end{chapeloutput}
Specifying the type is useful if it is important that each argument
have the same type.  Specifying the number is useful in, for example,
defining a method on a class that is instantiated over a rank
parameter.
\end{chapelexample}

\begin{chapelexample}{varargs-returns-tuples.chpl}
The code
\begin{chapel}
proc tuple(x ...) return x;
\end{chapel}
\begin{chapelpost}
writeln(tuple(1));
writeln(tuple("hi", "there"));
writeln(tuple(tuple(1, 2), tuple(3, 4)));
\end{chapelpost}
\begin{chapeloutput}
(1)
(hi, there)
((1, 2), (3, 4))
\end{chapeloutput}
defines a generic procedure that returns tuples.  When passed two or
more actuals in a call, it is equivalent to building a tuple so the
expressions \chpl{tuple(1, 2)} and \chpl{(1, 2)} are equivalent.  When
passed one actual, it builds a 1-tuple which is different than the
evaluation of the parenthesized expression.  Thus the
expressions \chpl{tuple(1)} and \chpl{(1)} are not equivalent.
\end{chapelexample}


\section{Variable Procedures}
\label{Variable_Procedures}
\index{procedures!variable procedures}
\index{procedures!as lvalues}

A variable procedure is a procedure whose call is an lvalue
(specifically, a call expression for a non-iterator procedure and
an iterator variable for an iterator).
This implies that a variable procedure produces a reference;
however, this
reference cannot be captured.

A variable procedure is specified by following the argument list with
the \chpl{var} keyword.  A variable procedure must return or yield an lvalue.

When a variable non-iterator procedure is called on the left-hand side of an
assignment statement or in the context of a call to a formal argument
by out or inout intent, the lvalue that is returned by the procedure is
assigned a value.

Variable procedures provide an implicit param formal argument \chpl{setter}
of type \chpl{bool}.  If the
variable procedure is called in a context requiring an lvalue,
the actual argument for \chpl{setter} is implicitly \chpl{true};
otherwise it is \chpl{false}.  This argument is useful for adjusting
the behavior depending to the calling context.

\begin{chapelexample}{variable-procedures.chpl}
The following code defines a procedure that can be interpreted as a
simple two-element array where the elements are actually global
variables:
\begin{chapel}
var x, y = 0;

proc A(i: int) var {
  if i < 0 || i > 1 then
    halt("array access out of bounds");
  if i == 0 then
    return x;
  else
    return y;
}
\end{chapel}
Calls to this procedure can be assigned to in order to write to the ``elements''
of the array as in
\begin{chapel}
A(0) = 1;
A(1) = 2;
\end{chapel}
It can be called as an expression to access the ``elements'' as in
\begin{chapel}
writeln(A(0) + A(1));
\end{chapel}
This code outputs the number \chpl{3}.

\index{setter}
\index{procedures!setter argument}
The implicit \chpl{setter} argument can be used to ensure, for
example, that the second element in the pseudo-array is only assigned
a value if the first argument is positive.  To do this, add the
following:
\begin{chapelnoprint}
proc A2(i: int) var { // } to fool latex
  if i < 0 || i > 1 then
    halt("array access out of bounds");
\end{chapelnoprint}
\begin{chapel}
if setter && i == 1 && x <= 0 then
  halt("cannot assign value to A(1) if A(0) <= 0");
\end{chapel}
\begin{chapelpost}
// { to fool latex
  if i == 0 then
    return x;
  else
    return y;
}
A2(0) = 0;
A2(1) = 1;
\end{chapelpost}
\begin{chapeloutput}
3
variable-procedures.chpl:18: error: halt reached - cannot assign value to A(1) if A(0) <= 0
\end{chapeloutput}
\end{chapelexample}


\section{Parameter Procedures}
\label{Parameter_Procedures}
\index{procedures!as parameters}
\index{procedures!parameter procedure}
\index{parameter procedure}

A \emph{parameter procedure}, or a \emph{param procedure}, is a procedure that returns a parameter
expression.  It is specified by following the procedure's argument list
by the keyword \chpl{param}.  It is often, but not necessarily,
generic.

It is a compile-time error if a parameter procedure does not return a
parameter expression.  The result of a parameter procedure is computed
during compilation and substituted for the call expression.

\begin{chapelexample}{param-procedures.chpl}
In the code
\begin{chapel}
proc sumOfSquares(param a: int, param b: int) param
  return a**2 + b**2;

var x: sumOfSquares(2, 3)*int;
\end{chapel}
\begin{chapelpost}
writeln(x);
\end{chapelpost}
\begin{chapeloutput}
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
\end{chapeloutput}
\chpl{sumOfSquares} is a parameter procedure that takes
two parameters as arguments.  Calls to this procedure can be used in
places where a parameter expression is required.  In this example, the
call is used in the declaration of a homogeneous tuple and so is
required to be a parameter.
\end{chapelexample}

Parameter procedures may not contain control flow that is not resolved
at compile-time.  This includes loops other than the parameter for
loop~\rsec{Parameter_For_Loops} and conditionals with a conditional
expressions that is not a parameter.


\section{Type Procedures}
\label{Type_Procedures}
\index{procedures!as types}

A \emph{type procedure} is a procedure that returns a type, not a value.  It is specified by
following the procedure's argument list by the keyword \chpl{type}, without the subsequent return type.  It
is often, but not necessarily, generic.

It is a compile-time error if a type procedure does not return a type.
The result of a type procedure is computed during compilation.

As with parameter procedures, type procedures may not contain control
flow that is not resolved at compile-time.  This includes loops other
than the parameter for loop~\rsec{Parameter_For_Loops} and
conditionals with a conditional expression that is not a parameter.

\begin{chapelexample}{type-procedures.chpl}
In the code
\begin{chapel}
proc myType(x) type {
  if numBits(x.type) <= 32 then return int;
  else return int(64);
}
\end{chapel}
\begin{chapelpost}
var a = 4,
    b = 4.0;
var at: myType(a),
    bt: myType(b);
writeln((numBits(at.type), numBits(bt.type)));
\end{chapelpost}
\begin{chapeloutput}
(32, 64)
\end{chapeloutput}
\chpl{myType} is a type procedure that takes a single
argument \chpl{x} and returns \chpl{int} if the number of bits used to
represent \chpl{x} is less than or equal to 32, otherwise it
returns \chpl{int(64)}.  \chpl{numBits} is a param
procedure defined in the Types module~(\rsec{Types_standard_module}).
\end{chapelexample}


\section{The Return Statement}
\label{The_Return_Statement}
\index{return@\chpl{return}}

The return statement can only appear in a procedure.  It exits that
procedure, returning control to the point at which that procedure was
called.  A return statement in a non-iterator procedure whose
return type is not void must include an expression.
That expression indicates the value to be returned,
i.e., the value that becomes the value of the invoking call expression.
Return statements in non-iterator procedures whose return type is void
and return statements in iterators may not include an expression.

The syntax of the return statement is given by
\begin{syntax}
return-statement:
  `return' expression[OPT] ;
\end{syntax}

\begin{chapelexample}{return.chpl}
The following code defines a procedure that returns the sum of three
integers:
\begin{chapel}
proc sum(i1: int, i2: int, i3: int)
  return i1 + i2 + i3;
\end{chapel}
\begin{chapelpost}
writeln(sum(1, 2, 3));
\end{chapelpost}
\begin{chapeloutput}
6
\end{chapeloutput}
\end{chapelexample}


\section{Return Types}
\label{Return_Types}
\index{return@\chpl{return}!type}
\index{procedures!return types}

A non-iterator procedure can optionally return a value.  If the procedure does not
return a value, its return type is \chpl{void}.  Specifying the return
type in a procedure declaration is optional.

\subsection{Explicit Return Types}
\label{Explicit_Return_Types}
\index{explicit return type}

If a return type is specified and is not \chpl{void}, the values that the non-iterator procedure returns
via return statements must be assignable to a variable of the return
type.  For variable procedures~(\rsec{Variable_Procedures}), the return
type must match the type returned in all of the return statements
exactly, when checked after generic instantiation and parameter folding
(if applicable).

\subsection{Implicit Return Types}
\label{Implicit_Return_Types}
\index{type inference!of return types}
\index{implicit return type}

If a return type is not specified, it will be inferred from the return
statements.  Given the types that are returned by the different
statements, if exactly one of those types can be a target, via
implicit conversions, of every other type, then that is the inferred
return type.  Otherwise, it is an error.  For variable
procedures~(\rsec{Variable_Procedures}), every return statement must
return the same exact type and it becomes the inferred type.
For non-iterator procedures without any return statements, the return type is \chpl{void}.


\section{Nested Procedures}
\label{Nested_Procedures}
\label{Procedure_Definition_Aspects__End}
\index{procedures!nested}
\index{nested procedure}

A procedure defined in another procedure is called a nested procedure.
Nesting of procedures may be done to arbitrary degrees, i.e., a
procedure can be nested in a nested procedure.

Nested procedures are only visible to procedure calls within the lexical scope
in which they are defined.

Nested procedures may refer to variables defined in the procedure(s) in
which they are nested.


\section{Procedure and Operator Overloading}
\label{Procedure_Overloading}
\index{procedures!overloading}
\index{operators!overloading}
\index{procedure overloading}
\index{operator overloading}

Procedures that have the same name but different argument lists are
called overloaded procedures.  Procedure calls to overloaded procedures
are resolved according to the procedure resolution algorithm in~\rsec{Procedure_Resolution}.

Operator overloading is achieved by defining a procedure with a name
specified by that operator.  The operators that may be overloaded are
listed in the following table:

\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf arity} & {\bf operators} \\
\hline
unary & \verb@+ - ! ~@ \\
binary & \verb@+ - * / % ** ! == <= >= < > << >> & | ^ @ by\\
\hline
\end{tabular}
\end{center}

The arity and precedence of the operator must be maintained when it is
overloaded.  Operator resolution follows the same algorithm as
procedure resolution.


\section{Procedure Resolution}
\label{Procedure_Resolution}
\index{procedure resolution}
\index{procedures!resolution}

\emph{Procedure resolution} is the algorithm that determines
which procedure to invoke for a given call expression.
Procedure resolution is defined as follows.
\begin{itemize}
\item
Identify the set of visible procedures for the procedure call.  A
\emph{visible procedure} is any procedure that satisfies the criteria
in~\rsec{Determining_Visible_Procedures}.  If no visible procedure can
be found, the compiler will issue an error stating that the call
cannot be resolved.
\item
From the set of visible procedures for the procedure call, determine the
set of candidate procedures for the procedure call.  A \emph{candidate
procedure} is any procedure that satisfies the criteria
in~\rsec{Determining_Candidate_Procedures}.  If no candidate procedure
can be found, the compiler will issue an error stating that the call
cannot be resolved.  If exactly one candidate procedure is found, this
is determined to be the procedure.
\index{procedures!resolution!most specific}
\item
From the set of candidate procedures, the most specific procedure is
determined.  The most specific procedure is a candidate procedure that
is \emph{more specific} than every other candidate procedure as defined
in~\rsec{Determining_More_Specific_Procedures}.  If there is no
procedure that is more specific than every other candidate procedure,
the compiler will issue an error stating that the call is ambiguous.
\end{itemize}

\subsection{Determining Visible Procedures}
\label{Determining_Visible_Procedures}
\index{procedures!resolution!visible}
\index{procedures!visible}

Given a procedure call, a procedure is determined to be a \emph{visible
procedure} if the name of the procedure is the same as the name of the
procedure call and the procedure is defined in the same scope as the
procedure call or a lexical outer scope of the procedure call, or if the
procedure is defined in a module that is used from the same scope as
the procedure call or a lexical outer scope of the procedure call.
Procedure visibility in generic procedures is discussed
in~\rsec{Procedure_Visibility_in_Generic_Procedures}.

\subsection{Determining Candidate Procedures}
\label{Determining_Candidate_Procedures}
\index{procedures!resolution!candidates}

Given a procedure call, a procedure is determined to be
a \emph{candidate procedure} if there is a \emph{valid mapping} from
the procedure call to the procedure and each actual argument is mapped
to a formal argument that is a \emph{legal argument mapping}.

\subsubsection{Valid Mapping}
\label{Valid_Mapping}

The following algorithm determines a valid mapping from a procedure
call to a procedure if one exists:
\begin{itemize}
\item
Each actual argument that is passed by name is matched to the formal
argument with that name.  If there is no formal argument with that
name, there is no valid mapping.
\item
The remaining actual arguments are mapped in order to the remaining
formal arguments in order.  If there are more actual arguments then
formal arguments, there is no valid mapping.  If any formal argument
that is not mapped to by an actual argument does not have a default
value, there is no valid mapping.
\item
The valid mapping is the mapping of actual arguments to formal
arguments plus default values to formal arguments that are not mapped
to by actual arguments.
\end{itemize}

\subsubsection{Legal Argument Mapping}

An actual argument of type $T_A$ can be mapped to a formal argument of
type $T_F$ if any of the following conditions hold:
\begin{itemize}
\item $T_A$ and $T_F$ are the same type.
\item There is an implicit coercion from $T_A$ to $T_F$.
\item $T_A$ is derived from $T_F$.
\item $T_A$ is scalar promotable to $T_F$.
\end{itemize}

\subsection{Determining More Specific Procedures}
\label{Determining_More_Specific_Procedures}
\index{procedures!resolution!more specific}

Given two procedures $P_1$ and $P_2$, the more specific procedure is
determined by the following steps:
\begin{itemize}
\item If $P_1$ does not require promotion and $P_2$ does require promotion, then $P_1$ is more specific.
\item If $P_2$ does not require promotion and $P_1$ does require promotion, then $P_2$ is more specific.
\item
If at least one of the legal argument mappings to $P_1$ is a {\em more
specific argument mapping} than the corresponding legal argument
mapping to $P_2$ and none of the legal argument mappings to $P_2$ is a
more specific argument mapping than the corresponding legal argument
mapping to $P_1$, then $P_1$ is more specific.
\item
If at least one of the legal argument mappings to $P_2$ is a {\em more
specific argument mapping} than the corresponding legal argument
mapping to $P_1$ and none of the legal argument mappings to $P_1$ is a
more specific argument mapping than the corresponding legal argument
mapping to $P_2$, then $P_2$ is more specific.
\item If $P_1$ shadows $P_2$, then $P_1$ is more specific.
\item If $P_2$ shadows $P_1$, then $P_2$ is more specific.
\item If $P_1$ has a where clause and $P_2$ does not have a where clause, then $P_1$ is more specific.
\item If $P_2$ has a where clause and $P_1$ does not have a where clause, then $P_2$ is more specific.
\item Otherwise neither procedure is more specific.
\end{itemize}

Given an argument mapping, $M_1$, from an actual argument, $A$, of
type $T_A$ to a formal argument, $F1$, of type $T_{F1}$ and an
argument mapping, $M_2$, from the same actual argument to a formal
argument, $F2$, of type $T_{F2}$, the more specific argument mapping
is determined by the following steps:
\begin{itemize}
\item
 If $T_{F1}$ and $T_{F2}$ are the same type, $F1$ is an instantiated
 parameter, and $F2$ is not an instantiated parameter, $M_1$ is more
 specific.
\item
 If $T_{F1}$ and $T_{F2}$ are the same type, $F2$ is an instantiated
 parameter, and $F1$ is not an instantiated parameter, $M_2$ is more
 specific.
\item
 If $M_1$ does not require scalar promotion and $M_2$ requires scalar
 promotion, $M_1$ is more specific.
\item
 If $M_1$ requires scalar promotion and $M_2$ does not require scalar
 promotion, $M_2$ is more specific.
\item
 If $T_{F1}$ and $T_{F2}$ are the same type, $F1$ is generic, and $F2$
 is not generic, $M_1$ is more specific.
\item
 If $T_{F1}$ and $T_{F2}$ are the same type, $F2$ is generic, and $F1$
 is not generic, $M_2$ is more specific.
\item
 If $F1$ is not generic over all types and $F2$ is generic over all
 types, $M_1$ is more specific.
\item
 If $F1$ is generic over all types and $F2$ is not generic over all
 types, $M_2$ is more specific.
\item
 If $T_A$ and $T_{F1}$ are the same type and $T_A$ and $T_{F2}$ are
 not the same type, $M_1$ is more specific.
\item
 If $T_A$ and $T_{F1}$ are not the same type and $T_A$ and $T_{F2}$
 are the same type, $M_2$ is more specific.
\item
 If $T_{F1}$ is derived from $T_{F2}$, then $M_1$ is more specific.
\item
 If $T_{F2}$ is derived from $T_{F1}$, then $M_2$ is more specific.
\item
 If there is an implicit coercion from $T_{F1}$ to $T_{F2}$, then
 $M_1$ is more specific.
\item
 If there is an implicit coercion from $T_{F2}$ to $T_{F1}$, then
 $M_2$ is more specific.
\item
 If $T_{F1}$ is any \chpl{int} type and $T_{F2}$ is any \chpl{uint}
 type, $M_1$ is more specific.
\item
 If $T_{F2}$ is any \chpl{int} type and $T_{F1}$ is any \chpl{uint}
 type, $M_2$ is more specific.
\item
 Otherwise neither mapping is more specific.
\end{itemize}
