\sekshun{Functions}
\label{Functions}
\index{functions}

This section defines functions.  Methods and iterators are functions
and most of this section applies to them as well.  They are defined
separately in~\rsec{Iterators} and~\rsec{Class_Methods}.

\subsection{Function Definitions}
\label{Function_Definitions}
\index{functions!syntax}

\index{def@\chpl{def}}
Functions are declared with the following syntax:
\begin{syntax}
function-declaration-statement:
  `def' function-name argument-list var-clause[OPT]
    return-type[OPT] where-clause[OPT] block-level-statement

function-name:
  identifier
  = identifier
  operator-name

operator-name: one of
  + - * / % ** && || ! == <= >= < > << >> & | ^ ~ #

argument-list:
  ( formals[OPT] )

formals:
  formal
  formal , formals

formal:
  formal-tag identifier formal-type[OPT] default-expression[OPT]
  formal-tag identifier formal-type[OPT] variable-argument-expression

formal-type:
  : type
  : TQUESTION identifier

default-expression:
  = expression

variable-argument-expression:
  ... expression
  ... TQUESTION identifier

formal-tag: one of
  in out inout param type

var-clause:
  `var'

where-clause:
  `where' expression
\end{syntax}

Operator overloading is supported in Chapel on the operators listed
above under operator name.  Operator and function overloading is
discussed in~\rsec{Function_Overloading}.

The intents \chpl{in}, \chpl{out}, and \chpl{inout} are discussed
in~\rsec{Intents}.  The formal tags \chpl{param} and \chpl{type} make
a function generic and are discussed in~\rsec{Generics}.  If the
formal argument's type is elided, generic, or prefixed with a question
mark, the function is also generic and is discussed
in~\rsec{Generics}.

Default expressions allow for the omission of actual arguments at the
call site, resulting in the implicit passing of a default value.
Default values are discussed in~\rsec{Default_Values}.

Functions can take a variable number of arguments.  Such functions are
discussed in~\rsec{Variable_Length_Argument_Lists}.

The optional var clause defines a variable function discussed
in~\rsec{Variable_Functions}.  A variable setter function can be
defined explicitly by prefixing the function's name with the
assignment operator.  This type of variable function is discussed
in~\rsec{Explicit_Setter_Functions}.

The optional where clause is only applicable if the function is
generic.  It is discussed in~\rsec{Where_Expressions}.

\subsection{The Return Statement}
\label{The_Return_Statement}
\index{return@\chpl{return}}

The return statement must appear in a function.  It exits that
function, returning control to the point at which that function was
called.  It can optionally return a value.  The syntax of the return
statement is given by
\begin{syntax}
return-statement:
  `return' expression[OPT] ;
\end{syntax}

\begin{example}
The following code defines a function that returns the sum of three
integers:
\begin{chapel}
def sum(i1: int, i2: int, i3: int)
  return i1 + i2 + i3;
\end{chapel}
\end{example}

\subsection{Function Calls}
\label{Function_Calls}
\index{function calls}

Functions are called in call expressions described
in~\rsec{Call_Expressions}.  The function that is called is resolved
according to the algorithm described in~\rsec{Function_Resolution}.

\subsection{Formal Arguments}
\label{Formal_Arguments}
\index{formal arguments}

Chapel supports an intuitive formal argument passing mechanism.  An
argument is passed by value unless it is a class, array, or domain in
which case it is passed by reference.

Intents~(\rsec{Intents}) result in potential assignments to temporary
variables during a function call.

\subsubsection{Named Arguments}
\label{Named_Arguments}
\index{named arguments}
\index{formal arguments!naming}

A formal argument can be named at the call site to explicitly map an
actual argument to a formal argument.

\begin{example}
In the code
\begin{chapel}
def foo(x: int, y: int) { ... }

foo(x=2, y=3);
foo(y=3, x=2);
\end{chapel}
named argument passing is used to map the actual arguments to the
formal arguments.  The two function calls are equivalent.
\end{example}

Named arguments are sometimes necessary to disambiguate calls or
ignore arguments with default values.  For a function that has many
arguments, it is sometimes good practice to name the arguments at the
callsite for compiler-checked documentation.

\subsubsection{Default Values}
\label{Default_Values}
\index{default values}
\index{formal arguments!defaults}

Default values can be specified for a formal argument by appending the
assignment operator and a default expression the declaration of the
formal argument.  If the actual argument is omitted from the function
call, the default expression is evaluated when the function call is
made and the evaluated result is passed to the formal argument as if
it were passed from the call site.

\begin{example}
In the code
\begin{chapel}
def foo(x: int = 5, y: int = 7) { ... }

foo();
foo(7);
foo(y=5);
\end{chapel}
default values are specified for the formal arguments \chpl{x}
and \chpl{y}.  The three calls to \chpl{foo} are equivalent to the
following three calls where the actual arguments are
explicit: \chpl{foo(5, 7)}, \chpl{foo(7, 7)}, and \chpl{foo(5, 5)}.
Note that named arguments are necessary to pass actual arguments to
formal arguments but use default values for arguments that are
specified earlier in the formal argument list.
\end{example}

\subsection{Intents}
\label{Intents}
\index{intents}

Intents allow the actual arguments to be copied to a formal argument
and also to be copied back.

\subsubsection{The Blank Intent}
\label{The_Blank_Intent}

If the intent is omitted, it is called a blank intent.  In such a
case, the value is copied in using the assignment operator.  Thus
classes are passed by reference and records are passed by value.
Arrays and domains are an exception because assignment does not apply
from the actual to the formal.  Instead, arrays and domains are passed
by reference.

With the exception of arrays, any argument that has blank intent
cannot be assigned within the function.

\subsubsection{The In Intent}
\label{The_In_Intent}
\index{in@\chpl{in}}

If \chpl{in} is specified as the intent, the actual argument is copied
to the formal argument as usual, but it may also be assigned to within
the function.  This assignment is not reflected back at the call site.

If an array is passed to a formal argument that has \chpl{in} intent,
a copy of the array is made via assignment.  Changes to the elements
within the array are thus not reflected back at the call site.
Domains cannot be passed to a function via the \chpl{in} intent.

\subsubsection{The Out Intent}
\label{The_Out_Intent}
\index{out@\chpl{out}}

If \chpl{out} is specified as the intent, the actual argument is
ignored when the call is made, but after the call, the formal argument
is assigned to the actual argument at the call site.  The actual
argument must be a valid lvalue.

The formal argument cannot not be generic and is treated as a variable
declaration.  Domains cannot be passed to a function via
the \chpl{out} intent.

\subsubsection{The Inout Intent}
\label{The_Inout_Intent}
\index{inout@\chpl{inout}}

If \chpl{inout} is specified as the intent, the actual argument is
both passed to the formal argument as if the \chpl{in} intent applied
and then copied back as if the \chpl{out} intent applied.  The formal
argument can be generic and takes its type from the actual argument.
Domains cannot be passed to a function via the \chpl{inout} intent.

\subsection{Variable Functions}
\label{Variable_Functions}
\index{functions!as lvalues}

A variable function is a function that can be assigned a value.  Note
that a variable function does not return a reference.  That is, the
reference cannot be captured.

A variable function is specified by following the argument list with
the \chpl{var} keyword.  A variable function must return an expression
that can be assigned.

When a variable function is called on the left-hand side of an
assignment statement, the expression that is normally returned is
instead assigned the result of the expression on the right-hand side
of the assignment statement.  Note that the right-hand side expression
is evaluated before the variable function is called.  Otherwise a
variable function evaluates normally and returns the result of the
expression that it returns.

\begin{example}
The following code creates a function that can be interpreted as a
simple two-element array where the elements are actually global
variables:
\begin{chapel}
var x, y = 0;

def A(i: int) var {
  if i < 0 || i > 1 then
    halt("array access out of bounds");
  return if i == 0 then x else y;
}
\end{chapel}
This function can be assigned to in order to write to the ``elements''
of the array as in
\begin{chapel}
A(0) = 1;
A(1) = 2;
\end{chapel}
It can be called as an expression to access the ``elements'' as in
\begin{chapel}
writeln(A(0) + A(1));
\end{chapel}
This code outputs the number \chpl{3}.
\end{example}

\subsubsection{Explicit Setter Functions}
\label{Explicit_Setter_Functions}
\index{functions!setters}
\index{functions!as lvalues}

Variable functions can be created by overloading a normal function
with an explicit setter function.  Alternatively, an explicit setter
function can be defined without a normal counterpart to create a
function that can only be assigned values.

An explicit setter function is defined by prepending the assignment
operator to the function name.  Setter functions can only be called
from the left-hand side of an assignment statement.

Setter functions require an extra formal argument (that must be the
last argument).  This argument is passed the value on the right-hand
side of the assignment statement.

\begin{example}
The following code defines a function \chpl{A} and a setter
function \chpl{A}.  These two definitions of \chpl{A} are equivalent
to the one definition in the previous section.
\begin{chapel}
var x, y = 0;

def A(i: int) {
  if i < 0 || i > 1 then
    halt("array access out of bounds");
  return if i == 0 then x else y;
}

def =A(i: int, value: int) {
  if i < 0 || i > 1 then
    halt("array access out of bounds");
  (if i == 0 then x else y) = value;
}
\end{chapel}
This code has the extra constraint that the expression on the
right-hand side of the assignment statement needs to be able to be
passed to an argument of type \chpl{int}.  For type \chpl{int}, the
constraints between assignment and argument passing are the same, so
these functions are equivalent to in the previous section.

In the variable function, there is no type constraint on the
expression other than any constraint placed on it by the assignment
statement.  The equivalent setter function would be generic in respect
to the last argument.
\end{example}

\subsection{Function Overloading}
\label{Function_Overloading}
\index{functions!overloading}
\index{operators!overloading}

Functions that have the same name but different argument lists are
called overloaded functions.  Function calls to overloaded functions
are resolved according to the algorithm in~\rsec{Function_Resolution}.

Operator overloading is achieved by defining a function with a name
specified by that operator.  The operators that may be overloaded are
listed in the following table:

\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf arity} & {\bf operators} \\
\hline
unary & \verb@+ - ! ~@ \\
binary & \verb@+ - * / % ** && || ! == <= >= < > << >> & | ^ #@ \\
\hline
\end{tabular}
\end{center}

The arity and precedence of the operator must be maintained when it is
overloaded.  Operator resolution follows the same algorithm as
function resolution.

\subsection{Function Resolution}
\label{Function_Resolution}

Given a function call, the function that the call resolves to is
determined according to the following algorithm:
\begin{itemize}
\item
Identify the set of visible functions.  A visible function is any
function with the same name that satisfies the criteria
in~\rsec{Identifying_Visible_Functions}.
\item
From the set of visible functions, determine the set of candidate
functions.  A function is a candidate if the function is a valid
application of the function call's actual arguments as determined
in~\rsec{Determining_Candidate_Functions}.  A compiler error occurs if
there are no candidate functions,
\item
From the set of candidate functions, the most specific function is
determined.  The most specific function is a candidate function that
is more specific than every other candidate function.  If there is no
function that is more specific than every other candidate function,
the function call is ambiguous and a compiler error occurs.  The term
{\em more specific function} is defined
in~\rsec{Determining_More_Specific_Functions}.
\end{itemize}.

\subsubsection{Identifying Visible Functions}
\label{Identifying_Visible_Functions}
\index{functions!visibile}

A function is a visible function to a function call if the name of the
function is the same as the name of the function call and the function
is defined or used in a lexical outer scope.

\index{functions!with class arguments}
Additionally, functions that have arguments of class type are
considered globally visible and so are always visible regardless of
the location of their definition.

\subsubsection{Determining Candidate Functions}
\label{Determining_Candidate_Functions}
\index{functions!candidates}

A function is a candidate function if there is a {\em valid mapping}
from the function call to the function and each actual argument is
mapped to a formal argument that is a {\em legal argument mapping}.

\paragraph{Valid Mapping}

A function call is mapped to a function according to the following
steps:
\begin{itemize}
\item
Each actual argument that is passed by name is matched to the formal
argument with that name.  If there is no formal argument with that
name, there is no valid mapping.
\item
The remaining actual arguments are mapped in order to the remaining
formal arguments in order.  If there are more actual arguments then
formal arguments, there is no valid mapping.  If any formal argument
that is not mapped to by an actual argument does not have a default
value, there is no valid mapping.
\item
The valid mapping is the mapping of actual arguments to formal
arguments plus default values to formal arguments that are not mapped
to by actual arguments.
\end{itemize}

\paragraph{Legal Argument Mapping}

An actual argument of type $T_A$ can be mapped to a formal argument of
type $T_F$ if any of the following conditions hold:
\begin{itemize}
\item $T_A$ and $T_F$ are the same type.
\item There is an implicit coercion from $T_A$ to $T_F$.
\item $T_A$ is derived from $T_F$.
\item $T_A$ is scalar promotable to $T_F$.
\end{itemize}

\subsubsection{Determining More Specific Functions}
\label{Determining_More_Specific_Functions}
\index{functions!most specific}

Given two functions $F_1$ and $F_2$, $F_1$ is determined to be more
specific than $F_2$ by the following steps:
\begin{itemize}
\item
If at least one of the legal argument mappings to $F_1$ is a {\em more
specific argument mapping} than the corresponding legal argument
mapping to $F_2$ and none of the legal argument mappings to $F_2$ is a
more specific argument mapping than the corresponding legal argument
mapping to $F_1$, then $F_1$ is more specific.
\item If $F_1$ shadows $F_2$, then $F_1$ is more specific.
\item $F_1$ is not more specific than $F_2$.
\end{itemize}

Given an argument mapping, $M_1$, from an actual argument, $A$, of
type $T_A$ to a formal argument, $F1$, of type $T_{F1}$ and an
argument mapping, $M_2$, from the same actual argument to a formal
argument, $F2$, of type $T_{F2}$, the more specific argument mapping
is determined by the following steps:
\begin{itemize}
\item
 If $T_{F1}$ and $T_{F2}$ are the same type and $F1$ is an
 instantiated parameter, $M_1$ is more specific.
\item
 If $T_{F1}$ and $T_{F2}$ are the same type and $F2$ is an
 instantiated parameter, $M_2$ is more specific.
\item
 If $M_1$ requires scalar promotion and $M_2$ does not require scalar
 promotion, $M_2$ is more specific.
\item
 If $M_2$ requires scalar promotion and $M_1$ does not require scalar
 promotion, $M_1$ is more specific.
\item
 If $F1$ is generic over all types and $F2$ is not generic over all
 types, $M_2$ is more specific.
\item
 If $F2$ is generic over all types and $F1$ is not generic over all
 types, $M_1$ is more specific.
\item
 If $T_{F1}$ and $T_{F2}$ are the same type, neither mapping is more
 specific.
\item
 If $T_A$ and $T_{F1}$ are the same type, $M_1$ is more specific.
\item
 If $T_A$ and $T_{F2}$ are the same type, $M_2$ is more specific.
\item
 If $T_{F1}$ is derived from $T_{F2}$, then $M_1$ is more specific.
\item
 If $T_{F2}$ is derived from $T_{F1}$, then $M_2$ is more specific.
\item
 If there is an implicit coercion from $T_{F1}$ to $T_{F2}$, then
 $M_1$ is more specific.
\item
 If there is an implicit coercion from $T_{F2}$ to $T_{F1}$, then
 $M_2$ is more specific.
\item
 If $T_{F1}$ is any \chpl{int} type and $T_{F2}$ is any \chpl{uint}
 type, $M_1$ is more specific.
\item
 If $T_{F2}$ is any \chpl{int} type and $T_{F1}$ is any \chpl{uint}
 type, $M_2$ is more specific.
\item
 Otherwise neither mapping is more specific.
\end{itemize}

\subsection{Nested Functions}
\label{Nested_Functions}
\index{functions!nested}

A function defined in another function is called a nested function.
Nesting of functions may be done to arbitrary degrees, i.e., a
function can be nested in a nested function.

Nested functions are only visible to function calls within the scope
in which they are defined.  An exception is to a function that has an
argument that is a class type.  Such functions are globally visible.

\subsubsection{Accessing Outer Variables}
\label{Accessing_Outer_Variables}

Nested functions may refer to variables defined in the function in
which they are nested.  If the function has class arguments, and is
thus globally visible, it is a compiler error to refer to a variable
in the outer function.

\begin{rationale}
It may be too strict to make this a compiler error.  Are there
advantages to making this a runtime error?
\end{rationale}

\subsection{Variable Length Argument Lists}
\label{Variable_Length_Argument_Lists}
\index{functions!variable number of arguments}

Functions can be defined to take a variable number of arguments.  This
allows the call site to pass a different number of actual arguments.

If the variable argument expression is an identifier prepended by a
question mark, the number of arguments is variable.  Alternatively,
the variable expression can evaluate to an integer parameter value
requiring the call site to pass that number of arguments to the
function.

In the function, the formal argument is a tuple of the actual
arguments.

\begin{example}
The code
\begin{chapel}
def mywriteln(x: int ...?k) {
  for param i in 1..k do
    writeln(x(i));
}
\end{chapel}
defines a function called \chpl{mywriteln} that takes a variable
number of arguments and then writes them out on separate lines.  The
parameter for-loop~(\rsec{Parameter_For_Loops}) is unrolled by the
compiler so that \chpl{i} is a parameter, rather than a variable.
This function can be made generic~(\rsec{Generics}) to take arguments
of different types by eliding the type.
\end{example}

A tuple of variables arguments can be passed to a function that takes
variable arguments by destructuring the tuple in a tuple destructuring
expressions defined in~\rsec{Tuple_Destructuring_Expressions}.  This
allows for the forwarding of variable arguments as variable arguments.
