\sekshun{Variables}
\label{Variables}

A variable is a symbol that represents memory.  Chapel is a
statically-typed, type-safe language so every variable has a type that
is known at compile-time and the compiler enforces that values
assigned to the variable can be stored in that variable as specified
by its type.

\subsection{Variable Declarations}
\label{Variable_Declarations}
\index{variables!declarations}

Variables are declared with the following syntax:
\begin{syntax}
variable-declaration-statement:
  `config'[OPT] variable-kind variable-declaration-list ;

variable-kind: one of
  `param' `const' `var'

variable-declaration-list:
  variable-declaration
  variable-declaration , variable-declaration-list

variable-declaration:
  identifier-list type-part[OPT] initialization-part
  identifier-list type-part

identifier-list:
  identifier
  identifier , identifier-list

type-part:
  : type
  : synchronization-type type

initialization-part:
  = expression
\end{syntax}
A \sntx{variable-declaration-statement} is used to define one or more
variables.  If the statement is a top-level module statement, the
variables are global; otherwise they are local.  Global variables are
discussed in~\rsec{Global_Variables}.  Local variables are discussed
in~\rsec{Local_Variables}.

The optional keyword \chpl{config} specifies that the variables are
configuration variables, described in
Section~\rsec{Configuration_Variables}.

The \sntx{variable-kind} specifies whether the variables are
parameters (\chpl{param}), constants (\chpl{const}), or regular
variables (\chpl{var}).  Parameters are compile-time constants whereas
constants are runtime constants.  Both levels of constants are
discussed in~\rsec{Constants}.

Multiple variables can be defined in the same \sntx{variable-declaration-list}.
All variables defined in the same \sntx{identifier-list} are
defined to have the same type and initialization expression.

The \sntx{type-part} of a variable declaration specifies the type of
the variable.  It is optional if the \sntx{initialization-part} is
specified.  If the \sntx{type-part} is omitted, the type of the
variable is inferred using local type inference described
in~\rsec{Local_Type_Inference}.

The \sntx{initialization-part} of a variable declaration specifies an
initial expression to assign to the variable.  If
the \sntx{initialization-part} is omitted, the variable is initialized
to a default value described in~\rsec{Default_Initialization}.

\subsubsection{Default Initialization}
\label{Default_Initialization}
\index{variables!default initialization}

If a variable declaration has no initialization expression, a variable
is initialized to the default value of its type.  The default values
are as follows:
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Type} & {\bf Default Value} \\
\hline
{\tt bool} & {\tt false} \\
{\tt int(*)} & {\tt 0} \\
{\tt uint(*)} & {\tt 0} \\
{\tt real(*)} & {\tt 0.0} \\
{\tt imag(*)} & {\tt 0.0i} \\
{\tt complex(*)} & {\tt 0.0 + 0.0i} \\
{\tt string} & {\tt ""} \\
enums & first enum constant \\
classes & {\tt nil} \\
records & default constructed record \\
ranges & an empty range \\
arrays & elements are default values \\
tuples & components are default values \\
\hline
\end{tabular}
\end{center}

\subsubsection{Local Type Inference}
\label{Local_Type_Inference}
\index{type inference}

If the type is omitted from a variable declaration, the type of the
variable becomes the type of the initialization expression.

\subsection{Global Variables}
\label{Global_Variables}
\index{variables!global}

Variables declared in statements that are in a module but not in a
function or block within that module are global variables.  Global
variables can be accessed anywhere within that module after the
declaration of that variable.  They can also be accessed in other
modules that use that module.

\subsection{Local Variables}
\label{Local_Variables}
\index{variables!local}

Local variables are variables that are not global.  Local variables
are declared within block statements.  They can only be accessed
within the scope of that block statement (including all inner nested
block statements and functions).

A local variable only exists during the execution of code that lies
within that block statement.  This time is called the lifetime of the
variable.  When execution has finished within that block statement,
the local variable and the storage it represents is removed.
Variables of class type are the sole exception.  Constructors of class
types create storage that is not associated with any scope.  Such
storage is managed automatically as discussed
in~\rsec{Automatic_Memory_Management}.

\subsection{Constants}
\label{Constants}

Constants are divided into two categories: parameters, specified with
the keyword \chpl{param}, are compile-time constants and constants,
specified with the keyword \chpl{const}, are runtime constants.

\subsubsection{Compile-Time Constants}
\label{Compile-Time_Constants}
\index{constants!compile-time}
\index{param@\chpl{param}}
\index{parameters}

A compile-time constant or parameter must have a single value that is
known statically by the compiler.  Parameters are restricted to
primitive and enumerated types.

Parameters can be assigned expressions that are parameter expressions.
Parameter expressions are restricted to the following constructs:
\begin{itemize}
\item
 Literals of primitive type.
\item
 Parenthesized parameter expressions.
\item
 Casts of parameter expressions to primitive or enumerated types.
\item
 Applications of the unary operators \verb@+@, \verb@-@, \verb@!@,
 and \verb@~@ on operands that are bool or integral parameter
 expressions.
\item
 Applications of the binary operators \verb@+@, \verb@-@, \verb@*@, \verb@/@, \verb@%@, \verb@**@, \verb@&&@, \verb@||@, \verb@!@, \verb@&@, \verb@|@, \verb@^@, \verb@~@, \verb@<<@, \verb@>>@, \verb@==@, \verb@!=@, \verb@<=@, \verb@>=@, \verb@<@, and \verb@>@ on operands that are bool or integral parameter expressions.
\item
 The conditional expression where the condition is a parameter and the
 then- and else-expressions are parameters.
\end{itemize}

There is an expectation that parameters will be expanded to more types
and more operations, and that functions that return parameters will be
introduced, in the future.

\subsubsection{Runtime Constants}
\label{Runtime_Constants}
\index{constants!runtime}
\index{const@\chpl{const}}

Constants, as opposed to parameters, do not have the restrictions that
are associated with parameters.  Constants can be any type.  They
require an initialization expression and contain the value of that
expression throughout their lifetime.

Variables of class type that are constants are constant references.
The fields of the class can be modified, but the variable always
points to the object that it was initialized to reference.

\subsection{Configuration Variables}
\label{Configuration_Variables}
\index{variables!configuration}
\index{config@\chpl{config}}

If the keyword \chpl{config} precedes the
keyword \chpl{var}, \chpl{const}, or \chpl{param}, the variable,
constant, or parameter is called a configuration variable,
configuration constant, or configuration parameter respectively.  Such
variables, constants, and parameters must be global.

The initialization of these variables can be set via implementation
dependent means, such as command-line switches or environment
variables.  The initialization expression in the program is ignored if
the initialization is alternatively set.

\index{parameters!configuration}
Configuration parameters are set during compilation time via
compilation flags or other implementation dependent means.
\begin{example}
A configuration parameter is set via a compiler flag.  It may be used
to control the target that is being compiled.  For example, the code
\begin{chapel}
config param target: string = "XT3";
\end{chapel}
sets a string parameter \chpl{target} to \chpl{"XT3"}.  This can be
checked to compile different code for this target.
\end{example}
