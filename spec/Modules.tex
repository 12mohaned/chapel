\sekshun{Modules}
\label{Modules}

\index{modules}

Chapel supports modules to manage name spaces.  A program consists of
one or more modules.  Every symbol, including variables, functions,
and types, is associated with some module.

Module definitions are described in~\rsec{Module_Definitions}.  The
relation between files and modules is described
in~\rsec{Implicit_Modules}.  Nested modules are described
in~\rsec{Nested_Modules}.  Module uses and explicit naming of symbols
are described in~\rsec{Using_Modules}.  The execution of a program and
module initialization is described in~\rsec{Program_Execution}.

\subsection{Module Definitions}
\label{Module_Definitions}

\index{module@\chpl{module}}

A module is declared with the following syntax:
\begin{syntax}
module-declaration-statement:
  `module' module-identifier block-statement

module-identifier:
  identifier
\end{syntax}
%% COMMENT FROM BRAD
%% * sec 1.1, par 1: ``in this block statement'' -- do you think we need to
%%    clarify that only top-level symbols are defined in (at?) the
%%    module's scope?  I.e., to point out the distinction between foo and
%%    x in:
%%      def foo() {
%%        var x = ...
%%      }
%%    since using the module will import foo but not x?  Do you think it
%%    would be worthwhile to coin a term like ``top-level module symbol''
%%    (or a better term?  ``module definitions''?  ``module symbols'' is
%%    tempting but potentially confusing since the module's name could
%%    also be considered a ``module symbol'') to define to these symbols as
%%    the ones that will be available when a 'module use' is encountered?
%%    (this comes up in the examples and using modules section below as
%%    well).

A module's name is specified after the \chpl{module} keyword.
The \sntx{block-statement} opens the module's scope.  Symbols defined
in this block statement are defined in the module's scope.

Module declaration statements must be top-level statements within a
module.  A module that is declared within another module is called a
nested module~(\rsec{Nested_Modules}).

\subsection{Implicit Modules}
\label{Implicit_Modules}
\index{modules!and files}

Multiple modules can be defined in the same file and need not bear any
relation to the file in terms of their names.

\begin{example}
The following file contains two explicitly named modules, MX and MY.
\begin{chapelcode}
module MX {
  var x: int = 0;
  def printX() {
    writeln(x);
  }
}

module MY {
  var y: int = 0;
  def printY() {
    writeln(y);
  }
}
\end{chapelcode}
\end{example}

For any file that contains top-level statements other than module
declarations, the file is treated as the module declaration.  In this
case, the module takes its name from the file.  If the file name is
not a legal Chapel identifier, the module name cannot be used in a use
statement.


\begin{example}
The following file, named my\_module.chpl, defines an implicitly named
module called my\_module.
\begin{chapelcode}
var x: int = 0;
var y: int = 0;

def printX() {
  writeln(x);
}
def printY() {
  writeln(y);
}
\end{chapelcode}
\end{example}


\subsection{Nested Modules}
\label{Nested_Modules}
\index{modules!nested}

A nested module is a module that is defined within another module, the
outer module.  Nested modules automatically have access to all of the
symbols in the outer module.  However, the outer module needs to
explicitly use a nested module to have access to its symbols.

A nested module can be used without using the outer module by
explicitly naming the module in the use statement.
\begin{example}
The code
\begin{chapel}
use libsci.blas;
\end{chapel}
uses a module named \chpl{blas} that is nested inside a module
named \chpl{libsci}.
\end{example}

Files with both module declarations and top-level statements result in
nested modules.

\begin{example}
The following file, named my\_module.chpl, defines an
implicitly named module called my\_module, with nested modules
MX and MY.
\begin{chapelcode}
module MX {
  var x: int = 0;
}

module MY {
  var y: int = 0;
}

use MX, MY;

def printX() {
  writeln(x);
}

def printY() {
  writeln(y);
}
\end{chapelcode}
\end{example}


\subsection{Using Modules}
\label{Using_Modules}
\index{modules!using}

A module can be used by code outside of that module.  This allows
access to the symbols in the module without the need for explicit
naming~(\rsec{Explicit_Naming}).  Using modules is accomplished via
the use statement as defined in~\rsec{The_Use_Statement}.

\subsubsection{Explicit Naming}
\label{Explicit_Naming}

All symbols can be named explicitly with the following syntax:
\begin{syntax}
module-access-expression:
  module-identifier-list . identifier

module-identifier-list:
  module-identifier
  module-identifier . module-identifier-list

\end{syntax}
This allows two variables that have the same name to be distinguished
based on the name of their module.  Using explicit module naming in a
function call restricts the set of candidate functions to those in the
specified module.

If code refers to symbols that are defined by multiple modules, the
compiler will issue an error.  Explicit naming can be used to
disambiguated the symbols in this case.



\subsubsection{Module Initialization}
\label{Module_Initialization}
\index{modules!initialization}

Module initialization occurs at program start-up.  All top-level
statements in a module other than function and type declarations are
executed during module initialization.

\begin{example}
In the code,
\begin{chapel}
var x = foo();       // executed at module initialization
writeln("Hi!");      // executed at module initialization
def sayGoodbye {
  writeln("Bye!");   // not executed at module initialization
}
\end{chapel}
The function foo() will be invoked and its result assigned to x.  Then
``Hi!'' will be printed.
\end{example}

Module initialization order is discussed
in~\ref{Module_Initialization_Order}.



\subsection{Program Execution}
\label{Program_Execution}

Chapel programs start by initializing all modules and then executing
the main function~(\rsec{The_main_Function}).

\subsubsection{The {\em main} Function}
\label{The_main_Function}

\index{main@\chpl{main}}
The main function must be called \chpl{main} and must have zero
arguments.  It can be specified with or without parentheses.  In any
Chapel program, there is a single main function that defines the
program's entry point.  If a program defines multiple potential entry
points, the implementation may provide a compiler flag that
disambiguates between main functions in multiple modules.

\begin{craychapel}
In the Cray Chapel compiler implementation, the \emph{--
--main-module} flag can be used to specify the module from which the
main function definition will be used.  Only modules passed to the
compiler on the command line will be searched for main functions
unless the \emph{-- --main-module} flag is used.
\end{craychapel}

\index{exploratory programming}

%% \subsubsection{Programs with a Single Module}
%% \label{Programs_with_a_Single_Module}

To aid in exploratory programming, if the file(s) listed on the
compiler's command line only define a single module, the module need
not define a main function.  In this case, a default main function is
created to execute the module initialization code.
\begin{example}
The code
\begin{chapel}
writeln("hello, world");
\end{chapel}
is a legal and complete Chapel program.  Its initialization function,
which also serves as the program's main function, is the top-level
writeln() statement.  The module declaration is taken to be the file
as described in~\rsec{Implicit_Modules}.
\end{example}


\subsubsection{Module Initialization Order}
\label{Module_Initialization_Order}

Module initialization is performed using the following algorithm.

Module use can be represented by a directed graph over the modules.
Starting from the module that defines the main function, modules are
initialized in the order implied by a depth-first, post-order
traversal of the graph.  Modules are initialized in the order in which
they appear in the program text.  For nested modules, uses in the
parent module are initialized before uses in the nested module.

\begin{example}
The code
\begin{chapelcode}
module M1 {
  use M2.M3;
  use M2;
  writeln("In M1's initializer");
  def main() {
    writeln("In main");
  }
}

module M2 {
  use M4;
  writeln("In M2's initializer");
  module M3 {
    writeln("In M3's initializer");
  }
}

module M4 {
  writeln("In M4's initializer");
}
\end{chapelcode}
prints the following
\begin{quote}
In M4's initializer\\
In M2's initializer\\
In M3's initializer\\
In M1's initializer\\
In main
\end{quote}
\end{example}
