\sekshun{Modules}
\label{Modules}

\index{modules}

Chapel supports modules to manage name spaces.  Every symbol,
including variables, functions, and types, are associated with some
module.

Module definitions are described in~\rsec{Module_Definitions}.  A
program consists of one or more modules.  The execution of a program
and command-line arguments are described in~\rsec{Program_Execution}.
Module uses and explicit naming of symbols is described
in~\rsec{Using_Modules}.  Nested modules are described
in~\rsec{Nested_Modules}.  The relation between files and modules is
described in~\rsec{Implicit_Modules}.

\subsection{Module Definitions}
\label{Module_Definitions}

\index{module@\chpl{module}}

A module is declared with the following syntax:
\begin{syntax}
module-declaration-statement:
  `module' identifier block-statement
\end{syntax}
A module's name is specified after the module keyword.
The \sntx{block-statement} opens the module's scope.  Symbols defined
in this block statement are defined in the module's scope.

Module declaration statements may only be top-level statements in
files or top-level statements in other modules.  A module that is
declared in another module is called a nested
module~(\rsec{Nested_Modules}).

\subsection{Program Execution}
\label{Program_Execution}

Chapel programs start by executing the main
function~(\rsec{The_main_Function}).  The main function takes no
arguments but command-line arguments can be passed to a program via a
global sequence of strings
called \chpl{argv}~(\rsec{Command_Line_Arguments}).  Command-line
flags can be passed to a program via configuration variables, as
discussed in~\rsec{Configuration_Variables}.

\subsubsection{The {\em main} Function}
\label{The_main_Function}

\index{main@\chpl{main}}
The main function must be called \chpl{main} and must have zero
arguments.  There can be only one main function in all of the modules
that make up a program.  Every main function starts by using the
module that it is defined in, and thus executing the top-level code in
that module~(\rsec{Module_Execution}).

The main function can be omitted if there is only a single module in
the program other than the standard modules, as discussed
in~\rsec{Programs_with_a_Single_Module}.

\subsubsection{Command-Line Arguments}
\label{Command_Line_Arguments}
\index{command-line arguments}

\index{argv@\chpl{argv}}
A predefined variable is used to capture arguments to the execution of
a program.  It has this declaration:
\begin{chapel}
var argv: seq of string;
\end{chapel}
The number of arguments passed to the program execution can be queried
with the sequence \chpl{length} function as in
\begin{chapel}
argv.length
\end{chapel}

\begin{status}
There is no support for the variable \chpl{argv}.  Only configuration
variables allow arguments to be passed to the execution of a program.
\end{status}

\subsubsection{Module Execution}
\label{Module_Execution}

Top-level code in a module is executed the first time that module is
used via a \sntx{use-statement}.

\subsubsection{Programs with a Single Module}
\label{Programs_with_a_Single_Module}

\index{exploratory programming}

To aid in exploratory programming, if a program is defined in a single
module that uses only standard modules, the module need not define a
main function.  A default main function is created in this case.  This
main function sole executable statement is to call the initialize
function of that module.
\begin{example}
The code
\begin{chapel}
writeln("Hello World!");
\end{chapel}
is a legal and complete Chapel program.  The module declaration is
taken to be the file as described in~\rsec{Implicit_Modules}.
\end{example}

\subsection{Using Modules}
\label{Using_Modules}
\index{modules!using}

Modules can be used by code outside of that module.  This allows
access to the symbols in the modules without the need for explicit
naming~(\rsec{Explicit_Naming}).  Using modules is accomplished via
the use statement as defined in~\rsec{The_Use_Statement}.

\subsubsection{Explicit Naming}
\label{Explicit_Naming}

All symbols can be named explicitly with the following syntax:
\begin{syntax}
module-named-identifier:
  module-identifier . identifier

module-identifier:
  identifier
\end{syntax}
This allows two variables that have the same name to be distinguished
based on the name of their module.  If code requires using symbols
from two different modules that have the same name, explicit naming is
needed to disambiguate between the two symbols.  Explicit naming can
also be used instead of using a module.

\subsection{Nested Modules}
\label{Nested_Modules}
\index{modules!nested}

A nested module is a module that is defined inside another module, the
outer module.  Nested modules automatically have access to all of the
symbols in the outer module.  However, the outer module needs to
explicitly use a nested module to have access to its symbols.

\begin{example}
A nested module can be used without using the outer module by
explictly naming the module in the use statement.  The code
\begin{chapel}
use libmsl.blas;
\end{chapel}
uses a module named \chpl{blas} that is nested inside a module
named \chpl{libmsl}.
\end{example}

\subsection{Implicit Modules}
\label{Implicit_Modules}
\index{modules!and files}

Multiple modules can be defined in the same file and do not need to
bear any relation to the file in terms of their names.  As a
convenience, a module declaration statement can be omitted if it is
the sole module defined in a file.  In this case, the module takes its
name from the file.
