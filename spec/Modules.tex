\sekshun{Modules}
\label{Modules}

\index{modules}

Chapel supports modules to manage name spaces.  A program consists of
one or more modules.  Every symbol, including variables, functions,
and types, are associated with some module.

Module definitions are described in~\rsec{Module_Definitions}.  The
relation between files and modules is described
in~\rsec{Implicit_Modules}.  Nested modules are described
in~\rsec{Nested_Modules}.  Module uses and explicit naming of symbols
are described in~\rsec{Using_Modules}.  The execution of a program and
module initialization is described in~\rsec{Program_Execution}.

\subsection{Module Definitions}
\label{Module_Definitions}

\index{module@\chpl{module}}

A module is declared with the following syntax:
\begin{syntax}
module-declaration-statement:
  `module' module-identifier block-statement

module-identifier:
  identifier
\end{syntax}
A module's name is specified after the \chpl{module} keyword.
The \sntx{block-statement} opens the module's scope.  Symbols defined
in this block statement are defined in the module's scope.

Module declaration statements must be top-level statements within a
module.  A module that is declared in another module is called a
nested module~(\rsec{Nested_Modules}).

\subsection{Implicit Modules}
\label{Implicit_Modules}
\index{modules!and files}

Multiple modules can be defined in the same file and do not need to
bear any relation to the file in terms of their names.

\begin{example}
The following file contains two explicitly named modules, MX and MY.
\begin{chapelcode}
module MX {
  var x: int = 0;
  def printX() {
    writeln(x);
  }
}

module MY {
  var y: int = 0;
  def printY() {
    writeln(y);
  }
}
\end{chapelcode}
\end{example}

For any file that contains top-level statements other than module
declarations, the file is treated as the module declaration.  In this
case, the module takes its name from the file.  The file name contains
illegal Chapel symbols, the module name cannot be used in a use
statement.


\begin{example}
The following file, named my\_module.chpl, defines an implicitly named
module called my\_module.
\begin{chapelcode}
var x: int = 0;
var y: int = 0;

def printX() {
  writeln(x);
}
def printY() {
  writeln(y);
}
\end{chapelcode}
\end{example}


\subsection{Nested Modules}
\label{Nested_Modules}
\index{modules!nested}

A nested module is a module that is defined inside another module, the
outer module.  Nested modules automatically have access to all of the
symbols in the outer module.  However, the outer module needs to
explicitly use a nested module to have access to its symbols.

A nested module can be used without using the outer module by
explicitly naming the module in the use statement.
\begin{example}
The code
\begin{chapel}
use libsci.blas;
\end{chapel}
uses a module named \chpl{blas} that is nested inside a module
named \chpl{libsci}.
\end{example}

Files with both module declarations and top-level statements result in
nested modules.

\begin{example}
The following file, named my\_nested\_module.chpl, defines an
implicitly named module called my\_nested\_module, with nested modules
MX and MY.
\begin{chapelcode}
module MX {
  var x: int = 0;
}

module MY {
  var y: int = 0;
}

use MX, MY;

def printX() {
  writeln(MX.x);
}

def printY() {
  writeln(MY.y);
}
\end{chapelcode}
\end{example}


\subsection{Using Modules}
\label{Using_Modules}
\index{modules!using}

Modules can be used by code outside of that module.  This allows
access to the symbols in the modules without the need for explicit
naming~(\rsec{Explicit_Naming}).  Using modules is accomplished via
the use statement as defined in~\rsec{The_Use_Statement}.

\subsubsection{Explicit Naming}
\label{Explicit_Naming}

All symbols can be named explicitly with the following syntax:
\begin{syntax}
module-access-expression:
  module-identifier-list . identifier

module-identifier-list:
  module-identifier
  module-identifier . module-identifier-list

\end{syntax}
This allows two variables that have the same name to be distinguished
based on the name of their module.  For functions, the visible
functions are restricted to the specified module.  For all symbols,
the symbol must be declared top-level to the specified module.

If code refers to symbols that are defined by multiple modules, the
compiler will issue an error.  Explicit naming can be used to
disambiguated the symbols in this case.



\subsubsection{Module Initialization}
\label{Module_Initialization}
\index{modules!initialization}

Module initialization occurs at program start-up.  All top-level
statements in a module (other than function and type declarations) are
executed during module initialization.

\begin{example}
In the code,
\begin{chapel}
var x: foo();        // executed at module initialization
writeln("Hi!");      // executed at module initialization
def sayGoodbye {
  writeln("Bye!");   // not executed at module initialization
}
\end{chapel}
All statements outside the function declaration are executed at module
initialization time.
\end{example}

Module initialization order is discussed
in~\ref{Module_Initialization_Order}.



\subsection{Program Execution}
\label{Program_Execution}

Chapel programs start by initializing all modules and then executing
the main function~(\rsec{The_main_Function}).

\subsubsection{The {\em main} Function}
\label{The_main_Function}

\index{main@\chpl{main}}
The main function must be called \chpl{main} and must have zero
arguments.  It can be specified with or without parentheses.  There
can be only one main function in all of the modules that make up a
program.  Implementations may provide a compiler flag that
disambiguates between main functions in multiple modules.

\begin{craychapel}
In the Cray Chapel compiler implementation, the \emph{--main-module}
flag can be used to specify the module from which the main function
definition will be used.  Only modules passed to the compiler on the
command line will be searched for main functions unless
the \emph{--main-module} flag is used.
\end{craychapel}

\index{exploratory programming}

%% \subsubsection{Programs with a Single Module}
%% \label{Programs_with_a_Single_Module}

To aid in exploratory programming, if a program is defined using a
single module that uses only standard modules, the module need not
define a main function.  In this case, a default main function is
created to execute the module code.
\begin{example}
The code
\begin{chapel}
writeln("hello, world");
\end{chapel}
is a legal and complete Chapel program.  The module declaration is
taken to be the file as described in~\rsec{Implicit_Modules}.
\end{example}


\subsubsection{Module Initialization Order}
\label{Module_Initialization_Order}

Module initialization is perform using the following algorithm.

Module use can be represented by a directed graph where an edge from a
node M1 (representing module M1) to node M2 (representing module M2)
denotes that M1 uses M2.  Starting from the module that defines the
main function, initialize modules in the order implied by a
depth-first, post-order traversal of the graph.  Modules are
initialized in the order in which they appear in the program text.
For nested modules, uses in the parent module are initialized before
uses in the nested module.

\begin{example}
The code
\begin{chapelcode}
module M1 {
  use M2.M3;
  use M2;
  writeln("In M1's initializer");
  def main() {
    writeln("In main");
  }
}

module M2 {
  use M4;
  writeln("In M2's initializer");
  module M3 {
    writeln("In M3's initializer");
  }
}

module M4 {
  writeln("In M4's initializer");
}
\end{chapelcode}
prints the following
\begin{quote}
In M4's initializer\\
In M2's initializer\\
In M3's initializer\\
In M1's initializer\\
In main
\end{quote}
\end{example}
