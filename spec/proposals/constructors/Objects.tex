\section{The Object Lifecycle Model and UMM}

The interaction of language semantics and the User-Managed Memory model can be discussed
in terms of state transitions in the object lifecycle.  For background, a summary of the
object lifecycle is presented in the following subsection.  We then discuss the
transitions made by the current constructor model, and how the proposed constructor model
would navigate these same changes.


\subsection{The Object Lifecycle}

In general, the states an object can be in are:
\begin{enumerate}
\item Undefined
\item Uninitialized
\item Value-Initialized
\item Field-Initialized
\item Fully-Initialized (a.k.a. Constructed)
\item Destroyed
\item Reclaimed
\end{enumerate}

Before an object has been allocated, it is in the ``undefined'' state.  This is
equivalent to representing its storage with a null pointer; the object {\it per
se} does not exist.

Once memory sufficient to represent the object has been allocated, the object
moves to the ``uninitialized'' state.  The name of the object (or the class
variable) refers to actual memory, but that memory is in an unknown state.

Value-initialization moves the object to the ``value-initialized'' state.  Each
field within an aggregate object is in an initial state consistent with its type,
but neither the fields nor the object as a whole have been ``constructed''.
Value-initialization may be applied knowing only the type of the object --- or
just the types of the fundamental leaves of an aggregate type.  In particular,
neither the constructors nor the field initializers are consulted in creating a
value-initialized object.\footnote{This can be stated more simply using just the
  restriction against consulting constructors, since field-initialization
  depends upon construction.}

Field-initialization consists of bringing each field in an aggregate type into a
state consistent with the field declarations.  If the field is declared without
a specified initializer, then the default constructor (for the type of that
field) is called; otherwise, a constructor for the type of that field is called,
passing the initialization expression for that field as its operand.

Following field-initialization, the actions specified in the body of the
constructor are called.  In many cases, the body of the constructor is empty,
because the actions of value- and field-initialization bring the object into a
state consistent with the desired class invariants.  In any case, after the body
of one of its constructors has run to completeion, the object is
fully-initialized (i.e. constructed).

When an object is destroyed, it transitions to the destroyed state.  This state
is equivalent to ``uninitialized'', meaning that its contents cannot be relied
upon.  An implementation may reuse a destroyed object without first returning it
to the heap through deallocation.\footnote{After its destruction, an object may
  still be accessible through the name or reference used to call the
  destructor.  But since its contents cannot be relied upon, it represents a
  programming error to attempt to read or write an object in this state.}

Once an object has been destroyed, an implementation may reuse or reclaim it.
This may happen immediately or at some unspecified future time.  After it has
been reclaimed, the object returns to the undefined state.


\subsection{Initialization in the Current Implementation}

Initialization is the sequence of actions that take place when a variable is prepared for
use within its scope, or when a field of a record or class is prepared for use.  Field
initialization usually takes place as part of the construction of such object, as outlined
above in the object lifecycle description.  We discuss the initialization of variables in
this section, and treat field-initialization in the following subsection as part of the
semantics of construction. 

Assuming that type inference and initialization are separable concepts, we would expect
there to be three canonical forms for variable declaration and initialization:
\begin{chapel}
// type T = ... ;
   var a:T;
   var b:T = noinit;
   var c:T = new T( ... );
\end{chapel}
In the final form, any expression coercible to type \chpl{T} should exhibit the same
semantics, so we could e.g. have said \chpl{var c:T = a;} instead.

In only the final form, the explicit type specifier on the variable may be omitted.  In that
case the compiler infers the type from the initializer expression.  In the other forms,
the type specifier is required.\footnote{The compiler might still be able to infer the type of the
variable depending on how it is used (as it currently does for the return value
temporary), but that would reflect a change in the semantics of the language.}

Anyway, as things stand, type inference in the compiler allows it to convert the
expression
\begin{chapel}
   var c = new T( ... );
\end{chapel}
into its canonical form \chpl{var c:T = new T( ... );}.  Note that since the inferred type
of c is the same as the type of the initializer expression, the initializer expression is
always coercible to the variable's type.

The way in which the compiler initializes variables of record type is the most interesting
case.  There are other types known to the compiler that should also be taken into
consideration in forming a complete description of the current behavior.  These are
considered separately below.


\subsubsection{Record Variables}

When \chpl{T} is a record type, we observe that the following Chapel code
\begin{chapel}
  var s:R;
  var t:R = noinit;
  var u:R = new R();
  var v:R = new R(8, 9, 10.0);
  var w = new R();
  var x = new R(9, 16, 0.5625);
\end{chapel}
gives rise to the corresponding AST
\begin{verbatim}
    var s:R
    {
      var type_tmp:R
      ('move' type_tmp (call _construct_R))
      ('move' s type_tmp)
    }
    var t:R
    var u:R
    {
      var type_tmp:R
      ('move' type_tmp (call _construct_R))
      var call_tmp:R
      ('move' call_tmp (call _construct_R))
      (call = type_tmp call_tmp)
      ('move' u type_tmp)
    }
    var v:R
    {
      var type_tmp:R
      ('move' type_tmp (call _construct_R))
      var call_tmp:R
      var coerce_tmp:uint(64)
      ('move' coerce_tmp (call _cast 8))
      ('move' call_tmp (call _construct_R coerce_tmp 9 10.0))
      (call = type_tmp call_tmp)
      ('move' v type_tmp)
    }
    var w:R
    ('move' w (call _construct_R))
    var x:R
    var coerce_tmp:uint(64)
    ('move' coerce_tmp (call _cast 9))
    ('move' x (call _construct_R coerce_tmp 16 0.5625))
\end{verbatim}
begin roughly equivalent to the following canonical expansion:
\begin{chapel}
  pragma "no init" var type_tmp:R; type_tmp <- new R();
  pragma "no init" var s:R; s <- type_tmp;

  pragma "no init" var t:R;

  pragma "no init" var type_tmp:R; type_temp <- new R();
  pragma "no init" var call_tmp:R; call_temp <- new R();
  type_tmp = call_tmp;
  pragma "no init" var u:R; u <- type_tmp;

  pragma "no init" var type_tmp2:R; type_temp2 <- new R();
  pragma "no init" var call_tmp2:R; call_temp2 <- new R(8, 9, 10.0);
  type_tmp2 = call_tmp2;
  pragma "no init" var v:R; v <- type_tmp2;

  pragma "no init" var w:R; w <- new R();

  pragma "no init" var x:R; x <- new R(9, 16, 0.5625);
\end{chapel}
\noindent
where the invented pragma \chpl{"no init"} performs basically the same function as the
\chpl{= noinit} initializer --- inhibiting any kind of initialization from being applied
to the raw memory representeing the object.  The invented syntax \chpl{<-} expresses the
action of the \chpl{'move'} primitive, which is to perform a bit-wise copy from the RHS
object into the LHS object.  This is in contrast to \chpl{=}, which calls the assignment
operator (i.e. \chpl{proc =}) compatible with the types of the two arguments.\footnote{The
assignment operator is not necessarily trivial.  It may perform reference-counting
operations, etc.}

It can be observed that the form with \chpl{= noinit} initializer performs no
initialization whatsoever.  Zero-initialization, field initialization and construction are
all inhibited.  Because construction is not performed, this breaks encapsulation of the
corresponding class or record.  And because the choice of whether construction is done or
not is made at the point of declaration (rather than as part of the class design), the
class designer is under no obligation to make any operation on an uninitialized object of
that type work correctly.  In particular, \emph{assignment into an uninitialized object is
  not expected to work correctly} which leaves \emph{no pathway for an uninitialized
  object to ever become properly initialized}.  As it is currently implemented, I would
have to advise the serious programmer to never use the \chpl{= noinit} feature.

Somewhat to my surprise, the forms involving type inference are not merely normalized
to their corresponding cononical forms.  They follow a completely different translation
pathway.  I suspect this is due more to implementation history rather than being a matter
of design.  In many places, the current implementation requires the construction of a
full-up object where the construction of a mere type would suffice.  

In terms of user intent, both forms of initialized variable declaration (with and without
an explicit type specifier) should have implementations resembling the
form that does not contain an explicit type; it is hard to imagine the utility of
fully-establishing the type-default value in a variable that is then immediately overwritten.

There is further complexity surrounding whether a record type defines a constructor that
can be called with no arguments.  In the example code above it does, so the initial value of
a \chpl{type_temp} variable is determined by calling that user-defined no-argument
constructor.  If such a user-defined constructor does not exist, the compiler instead
inserts a call to \chpl{_defaultOf(t)}, where \chpl{t} is the type of that record.  The
compiler-supplied version of \chpl{_defaultOf()} calls the all-fields constructor for the
passed-in type, passing no arguments.  

This is the same behavior as would be achieved by consistently generating a call to the
constructor for that type, passing no arguments.  In the case that no user-defined
constructor that can bind to an empty argument list is supplied, the call would bind to
the compiler-supplied all-fields constructor.  In the case that such a user-defined
constructor is supplied, the compiler would preferentially bind that one.

In the current implementation, it is possible to override the compiler-supplied version of
\chpl{_defaultOf()}.  In that case, the user-defined version is used preferentially.
However, it is still the case that \chpl{_defaultOf()} will only be called if no
user-defined constructor that can bind to an empty argument list is supplied for that
type.

Because \chpl{_defaultOf()} produces an object that is properly initialized, it is
equivalent in its effect to construction.  It should therefore be under the control of the
author of that type.  Both \chpl{_defaultOf()} and the no-argument constructor for a given
type have the meaning ``give me a default-initialized object of type T'', so at least in
concept they are aliases for one another.  The two differences that exist in the current
implementation are that the user-defined no-argument constructor will take precedence over
\chpl{_defaultOf()} and that \chpl{_defaultOf()} bypasses any user-defined no-argument
constructor (which doesn't exist, by definition), and calls the compiler-defined
all-fields constructor (passing no arguments) instead.  A way to bring these concepts
closer into alignment would be to have the compiler-supplied version of
\chpl{_defaultOf()} for record types call a constructor of that type by name, passing no
arguments.  This will bind with the compiler-supplied all-fields constructor (passing no
arguments) if no user-defined no-argument constructor is supplied, and bind to the
user-defined version if one is present.

\subsubsection{Class Variables}

When initializing a variable of class type, the following forms are possible:
\begin{chapel}
  var c:C; c = new C(false);
  var d:C = new C(true);
  var e = new C(false);
  var f:C = noinit;
\end{chapel}
This produces the following AST
\begin{verbatim}
    var c:C
    {
      var type_tmp:C
      ('move' type_tmp (call _defaultOf))
      ('move' c type_tmp)
    }
    var call_tmp:C
    ('move' call_tmp (call _construct_C))
    (call = c call_tmp)
    var d:C
    {
      var type_tmp:C
      ('move' type_tmp (call _defaultOf))
      var call_tmp:C
      ('move' call_tmp (call _construct_C))
      (call = type_tmp call_tmp)
      ('move' d type_tmp)
    }
    var e:C
    ('move' e (call _construct_C))
    var f:C
\end{verbatim}
which is roughly equivalent to the following pseudo-Chapel code:
\begin{chapel}
  pragma "no init" var c:C;
  pragma "no init" var type_tmp:C; type_tmp <- _defaultOf(C);
  c <- type_tmp;

  c = new C(false);

  pragma "no init" var d:C; 
  pragma "no init" var type_tmp:C; type_tmp <- _defaultOf(C);
  pragma "no init" var call_tmp:C; call_tmp <- new C(true);
  type_tmp = call_tmp;
  d <- type_tmp;

  pragma "no init" var e:C; e <- new C(false);
  pragma "no init" var f:C;
\end{chapel}

For class variables, assignment is rigidly defined by the compiler to be a pointer copy,
so there is no difference between the assignment operator and move primitives for all
class types.  Therefore, the actions taken for the separate declaration and initialization
(for variable \chpl{c}) are the same as those taken for the canonical initialization form
(for variable \chpl{d}).  In gruesome detail, the first form involves one update of
\chpl{type_tmp} and two updates to \chpl{c} while the second form involves two updates of
\chpl{type_temp} and only one of \chpl{d}.  This may have performance impacts depending on
where the two are stored.


\subsubsection{Array Variables}

\subsubsection{Domain Variables}

\subsubsection{Distribution Variables}

\subsubsection{Sync and Single Variables}

\subsubsection{Tuple Variables}

\subsubsection{Scalar Variables}

\subsection{Construction in the Current Implementation}

In the current implementation, construction involves all of the steps from undefined
through fully-initialized.

\subsubsection{Allocation}

Variables of class type are only allocated explicitly through the \chpl{new} operator.
The allocation is performed in the wrapper function which calls the compiler-generated
``all-fields'' constructor for that class, passing in all default-valued field arguments.
\begin{verbatim}
  // This is the AST clipped from the compiler-supplied constructor for a class C.
  function C._construct_C() : C
  {
    var this:C
    var call_tmp:int(64)
    ('move' call_tmp ('sizeof' C))
    var cast_tmp:opaque
    ('move' cast_tmp (call chpl_here_alloc call_tmp 28))
    ('move' this ('cast' C cast_tmp))
    ('setcid' this)
\end{verbatim}
Storage for all other types is allocated either statically or on the stack.  In particular,
variables of record type are not heap-allocated.  Therefore, the allocation code
inserted in the class constructor wrapper shown above is \emph{not} inserted in the
compiler-generated default construtor.

\subsubsection{Value Initialization}

In the current implementation, value-initialization is equivalent to zero-initialization.
Zero-initialization is applied before field-initialization, and this occurs before any
assignments that occur within the body of the constructor.

In record and class constructors, this is done on a field-by-field basis, recursively,
according to the default value specified for each fundamental type.  For records --- for
example --- we have: 
\begin{verbatim}
    var this:R
    ('.=' this u 0)
    ('.=' this i 0)
    ('.=' this r 0.0)
\end{verbatim}
This code appears in every wrapper constructor that is used to call the compiler-generated
all-fields constructor, but not in the all-fields constructor itself.  The all-fields
constructor can be distinguished by the presence of a ``meme'' argument.  This argument
does not appear in any of the constructor-wrapper functions that call the all-fields
constructor nor in user-supplied constructors.

The zero-initialization code for a class object containing two records of the above type
looks like:
\begin{verbatim}
    var this:C
    // Allocation code elided. See above.
    var _init_class_tmp_:R
    ('.=' _init_class_tmp_ u 0)
    ('.=' _init_class_tmp_ i 0)
    ('.=' _init_class_tmp_ r 0.0)
    ('.=' this uninit _init_class_tmp_)
    var _init_class_tmp_:R
    ('.=' _init_class_tmp_ u 0)
    ('.=' _init_class_tmp_ i 0)
    ('.=' _init_class_tmp_ r 0.0)
    ('.=' this init _init_class_tmp_)
\end{verbatim}
\noindent
Note that zero-initialization has effectively been recursively inlined.  This AST snapshot
is taken at the end of the ``resolve'' pass --- well before explicit inlining is applied.

The zero-initialization code is injected by the compiler in all constructors that can be
called directly from user code.

\subsubsection{Field Initialization}

Field-initialization in class and record construction is performed by the
compiler-generated all-fields constructor.  Example AST for this function for a record is
\begin{verbatim}
  function R._construct_R(arg u:uint(64), arg i:int(64), arg r:real(64), arg meme:R) : R
  {
    // Move meme into this.
    var this:R
    ('move' this meme)
    // Perform field-by-field copy.
    ('.=' this u u)
    ('.=' this i i)
    ('.=' this r r)
    // Return this.
    (return this)
  }
\end{verbatim}
and for a class,
\begin{verbatim}
  function C._construct_C(arg uninit:R, arg init:R, arg meme:C) : C
  {
    // Move meme into this.
    var this:C
    ('move' this meme)
    // Construct the base-class sub-object.
    var _tmp:object
    ('move' _tmp ('.v' this super))
    var _return_tmp_:object
    ('move' _return_tmp_ (call _construct_object _tmp))
    // Perform field-by-field copy.
    ('.=' this uninit uninit)
    ('.=' this init init)
    // Return this.
    (return this)
  }
\end{verbatim}
Both begin by moving \chpl{meme} into \chpl{this}.  The class constructor then calls its
base-class constructor, passing in the pointer to the base-class sub-object.  Every class
inherits from \chpl{object}.  The sub-object of type \chpl{object} contains the class ID
and in this way, the run-time type of an object is established.  As an optimization,
objects that are statically bound can be declared withe the \chpl{"no object"} pragma ---
in which case the \chpl{object} base class object is elided.

In the compiler-generated all-fields constructor, it is apparent that the \chpl{meme}
argument could be eliminated and the initial move avoided if that constructor is called as
a method.  Aside from dependencies within the compiler on the form of the all-fields
constructor function, this change should be relatively small.

\subsubsection{Construction}

In the object lifecycle, construction is the set of actions that take place after
field-initialization is complete.  This usually corresponds to the body of the constructor
function --- especially the body of a user-supplied constructor.

In the example code, the user-supplied record constructor looks like:
\begin{chapel}
  proc R() { r = 2.71; }
\end{chapel}
It sets the r field of that record to a very bad approximation of $e$.

The corresponding AST at the end of resolution is
\begin{verbatim}
  function R._construct_R() : R
  {
    // The compiler adds this.
    var this:R
    ('move' this (call _construct_R))
    // The original constructor body begins here.
    var call_tmp:_ref(real(64))
    ('move' call_tmp (call r this))
    (call = call_tmp 2.71)
    (return this)
  }
\end{verbatim}

The compiler post-processes the source code for a constructor in the normalize pass (in
\chpl{change_method_into_constructor}) to insert a call to the compiler-generated default
constructor.  For a record, this performs zero-initialization followed by
field-initialization.  Control then advances to the code that constituted the original
constructor body.

In the example code, the user-supplied class constructor looks like:
\begin{chapel}
  proc C(param overw:bool)
  {
    if overw then
    {
      uninit = new R(r=3.14);
      init.r = 12.0;
    }
  }
\end{chapel}
The interesting case is when overw is true.  (The param argument causes generic
instantiation to stamp out two copies of this constructor --- one with the 
\chpl{overw == true} clause and the other without.)  The corresponding AST is
\begin{verbatim}
  function C._construct_C() : C
  {
    var this:C
    ('move' this (call _construct_C))
    {
      var call_tmp:_ref(R)
      ('move' call_tmp (call uninit this))
      var call_tmp:R
      ('move' call_tmp (call _construct_R 3.14))
      (call = call_tmp call_tmp)
      var call_tmp:_ref(R)
      ('move' call_tmp (call init this))
      var call_tmp:_ref(real(64))
      ('move' call_tmp (call r call_tmp))
      (call = call_tmp 12.0)
    }
    (return this)
  }
\end{verbatim}
Note that as with records, the compiler inserts a call to the default constructor for C,
moving the result into \chpl{this}.  The default constructor for C, in addition to
performing zero- and field-initialization, heap-allocates space to hold the returned object.


\subsubsection{Post-Construction}

A currently-supported feature of the compiler is to insert a call to an \chpl{initialize}
method at the end of a constructor if such a method is defined in the class.

There are a number of reasons why this language feature should be deprecated, including:
\begin{itemize}
\item The same effect can be achieved by calling an \chpl{initialize} function explicitly.
\item The signature of the built-in \chpl{initialize} method is highly constrained (no
  arguments, no return value) while a user-defined \chpl{initialize} method is not so
  constrained. 
\item It provides a way for a sophisticated user to write obfuscated code.
\item It slightly complicates the compiler.
\item It removes that name from the user's namespace.
\item Whatever was the historical problem it solved seems to have been overcome by now.
\end{itemize}


\subsection{Construction in the Proposed Implementation}

With the exception of the new initialization syntax proposed in sections
\rsec{Declarations} and \rsec{Constructors}, the observable semantics of construction is
expected to be largely compatible with today's implementation.  
\subsubsection{Allocation}

\subsubsection{Value Initialization}

\subsubsection{Field Initialization}

\subsubsection{Construction}

\subsubsection{Post-Construction}

