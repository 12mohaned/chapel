\sekshun{Ranges}
\label{Ranges}
\index{ranges}

\subsection{Range Assignment}
\label{Range_Assignment}
\index{ranges!assignment}



\subsection{Arithmetic Sequences}
\label{Arithmetic_Sequences}
\index{sequences!arithmetic}
\index{arithmetic sequences}
Arithmetic sequences contain an ordered set of values of integral type
that can be specified with a low bound $l$, a high bound $h$, and a
stride $s$.  If the stride is negative, the values contained by the
arithmetic sequence are $h, h-s, h-2s, h-3s, ...$ such that all of the
values in the sequence are greater than $l$.  If the stride is
positive, the values contained by the arithmetic sequence are $l, l+s,
l+2s, l+3s, ...$ such that all of the values in the sequence are
less than $h$.

\index{arithmetic sequences!literals}
An arithmetic sequence is specified by the syntax
\begin{syntax}
arithmetic-sequence-literal:
  expression .. expression
\end{syntax}
The first expression is taken to be the lower bound, the second
expression is taken to be the upper bound.  The stride of the
arithmetic sequence is 1 and can be modified with the \chpl{by}
operator.

\index{arithmetic sequences!integral element type}
The element type of the arithmetic sequence type is determined by the
type of the low and high bound.  It is
either \chpl{int}, \chpl{uint}, \chpl{int(64)}, or \chpl{uint64}.  The
type is determined by conceptually adding the low and high bounds
together.

All operations supported over sequences are supported over arithmetic
sequences.  So arithmetic sequences can, for example, sequence promote
functions and be iterated over.  The result of the sequence promotion
is a sequence but not an arithmetic sequence.

\subsubsection{Strided Arithmetic Sequences}
\label{Strided_Arithmetic_Sequences}
\index{arithmetic sequences!strided}

The \chpl{by} operator can be applied to any arithmetic sequence to
create a strided arithmetic sequence.  It is predefined over an
arithmetic sequence and an integer to yield a new arithmetic sequence
that is strided by the integer.  Striding of strided sequences is
accomplished by multiplying the strides.

\subsubsection{Querying the Bounds and Stride of an Arithmetic Sequence}
\index{low@\chpl{low}}
\index{high@\chpl{high}}
\index{stride@\chpl{stride}}

\begin{protohead}
def $arithmetic\mbox{ }sequence$.low: eltType
def $arithmetic\mbox{ }sequence$.high: eltType
def $arithmetic\mbox{ }sequence$.stride: int
\end{protohead}
\begin{protobody}
These routines respectively return the low bound, the high bound, and
the stride of the arithmetic sequence.  The type of the returned low
and high bound is the element type of the arithmetic sequence.
\end{protobody}

\subsubsection{Indefinite Sequences}
\label{Indefinite_Sequences}
\index{arithmetic sequences!indefinite}

An indefinite arithmetic sequence is specified by the syntax
\begin{syntax}
indefinite-arithmetic-sequence-literal:
  expression ..
  .. expression
\end{syntax}

Indefinite arithmetic sequences can be iterated over with zipper
iteration and their shape conforms to the shape of the sequences they
are being iterated over.
\begin{example}
The code
\begin{chapel}
for i in (1..5, 3..) do
  write(i);
\end{chapel}
produces the output ``(1, 3)(2, 4)(3, 5)(4, 6)(5, 7)''.
\end{example}

It is an error to zip an indefinite arithmetic sequence with an
arithmetic sequence that does not have the same sign stride.

Indefinite arithmetic sequences can be used to index into arithmetic
sequences, sequences, arrays, and strings.  In thesse cases, the
elided bound conforms to the expression being indexed.
\begin{status}
Indexing by indefinite arithmetic sequences is not yet supported.
\end{status}
