\sekshun{Ranges}
\label{Ranges}
\index{ranges}

Chapel's ranges represent a sequence of integral values.  Ranges are
either \emph{bounded} or \emph{unbounded}.

Bounded ranges are characterized by a low bound~$l$, a high bound~$h$,
and a stride~$s$.  If the stride is positive, the values described by
the range are $l, l+s, l+2s, l+3s, ...$ such that all of the values in
the sequence are less than $h$.  If the stride is negative, the values
described by the range are $h, h-s, h-2s, h-3s, ...$ such that all of
the values in the sequence are greater than $l$.  If $l > h$, the
range is considered degenerate and represents an empty sequence.

Unbounded ranges are those in which the low and/or high bounds are
omitted.  Unbounded ranges conceptually represent a countably infinite
number of values.

\subsection{Range Types}
\label{Range_Types}
\index{ranges!types}

The type of a range in Chapel is characterized by three things:
(1)~the type of the values being represented, (2)~the boundedness of
the range, and (3)~whether or not the range is \emph{stridable}.

The type of the range's values is represented using a type parameter
named \emph{eltType}.  This must be one of Chapel's \chpl{int} or
\chpl{uint} types.

\begin{openissue}
It has been hypothesized that ranges of other types, such as floating
point values, might also be of interest to represent a range of legal
tolerances, for example.  If you believe such support would be of
interest to you, please let us know.
\end{openissue}

The boundedness of the range is represented using an enumerated
parameter named \emph{boundedType} of type \chpl{BoundedRangeType}.
Legal values are \chpl{bounded}, \chpl{boundedLow},
\chpl{boundedHigh}, and \chpl{boundedNone}.  The first value specifies
a bounded range while the other three values specify a range in which
the high bound is omitted, the low bound is omitted, or both bounds
are omitted, respectively.

The stridability of a range is represented by a boolean parameter
named \emph{stridable}.  If this parameter is set to true, the range
can represent any stride.  If set to false, the range's stride is
fixed to be the value 1.

\begin{rationale}
The \emph{boundedType} and \emph{stridable} values of a range are used
to optimize the generated code for common cases of ranges, as well as
to optimize the implementation of domains and arrays defined using
ranges.
\end{rationale}

\begin{example}
As an example, the following declaration declares a variable \chpl{r}
of range type that can represent ranges of 64-bit integers, with both
high and low bounds specified, and the ability to have a stride other
than 1.
\begin{chapel}
var r: range(int(64), bounded, stridable=true);
\end{chapel}
\end{example}

\subsection{Literal Range Values}
\label{Range_Literals}
\index{ranges!literals} 

Range literals are specified as follows:
\begin{syntax}
range-literal:
  bounded-range-literal
  unbounded-range-literal
\end{syntax}

\subsubsection{Bounded Range Literals}
\label{Bounded_Ranges}
\index{ranges!bounded}

A bounded range is specified by the syntax
\begin{syntax}
bounded-range-literal:
  expression .. expression
\end{syntax}
The first expression is taken to be the lower bound $l$ and the second
expression is taken to be the upper bound $h$.  The stride of the
range is 1 and can be modified with the \chpl{by} operator as described
in~\rsec{Strided_Ranges}.

\index{ranges!integral element type}
The element type of the range type is determined by the type of the
low and high bound.  It is either \chpl{int}, \chpl{uint},
\chpl{int(64)}, or \chpl{uint(64)}.  The type is determined by
conceptually adding the low and high bounds together.  The boundedness
of such a range is \chpl{bounded}.  The stridability of the range is
\chpl{false}.

\subsubsection{Unbounded Range Literals}
\label{Unbounded_Ranges}
\index{ranges!unbounded}

An unbounded range is specified by the syntax
\begin{syntax}
unbounded-range-literal:
  expression ..
  .. expression
  ..
\end{syntax}

The first form results in a \chpl{boundedLow} range, the second in a
\chpl{boundedHigh} range, and the third in a \chpl{boundedNone} range.

Unbounded ranges can be iterated over with zipper iteration and their
shape conforms to the shape of the other iterators they are being
iterated over with.
\begin{example}
The code
\begin{chapel}
for i in (1..5, 3..) do
  write(i, "; ");
\end{chapel}
produces the output ``(1, 3); (2, 4); (3, 5); (4, 6); (5, 7); ''.
\end{example}

It is an error to zip an unbounded range with a range that does not
have a stride with the same sign.

Unbounded ranges can also be used to index into ranges, domains,
arrays, and strings.  In these cases, elided bounds are inherited
from the bounds of the expression being indexed.


\subsection{Range Methods}
\index{low@\chpl{low}}
\index{high@\chpl{high}}
\index{stride@\chpl{stride}}

\begin{protohead}
def range.low: eltType
def range.high: eltType
def range.stride: int
\end{protohead}
\begin{protobody}
These routines respectively return the low bound, the high bound, and
the stride of the range.  The type of the returned low and high bound
is the element type of the range.
\end{protobody}


\subsection{Range Assignment}
\label{Range_Assignment}
\index{ranges!assignment}

Assigning one range to another results in its low, high, and stride
values being copied from the source range to the destination range.

In order for range assignment to be legal, the element type of the
source range must be implicitly coercible to the element type of the
destination range.  The two range types must have the same boundedness
parameter.  It is legal to assign a non-stridable range to a stridable
range, but illegal to assign a stridable range to a non-stridable
range unless the stridable range has a stride value of 1.


\subsection{Range Operators}
\label{Range_Operators}
\index{ranges!operators}

\subsubsection{By Operator}
\label{Strided_Ranges}
\index{ranges!strided}
\index{ranges!by operator}

The \chpl{by} operator can be applied to any range to create a strided
range.  Its syntax is as follows:

\begin{syntax}
expression `by' expression
\end{syntax}

The by operator takes a range and an integer to yield a new range that
is strided by the integer.  Striding a strided range results in a
stride whose value is the product of the two strides.

\subsubsection{Arithmetic Operators}
\label{Range_Arithmetic}
\index{ranges!arithmetic operators}

The following arithmetic operators are defined on ranges and integral
types:

\begin{chapel}
def +(r: range, s: integral): range
def +(s: integral, s: range): range
def -(r: range, s: integral): range
def -(s: integral, s: range): range
def *(r: range, s: integral): range
def *(s: integral, s: range): range
def /(r: range, s: integral): range
def /(s: integral, s: range): range
\end{chapel}

The \chpl{+} and \chpl{-} operators apply the scalar via the operator
to the range's low and high bounds, producing a shifted version of the
range.  The element type of the resulting range is based on the
element type of applying the operator to the input range's element
type and the scalar type.  The bounded and stridable parameters for
the result range are the same as for the input range.

The \chpl{*} and \chpl{/} operators apply the scalar via the operator
to the range's low and high bounds as well as to its stride value,
producing a shifted and scaled version of the range.  The element type
of the resulting range is based on the element type of applying the
operator to the range's element type and the scalar type.  The bounded
parameter for the result range is the same as for the input range.
The stridable parameter for the result range is always set to
\chpl{true}.

\begin{example}
The following code creates a bounded, non-stridable range \chpl{r}
which has an element type of \chpl{int} representing the values ${0,
  1, 2, 3}$.  It then uses the \chpl{*} and \chpl{+} operators to
create a second range \chpl{r2} representing the values ${1, 3, 5,
  7}$.  The \chpl{r2} range is bounded, stridable, and represents
values of type \chpl{int}
\begin{chapel}
var r = 0..3;
var r2 = (r * 2) + 1;
\end{chapel}
\end{example}


\subsubsection{Range Slicing}
\label{Range_Slicing}
\index{ranges!slicing}

Ranges can be \emph{sliced} using other ranges to create new
sub-ranges.  Range slicing is accomplished using either square
brackets or parenthesis using the following syntax:

\begin{syntax}
slice-expr:
  expression [ expression ]
  expression ( expression )
\end{syntax}

Where the first expression is the range being sliced and the second
expression is the range expressing the slice.  The resulting range
represents the intersection between the two ranges.  If the slicing
range is unbounded in one or both directions, it inherits its missing
bounds from the range being sliced.

\begin{example}
In the following example, \chpl{r} represents the integers from 1 to
10 inclusive.  Ranges \chpl{r2} and \chpl{r3} are defined using range
slices and represent the indices from 3 to 10 and the odd integers
between 1 and 10 respectively.
\begin{chapel}
var r = 1..10;
var r2 = r[3..];
var r3 = r[1.. by 2];
\end{chapel}
\end{example}

\subsubsection{Open Interval Notation}
\label{Open_Interval}
\index{ranges!open interval}

Chapel's \emph{open interval notation} uses the following syntax:

\begin{syntax}
open-interval-expr:
  [ expression )
\end{syntax}

This notation is a loose adaptation of mathematical notation for open
(upper) intervals in which the upper bound is not included in the
range.  For an argument range expression characterized by $l$, $h$,
and $s$, this syntax produces a range characterized by $l$, $h-1$ and
$s$.

\begin{rationale}
While this operator is pure syntactic sugar for subtracting one from a
range's upper bound, it is provided as a concession to C programmers
and others who prefer 0-based indexing to avoid having to write
declare ranges (and domains) using \chpl{0..n-1} all the time.  In its
place, [0..n) can be used.

Open intervals are not supported on lower bounds or on both upper and
lower bounds due to the syntactic ambiguities that they can result in
combined with the fact that these cases are not as important as the
above for 0-based programming.
\end{rationale}


\subsection{Predefined Functions and Methods on Ranges}
\index{ranges!predefined functions}

\begin{protohead}
def $range$.member(i: this.eltType): bool
\end{protohead}
\begin{protobody}
Returns whether or not \chpl{i} is in the range.
\end{protobody}

\begin{protohead}
def $range$.member(other: range): bool
\end{protohead}
\begin{protobody}
Returns whether or not every element in other is also in this.
\end{protobody}
