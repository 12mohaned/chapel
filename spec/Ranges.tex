\sekshun{Ranges}
\label{Ranges}
\index{ranges}

Chapel's ranges represent a sequence of integral values.  Ranges are
either \emph{bounded} or \emph{unbounded}.

Bounded ranges are characterized by a low bound~$l$, a high bound~$h$,
and a stride~$s$.  If the stride is positive, the values described by
the range are $l, l+s, l+2s, l+3s, ...$ such that all of the values in
the sequence are less than $h$.  If the stride is negative, the values
described by the range are $h, h-s, h-2s, h-3s, ...$ such that all of
the values in the sequence are greater than $l$.  If $l > h$, the
range is considered degenerate and represents an empty sequence.

Unbounded ranges are those in which the low and/or high bounds are
omitted.  Unbounded ranges conceptually represent a countably infinite
number of values.

\subsection{Range Types}
\label{Range_Types}
\index{ranges!types}

The type of a range in Chapel is characterized by three things:
(1)~the type of the values being represented, (2)~the boundedness of
the range, and (3)~whether or not the range is \emph{stridable}.

The type of the range's values is represented using a type parameter
named \emph{eltType}.  This must be one of Chapel's \chpl{int} or
\chpl{uint} types.  The default value is \chpl{int}.

\begin{openissue}
It has been hypothesized that ranges of other types, such as floating
point values, might also be of interest to represent a range of legal
tolerances, for example.  If you believe such support would be of
interest to you, please let us know.
\end{openissue}

The boundedness of the range is represented using an enumerated
parameter named \emph{boundedType} of type \chpl{BoundedRangeType}.
Legal values are \chpl{bounded}, \chpl{boundedLow},
\chpl{boundedHigh}, and \chpl{boundedNone}.  The first value specifies
a bounded range while the other three values specify a range in which
the high bound is omitted, the low bound is omitted, or both bounds
are omitted, respectively.  The default value is \chpl{bounded}.

The stridability of a range is represented by a boolean parameter
named \emph{stridable}.  If this parameter is set to true, the range
can represent any stride.  If set to false, the range's stride is
fixed to be the value 1.  The default value is \chpl{false}.

\begin{rationale}
The \emph{boundedType} and \emph{stridable} values of a range are used
to optimize the generated code for common cases of ranges, as well as
to optimize the implementation of domains and arrays defined using
ranges.
\end{rationale}

The syntax of a range type is summarized as follows:
\begin{syntax}
range-type:
  `range' ( named-expression-list )
\end{syntax}

\begin{example}
As an example, the following declaration declares a variable \chpl{r}
of range type that can represent ranges of 64-bit integers, with both
high and low bounds specified, and the ability to have a stride other
than 1.
\begin{chapel}
var r: range(int(64), BoundedRangeType.bounded, stridable=true);
\end{chapel}
\end{example}

The default value for a range is \chpl{1..0}.

\subsection{Literal Range Values}
\label{Range_Literals}
\index{ranges!literals} 

Range literals are specified as follows:
\begin{syntax}
range-literal:
  bounded-range-literal
  unbounded-range-literal
\end{syntax}

\subsubsection{Bounded Range Literals}
\label{Bounded_Ranges}
\index{ranges!bounded}

A bounded range is specified by the syntax
\begin{syntax}
bounded-range-literal:
  expression .. expression
\end{syntax}
The first expression is taken to be the lower bound $l$ and the second
expression is taken to be the upper bound $h$.  The stride of the
range is 1 and can be modified with the \chpl{by} operator as described
in~\rsec{Strided_Ranges}.

\index{ranges!integral element type}
The element type of the range type is determined by the type of the
low and high bound.  It is either \chpl{int}, \chpl{uint},
\chpl{int(64)}, or \chpl{uint(64)}.  The type is determined by
conceptually adding the low and high bounds together.  The boundedness
of such a range is \chpl{BoundedRangeType.bounded}.  The stridability of
the range is \chpl{false}.

\subsubsection{Unbounded Range Literals}
\label{Unbounded_Ranges}
\index{ranges!unbounded}

An unbounded range is specified by the syntax
\begin{syntax}
unbounded-range-literal:
  expression ..
  .. expression
  ..
\end{syntax}

The first form results in a \chpl{BoundedRangeType.boundedLow} range, the
second in a \chpl{BoundedRangeType.boundedHigh} range, and the third in
a \chpl{BoundedRangeType.boundedNone} range.

Unbounded ranges can be iterated over with zipper iteration and their
shape conforms to the shape of the other iterators they are being
iterated over with.
\begin{example}
The code
\begin{chapel}
for i in (1..5, 3..) do
  write(i, "; ");
\end{chapel}
produces the output ``(1, 3); (2, 4); (3, 5); (4, 6); (5, 7); ''.
\end{example}

It is an error to zip an unbounded range with a range that does not
have a stride with the same sign.

Unbounded ranges can also be used to index into ranges, domains,
arrays, and strings.  In these cases, elided bounds are inherited
from the bounds of the expression being indexed.

\subsection{Range Methods}
\index{low@\chpl{low}}
\index{high@\chpl{high}}
\index{stride@\chpl{stride}}

\begin{protohead}
def range.low: eltType
def range.high: eltType
def range.stride: int
\end{protohead}
\begin{protobody}
These routines respectively return the low bound, the high bound, and
the stride of the range.  The type of the returned low and high bound
is the element type of the range.
\end{protobody}


\subsection{Range Assignment}
\label{Range_Assignment}
\index{ranges!assignment}

Assigning one range to another results in its low, high, and stride
values being copied from the source range to the destination range.

In order for range assignment to be legal, the element type of the
source range must be implicitly coercible to the element type of the
destination range.  The two range types must have the same boundedness
parameter.  It is legal to assign a non-stridable range to a stridable
range, but illegal to assign a stridable range to a non-stridable
range unless the stridable range has a stride value of 1.


\subsection{Range Operators}
\label{Range_Operators}
\index{ranges!operators}

\subsubsection{By Operator}
\label{Strided_Ranges}
\index{ranges!strided}
\index{ranges!by operator}

The \chpl{by} operator can be applied to any range to create a strided
range.  Its syntax is as follows:

\begin{syntax}
expression `by' expression
\end{syntax}

The by operator takes a range and an integer to yield a new range that
is strided by the integer.  Striding a strided range results in a
stride whose value is the product of the two strides.

\begin{rationale}
{\it Why isn't the high bound specified first if the stride is
negative?}  The reason for this choice is that the \chpl{by} operator
is binary, not ternary.  Given a range \chpl{R} initialized
to \chpl{1..3}, we want \chpl{R by -1} to contain the ordered sequence
$3,2,1$.  But then \chpl{R by -1} would be different than \chpl{3..1
by -1} even though it should be identical by substituting the value in
R into the expression.
\end{rationale}

\subsubsection{Count Operator}
\label{Count_Operator}
\index{ranges!count operator}

The \chpl{#} operator can be applied to a range that has a high bound,
a low bound, or both.  Its syntax is:
\begin{syntax}
expression `#' expression
\end{syntax}

The \chpl{#} operator takes a range and an integral count and creates
a new range with count elements. The stride of the resulting range is
the same as that of the initial range. It is an error for the count to
be negative.  The \emph{eltType} of the resulting range is the same
type that would be obtained by adding the integral count value to the
range's \emph{eltType}.

When applied to a \chpl{BoundedRangeType.bounded} range with a positive
stride, the low bound count elements are taken starting from the low
bound. When the stride is negative, count elements are taken starting
from the high bound.

When applied to a \chpl{BoundedRangeType.boundedLow} range, the low bound
is fixed and and the high bound is set based on the count and the
absolute value of the stride.

When applied to a \chpl{BoundedRangeType.boundedHigh} range, the high
bound is fixed and the low bound is set based on the count and the
absolute value of the stride.

It is an error to apply the count operator to a
\chpl{BoundedRangeType.boundedNone} range.

\begin{example}
The following declarations result in equivalent ranges.
\begin{chapel}
var r = 2.. by -2 # 3;
var r2 = ..6 by -2 # 3;
var r3 = 0..6 by -2 # 3;
\end{chapel}
Each of these ranges represents the ordered set of three values: 6, 4, 2.
\end{example}

\subsubsection{Arithmetic Operators}
\label{Range_Arithmetic}
\index{ranges!arithmetic operators}

The following arithmetic operators are defined on ranges and integral
types:

\begin{chapel}
def +(r: range, s: integral): range
def +(s: integral, s: range): range
def -(r: range, s: integral): range
\end{chapel}

The \chpl{+} and \chpl{-} operators apply the scalar via the operator
to the range's low and high bounds, producing a shifted version of the
range.  The element type of the resulting range is based on the
element type of applying the operator to the input range's element
type and the scalar type.  The bounded and stridable parameters for
the result range are the same as for the input range.

\begin{example}
The following code creates a bounded, non-stridable range \chpl{r}
which has an element type of \chpl{int} representing the values ${0,
  1, 2, 3}$.  It then uses the \chpl{+} operator to
create a second range \chpl{r2} representing the values ${1, 2, 3,
  4}$.  The \chpl{r2} range is bounded, non-stridable, and represents
values of type \chpl{int}
\begin{chapel}
var r = 0..3;
var r2 = r + 1;
\end{chapel}
\end{example}


\subsubsection{Range Slicing}
\label{Range_Slicing}
\index{ranges!slicing}

Ranges can be \emph{sliced} using other ranges to create new
sub-ranges.  Range slicing is defined by using the range as a function
in a call expression where the argument is another range.  The
resulting range represents the intersection between the two ranges.
If the slicing range is unbounded in one or both directions, it
inherits its missing bounds from the range being sliced.

\begin{example}
In the following example, \chpl{r} represents the integers from 1 to
10 inclusive.  Ranges \chpl{r2} and \chpl{r3} are defined using range
slices and represent the indices from 3 to 10 and the odd integers
between 1 and 10 respectively.
\begin{chapel}
var r = 1..10;
var r2 = r[3..];
var r3 = r[1.. by 2];
\end{chapel}
\end{example}

\subsection{Predefined Functions and Methods on Ranges}
\index{ranges!predefined functions}

\begin{protohead}
def $range$.eltType type
\end{protohead}
\begin{protobody}
Returns the element type of the range.
\end{protobody}

\begin{protohead}
def $range$.boundedType param : BoundedRangeType
\end{protohead}
\begin{protobody}
Returns the boundedness of the range.
\end{protobody}

\begin{protohead}
def $range$.stridable param: bool
\end{protohead}
\begin{protobody}
Returns the stridable parameter of the range.
\end{protobody}

\begin{protohead}
def $range$.member(i: eltType): bool
\end{protohead}
\begin{protobody}
Returns whether or not \chpl{i} is in the range.
\end{protobody}

\begin{protohead}
def $range$.member(other: range): bool
\end{protohead}
\begin{protobody}
Returns whether or not every element in other is also in this.
\end{protobody}

\begin{protohead}
def $range$.order(i: eltType): eltType
\end{protohead}
\begin{protobody}
If \chpl{i} is a member of the range, returns an integer value giving
the ordinal value of \chpl{i} within the range using 0-based indexing.
Otherwise, it returns \chpl{(-1):eltType}.
\end{protobody}

\begin{example}
The following calls show the order of index 4 in each of the given
ranges:
\begin{chapel}
(0..10).order(4) == 4
(1..10).order(4) == 3
(3..5).order(4) == 1
(0..10 by 2).order(4) == 2
(3..5 by 2).order(4) == -1
\end{chapel}
\end{example}
