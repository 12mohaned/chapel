\sekshun{Domains}
\label{Domains}
\index{domains}

A \emph{domain} is a first-class representation of an index set.
Domains are used to specify iteration spaces, to define the size and
shape of arrays, and to specify operations on data aggregates like
slicing.  The indices described by a domain may be regular and
structured or they may less regular and unstructured.  Chapel also
supports the ability to create \emph{subdomains} and \emph{sparse
subdomains} to represent subsets of a domain's index set.  A domain's
indices may potentially be distributed across multiple locales as
described in~\rsec{Domain_Maps}, supporting global-view data
structures in Chapel.


\subsection{Domain Type Categories}
\label{Domain_Type_Categories}
\index{domains!type categories}

This section describes Chapel's taxonomy of domain types.

\subsubsection{Root Domains and Subdomains}

A domain is either a \emph{root domain} or a \emph{subdomain}.  A root
domain has no parent domain and can represent an arbitrary set of
indices of its index type.  A subdomain has an associated parent
domain and is constrained to only store indices that are also
described by its parent domain.  This is represented as follows:

\begin{syntax}
domain-type:
  root-domain-type
  subdomain-type
\end{syntax}

 \noindent Most of this chapter describes root domains.  Subdomains
 are described in ~\rsec{Subdomains}


\subsubsection{Regular and Irregular Domain Types}

Domain types can be thought of as falling into two major categories:
regular and irregular.  This is represented for root domain types as
follows:

\begin{syntax}
root-domain-type:
  regular-domain-type
  irregular-domain-type
\end{syntax}

Regular domains, known as \emph{arithmetic domains}, describe
multidimensional rectangular index sets.  They are characterized by a
tensor product of ranges and represent indices that are tuples of an
integral type.  Regular domains can be represented using $O(1)$ space.
They are used to represent standard multidimensional rectangular index
sets and arrays.

% TODO: Do we depend on the term arithmetic anywhere in the spec or
% code?

An irregular domain can store an arbitrary set of indices of an
arbitrary but homogenous index type.  Irregular domains typically
require space proportional to the number of indices being
representeed.

The two major classes of irregular domains in Chapel are associative
domains and opaque domains.

\begin{syntax}
irregular-domain-type:
  associative-domain-type
  opaque-domain-type
\end{syntax}

\noindent Associative domains represent an arbitrary set of indices
of a given type and can be used to describe sets or to create
dictionary-style arrays.  Opaque domains are those for which the
indices have no inherent logical names and are therefore anonymous.
They are useful for creating sets and for building unstructured
arrays, similar to pointer-based data structures in conventional
languages.

Sparse subdomains, described in~\rsec{Sparse_Subdomains}, are also
considered to be irregular domains.  A non-sparse subdomain inherits
the regularity or irregularity of its parent domain.



\subsection{Domain Types}
\label{Domain_Types}
\index{domains!types}

All domain types are characterized by the type of indices that they
store (see~\rsec{Index_Types} below).  The way in which these index
types are specified in the domain's type signature varies across
domain types.

\subsubsection{Arithmetic Domain Types}

Arithmetic domains are parameterized by three things:
\begin{itemize}

 \item \chpl{rank}, a positive \chpl{int} value indicating the number
of dimensions that the domain represents;

 \item \chpl{idxType}, a type member representing the index type for
each dimension.  If unspecified, \chpl{idxType} defaults
to \chpl{int}.

% BLC: we should potentially rename idxType to idxDimType to make it
% more consistent with the irregular case

 \item \chpl{stridable}, a \chpl{bool} value indicating whether or not
any of the domain's dimensions will be characterized by a strided
range.  If unspecified, \chpl{stridable} defaults to \chpl{false}.

\end{itemize}

If \chpl{rank} is $1$, the index type represented by an arithmetic
domain is \chpl{idxType}.  Otherwise, the index type is the homogenous
tuple type \chpl{rank*idxType}.

% BLC: longer-term, we've talked about potentially making it be
% rank*idxType even if rank is 1.

The syntax of an arithmetic domain type is summarized as follows:

\begin{syntax}
regular-domain-type:
  `domain' ( named-expression-list )
\end{syntax}

\noindent where \sntx{named-expression-list} permits the values of
\chpl{rank}, \chpl{idxType}, and \chpl{stridable} to be specified
using standard function call syntax.

\begin{example}
%
% PLACEHOLDER: INSERT EXAMPLE HERE
%
\end{example}


\subsubsection{Associative Domain Types}
\label{Associative_Domain_Types}
\index{domain types!associative}

An associative domain type is parameterized by \chpl{idxType}, the
type of the index that it stores.  The syntax is as follows:

\begin{syntax}
associative-domain-type:
  `domain' ( associative-index-type )

associative-index-type:
  type-specifier
\end{syntax}

%
% should there be an opt_idxTypeEquals in the domain type above?
%


If the \sntx{associative-index-type} is an enumerated type, the
associative domain is considered to be an \emph{enumerated domain
type} which differs in some key ways, described in subsequent
sections.

% TODO: is there a more explicit reference I could put here?

\subsubsection{Opaque Domain Types}

An opaque domain type is parameterized by the type \chpl{opaque},
indicating that the index values are anonymous and have no obvious
representational value.  The opaque domain type is given by the
following syntax:

\begin{syntax}
opaque-domain-type:
  `domain' ( `opaque' )
\end{syntax}

Opaque domains permit more efficient implementations than associative
domains under the assumption that creation of new domain index values
is rare.


\subsection{Domain Values}

This section describes the values and literal formats (if any) for
each root domain type.

\subsubsection{Arithmetic Domain Values}

An arithmetic domain's value is represented as \chpl{rank} ranges of
 type \chpl{range(idxType, BoundedRangeType.bounded, stridable)}.  The
 index set for a \chpl{rank}~1 domain is the set of indices described
 by its singleton range.  The index set for a \chpl{rank}-$n$ domain
 is the set of all \chpl{n*idxType} tuples described by the tensor
 product of its ranges.

Literal arithmetic domain values are represented by a comma-separated
list of range expressions of matching idxType surrounded by square
brackets:

%
% TODO: Is it correct that they must be matching?
%

\begin{syntax}
domain-literal:
  [ range-expression-list ]

range-expression-list:
  range-expression
  range-expression, range-expression-list

range-expression:
  expression
\end{syntax}

\noindent The type of an arithmetic domain literal is defined as follows:

\begin{itemize}

\item \chpl{rank} = the number of range expressions in the literal

\item \chpl{idxType} = the idxType of the range expressions

\item \chpl{stridable} = \chpl{true} if any of the range expressions
are stridable, otherwise false

\end{itemize}

\begin{example}
The expression \chpl{[1..5, 1..5]} defines an arithmetic domain with
type \chpl{domain(rank=2, idxType=int, strided=false)}.
\end{example}

\begin{example}
The expression \chpl{[1..5, 1..5]} defines a $5 \times 5$ arithmetic
domain with the indices $(1, 1), (1, 2), \ldots, (5, 5)$.
\end{example}

The default value of a range type is the \chpl{rank} default range
values for type \chpl{range(idxType, BoundedRangeType.bounded,
stridable)}.

% TODO: example here

\subsubsection{Associative Domain Values}

An associative domain's value is simply the unordered set of all index
values that the domain describes.

There is no literal syntax for an associative domain, though a tuple
of values of type \chpl{idxType} can be used to initialize a variable
of associative domain type.

% TODO: assign too?

The default value for an associative domain is the empty set unless
\chpl{idxType} is an enumerated type in which case the default value
is the set of all identifiers in the enumeration.

\begin{rationale}

The decision to have enumerated domains start fully populated was
based on the observation that enumerations have a finite, typically
small number of elements and that it would be common to declare arrays
with values corresponding to each identifier in the enumeration.

Moreover, we believe that constant enumerated domains will be amenable
to compiler optimization, particularly if the numeric values of the
enumeration are consecutive.
\end{rationale}


\subsubsection{Opaque Domain Values}

An opaque domain's value is simply the unordered set of anonymous
indices that the domain describes.

There is no literal syntax for an opaque domain due to the fact that
the indices have no inherent names.

The default value for an opaque domain is the empty set.


%%% STOPPED HERE

\subsection{Domain Assignment}
\label{Domain_Assignment}
\index{domains!assignment}

Domain assignment is by value.  If arrays are declared over a domain,
domain assignment impacts these arrays as discussed
in~\rsec{Association_of_Arrays_to_Domains}, but the arrays remain
associated with the same domain regardless of the assignment.


\subsection{Iteration over Domains}
\label{Iteration_over_Domains}

All domains support iteration via forall and for loops over the
indices in the set that the domain defines.  The type of the indices
returned by iterating over a domain is the index type of the domain.


\subsection{Arithmetic Domain Slicing}
\label{Arithmetic_Domain_Slicing}

Arithmetic domains support slicing by indexing into them specifying a
range per dimension.  Square brackets should be used for
multidimensional domains, while either square brackets or parenthesis
can be used for 1D domains.  

For multi-dimensional arithmetic domains, slicing with a rank change
is supported by substituting integral values within a dimension's
range for an actual range.  The resulting domain will have a rank less
than the arithmetic domain's rank and equal to the number of ranges
that are passed in to take the slice.

The result is a subdomain of the domain being sliced, as described
in~\rsec{Subdomains}, as defined by the intersection of the two
domains.  Partially unbounded or completely unbounded ranges may be
used to specify that the slice should extend to the domain's lower
and/or upper bound.

\begin{example}
The following code declares a 2D arithmetic domain \chpl{D}, and then
a number of subdomains of \chpl{D} by slicing into \chpl{D} using
bounded and unbounded ranges.  The \chpl{InnerD} domain describes the
inner indices of D, \chpl{Col2OfD} describes the 2nd column of
\chpl{D}, and \chpl{AllButLastRow} describes all of \chpl{D} except
for the last row.

\begin{chapel}
const D: domain(2) = [1..n, 1..n],
      InnerD = D[2..n-1, 2..n-1],
      Col2OfD = D[.., 2..2],
      AllButLastRow = D[..n-1, ..];
\end{chapel}
\end{example}


\subsection{Domain Promotion of Scalar Functions}
\label{Domain_Promotion_of_Scalar_Functions}
\index{domains!promotion}

Domain promotion of a scalar function is defined over the domain type
and the type of the indices of the domain (not the index type).

\begin{example}
Given an array \chpl{A} with element type \chpl{int} declared over a
one-dimensional domain \chpl{D} with integral type \chpl{int}, then
the array can be assigned the values given by the indices in the
domain by writing
\begin{chapel}
A = D;
\end{chapel}
\end{example}


\subsection{Domain Operators}

\subsubsection{Changing the Indices in Associative Domains}

As with sparse domains, indices can be added or removed to associative
domains.  Associative domains support a method \chpl{add} that takes
an index and adds this index to the associative domain.  All arrays
declared over this associative domain can now access elements
corresponding to this index.

Associative domains support a method \chpl{remove} that takes an index
and removes this index from the associative domain.  The values in the
arrays indexed by the removed index are lost.

The operators \chpl{+=} and \chpl{-=} have special semantics for
associative domains; they are interpreted as calls to the \chpl{add}
and \chpl{remove} methods respectively.  The statement
\begin{chapel}
D += i;
\end{chapel}
is equivalent to
\begin{chapel}
D.add(i);
\end{chapel}
Similarly, the statement
\begin{chapel}
D -= i;
\end{chapel}
is equivalent to
\begin{chapel}
D.remove(i);
\end{chapel}

Like sparse domains, associative domains can be emptied by using a
method \chpl{clear} that clears out its index set.

\begin{example}
The following call will cause the associative domain \chpl{HashD} to
describe an empty set of indices as it was when initially declared.
\begin{chapel}
HashD.clear();
\end{chapel}
\end{example}

\subsubsection{Testing Membership in Associative Domains}

An associative domain supports a \chpl{member} method that can test
whether a particular value is part of the index set. It
returns \chpl{true} if the index is in the associative domain and
otherwise returns \chpl{false}.


\subsection{By Operator}
\label{By_Operator_For_Domains}

The \chpl{by} operator can be applied to any arithmetic domain to
create a strided arithmetic domain.  It is predefined over an
arithmetic domain and an integer or a tuple of integers.  In the
integer case, the ranges in each dimension are strided by the integer.
In the tuple of integers case, the size of the tuple must match the
rank of the domain; the integers stride each dimension of the domain.
If the ranges are already strided, the strides applied by
the \chpl{by} operator are multiplied to the strides of the ranges.


\begin{example}
In the code
\begin{chapel}
var D: domain(2) = [1..n, 1..n];
\end{chapel}
\chpl{D} is defined as a two-dimensional arithmetic domain and is
initialized to contain the set of indices $(i,j)$ for all $i$ and $j$
such that $i \in {1, 2, \ldots, n}$ and $j \in {1, 2, \ldots, n}$.
\end{example}


\subsection{Formal Arguments of Domain Type}
\label{Formal_Arguments_of_Domain_Type}
\index{formal arguments!domains}
\index{domains!as formal arguments}

Domains are passed to functions by reference.  Formal arguments that
receive domains are aliases of the actual arguments.  It is a
compile-time error to pass a domain to a formal argument that has a
non-blank intent.

\subsection{Index Types}
\label{Index_Types}
\index{domains!index types}

Each domain has a corresponding \emph{index} type which is the type of
the domain's indices qualified by its status as an index.  Variables
of this type can be declared using the following syntax:
\begin{syntax}
index-type:
  `index' ( domain-expression )
\end{syntax}
If the type of the indices of the domain is \chpl{int}, then the index
type can be converted into this type.

A value with a type that is the same as the type of the indices in a
domain but is not the index type can be converted into the index type
using a special ``method'' called \chpl{index}.

\begin{example}
In the code
\begin{chapel}
var j = D.index(i);
\end{chapel}
the type of the variable \chpl{j} is the index type of
domain \chpl{D}.  The variable \chpl{i}, which must have the same type
as the underlying type of the indices of \chpl{D}, is verified to be
in domain \chpl{D} before it is assigned to \chpl{j}.
\end{example}

Values of index type are known to be valid and may have specialized
representations to facilitate accessing arrays defined for that
domain. It may therefore be less expensive to access arrays using
values of appropriate index type rather than values of the more
general type the domain is defined over.

\subsection{Subdomains}
\label{Subdomains}
\index{subdomains}
\index{domains!subdomains}

A subdomain is a domain whose indices are a subset of those described
by a \emph{base domain}.  A subdomain is specified by the following
syntax:
\begin{syntax}
subdomain-type:
  `subdomain' ( domain-expression )
  sparse-subdomain-type
\end{syntax}
The ordering of the indices in the subdomain is consistent with the
ordering of the indices in the base domain.

Subdomains are verified during execution even as domains are
reassigned.  The indices in a subdomain are known to be indices in a
domain, allowing for fast bounds-checking.

\subsection{Sparse Subdomains}
\label{Sparse_Subdomains}
\index{domains!sparse}
\index{subdomains!sparse}

Sparse domains are used in Chapel to describe irregular index subsets
and to define sparse arrays.  Sparse arrays are typically used to
represent data aggregates in which a value occurs so frequently that
it would be wasteful to store it explicitly for each occurrence.  This
value is commonly described as the ``zero value'', though we refer to
it as the \emph{implicitly replicated value} or \emph{IRV} since it
may be a value other than zero.

\subsubsection{Sparse Domain Types}

A sparse domain type is specified by the syntax
\begin{syntax}
sparse-subdomain-type:
  `sparse' `subdomain' ( domain-expression )
\end{syntax}
This syntax specifies that the domain is a sparse subset of the
indices in the domain specified by the \sntx{domain-expression},
sometimes called the \emph{base domain} or \emph{parent domain}.

\begin{example}
The following code declares a 2D dense domain \chpl{D}, followed by a
2D sparse subdomain of \chpl{D} named \chpl{SpsD}.  Since \chpl{SpsD}
is uninitialized, it will initially describe the empty set of indices
from \chpl{D}.
\begin{chapel}
const D: domain(2) = [1..n, 1..n];
var SpsD: sparse subdomain(D);
\end{chapel}
\end{example}


\subsubsection{Sparse Domain Assignment}

Sparse domains can be assigned aggregates of indices from their parent
domain.  Common methods for expressing such aggregates are to use a
tuple of indices, a forall expression that enumerates indices, or an
iterator that generates indices.

\begin{example}
The following three assignments show ways of assigning indices to a
sparse domain, \chpl{SpsD}.  The first assigns the domain two index
values, \chpl{(1,1)} and \chpl{(n,n)}.  The second assigns the domain
all of the indices along the diagonal from
\chpl{(1,1)}$\ldots$\chpl{(n,n)}.  The third invokes an iterator that
is written to \chpl{yield} indices read from a file named
``inds.dat''.  Each of these assignments has the effect of replacing
the previous index set with a completely new set of values.
\begin{chapel}
SpsD = ((1,1), (n,n));
SpsD = [i in 1..n] (i,i);
SpsD = readIndicesFromFile("inds.dat");
\end{chapel}
\end{example}

Sparse domains can be emptied by using a method \chpl{clear} that
clears out its index set.

\begin{example}
The following call will cause the sparse domain \chpl{SpsD} to
describe an empty set of indices as it was when initially declared.
\begin{chapel}
SpsD.clear();
\end{chapel}
\end{example}

As with other domain types, reassigning a domain's index set will
cause arrays declared in terms of that domain to store elements
corresponding to the new indices of the domain.  These elements will
be initialized to the array's IRV by default.



\subsubsection{Modifying a Sparse Domain}

Indices can be incrementally added to or removed from sparse domains.
Sparse domains support a method \chpl{add} that takes an index and
adds it to the sparse domain's index set.  All arrays declared over
this sparse domain will now store an element corresponding to this
index, initialized to be its IRV.

Sparse domains support a method \chpl{remove} that takes an index and
removes this index from the sparse domain.  The values in the arrays
indexed by the removed index are lost.

The operators \chpl{+=} and \chpl{-=} have special semantics for
sparse domains; they are interpreted as calls to the \chpl{add}
and \chpl{remove} methods respectively.  The statement
\begin{chapel}
D += i;
\end{chapel}
is equivalent to
\begin{chapel}
D.add(i);
\end{chapel}
Similarly, the statement
\begin{chapel}
D -= i;
\end{chapel}
is equivalent to
\begin{chapel}
D.remove(i);
\end{chapel}

As with other methods and operators, the \chpl{add}, \chpl{remove},
\chpl{+=}, and \chpl{-=} operators can be invoked in a promoted manner
by specifying an aggregate of indices rather than a single index at a
time.

\subsection{Predefined Functions and Methods on Domains}
\index{domains!predefined functions}

There is an expectation that this list of predefined functions and
methods will grow.

\begin{protohead}
def $Domain$.numIndices: dim_type
\end{protohead}
\begin{protobody}
Returns the number of indices in the domain.
\end{protobody}

\begin{protohead}
def $Domain$.member(i: index($Domain$)): bool
\end{protohead}
\begin{protobody}
Returns whether or not index \chpl{i} is a member of the domain's
index set.
\end{protobody}

\begin{protohead}
def $Domain$.order(i: index($Domain$)): dim_type
\end{protohead}
\begin{protobody}
If \chpl{i} is a member of the domain, returns the ordinal value of
\chpl{i} using a total ordering of the domain's indices using 0-based
indexing.  Otherwise, it returns \chpl{(-1):dim_type}.  For arithmetic
domains, this ordering will be based on a row-major ordering of the
indices; for other domains, the ordering may be
implementation-dependent and unstable as elements are added and
removed from the domain.
\end{protobody}


\subsubsection{Predefined Functions and Methods on Arithmetic Domains}

We expect that this list of predefined functions and methods will
grow.

\begin{protohead}
def $Domain$.rank param
\end{protohead}
\begin{protobody}
Returns the rank of the domain.
\end{protobody}

\begin{protohead}
def $Domain$.dim(d: int): range
\end{protohead}
\begin{protobody}
Returns the range of indices described by dimension \chpl{d} of the
domain.
\end{protobody}

\begin{example}
In the code
\begin{chapel}
for i in D.dim(1) do
  for j in D.dim(2) do
    writeln(A(i,j));
\end{chapel}
domain \chpl{D} is iterated over by two nested loops.  The first
dimension of \chpl{D} is iterated over in the outer loop.  The second
dimension is iterated over in the inner loop.
\end{example}

% BLC: ``integral'' isn't really correct in the two 1D cases below,
% however, we don't really seem to have a user-level name for the
% per-dimension index type in the language that I can see.

\begin{protohead}
def $Domain$.low: $integral$        // for 1D domains
def $Domain$.low: index($Domain$)   // for multidimensional domains
\end{protohead}
\begin{protobody}
Returns the low index of the domain as a scalar value for 1D domains
and as an index value for a multidimensional domain.
\end{protobody}

\begin{protohead}
def $Domain$.high: $integral$        // for 1D domains
def $Domain$.high: index($Domain$)   // for multidimensional domains
\end{protohead}
\begin{protobody}
Returns the high index of the domain as a scalar value for 1D domains
and as an index value for a multidimensional domain.
\end{protobody}

\begin{protohead}
def $Domain$.position(i: index($Domain$)): rank*dim_type
\end{protohead}
\begin{protobody}
Returns a tuple holding the order of index i in each range defining
the domain.
\end{protobody}


%
% TODO: 
% Storage format
% Index entries
