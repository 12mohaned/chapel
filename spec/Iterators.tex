\sekshun{Iterators}
\label{Iterators}
\index{iterators}

An iterator is a function that conceptually returns multiple values
rather than simply a single value.

\begin{openissue}
The parallel iterator story is under development.  It is expected that
the specification will be expanded regarding parallel iterators soon.
\end{openissue}

\subsection{Iterator Functions}
\label{Iterator_Functions}

The syntax of an iterator declaration is identical to that of a
function declaration.  A function is an iterator if it includes yield
statements.  When a yield is encountered, the value is returned, but
the iterator is not finished evaluating when called within a loop.  It
will continue from the point after the yield and can yield or return
more values.  When a return is encountered, the value is returned and
the iterator finishes.  An iterator also completes after the last
statement in the iterator function is executed.

\subsection{The Yield Statement}
\label{The_Yield_Statement}
\index{yield@\chpl{yield}}

The yield statements can only appear in iterators.  The syntax of the
yield statement is given by
\begin{syntax}
yield-statement:
  `yield' expression ;
\end{syntax}

\subsection{Iterator Calls}
\label{Iterator_Calls}

Iterator functions can be called within for or forall loops, in which
case they are executed in an interleaved manner with the body of the
loop, can be captured in new variable declarations or arrays, in which
case they evaluate to an array of values, or can be passed to a
generic function argument.

\subsubsection{Iterators in For and Forall Loops}
\label{Iterators_in_For_and_Forall_Loops}

When an iterator is accessed via a for or forall loop, the iterator is
evaluated alongside the loop body in an interleaved manner.  For each
iteration, the iterator yields a value and the body is executed.

\subsubsection{Iterators as Arrays}
\label{Iterators_as_Arrays}
\index{iterators!and arrays}

If an iterator function is captured into a new variable declaration or
assigned to an array, the iterator is iterated over in total and the
expression evaluates to a one-dimensional arithmetic array that
contains the values returned by the iterator on each iteration.
\begin{example}
Given an iterator
\begin{chapel}
def squares(n: int): int {
  for i in 1..n do
    yield i * i;
}
\end{chapel}
the expression \chpl{squares(5)} evaluates to the array \chpl{1, 4, 9, 16, 25}.
\end{example}

\subsubsection{Iterators and Generics}
\label{Iterators_and_Generics}
\index{iterators!and generics}

If an iterator call expression is passed to a function argument that
is generic, the iterator is passed without being evaluated and is
treated as a closure within the generic function.

\subsection{Scalar Promotion}
\label{Scalar_Promotion}

A function requires scalar promotion if an iterator (or array, domain,
or range) is passed to a formal argument with a type that allows the
yielded type of the iterator to dispatch to the formal argument.  In
the case of arrays, the yielded type is the element type.  In the case
of domains and ranges, the yielded type is the index type.  The rules
of when an overloaded function is promoted are discussed
in~\rsec{Function_Resolution}.  If a promoted function returns a
value, the promoted function becomes an iterator that is controlled by
a loop over the iterator (or array, domain, or range) that it is
promoted by.  If the function does not return a value, the function is
controlled by a loop over the iterator that it is promoted by, but the
promotion does not become an iterator.

In addition to scalar promotion of functions, operators and casts are
also promoted.

\begin{example}
Given an iterator
\begin{chapel}
def oneToFive() {
  for i in 1..5 do
    yield i;
}
\end{chapel}
and a function
\begin{chapel}
def square(x: int) return x**2;
\end{chapel}
then the call \chpl{square(oneToFive())} results in the promotion of
the \chpl{square} function over the values returned by
the \chpl{oneToFive} iterator.  The result is an iterator that returns
the values \chpl{1}, \chpl{4}, \chpl{9}, \chpl{16}, and \chpl{25}.
Instead of using the \chpl{oneToFive} iterator to promote
the \chpl{square} function, the range \chpl{1..5} could be used
directly as in \chpl{square(1..5)}.  Also note that operator
invocations are treated as function calls in terms of promotion
so \chpl{(1..5)**2} is also equivalent.
\end{example}

\subsubsection{Zipper Promotion}
\label{Zipper_Promotion}
\index{scalar promotion!zipper iteration}

Consider a function \chpl{f} with formal
arguments \chpl{s1}, \chpl{s2},~... that are promoted and formal
arguments \chpl{a1}, \chpl{a2},~... that are not promoted.  The call
\begin{chapel}
f(s1, s2, ..., a1, a2, ...)
\end{chapel}
is equivalent to
\begin{chapel}
[(e1, e2, ...) in (s1, s2, ...)] f(e1, e2, ..., a1, a2, ...)
\end{chapel}
The usual constraints of zipper iteration apply to zipper promotion so
the promoted actuals must have the same shape.

\begin{example}
Given a function defined as
\begin{chapel}
def foo(i: int, j: int) {
  write(i, " ", j, " ");
}
\end{chapel}
and a call to this function written
\begin{chapel}
foo(1..3, 4..6);
\end{chapel}
then the output is ``1 4 2 5 3 6 ''.
\end{example}

\subsubsection{Tensor Product Promotion}
\label{Tensor_Product_Promotion}
\index{scalar promotion!tensor product iteration}

If the function \chpl{f} were called by using square brackets instead
of parentheses, the equivalent rewrite would be
\begin{chapel}
[(e1, e2, ...) in [s1, s2, ...]] f(e1, e2, ..., a1, a2, ...)
\end{chapel}
There are no constraints on tensor product promotion.

\begin{example}
Given a function defined as
\begin{chapel}
def foo(i: int, j: int) {
  write(i, " ", j, " ");
}
\end{chapel}
and a call to this function written
\begin{chapel}
foo[1..3, 4..6];
\end{chapel}
then the output is ``1 4 1 5 1 6 2 4 2 5 2 6 3 4 3 5 3 6 ''.
\end{example}

\subsubsection{Promotion and Evaluation Order}

The evaluation of an iterator is interleaved with the evaluation of
the promoted expression or function.  The values produced by the
iterator are not evaluated first.  This means that the array semantics
of array programming languages are not maintained.

\begin{example}
If \chpl{A} is an array declared over the indices \chpl{1..5}, then
the following codes are not equivalent:
\begin{chapel}
A[2..4] = A[1..3] + A[3..5];
\end{chapel}
and
\begin{chapel}
var T = A[1..3] + A[3..5];
A[2..4] = T;
\end{chapel}
This follows because, in the former code, some of the new values that
are assigned to \chpl{A} may be read to compute the sum depending on
the amount of concurrency in the promotion.
\end{example}
