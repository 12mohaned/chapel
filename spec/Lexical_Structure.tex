\sekshun{Lexical Structure}
\label{Lexical_Structure}

This section describes the lexical components of Chapel programs.

\subsection{Comments}
\label{Comments}
\index{comments}

Two forms of comments are supported.  All text following the
consecutive characters {\tt //} and before the end of the line is in a
comment.  All text following the consecutive characters {\tt /*} and
before the consecutive characters {\tt */} is in a comment.

Comments, including the characters that delimit them, are ignored by
the compiler.  If the delimiters that start the comments appear within
a string literal, they do not start a comment but rather are part of
the string literal.

\subsection{White Space}
\label{White_Space}
\index{white space}

White-space characters are spaces, tabs, and new-lines.  Aside from
delimiting comments and tokens, they are ignored by the compiler.

\subsection{Case Sensitivity}
\label{Case_Sensitivity}
\index{case sensitivity}

Chapel is a case sensitive language so identifiers that are identical
except of the case of the characters are still different.

\subsection{Tokens}
\label{Tokens}

Tokens include identifiers, keywords, literals, operators, and
punctuation.

The productions in this section are lexical so the components are not
delimited by white space.

\subsubsection{Identifiers}
\label{Identifiers}
\index{identifiers}

An identifier in Chapel is a sequence of characters that must start
with a letter, lower-case or upper-case, or an underscore, and can
include lower-case letters, upper-case letters, digits, and the
underscore.
\begin{syntax}
identifier:
  legal-first-identifier-char legal-identifier-chars[OPT]

legal-first-identifier-char: one of
  `_' `A' `B' `C' `D' `E' `F' `G' `H' `I' `J' `K' `L' `M' `N' `O' `P' `Q' `R' `S' `T' `U' `V' `W' `X' `Y' `Z' `a' `b' `c' `d' `e' `f' `g' `h' `i' `j' `k' `l' `m' `n' `o' `p' `q' `r' `s' `t' `u' `v' `w' `x' `y' `z'

legal-identifier-chars:
  legal-identifier-char legal-identifier-chars[OPT]

legal-identifier-char:
  legal-first-identifier-char
  digit

digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7' `8' `9'
\end{syntax}

\begin{example}
The following are legal identifiers:
\begin{chapel}
  x, x1e, xt3, legalChapelIdentifier, legal_chapel_identifier
\end{chapel}
\end{example}

\subsubsection{Keywords}
\label{Keywords}
\index{keywords}
\index{reserved words}

The following keywords are reserved:

\begin{tabular}{lllll}
\begin{chapel}
atomic
begin
break
by
class
cobegin
coforall
compilerError
config
const
continue
\end{chapel} & \begin{chapel}
def
distributed
do
domain
else
enum
for
forall
goto
if
in
\end{chapel} & \begin{chapel}
index
inout
label
let
module
nil
of
on          
ordered
otherwise
out
\end{chapel} & \begin{chapel}
param
pragma
record      
reduce      
return      
scan        
select
serial      
single      
sparse
subdomain
\end{chapel} & \begin{chapel}
sync        
then        
type        
union       
use         
var
when        
where       
while       
yield
\end{chapel} \\
\begin{invisible}
compilerError
\end{invisible} & \begin{invisible}
compilerError
\end{invisible} & \begin{invisible}
compilerError
\end{invisible} & \begin{invisible}
compilerError
\end{invisible} & \begin{invisible}
compilerError
\end{invisible}
\end{tabular}


\subsubsection{Literals}
\label{Literals}
\label{Primitive_Type_Literals}

\index{literals!primitive type}
Bool literals are designated by the following syntax:
\begin{syntax}
bool-literal: one of
  `true' `false'
\end{syntax}

Signed and unsigned integer literals are designated by the following
syntax:
\begin{syntax}
integer-literal:
  digits
  `0' `x' hexadecimal-digits
  `0' `b' binary-digits

digits:
  digit
  digit digits

hexadecimal-digits:
  hexadecimal-digit
  hexadecimal-digit hexadecimal-digits

hexadecimal-digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7' `8' `9' `A' `B' `C' `D' `E' `F' `a' `b' `c' `d' `e' `f'

binary-digits:
  binary-digit
  binary-digit binary-digits

binary-digit: one of
  `0' `1'
\end{syntax}
Suffixes, like those in C, are not necessary.  The type of an integer
literal is the first type of the following that can hold the value of
the digits: \chpl{int}, \chpl{int(64)}, \chpl{uint(64)}.  Explicit
conversions are necessary to change the type of the literal to another
integer size.

Real literals are designated by the following syntax:
\begin{syntax}
real-literal:
  digits[OPT] . digits exponent-part[OPT]
  digits exponent-part

exponent-part:
  `e' sign[OPT] digits

sign: one of
  + -
\end{syntax}
The type of a real literal is \chpl{real}.  Explicit conversions are
necessary to change the type of the literal to another real
size.

Note that real literals require that a digit follow the
decimal point.  This is necessary to avoid an ambiguity in
interpreting \chpl{2.e+2} that arises if a method called \chpl{e} is
defined on integers.

Imaginary literals are designated by the following syntax:
\begin{syntax}
imaginary-literal:
  real-literal `i'
  integer-literal `i'
\end{syntax}

A complex literal is specified by adding or subtracting an imaginary
literal with a real literal.  Alternatively, a 2-tuple literal of
expressions of integer or real type can be cast to a complex.  These
expressions can be literals, but do not need to be.  To create a
complex literal or parameter, they must be literals or parameters.

\begin{example}
The following codes represent the same complex literal:
\begin{center}
\chpl{2.0i}, \hspace{1pc} \chpl{0.0+2.0i}, \hspace{1pc}
\chpl{(0.0,2.0):complex}.
\end{center}
\end{example}

String literals are designated by the following syntax:
\begin{syntax}
string-literal:
  " characters[OPT] "
  ' characters[OPT] '

characters:
  character
  character characters

character:
  any-character
\end{syntax}

\begin{status}
Strings are currently restricted to ASCII characters.  In a future
version of Chapel, strings will be defined over alphabets to allow for
more exotic characters.
\end{status}

\subsubsection{Operators and Punctuation}
\label{Operators_and_Punctuation}

The following special characters are interpreted by the syntax of the
language specially:
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf symbols} & {\bf use} \\
\hline
\verb@= += -= *= /= **= %= &= |= ^= &&= ||= <<= >>=@ & assignment \\
\verb@<=>@ & swap operator \\
\verb@..@ & ranges \\
\verb@...@ & variable argument lists \\
\verb@&& || !@ & logical operators \\
\verb@& | ^ ~ << >>@ & bitwise operators \\
\verb@== != <= >= < >@ & relational operators \\
\verb@+ - * / % **@ & arithmetic operators \\
\verb@:@ & types \\
\verb@;@ & statement separator \\
\verb@,@ & expression separator \\
\verb@.@ & member access \\
\verb@?@ & query types \\
\verb@" '@ & string delimiters \\
\hline
\end{tabular}
\end{center}

\subsubsection{Grouping Tokens}
\label{Grouping_Tokens}

The following braces are part of the Chapel language:
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf braces} & {\bf use} \\
\hline
\verb@( )@ & parenthesization, function calls, and tuples \\
\verb@[ ]@ & domains, square tuples, forall expressions, and function calls \\
\verb@{ }@ & type scopes and blocks \\
\hline
\end{tabular}
\end{center}
