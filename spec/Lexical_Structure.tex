\sekshun{Lexical Structure}
\label{Lexical_Structure}

This section describes the lexical components of Chapel programs.

\subsection{Comments}
\label{Comments}
\index{comments}

Two forms of comments are supported.  All text following the
consecutive characters {\tt //} and before the end of the line is in a
comment.  All text following the consecutive characters {\tt /*} and
before the consecutive characters {\tt */} is in a comment.

Comments, including the characters that delimit them, are ignored by
the compiler.  If the delimiters that start the comments appear within
a string literal, they do not start a comment but rather are part of
the string literal.

\subsection{White Space}
\label{White_Space}
\index{white space}

White-space characters are spaces, tabs, and new-lines.  Aside from
delimiting comments and tokens, they are ignored by the compiler.

\subsection{Case Sensitivity}
\label{Case_Sensitivity}
\index{case sensitivity}

Chapel is a case sensitive language so identifiers that are identical
except of the case of the characters are still different.

\subsection{Tokens}
\label{Tokens}

Tokens include identifiers, keywords, literals, operators, and
punctuation.

\subsubsection{Identifiers}
\label{Identifiers}
\index{identifiers}

An identifier in Chapel is a sequence of characters that must start
with a letter, lower-case or upper-case, or an underscore, and can
include lower-case letters, upper-case letters, digits, and the
underscore.
\begin{example}
The following are legal identifiers:
\begin{chapel}
  x, x1e, xt3, legalChapelIdentifier, legal_chapel_identifier
\end{chapel}
\end{example}

\subsubsection{Keywords}
\label{Keywords}
\index{keywords}
\index{reserved words}

The following keywords are reserved:

\begin{tabular}{lllll}
\begin{chapel}
atomic
begin
break
by
class
cobegin
coforall
compilerError
config
const
continue
\end{chapel} & \begin{chapel}
def
distributed
do
domain
else
enum
for
forall
goto
if
in
\end{chapel} & \begin{chapel}
index
inout
label
let
module
nil
of
on          
ordered
otherwise
out
\end{chapel} & \begin{chapel}
param
pragma
record      
reduce      
return      
scan        
select
serial      
single      
sparse
subdomain
\end{chapel} & \begin{chapel}
sync        
then        
type        
union       
use         
var
when        
where       
while       
yield
\end{chapel} \\
\begin{invisible}
compilerError
\end{invisible} & \begin{invisible}
compilerError
\end{invisible} & \begin{invisible}
compilerError
\end{invisible} & \begin{invisible}
compilerError
\end{invisible} & \begin{invisible}
compilerError
\end{invisible}
\end{tabular}


\subsubsection{Literals}
\label{Literals}

Literal values for primitive types are described
in~\ref{Primitive_Type_Literals}.

\subsubsection{Operators and Punctuation}
\label{Operators_and_Punctuation}

The following special characters are interpreted by the syntax of the
language specially:
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf symbols} & {\bf use} \\
\hline
\verb@= += -= *= /= **= %= &= |= ^= &&= ||= <<= >>=@ & assignment \\
\verb@<=>@ & swap operator \\
\verb@..@ & ranges \\
\verb@...@ & variable argument lists \\
\verb@&& || !@ & logical operators \\
\verb@& | ^ ~ << >>@ & bitwise operators \\
\verb@== != <= >= < >@ & relational operators \\
\verb@+ - * / % **@ & arithmetic operators \\
\verb@:@ & types \\
\verb@;@ & statement separator \\
\verb@,@ & expression separator \\
\verb@.@ & member access \\
\verb@?@ & query types \\
\verb@" '@ & string delimiters \\
\hline
\end{tabular}
\end{center}

\subsubsection{Grouping Tokens}
\label{Grouping_Tokens}

The following braces are part of the Chapel language:
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf braces} & {\bf use} \\
\hline
\verb@( )@ & parenthesization, function calls, and tuples \\
\verb@[ ]@ & domains, square tuples, forall expressions, and function calls \\
\verb@{ }@ & type scopes and blocks \\
\hline
\end{tabular}
\end{center}

\subsection{User-Defined Compiler Errors}
\label{User-Defined_Compiler_Errors}
\index{compiler errors!user-defined}

The special compiler error statement given by
\begin{syntax}
compiler-error-statement:
  `compilerError' ( expression-list ) ;

expression-list:
  expression
  expression , expression-list
\end{syntax}
invokes a compiler error if the function that the statement is located
within may be called when the program is executed and the statement is
not eliminated by parameter folding.

The compiler error is defined by the expression list which can contain
string literals and types.  The error points to the spot in the Chapel
program where the function containing
the \sntx{compiler-error-statement} is called from.
