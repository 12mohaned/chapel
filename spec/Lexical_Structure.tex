\sekshun{Lexical Structure}
\label{Lexical_Structure}

This section describes the lexical components of Chapel programs.

\subsection{Comments}
\label{Comments}
\index{comments}

Two forms of comments are supported.  All text following the
consecutive characters {\tt //} and before the end of the line is in a
comment.  All text following the consecutive characters {\tt /*} and
before the consecutive characters {\tt */} is in a comment.

Comments, including the characters that delimit them, are ignored by
the compiler.  If the delimiters that start the comments appear within
a string literal, they do not start a comment but rather are part of
the string literal.

\subsection{White Space}
\label{White_Space}
\index{white space}

White-space characters are spaces, tabs, and new-lines.  Aside from
delimiting comments and tokens, they are ignored by the compiler.

\subsection{Case Sensitivity}
\label{Case_Sensitivity}
\index{case sensitivity}

Chapel is a case sensitive language so identifiers that are identical
except for the case of the characters are considered different.

\subsection{Tokens}
\label{Tokens}

Tokens include identifiers, keywords, literals, operators, and
punctuation.

The productions in this section are lexical so the components are not
delimited by white space.

\subsubsection{Identifiers}
\label{Identifiers}
\index{identifiers}

An identifier in Chapel is a sequence of characters that must start
with a letter, lower-case or upper-case, an underscore, or a dollar
sign, and can include lower-case letters, upper-case letters, digits,
and the underscore.
\begin{syntax}
identifier:
  legal-first-identifier-char legal-identifier-chars[OPT]

legal-first-identifier-char: one of
  `_' `$\mbox{{\bf \$}}$' `A' `B' `C' `D' `E' `F' `G' `H' `I' `J' `K' `L' `M' `N' `O' `P' `Q' `R' `S' `T' `U' `V' `W' `X' `Y' `Z' `a' `b' `c' `d' `e' `f' `g' `h' `i' `j' `k' `l' `m'
                           `n' `o' `p' `q' `r' `s' `t' `u' `v' `w' `x' `y' `z'

legal-identifier-chars:
  legal-identifier-char legal-identifier-chars[OPT]

legal-identifier-char:
  legal-first-identifier-char
  digit

digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7' `8' `9'
\end{syntax}

\begin{rationale}
The inclusion of the \$ character is meant to assist programmers using
sync and single variables by presenting a style (a \$ at the end
of such variables) in order to help write properly synchronized code.
It is felt that making such variables ``stand out'' is useful since
such variables could result in deadlocks.
\end{rationale}

\begin{example}
The following are legal identifiers:
\begin{chapel}
  CX1, XT5, XMT, syncvar$\mbox{{\bf \$}}$, legalIdentifier, legal_identifier
\end{chapel}
\end{example}

\subsubsection{Keywords}
\label{Keywords}
\index{keywords}
\index{reserved words}

The following keywords are reserved:

\begin{tabular}{lllll}
\begin{chapel}
atomic
begin
break
by
class
cobegin
coforall
compilerError
compilerWarning
config
const
\end{chapel} & \begin{chapel}
continue
def
delete
distributed
do
domain
else
enum
for
forall
if
\end{chapel} & \begin{chapel}
in
index
inout
label
let
local
module
new
nil
on
otherwise
\end{chapel} & \begin{chapel}
out
param
record      
reduce      
return      
scan        
select
serial      
single      
sparse
subdomain
\end{chapel} & \begin{chapel}
sync        
then        
type        
union       
use         
var
when        
where       
while       
yield
$$
\end{chapel} \\
\begin{invisible}
compilerWarning
\end{invisible} & \begin{invisible}
compilerWarning
\end{invisible} & \begin{invisible}
compilerWarning
\end{invisible} & \begin{invisible}
compilerWarning
\end{invisible} & \begin{invisible}
compilerWarning
\end{invisible}
\end{tabular}


\subsubsection{Literals}
\label{Literals}
\label{Primitive_Type_Literals}

\index{literals!primitive type}
Bool literals are designated by the following syntax:
\begin{syntax}
bool-literal: one of
  `true' `false'
\end{syntax}

Signed and unsigned integer literals are designated by the following
syntax:
\begin{syntax}
integer-literal:
  digits
  `0' `x' hexadecimal-digits
  `0' `b' binary-digits

digits:
  digit
  digit digits

hexadecimal-digits:
  hexadecimal-digit
  hexadecimal-digit hexadecimal-digits

hexadecimal-digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7' `8' `9' `A' `B' `C' `D' `E' `F' `a' `b' `c' `d' `e' `f'

binary-digits:
  binary-digit
  binary-digit binary-digits

binary-digit: one of
  `0' `1'
\end{syntax}
Suffixes, like those in C, are not necessary.  The type of an integer
literal is the first type of the following that can hold the value of
the digits: \chpl{int}, \chpl{int(64)}, \chpl{uint(64)}.  Explicit
conversions are necessary to change the type of the literal to another
integer size.

Real literals are designated by the following syntax:
\begin{syntax}
real-literal:
  digits[OPT] . digits exponent-part[OPT]
  digits exponent-part

exponent-part:
  `e' sign[OPT] digits

sign: one of
  + -
\end{syntax}
The type of a real literal is \chpl{real}.  Explicit conversions are
necessary to change the type of the literal to another real
size.
\begin{rationale}
Note that real literals require that a digit follow the decimal point.
This is necessary to avoid an ambiguity in interpreting \chpl{2.e+2}
that arises if a method called \chpl{e} is defined on integers.
\end{rationale}

Imaginary literals are designated by the following syntax:
\begin{syntax}
imaginary-literal:
  real-literal `i'
  integer-literal `i'
\end{syntax}

There are no complex literals.  Rather, a complex value can be
specified by adding or subtracting an imaginary literal with a real
literal.  Alternatively, a 2-tuple of integral or real expressions can
be cast to a complex such that the first component becomes the real
part and the second component becomes the imaginary part.
\begin{example}
The following codes represent the same complex value:
\begin{center}
\chpl{2.0i}, \hspace{1pc} \chpl{0.0+2.0i}, \hspace{1pc}
\chpl{(0.0,2.0):complex}.
\end{center}
\end{example}

String literals are designated by the following syntax:
\begin{syntax}
string-literal:
  " quote-delimited-characters[OPT] "
  ' apostrophe-delimited-characters[OPT] '

quote-delimited-characters:
  character quote-delimited-characters[OPT]
  ' quote-delimited-characters[OPT]

apostrophe-delimited-characters:
  character apostrophe-delimited-characters[OPT]
  " apostrophe-delimited-characters[OPT]

character:
  `any-character-except-newline-quote-and-apostrophe'
\end{syntax}

\subsubsection{Operators and Punctuation}
\label{Operators_and_Punctuation}

The following special characters are interpreted by the syntax of the
language specially:
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf symbols} & {\bf use} \\
\hline
\verb@= += -= *= /= **= %= &= |= ^= &&= ||= <<= >>=@ & assignment \\
\verb@<=>@ & swap operator \\
\verb@..@ & ranges \\
\verb@...@ & variable argument lists \\
\verb@&& || !@ & logical operators \\
\verb@& | ^ ~ << >>@ & bitwise operators \\
\verb@== != <= >= < >@ & relational operators \\
\verb@+ - * / % **@ & arithmetic operators \\
\verb@:@ & types \\
\verb@;@ & statement separator \\
\verb@,@ & expression separator \\
\verb@.@ & member access \\
\verb@?@ & query types \\
\verb@" '@ & string delimiters \\
\hline
\end{tabular}
\end{center}

\subsubsection{Grouping Tokens}
\label{Grouping_Tokens}

The following braces are part of the Chapel language:
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf braces} & {\bf use} \\
\hline
\verb@( )@ & parenthesization, function calls, and tuples \\
\verb@[ ]@ & domains, square tuples, forall expressions, and function calls \\
\verb@{ }@ & type scopes and blocks \\
\hline
\end{tabular}
\end{center}
