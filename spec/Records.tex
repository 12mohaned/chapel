\sekshun{Records}
\label{Records}
\index{records}

A record is a data structure that is similar to a class but instead has value
semantics.  Value semantics mean that a variable of record type is associated
with only one piece of storage and has only one type throughout its lifetime.
Storage is allocated for a variable of record type when the variable declaration
is executed, and the record variable is also initialized at that time.

A record declaration creates a record type~\rsec{Record_Declarations}.  A
variable of record type contains all and only the fields defined by that type
(\rsec{Record_Types}).  Value semantics imply that the type of a record variable
is known at compile time (i.e. it is statically typed).  


Record initialization is described in~\rsec{Record_Initialization}.  The
semantics of record assignment and parameter passing are described
in~\rsec{Record_Assignment} and~\rsec{Record_Parameters}, respectively.

Records can be created through an explicit call to a record
constructor (\rsec{Record_Constructors}), which allocates storage, initializes
it and returns it.  However, since the record's lifetime is constrained by the
expression in which it appears, this usage is much less common than for classes.

Like classes, records can be generic (\rsec{Generic_Types}).


\subsection{Record Declarations}
\label{Record_Declarations}

\index{record@\chpl{record}}
A record is defined with the following syntax:
\begin{syntax}
record-declaration-statement:
  `record' identifier record-inherit-list[OPT] {
    record-statement-list }

record-inherit-list:
  : record-type-list

record-type-list:
  record-type
  record-type , record-type-list

record-statement-list:
  record-statement
  record-statement record-statement-list

record-statement:
  type-declaration-statement
  function-declaration-statement
  iterator-declaration-statement
  variable-declaration-statement
  empty-statement
\end{syntax}
A \sntx{record-declaration-statement} defines a new type symbol specified by the
identifier.  A record inherits data and functionality from other records
if the \sntx{record-inherit-list} is specified.  A record type can inherit from
other record types, but not from class types.

\begin{rationale}
Inheritance implies that the derived type can be cast to one of its base types.
If the base type is a record type, casting to the base type has the effect of
removing all of the data fields and all of functions that are not associated
with the base type.  Thereafter, the record variable has the base record type,
in both compile-time and run-time interpretations.

If the base type were a class type, the result of the cast would have the static
type of the base class while its run-time type was a record type.
% Which is not necessarily incongruous....
\end{rationale}
% You were here!!!
The only difference between record and class declarations is that
the \chpl{record} keyword replaces the \chpl{class} keyword.

The base class list may contain only record types.
%REVIEW: hilde
% Why not class types as well?
A record type specifier simply names a record type, using
the following syntax:
\begin{syntax}
record-type:
  identifier
  identifier ( named-expression-list )
\end{syntax}

\subsection{Record Construction}
\label{Record_Construction}
\index{records!new}
\index{new!records}
\index{records!instances}

A variable of a record type declared without an initialization expression
is initialized through a call to the record's default constructor.
The default constructor is a constructor which may be
called without arguments.  If no default constructor exists for a record type,
the compiler will generate one (see~\rsec{Default_Record_Constructor}).  In this
context, the default constructor is called with no arguments.  

To construct a record instance as an expression,
i.e. without binding it to a variable, a \chpl{new} expression is
required.  In this case, storage is allocated and reclaimed as for a record
variable declaration (\rsec{Record_Storage}).
To initialize a variable with a non-default value, it can be assigned
the value of a \chpl{new} expression.

\begin{rationale}
The \chpl{new} keyword disambiguates types from values. This is needed because of the close
relationship between constructors and type specifiers for classes and
records.
\end{rationale}

\begin{example}
\begin{chapelpre}
% recordCreation.chpl
\end{chapelpre}
\begin{chapel}
record TimeStamp {
  var time: string = "1/1/1011";
}

var timestampDefault: TimeStamp;                  // use the default for 'time'
var timestampCustom = new TimeStamp("2/2/2022");  // ... or a different one
writeln(timestampDefault);
writeln(timestampCustom);

var idCounter = 0;
record UniqueID {
  var id: int;
  proc UniqueID() { idCounter += 1; id = idCounter; }
}

writeln(new UniqueID());  // create and use a record value without a variable
writeln(new UniqueID());
\end{chapel}
\begin{chapeloutput}
(time = 1/1/1011)
(time = 2/2/2022)
(id = 1)
(id = 2)
\end{chapeloutput}
The variable \chpl{timestampDefault} is initialized with \chpl{TimeStamp}'s default constructor. The \chpl{new TimeStamp} expression creates a record that is assigned to \chpl{timestampCustom}, effectively initializing \chpl{timestampCustom} via a call to the constructor with desired arguments. The records created with \chpl{new UniqueID()} are discarded after they are used.
\end{example}

\subsection{Record Assignment}
\label{Record_Assignment}
\index{records!assignment}

In record assignment, the fields of the record on the left-hand side
of the assignment are assigned the corresponding field values of the record
on the right-hand side of the assignment.
Record assignment is generic and structural in that the
right-hand side expression can be of any type as long as it
contains at least the same fields (by name) as the record on the left-hand
side.

A left-hand-side field must be assignable the corresponding
right-hand-side field, i.e., an implicit conversion
(\rsec{Implicit_Conversions}) must exist between the fields' types.
Fields on the right-hand side that do not exist on the left-hand side
are ignored during record assignment.  For example, when a base record is
assigned a derived record, just the fields that exist in the base
record are assigned.
Assignment from a class instance to a record is allowed, but assignment
from record to class is not.

The following example demonstrates record assignment.
\begin{example}
\begin{chapelpre}
% assignment.chpl
\end{chapelpre}
\begin{chapel}
record R {
  var i: int;
  var x: real;
  proc print(r:R) { writeln("i = ", r.i, ", x = ", r.x); }
}
var A: R;
A.i = 3;
R.print(A);	// "i = 3, x = 0.0"

var C: R;
A = C;
R.print(A);	// "i = 0, x = 0.0"

C.x = 3.14;
R.print(A);	// "i = 0, x = 0.0"
\end{chapel}
\begin{chapeloutput}
i = 3, x = 0.0
i = 0, x = 0.0
i = 0, x = 0.0
\end{chapeloutput}
\end{example}
Prior to the first call to \chpl{R.print}, the record \chpl{A} is created and
initialized to all zeroes.  Then, its \chpl{i} field is set to \chpl{3}.
For the second call to \chpl{R.print}, the record \chpl{C} is created assigned
to \chpl{A}.  Since \chpl{C} is default-initialized to all zeroes, those zero
values overwrite both values in \chpl{A}.

The next clause demonstrates that \chpl{A} and \chpl{C} are distinct entities,
rather than two references to the same object.  Assigning \chpl{3.14}
to \chpl{C.x} does not affect the \chpl{x} field in \chpl{A}.

\subsubsection{Assigning Objects to Records}
\label{Assigning_Objects_to_Records}
\index{records!assignment!objects}

An object (class instance) can be assigned to a record.  The same rules apply as
those that govern the assignment of one record to another.  Namely, the type on
the right-hand side must initially contain all of the fields --- in the same
order and of compatible types --- as the record on the left-hand side.

The assignment is performed element-by-element between the right-hand expression
and the left-hand expression until all elements in the left-hand expression have
been overwritten.  The types are compatible if a element-wise assignment is
legal for each pair of elements.

\begin{example}
\begin{chapelpre}
% objectAssignment.chpl
\end{chapelpre}
\begin{chapel}
record R {
  var i: int;
  var x: real;
}
class C : R {
  var u: uint;
}

var c = new C(-3, 4.0, 5);
var r: R;
r = c;
writeln("r.i = ", r.i, ", r.x = ", r.x);
\end{chapel}
\begin{chapeloutput}
r.i = -3, r.x = 4.0
\end{chapeloutput}
\end{example}

Since C is derived from R, its initial fields are in the same order and of the
same type as in R.  Therefore, assignment from an instance of class \chpl{C} to
a record of type \chpl{R} is legal.
The first two fields are copied out of \chpl{c} and into \chpl{r}.  The
remaining field in the object referenced by \chpl{c} is ignored.


\subsection{Differences between Classes and Records}
\label{Class_and_Record_Differences}
\index{records!differences with classes}

The key differences between records and classes are listed below.

\subsubsection{References vs. Values}
\label{Records_as_Value_Classes}

The main difference between records and classes is that records are
value classes.  Record instances are manipulated as values, in the
same manner as values of primitive types.  Records are assigned by value;
see \rsec{Record_Assignment} for more details.  Records are also passed
by value to functions, unless argument intents (\rsec{Intents}) are used.

\begin{example}
\begin{chapelpre}
% paramPassing.chpl
\end{chapelpre}
\begin{chapel}
record MyColor {
  var color: int;
}

proc printMyColor(mc: MyColor) {
  writeln("my color is ", mc.color);
  mc.color = 6;   // does not affect the caller's record
}

var mc1: MyColor;        // 'color' defaults to 0
var mc2: MyColor = mc1;  // mc1's value is copied into mc2
mc1.color = 3;           // mc1's value is modified
printMyColor(mc2);       // mc2 is not affected by assignment to mc1
printMyColor(mc2);       // ... or by assignment in printMyColor()

proc modifyMyColor(inout mc: MyColor, newcolor: int) {
  mc.color = newcolor;
}
modifyMyColor(mc2, 7);   // mc2 is affected because of the 'inout' intent
printMyColor(mc2);
\end{chapel}
\begin{chapeloutput}
my color is 0
my color is 0
my color is 7
\end{chapeloutput}
The assignment to \chpl{mc1.color} affects only the record stored
in \chpl{mc1}. The record in \chpl{mc2} is not affected by
the assignment to \chpl{mc1} or by the assignment in \chpl{printMyColor}.
\chpl{mc2} is affected by the assignment in \chpl{modifyMyColor}
because the intent \chpl{inout} is used.
\end{example}

\subsubsection{Record Inheritance}
\label{Record_Inheritance}
\index{records!inheritance}

When a new record type is derived from a base record type, it contains all of
the data fields defined in the base record type, as well as any that are
declared in the body of the new record type declaration.
Multiple inheritance is supported in the same way as for classes.

The difference between record inheritance and class
inheritance is that there is no dynamic dispatch.  The record type of
a variable is the exact type of that variable, i.e. a variable of a
base record type cannot store a derived record type.

\subsubsection{Storage Allocation}
\label{Record_Storage}

Storage for a record variable directly contains the data associated
with the fields in the record, in the same manner as variables
of primitive types directly contain the primitive values.
Record storage is reclaimed when the record variable goes out of scope.
No additional storage for a record is allocated or reclaimed.
Field data of one variable's record is not shared with data
of another variable's record.

By contrast, the memory for a class variable contains only a reference to a
class instance.  Storage for a class instance (an object) is allocated and reclaimed
separately from variables referencing that object.  The same object
can be referenced by multiple variables.

\subsubsection{No Dynamic Dispatch}

Records do not support dynamic dispatch, because the type of a record variable
is determined statically.

\subsubsection{No {\em nil} Value}
\index{nil!not provided for records}

Records do not provide a counterpart of the \chpl{nil} value.  A variable of
record type is associated with storage throughout its lifetime, so \chpl{nil}
has no meaning with respect to records.

\subsection{Record Constructors}
\label{Record_Constructors}
\index{records!constructors}
\index{constructors}

%REVIEW: hilde
% Michael Ferguson suggests using a standard (invariant) name such as __init__
% for constructors in general.  Is this workable/desirable?

\subsection{Default Comparison Operators on Records}
\label{Record_Comparison_Operators}
\index{records!equality}
\index{records!inequality}

Default functions to overload \chpl{==} and \chpl{\!=} are defined for
records if there is none defined for the record in the Chapel program.
The default implementation of \chpl{==} applies \chpl{==} to each
field of the two argument records and reduces the result with
the \chpl{&&} operator.  The default implementation of \chpl{\!=}
applies \chpl{\!=} to each field of the two argument records and
reduces the result with the \chpl{||} operator.
