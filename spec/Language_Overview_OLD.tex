\sekshun{Language Overview}
\label{Language_Overview}

In HPC applications, the current dominant parallel programming paradigm 
is characterized by a localized
view of the computation combined with explicit control
over message passing, as exemplified by a combination
of Fortran or C/C++ with MPI. Such a fragmented memory
model provides the programmer with full control over data
distribution and communication, at the expense of productivity,
conciseness, and clarity.

Chapel is a new parallel programming language that 
strives to improve the programmability of parallel computer systems.
It provides a higher level of expression 
than current parallel languages do and it improves the separation between 
algorithmic expression and data structure implementation details. 

Chapel supports a global-view parallel programming model at a high level by 
supporting abstractions for data parallelism, task parallelism, and nested parallelism. 
It supports optimization for the locality of data and computation in the program 
via abstractions for data distribution and data-driven placement of subcomputations. 
It supports code reuse and generality via object-oriented concepts and generic 
programming features. While Chapel borrows concepts from many preceding languages, 
its parallel concepts are most closely based on ideas from High-Performance Fortran 
(HPF), ZPL, and the Cray MTA's extensions to Fortran/C. 

\subsection{Motivating Principles}
\label{Motivating_Principles}

Chapel pushes the state-of-the-art in parallel programming
by focusing on productivity and not just performance. In particular
Chapel combines the goal of highest possible
object code performance with that of programmability
by supporting a high level interface resulting in
shorter time-to-solution and reduced application development
cost. The design of Chapel is guided by four key
areas of programming language technology: global-view programming,
locality-awareness, object-orientation, and generic
programming.

\subsubsection{Global View Programming Model}
\label{Global_View_Programming_Model}

Parallel programming models can be divided into two types of models:
{\em fragmented} and {\em global-view}.  Fragmented programming models
require programmers to express algorithms on a task-by-task basis so that
the tasks can execute in parallel.  Global-view programming models
allow programmers to express a parallel algorithm as a whole, similar to
a serial algorithm.  The compiler and runtime libraries identify and assign
tasks to run in parallel across processors.  Chapel provides such a global-view 
programming model.

The global-view programming model is is able:
\begin{itemize}
\item to operate on distributed data structures monolithically as 
though they were local to the executing thread's memory, and 
\item to express parallelism within a single source text without requiring 
multiple executables to be run simultaneously. 
\end{itemize}
While the global-view programming model can be implemented on any distributed memory 
machine, specific architectures provide an ideal target for this model.  
Global-view models map particularly well to architectures that 
support a global address space, DGAS and PGAS memory segments, a high performance 
network, lightweight synchronization, and latency-tolerant processors.  This 
synergy results in improved performance as compared to implementations on less-
productive architectures.

\subsubsection{Locality Aware Programming}
\label{Locality_Aware_Programming}

Locality-aware programming, in the style of HPF and
ZPL, provides distribution of shared data structures without
requiring a fragmentation of control structure. The programmer
reasons about load-balance and locality by specifying
the placement of data objects and threads.

\subsubsection{Object-Oriented Programming}
\label{Object-Oriented_Programming}

Object-oriented programming helps in managing complexity
by separating common function from specific implementation
to facilitate reuse.

\subsubsection{Generic Programming}
\label{Generic_Programming}

Generic programming and type-inference simplify the
type systems presented to users. High-performance computing
requires type systems to provide data structure details
that allow for efficient implementation. Generic programming
avoids the need for explicit specification of such
details when they can be inferred from the source or from
specialization of program templates.

\subsection{Basic Language Features}
\label{Basic_Language_Features}

Chapel is an imperative programming language.  The basic concepts of the
language should be familiar to users of C, Fortran, Java, Modula and Ada.
However, the syntax of the Chapel language does not directly build upon any of 
these existing languages.   Programmers should start afresh when programming in 
Chapel and not be limited to the constructs of existing languages.

\subsubsection{Getting Started}

Consider the classic first program.  The program file,
\chpl{helloworld.chpl} contains:
\begin{chapel}
def main() {
  writeln("hello, world");
}
\end{chapel}

The syntax of this simple program somewhat resembles C.  There are a
few items to note.
The program contains one module, \chpl{helloworld}, which is implicitly
named from the name of the file.  The keyword \chpl{def} indicates that the
definition of a function follows.

To compile and run this program, execute the following
commands at the system prompt:
\begin{verbatim}
> chpl helloworld.chpl
> ./a.out
\end{verbatim}
The following output is shown:
\begin{verbatim}
> hello, world
\end{verbatim}

\subsubsection{Simple Chapel Example}
\label{Simple_Chapel_Example}
The following example code defines a module named \chpl{Norm}.
This module contains three function definitions for \chpl{norm}
for computing various norms for vectors and matrices.  Depending
on the argument parameters for a call to the \chpl{norm} function,
the compiler will resolve to the appropriate function definition
and compute the norm of \chpl{x}.

This module and following examples of how it is used demonstrate
how Chapel programs are organized into modules.  Further, it demonstrates
the generic programming features of the language, as well as the syntax
for variable and array declarations, for function definitions, for 
conditional statements and for reductions.  Later sections of
this language overview will refer back to this example.

\begin{chapel}
module Norm{
  def norm(x: [], p) where x.rank == 1 {

    if (p == 2) {
      return sqrt(+ reduce (x*x));
    } else if (p == 1) {
      return + reduce abs(x);
    } else if ((p == 'inf') || (p == 'INF') || (p == 'Inf')) {
      return max reduce abs(x);
    } else return -1;
  }

  def norm(x:[?D], p) where x.rank == 2 {

    if (p == 1) {
      var maxColSum = abs(x(1,1));
      for j in D(2) {
        maxColSum = max(maxColSum,+ reduce abs(x[D(1),j]));
      }
      return maxColSum;
    } else if ((p == 'inf') || (p == 'INF') || (p == 'Inf')) {
      var maxRowSum = abs(x(1,1));
      for i in D(1) {
        maxRowSum = max(maxRowSum,+ reduce abs(x[i,D(2)]));
      }
      return maxRowSum;
    } else if ((p == 'frob') || (p == 'FROB') || (p == 'Frob')) {
      return sqrt(+ reduce abs(x));
    } else return -1;
  }

  def norm(x: []) {
    if (x.rank == 1) then return norm(x,2);
    else if (x.rank == 2) then return norm(x,'frob');
    else return -1;
  }
}
\end{chapel}

Below, two examples of calling the \chpl{norm} function are given.
\begin{chapel}
use Norm;
const Dom2D = [1..n,1..n];
var A:[Dom2D] real;

const Dom1D = [1..m];
var x:[Dom1D] complex;

$\vdots$

var normA = norm(A,1);
var normx = norm(x);
\end{chapel}
The variable \chpl{normA} will contain the result of the second
\chpl{norm} function definition in the \chpl{Norm} module, for the
case where \chpl{p == 1}.  The resulting value for \chpl{NormA} is
of type \chpl{real}, computed from the complex values in \chpl{A}.
The variable \chpl{normx} will contain
the \chpl{real} result of the first \chpl{norm} function definition, for
the case where \chpl{p == 2}.

\subsubsection{Programs and Modules}
\label{Programs_and_Modules}

All Chapel code is organized using \emph{modules} which serve as code
containers to help manage code complexity as programs grow in size.
One module may ``\chpl{use}'' another, giving it access to that
module's public global symbols.  

All Chapel programs must contain a single function
\chpl{main()} that specifies the entry point for the program.  
This entry point is executed by a single logical thread.

For convenience in exploratory programming,
explicit module and main function declarations are not required.  If code is specified 
without a module declaration, the code's
filename is used as the module name for the code that it contains.
The main function may be omitted if there is only a single module in
the program other than the standard modules, as discussed
in~\rsec{Programs_with_a_Single_Module}.

Chapel provides standard modules for bit level operations, computing
random numbers and querying the system time.  See~\rsec{Standard_Modules}
for more details about these modules and how to use them.

\subsubsection{Data Types and Variables}
\label{Data_Types_and_Variables}

The following example demonstrates some variable declarations in Chapel.
\begin{chapel}
config const n = 10;

var x = 1.0,
    y = n:real,
    z: real;
\end{chapel}

The constant \chpl{n} can be set at runtime, as indicated by \chpl{config}, 
or it is set to its default value of \chpl{10}.  It is inferred to be of 
type \chpl{int} from this integer default value.  Similarly, \chpl{x} and 
\chpl{y} are inferred to be of type \chpl{real}.  The variable \chpl{x}
is initialized to \chpl{1.0} and the variable \chpl{y} is initialized to
the value of \chpl{n}, converted from an integer value to a real value.
The variable \chpl{z} has an explicit type declaration.  
Because \chpl{z} is not initialized, it has a default initial value of \chpl{0.0}.

Variable declarations in Chapel include the kind of variable, the variable's
name, type and initial value.  A variable's initialization may be omitted, 
in which case it will be initialized to an value dependent on its definition for 
safety (\eg, ``zero'' for numerical types).  Alternatively, a variable's type 
may be omitted, in which case it will be inferred from its
initializer.

There are three kinds of variables in Chapel specified by the following 
keywords:  \chpl{var}, \chpl{const},
and \chpl{param}.  The optional keyword \chpl{config} may precede
any of these variable keywords.  The \chpl{var} keyword indicates that a
variable is truly ``variable'' and may be modified throughout its
lifetime.  The \chpl{const} keyword indicates that a variable is a
constant, meaning that it \emph{must} be initialized and that its
value cannot change during its lifetime.  Unlike many languages,
Chapel's constant initializers need not be known at compile-time.  The
\chpl{param} keyword is used to define a \emph{parameter}, which is a
compile-time constant.  Parameter values are
required in certain language contexts, such as when specifying a
scalar type's bit-width or an array's rank.  In other contexts,
parameter values can be used to assert to the compiler that a
variable's value is known and unchanging.

Labeling a variable declaration with the optional \chpl{config}
keyword allows its value to be specified on the command line of the
compiler-generated executable (for \chpl{config const} and
\chpl{config var} declarations), or on the command-line of the
compiler itself (for \chpl{config param} declarations).

Variable declarations may also be specified in a variety of
comma-separated ways which allow multiple variables to share the same
variable-kind, type definition or initializer.  

Chapel has support for boolean, integer and floating point primitive types,
including the support for unsigned integers and complex types.  There is
also support for strings as primitive types.  The numeric primitive types
have multiple sizes, which can be specified by appending the size to the
type as shown in the following table.  When a size is not specified, then
the type has the default size.

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf Type} & {\bf Default Size} & {\bf Type Names}  \\
\hline
\begin{chapel}
int
\end{chapel}
& 32 bits & 
\begin{chapel}
int(8)
int(16) 
int(32) 
int(64) 
\end{chapel} \\
\hline
\begin{chapel}
uint
\end{chapel}
& 32 bits & 
\begin{chapel}
uint(8)
uint(16) 
uint(32) 
uint(64) 
\end{chapel} \\
\hline
\begin{chapel}
real
\end{chapel}
& 64 bits & 
\begin{chapel}
real(32)
real(64)
real(128)
\end{chapel} \\
\hline
\begin{chapel}
imag
\end{chapel} 
& 64 bits & 
\begin{chapel}
imag(32) 
imag(64)
imag(128)
\end{chapel} \\
\hline
\begin{chapel}
complex
\end{chapel}
& 128 bits & 
\begin{chapel}
complex(64)
complex(128)
complex(256)
\end{chapel} \\
\hline
\begin{chapel}
bool
\end{chapel} 
& 1 bit & 
\begin{chapel}
bool
\end{chapel}  \\
\hline
\begin{chapel}
string
\end{chapel}
& unbounded & 
\begin{chapel}
string 
\end{chapel} \\
\hline
\end{tabular}
\end{center}

%% Should locale be listed in the above table?

Chapel is a type-safe language.  When assigning from one type to another, explicit 
casts are often required by the compiler.  Details of implicit and explicit
conversions are discussed in~\rsec{Conversions}.

%% Not sure how much to say about coercions and conversions here.

Beyond these primitive types, there is support for enumerated types, tuples and
unions.  Additionally, arrays, domains, sequences, classes and records are
used in variable declarations as type definitions.

Chapel supports the ability to created named type definitions using
the \chpl{type} keyword.  Like parameter variables, type definitions
must be known at compile-time.  The example below demonstrates a use of a type
definition.

\begin{chapel}
type elemType = real(32);
var alpha: elemType;
\end{chapel}

The first line of the example code defines the identifier 
\typename{elemType} to be
an alias for a \chpl{real(32)}---Chapel's 32-bit floating point type.
The identifier \typename{elemType} may be used to specify a variable's
definition or anywhere else that a type is allowed.  

\subsubsection{Statements and Expressions}
\label{Statements_and_Expressions}

Examples of Chapel statements are given in the following table.

\begin{center}
\begin{longtable}{|l|l|}
\hline
{\bf Statement} & {\bf Example} \\
\hline
\endhead
\hline
\endfoot
Block Statement &
\begin{chapel} % test:  block.chpl
// Block statement for computing Givens rotation
{
tau = -a/b;
s = 1/sqrt(1 + tau*tau);
c = s*tau;
}
\end{chapel} \\
\hline
Expression Statement & 
\begin{chapel} % test:  expstmt.chpl

// Expression statements
testForZero(denom);
testForZero(x);
testForZero(0.0);

def testForZero(x: real) {
  if (x == 0.0) then halt("Value is zero.");
  else writeln("Non-zero value.  Continuing.");   
}
\end{chapel} \\
\hline
Assignment Statement & 
\begin{chapel} % test: assign.chpl

var i = 0;
i = i + 1;
i += 1;
\end{chapel} \\
\hline
Conditional Statement &
\begin{chapel} % test:  cond.chpl
def scale(x, y, alpha: real) {
  if (x.numElements != y.numElements) then
    writeln("Error:  Inputs are not the same length.");
  else {
    if (alpha == 0.0) {
      x = 0.0;
    } else if (alpha == 1.0) {
      x = y;
    } else {
      x = alpha*y;
    }
  }
}
\end{chapel} \\
\hline
Select Statement &
\begin{chapel} % test:  select.chpl
def getvalue(pos:string,y) {
  var x = 0.0;
  select pos {
    when "first" do x = y(1);
    when "last" do x = y(y.numElements);
    when "middle" do x = y((y.numElements/2):int + y.numElements%2);
    otherwise writeln("Unrecognized element position");
  }
  return x;
}
\end{chapel} \\
\hline
While and Do While Loops &
\begin{chapel} % test: while.chpl
do {
  t += 1;
  writeln(t);
} while (t <= 10);

while (t <= 10) {
  t += 1;
  writeln(t);
}
\end{chapel} \\
\hline
For Loop &
\begin{chapel} % test: for.chpl
def norm1(x) {
  var norm = 0.0;
  for i in x.domain {
    norm += abs(x(i));
  }
  return norm;
}
\end{chapel} \\
\hline
Use Statement &
\begin{chapel} % test:  use.chpl
use Time;
var programTimer:Timer;

programTimer.start();
writeln("Write one line.");
programTimer.stop();
var totalTime = programTimer.elapsed();
\end{chapel} \\
\hline
Type Select Statement &
\begin{chapel} % test:  typeselect.chpl
def writetype(x) {
  type select x {
    when int do writeln("Integer type");
    when uint do writeln("Unsigned integer type");
    when real do writeln("Real type");
    when complex do writeln("Complex type");
    when string do writeln("String type");
    when bool do writeln("Boolean type");
    otherwise writeln("Non-primitive type");
  }
}
\end{chapel} \\
\hline
Empty Statement &
\begin{chapel}
;
\end{chapel} \\
\hline
\end{longtable}
\end{center}

The syntax for all expressions is given in~\rsec{Expressions}.  Examples
of less common expressions are given in the following table.

\begin{center}
\begin{longtable}{|l|l|}
\hline
{\bf Expression} & {\bf Example} \\
\hline
\endhead
\hline
\endfoot
Query Expression &
\begin{chapel} % query.chpl
def sumOfThree(x: ?t, y:t, z:t):t {
   var sum: t;

   sum = x + y + z;
   return sum;
}
\end{chapel} \\
\hline
Casts &
\begin{chapel} % casts.chpl
var x, y: complex;
x = 2.56 + 9.0i;
y = (3.12, 8.7): complex;

var m = 2: int(64);
var n = 2;
var i = 1;
var j = 1;

while (n > 0) do {
  n *= 2;
  i += 1;
}
while (m > 0) do {
  m *= 2;
  j += 1;
}

writeln("For 32-bit integers, 2 ** (",i,") overflows.");
writeln("For 64-bit integers, 2 ** (",j,") overflows.");
\end{chapel} \\
\hline
Let Expression &
\begin{chapel} % let.chpl
def quadsol(a:real, b:real, c:real) {
  writeln("The solution of ",a,"x^2 + ",b,"x + ",c," = 0 is:");
  if (b*b > 4.0*a*c) {
    var x:  (real, real);

    x = let temp1 = sqrt(b*b - 4.0*a*c), temp2 = 2.0*a in
        ((-b + temp1)/temp2, (-b - temp1)/temp2);

    writeln(x);
  } else {
    var x: (complex, complex);

    x = let temp1 = sqrt(4.0*a*c - b*b)/(2.0*a), temp2 = -b/(2.0*a) in
        ((temp2,temp1):complex,(temp2,-temp1):complex);

    writeln(x);
  }
}
\end{chapel} \\
\hline
Conditional Expression &
\begin{chapel} % condexp.chpl
def writehalf(i: int) {
  var half = if (i % 2) then i/2 +1 else i/2;
  writeln("Half of ",i," is ",half);
}
\end{chapel} \\
\hline
\end{longtable}
\end{center}

\subsubsection{Classes}
\label{Intro_Classes}

This section is forthcoming.

\subsubsection{Records and Unions}
\label{Intro_Records_and_Unions}

This section is forthcoming.

\subsubsection{Functions}
\label{Intro_Functions}

This section is forthcoming.

\subsubsection{Sequences and Iterators}
\label{Sequences_and_Iterators}

Sequences are ordered sets of elements, each of which has the same type.
Sequences may be used in iterating in \chpl{for} and \chpl{forall} loops and 
in defining domains.  Sequences are also necessary constructs for defining iterators.    

A simple example of a sequence of integers is given below.
\begin{chapel}
var list: seq of int = (/ 1 /);

[i in 2..n] list #= i;
\end{chapel}
The variable \chpl{list} is declared to be a sequence of integers and it is 
initialized to be \chpl{(/ 1 /)}. In general, literal sequences are delimited by 
\chpl{(/} and \chpl{/)}, and the elements of the sequence are separated by commas.
In the loop, \chpl{[i in 2..n]}, the sequence \chpl{list} is constructed an element 
at a time by concatenating \chpl{i} at each iteration. After the first iteration 
of the loop, \chpl{list = (/ 1, 2 /)}. At the end of the loop,
\chpl{list} is a sequence of integers from \chpl{1} to \chpl{n}.

Consider the following example of a routine which sorts a list \chpl{x}
of elements and returns the sequence of indices which maps the original
list to the sorted list.
\begin{example}
\begin{chapel}
def insertionSort(x: [?D]) {
  var order: seq of int;

  for i in D {
    var val = x(i);
    var ind = i-1;
    while (ind > 0) {
      if x(order(ind)) <= val then break;
      ind -= 1;
    }
    order = order(1..ind) # i # order(ind+1..i-1);
  }
  return order;
}
\end{chapel}
\end{example}
At each iteration of the insertion sort, \chpl{i} is inserted into the
order list, according to where the \chpl{i}th element belongs in
the already sorted list of \chpl{i-1} elements.  The concatenation operator 
\chpl{#} is used to grow the sequence by one each iteration.  Once the sort is
complete, the function returns the sequence of indices that would permute
the original unsorted list into the sorted list.

In the following code, \chpl{x} is some list of elements that can be
ordered.  The function call, \chpl{insertionSort(x)}, returns a sequence which
is then used in a \chpl{for} loop. 
\begin{chapel}
var order: seq of int = insertionSort(x);
for i in order do write(x(i)," ");
writeln(); 
\end{chapel}
The output of the above code are the elements of \chpl{x} in sorted order.

Arithmetic sequences are a special case of general sequences.  Arithmetic
sequences contain integral values that can be specified with lower and upper
bounds and with a stride.  The following example is a strided arithmetic sequence.
\begin{chapel}
var fours = 0..36 by 4;
[i in fours] writeln(i);
\end{chapel}
The output of this code are the multiples of \chpl{4} from \chpl{0} to
\chpl{36}.

All sequence operations apply to arithmetic sequences.  For more information
about these operations and other details about sequences, see~\rsec{Sequences}.

When a sequence can be generated one element at a time, it can be used
in the definition of an iterator.  In the above sorting example, the 
sequence was modified as a whole during each iteration.  The routine
\chpl{insertionSort} therefore cannot be used as an iterator.  An example
of a sequence that can be used as an iterator is the sequence of even
numbers.  The following Chapel code shows an iterator that generates 
the first \chpl{n} even numbers.  
\begin{chapel}
iterator evens(n): int {
  for i in 1..n do yield 2*i;
}
\end{chapel}
When the iterator is not called from inside of a loop, the iterator returns
the entire sequence of values computed.  For example, if the \chpl{evens} iterator
is called on its own, it returns the sequence of \chpl{n} even numbers.
\begin{chapel}
var y = evens(5);
\end{chapel}
In this case, \chpl{y = (/2, 4, 6, 8, 10/)}.

When an iterator is called within a \chpl{for} or \chpl{for all} loop,
then the iterator is evaluated at each iteration of the loop body.
For example, the following code writes the \chpl{i}th even number at 
each iteration \chpl{i}.
\begin{chapel}
for i in evens(5) do writeln(i);
\end{chapel}

The following code gives an example of an iterator that can be
used to define two-dimensional blocks of \chpl{m} columns.
\begin{chapel}
iterator blockByCol(m,n): seq of seq of int {
  for i in 1..n by 2 yield [1..n, i..i+1];
}
\end{chapel}
Using this iterator in a \chpl{for} loop allows a matrix to be
accessed \chpl{m} columns at a time.  For example, the following
code prints \chpl{2} columns at a time of the \chpl{4} $\times$ \chpl{4} 
matrix \chpl{A}.
\begin{chapel}
for block in blockByCol(2,4) {
  writeln("This block:");
  writeln(A(block));
}
\end{chapel}


\subsubsection{Arrays and Domains}
\label{Arrays_and_Domains}

In Chapel, arrays are reference types that are declared using domains.
A domain is a first-class representation of an index space, potentially 
defined to be distributed across multiple locales.   All arrays
declared with a particular domain are indexed and distributed according 
to that domain's specifications.  

Arithmetic domains are formed from arithmetic sequences.  In the following
example, the domain \chpl{D} is initialized to \chpl{1..n} and then it is
used to declare one dimensional arrays, and to iterate over those arrays.
\begin{chapel}
const D = [1..n];
var x, y: [D] real;

for i in D {
  x(i) = i;
  y(i) = i*i;
}
\end{chapel}

The following example shows three arrays that are declared to be
vectors of length \chpl{m} and then used to compute and store a 
scaled addition.
\begin{chapel}
const D2: domain(2) = [1..n, 1..n];
var A, B, C: [D2] real;
const alpha: real;

A = B + alpha * C;
\end{chapel}
In this example, the domain \chpl{D2} is declared using  
\chpl{domain(2)} to indicate that it is a two-dimensional domain.
This domain is initialized to be an \chpl{n} $\times$ \chpl{n}
square.  The two-dimensional real arrays \chpl{A, B, C} are declared using
\chpl{D2}.

The final line uses whole-array syntax to specify the element-wise 
multiplications, additions, and assignments.  In this case since
all three arrays are declared with the same domain, the compiler
knows that the arrays are the right shape and size to successfully
compute the array addition and can generate the appropriate element-wise
additions.

Whole-array operations like this one are implicitly parallel, if the \chpl{D2}
domain were distributed across a set of processors.  For example, 
a block distribution of \chpl{D2} would be specified as follows.    
\begin{chapel}
const DistD2: domain(2) distributed(Block) = [1..n, 1..n];
var A, B, C: [DistD2] real;
\end{chapel}
To compute \chpl{A = B + alpha * C}, each processor would perform the 
operations for the array elements that it owns, 
as defined by \chpl{DistD2}'s distribution since that was the domain
used to define all three arrays.

Since arrays are reference types, they are passed by reference to functions
where they may be modified and remain modified upon return.  However, assignment
of arrays is by value.

Arithmetic domains are just one kind of domain.  Domains may
also be sparse, associative, enumerated or opaque.  Subdomains may be
defined to specify a subset of the domain's indices, as in the case of
inner, non-boundary points of a grid.  See~\rsec{Domains_and_Arrays} for
a complete description of domains and arrays.
 
\subsection{Parallel Features}
\label{Parallel_Features}

This section is forthcoming.


\subsubsection{Data Parallel Constructs}
\label{Data_Parallel_Constructs}

This section is forthcoming.


\subsubsection{Task Parallel Constructs}
\label{Task_Parallel_Constructs}

This section is forthcoming.


\subsubsection{Exploiting Data Locality}
\label{Exploiting_Data_Locality}

This section is forthcoming.


\subsubsection{Synchronizing and Serializing Tasks}
\label{Synchronizing_and_Serializing_Tasks}

This section is forthcoming.


\subsection{Data Distributions}
\label{Data_Distributions}

This section is forthcoming.


