\sekshun{Types}
\label{Types}

Chapel is a statically typed language with a rich set of types.  These
include a set of predefined primitive types, enumerated types,
classes, records, unions, tuples, ranges, domains, and arrays.
This section defines the primitive types, enumerated types, and type
aliases.  The syntax of a type is summarized by the following syntax:
\begin{syntax}
type-specifier:
  primitive-type
  enum-type
  class-type
  record-type
  union-type
  tuple-type
  range-type
  domain-type
  array-type
  sync-type
  single-type
  index-type
\end{syntax}

Sync and single types are discussed
in~\rsec{Synchronization_Variables}.

Programmers can define their own enumerated types, classes, records,
unions, and type aliases in type declaration statements summarized by
the following syntax:
\begin{syntax}
type-declaration-statement:
  enum-declaration-statement
  class-declaration-statement
  record-declaration-statement
  union-declaration-statement
  type-alias-declaration-statement
\end{syntax}

Classes are discussed in~\rsec{Classes}.  Records are discussed
in~\rsec{Records}.  Unions are discussed in~\rsec{Unions}.  Tuples are
discussed in~\rsec{Tuples}.  Ranges are discussed in~\rsec{Ranges}.
Domains and arrays are discussed in~\rsec{Domains_and_Arrays}.

\subsection{Primitive Types}
\label{Primitive_Types}
\index{types!primitive}

The primitive types include the following
types: \chpl{bool}, \chpl{int}, \chpl{uint}, \chpl{real},
\chpl{complex}, \chpl{imag}, \chpl{string}, and \chpl{locale}.
These primitive types are defined in this section except for
the \chpl{locale} type which is defined in~\rsec{The_Locale_Type}.
The syntax of a primitive type is summarized by the following syntax:
\begin{syntax}
primitive-type:
  `bool'
  `int' primitive-type-parameter-part[OPT]
  `uint' primitive-type-parameter-part[OPT]
  `real' primitive-type-parameter-part[OPT]
  `complex' primitive-type-parameter-part[OPT]
  `imag' primitive-type-parameter-part[OPT]
  `string'
  `locale'

primitive-type-parameter-part:
  ( integer-parameter-expression )
\end{syntax}

\subsubsection{The Bool Type}
\label{The_Bool_Type}
\index{bool@\chpl{bool}}

Chapel defines a logical data type designated by the symbol
\chpl{bool} with the two predefined values \chpl{true} and
\chpl{false}.

The relational operators return values of \chpl{bool} type and the
logical operators operate on values of \chpl{bool} type.

Some statements require expressions of \chpl{bool} type and Chapel
supports a special conversion of values to \chpl{bool} type when used
in this context~(\rsec{Implicit_Statement_Bool_Conversions}).
For example, an integer can be used as the condition in a conditional
statement.  It is converted to \chpl{false} if it is zero, and
otherwise, it is converted to \chpl{true}.

\subsubsection{Signed and Unsigned Integral Types}
\label{Signed_and_Unsigned_Integral_Types}
\index{uint@\chpl{uint}}
\index{int@\chpl{int}}

The integral types can be parameterized by the number of bits used to
represent them.  The default signed integral type, \chpl{int}, and the
default unsigned integral type, \chpl{uint}, are 32 bits.

The integral types and their ranges are given in the following table:

\begin{center}
\begin{tabular}{|l|r|r|}
\hline
{\bf Type} & {\bf Minimum Value} & {\bf Maximum Value} \\
\hline
{\tt int(8)} & -128 & 127 \\
{\tt uint(8)} & 0 & 255 \\
{\tt int(16)} & -32768 & 32767 \\
{\tt uint(16)} & 0 & 65535 \\
{\tt int(32)}, {\tt int} & -2147483648 & 2147483647 \\
{\tt uint(32)}, {\tt uint} & 0 & 4294967295 \\
{\tt int(64)} & -9223372036854775808 & 9223372036854775807 \\
{\tt uint(64)} & 0 & 18446744073709551615 \\
\hline
\end{tabular}
\end{center}

The unary and binary operators that are pre-defined over the integral
types operate with 32- and 64-bit precision.  Using these operators on
integral types represented with fewer bits results in a coercion
according to the rules defined in~\rsec{Implicit_Conversions}.

\subsubsection{Real Types}
\label{Real_Types}
\index{real@\chpl{real}}

Like the integral types, the real types can be parameterized by the
number of bits used to represent them.  The default real
type, \chpl{real}, is 64 bits.  The real types that are supported are
machine-dependent, but usually include \chpl{real(32)}
and \chpl{real(64)}, and sometimes include \chpl{real(128)}.

Arithmetic over real values follows the IEEE 754 standard.

\subsubsection{Complex Types}
\label{Complex_Types}
\index{complex@\chpl{complex}}

Like the integral and real types, the complex types can be
parameterized by the number of bits used to represent them.  A complex
number is composed of two real numbers so the number of bits used to
represent a complex is twice the number of bits used to represent the
real numbers.  The default complex type, \chpl{complex}, is 128 bits;
it consists of two 64-bit real numbers.  The complex types that are
supported are machine-dependent, but usually
include \chpl{complex(64)} and \chpl{complex(128)}, and sometimes
include \chpl{complex(256)}.

The real and imaginary components can be accessed via the methods
\chpl{re} and \chpl{im}.  The type of these components is real.

\begin{example}
Given a complex number \chpl{3.14+2.72i}, the expressions
\chpl{c.re} and \chpl{c.im} refer to \chpl{3.14} and \chpl{2.72}
respectively.
\end{example}

\subsubsection{Imaginary Types}
\label{Imaginary_Types}
\index{imaginary@\chpl{imaginary}}

The imaginary types can be parameterized by the number of bits used to
represent them.  The default imaginary type, \chpl{imag}, is 64 bits.
The imaginary types that are supported are machine-dependent, but
usually include \chpl{imag(32)} and \chpl{imag(64)}, and sometimes
include \chpl{imag(128)}.

\begin{rationale}
The imaginary type is included to avoid numeric instabilities and
under-optimized code stemming from always coercing real values to
complex values with a zero imaginary part.
\end{rationale}

\subsubsection{The String Type}
\label{The_String_Type}
\index{string@\chpl{string}}

Strings are a primitive type designated by the symbol \chpl{string}.
Their length is unbounded.

Characters in a string can be accessed via the \chpl{substring} method
on strings.  This method takes an integer $i$ and returns the $i$th
character in the string.
\begin{example}
The first character of a string \chpl{s} can be selected by the method
call \chpl{s.substring(1)}.
\end{example}

\subsection{Enumerated Types}
\label{Enumerated_Types}
\index{enumerated types}

Enumerated types are declared with the following syntax:
\begin{syntax}
enum-declaration-statement:
  `enum' identifier { enum-constant-list } ;

enum-constant-list:
  enum-constant
  enum-constant , enum-constant-list

enum-constant:
  identifier init-part[OPT]

init-part:
  = expression
\end{syntax}

The enumerated type can then be specified with its name as summarized
by the following syntax:
\begin{syntax}
enum-type:
  identifier
\end{syntax}

An enumerated type defines a set of named constants.  These are
associated with parameters of integral type.  Each enumerated type is
a distinct type. If the \sntx{init-part} is omitted, the
\sntx{enum-constant} has an integral value one higher than the previous
\sntx{enum-constant} in the enum, with the first having the value \chpl{1}.

\subsection{Class Types}

The class type defines a type that contains variables and constants,
called fields, and functions, called methods.  Classes are defined
in~\rsec{Classes}.  The class type can also contain type aliases and
parameters.  Such a class is generic and is defined
in~\rsec{Generics}.

\subsection{Record Types}

The record type is similar to a class type; the primary difference is
that a record is a value rather than a reference.  The difference
between classes and records is elaborated on in~\rsec{Records}.

\subsection{Union Types}

The union type defines a type that contains one of a set of variables.
Like classes and records, unions may also define methods.  Unions are
defined in~\rsec{Unions}.

\subsection{Tuple Types}
\label{Tuple_Types}

A tuple is a light-weight record that consists of one or more
anonymous fields.  If all the fields are of the same type, the tuple
is homogeneous.  Tuples are defined in~\rsec{Tuples}.

\subsection{Range Types}

A range defines an integral sequence of some integral type.  Ranges
are defined in~\rsec{Ranges}.

\subsection{Domain and Array Types}
\label{Domain_and_Array_Types}

Domains are index sets.  Arrays are types that contain a set of zero
or more elements all of the same type.  The elements are referenced
via indices that are in the domain that the array is declared over.
Domains and arrays are defined in~\rsec{Domains_and_Arrays}.

\subsection{Type Aliases}
\label{Type_Aliases}
\index{type aliases}

Type aliases are declared with the following syntax:
\begin{syntax}
type-alias-declaration-statement:
  `type' type-alias-declaration-list ;

type-alias-declaration-list:
  type-alias-declaration
  type-alias-declaration , type-alias-declaration-list

type-alias-declaration:
  identifier = type-specifier
  identifier
\end{syntax}
A type alias is a symbol that aliases any type as specified in the
\sntx{type-part}.  A use of a type alias has the same meaning as using
the type specified by \sntx{type-part} directly.

The \sntx{type-part} is optional in the definition of a class or
record.  Such a type alias is called an unspecified type
alias. Classes and records that contain type aliases, specified or
unspecified, are generic~(\rsec{Type_Aliases_in_Generic_Types}).

