The \chpl{ordered} keyword can be used to constrain the parallelism
within the iterator-list generation to that specified by the iterator.
The syntax is:
\begin{syntax}
forall-statement:
   ordered `forall' index-list `in' iterator-list `do' statement
   ordered `forall' index-list `in' iterator-list block-level-statement
\end{syntax}

The \chpl{ordered} constraint only affects order of evaluation only
when the iterator-list is an iterator. There is no effect if the
iterator-list is a sequence value.

By default a forall loop allows complete concurrent evaluation within
the iterator-list and with evaluation of the statements. When
the \chpl{ordered} keyword is present, the only concurrency between
statements is the concurrency that is explicitly specified in the
iterator itself. This allows an iterator to not only define a sequence of
values, but to impose a partial order on that sequence.

% \footnote{It might be tempting to generate a warning when the
% keyword is ignored but those warnings may be spurious in a generic
% context where we are reusing an abstract function definition.}

\begin{example}
\begin{chapel}
forall i in 1..10000 do
  a(i) = b(i);

def jam() {
  yield me;
  cobegin {
  }
}
\end{chapel}
In this example the user has stated that the element-wise assignments can
execute concurrently. The compiler and runtime will decide how many
computations are used to assign all 10,000 elements.
\end{example}

