An {\em atomic transaction} is a region of the program that appears to
execute as if all other computations in the program are suspended. It
is indicated as:
\begin{chapel}
atomic <<block>>;
\end{chapel}
where \chpl{<<block>>} is executed as if it were serialized by a
\chpl{serial} statement.

The behavior of an atomic statement is defined operationally in terms
of acquiring ownership of variables. Each variable in the program may
have an {\em owning} computation. Inside an atomic statement, before
each variable reference, the current computation attempts to acquire
ownership of the variable. If the variable is owned by another
computation, a deadlock might occur if the computation naively
waits. At such a point the implementation may {\em abort} the
statement. This means we release ownership of all variables owned by
the current computation without changing any of their values, and we
restart execution at the beginning of \chpl{<<block>>}.  Visible
side-effects to variables are delayed until \chpl{<<block>>}
completes. At this point we say the atomic statement {\em commits},
and all variables it owns are released and any modifications to
variables are made.

The implementation of the atomic statement must ensure forward
progress, but the details of how ownership information is maintained
and when computations are aborted is not defined here.

Here is an example of an atomic transaction:
\begin{chapel}
var found = false;
atomic {
  if(head == obj) {
    found = true;
    head = obj.next;
  } else  {
    var last = head;
    while(last != null) {
    if (last.next == obj) {
      found = true;
      last.next = object.next;
      break;
    }
    last = last.next;
  }
}
\end{chapel}
Inside the atomic statement is a simple sequential implementation of
removing a particular object denoted by \chpl{obj} from a singly
linked list.  This is an operation that is well-defined, assuming only
one computation is attempting it at a time. The atomic statement
insures that, for example, the value of \chpl{head} does not change
after it is first in the first comparison and subsequently read to
initialize \chpl{last}. The variables eventually owned by this
computation are \chpl{found}, \chpl{head}, \chpl{obj}, and the various
\chpl{next} fields on examined objects.

The effect of an atomic statement extends into called functions. Thus
if we have some method associated with a list that removes an object,
that method may not be parallel safe but could be invoked inside an
atomic statement for safety:
\begin{chapel}
var found;
atomic found = head.remove(obj);
\end{chapel}

Chapel defines three operations that are used to optimize atomic
statements to avoid overheads.  They are the \chpl{_invariant},
\chpl{_private}, and \chpl{_release} operations. The first two are
similar in that they identify variables that are either known to be
invariant over a program interval, or known to not be accessed by any
other computation. In either case, the protocol to assert ownership
and delay side-effects can be avoided. The \chpl{_release} operator
identifies a variable currently owned by the computation that has not
been modified and will not be accessed again. The current
computation's ownership is revoked and another computation can assert
ownership.

These operations might be used to tune the above code to reduce
overheads. For example:
\begin{chapel}
var found;
atomic {
  _private found = false;	   
  if (head == _invariant obj) {
    found = true;
    head = _invariant obj.next;
  } else {
    var last = _release head;
    while(last != null) {
      if(last.next == obj) {
        found = true;
        last.next = _invariant obj.next;
        break;
      }
      last = _release last.next;
    }
  }
}
\end{chapel}
These avoid overheads on the computation's private variables
\chpl{obj} and \chpl{found}.  It also allows a list-removal operation
to be pipelined by releasing ownership of the list head and various
link fields as soon as they will no longer be referenced. The
assertion that \chpl{obj.next} is invariant reflects the fact that no
other variables need to be acquired to allow the transaction to
complete, not that the field is actually invariant. The implementation
is free to prove these attributes and apply them automatically. For
example, we would expect the implementation to identify \chpl{last} as
a private variable without programmer assertion.

Chapel allows variables to have an \chpl{atomic} attribute to allow
optimization of ownership. For example:
\begin{chapel}
class ObjType {
  atomic var next : ObjType;
  ...
}
\end{chapel}
This declaration treats a definitions of such fields as if they are in
short atomic sections. Thus, a statement of the form:
\begin{chapel}
e1.x = e2;
\end{chapel}
where \chpl{x} is atomic would be evaluated as:
\begin{chapel}
var t1 = e1;
var t2 = e2;
atomic (_invariant t1).x = _invariant t2;
\end{chapel}

The declaration also encourages the implementation to allocate any
extra storage needed to maintain ownership adjacent to the variable
itself, avoiding the overhead of mapping the variable to sparsely
maintained information.

