\sekshun{Statements}
\label{Statements}

\index{statement}

Chapel is an imperative language with statements that may have side
effects.  Statements allow for the sequencing of program execution.
They are as follows:
\begin{syntax}
statement:
  block-statement
  expression-statement
  conditional-statement
  select-statement
  while-do-statement
  do-while-statement
  for-statement
  param-for-statement
  return-statement
  yield-statement
  module-declaration-statement
  function-declaration-statement
  type-declaration-statement
  variable-declaration-statement
  use-statement
  type-select-statement
  empty-statement
  cobegin-statement
  begin-statement
  serial-statement
  atomic-statement
  on-statement
\end{syntax}

The declaration statements are discussed in the sections that define
what they declare.  Module declaration statements are defined
in~\rsec{Modules}.  Function declaration statements are defined
in~\rsec{Functions}.  Type declaration statements are defined
in~\rsec{Types}.  Variable declaration statements are defined
in~\rsec{Variables}.  Return statements are defined
in~\rsec{The_Return_Statement}.  Yield statements are defined
in~\rsec{The_Yield_Statement}.

The \sntx{cobegin-statement} is defined in~\rsec{Cobegin}.
The \sntx{begin-statement} is defined in~\rsec{Begin}.
The \sntx{serial-statement} is defined in~\rsec{Serial}.
The \sntx{atomic-statement} is defined in~\rsec{Atomic_Transactions}.
The \sntx{on-statement} is defined in~\rsec{On}.

\subsection{Blocks}
\label{Blocks}

\index{block}

A block is a statement or a possibly empty list of statements that
form their own scope.  A block is given by
\begin{syntax}
block-statement:
  { statements[OPT] }
  { }

statements:
  statement
  statement statements
\end{syntax}

Variables defined within a block are local
variables~(\rsec{Local_Variables}).

The statements within a block are executed serially unless the block
is in a cobegin statement~(\rsec{Cobegin}).

\subsection{Block Level Statements}
\label{Block_Level_Statements}

\index{block level statement}
A block level statement is a category of statement that is sometimes
called for by the language syntax. A block level statement is given by
\begin{syntax}
block-level-statement:
  block-statement
  conditional-statement
  select-statement
  while-do-statement
  for-statement
  param-for-statement
  return-statement
  yield-statement
  type-select-statement
  empty-statement
  cobegin-statement
  begin-statement
  serial-statement
  atomic-statement
  on-statement
\end{syntax}

Block level statements are part of the language to avoid the excessive
and unnecessary use of curly brackets.  For example, function bodies
are not required to be blocks, but must be block level statements.

\subsection{Expression Statements}
\label{Expression_Statements}

\index{expression statement}
\index{expression!as a statement}
The expression statement evaluates an expression solely for side
effects. The syntax for an expression statement is given by
\begin{syntax}
expression-statement:
  expression ;
\end{syntax}

\subsection{Assignment Statements}
\label{Assignment_Statements}
\index{assignment}

An assignment statement assigns the value of an expression to another
expression that can appear on the left-hand side of the operator, for
example, a variable.  Assignment statements are given by

\index{=@\chpl{=}}
\index{+=@\chpl{+=}}
\index{-=@\chpl{-=}}
\index{*=@\chpl{*=}}
\index{/=@\chpl{/=}}
\index{\%=@\chpl{\%=}}
\index{**=@\chpl{**=}}
\index{&=@\chpl{&=}}
\index{|=@\chpl{|=}}
\index{^=@\chpl{^=}}
\index{||=@\chpl{||=}}
\index{&&=@\chpl{&&=}}
\index{<<=@\chpl{<<=}}
\index{>>=@\chpl{>>=}}
\begin{syntax}
assignment-statement:
  lvalue-expression assignment-operator expression

assignment-operator: one of
   = += -= *= /= %= **= &= |= ^= &&= ||= <<= >>=
\end{syntax}

The expression on the right-hand side of the assignment operator is
evaluated first; it can be any expression.  The expression on the left
hand side must be a valid lvalue~(\rsec{lvalue}).  It is evaluated
second and then assigned the value.

The assignment operators that contain a binary operator as a prefix is
a short-hand for applying the binary operator to the left and
right-hand side expressions and then assigning the value of that
application to the already evaluated left-hand side.  Thus, for
example, \chpl{x += y} is equivalent to \chpl{x = x + y} where the
expression \chpl{x} is evaluated once.

In a compound assignment, a cast to the type on the left-hand side is
inserted before the simple assignment if the right-hand side
expression can be assigned to the left-hand side expression and the
type of the left-hand side is a primitive type.

\begin{rationale}
This cast is necessary to handle \chpl{+=} where the type of the
left-hand side is, for example, \chpl{int(8)} because the \chpl{+}
operator is defined on \chpl{int(32)}, not \chpl{int(8)}.
\end{rationale}

\begin{status}
Currently, there is no verification that the right-hand side
expression can be assigned to the left-hand side expression.
\end{status}

Values of one primitive or enumerated type can be assigned to another
primitive or enumerated type if an implicit coercion exists between
those types~(\rsec{Implicit_Conversions}).

The validity and semantics of assigning between
classes~(\rsec{Class_Assignment}), records~(\rsec{Record_Assignment}),
unions~(\rsec{Union_Assignment}), tuples~(\rsec{Tuple_Assignment}),
ranges~(\rsec{Range_Assignment}),
domains~(\rsec{Domain_Assignment}), and arrays~(\rsec{Array_Assignment})
is discussed in these later sections.

\subsection{The Swap Statement}
\label{The_Swap_Statement}
\index{swap!statement}
\index{swap!operator}
The swap statement indicates to swap the values in the expressions
on either side of the swap operator.  Since both expressions are assigned
to, each must be a valid lvalue expression~(\rsec{lvalue}).
\begin{syntax}
swap-statement:
  lvalue-expression swap-operator lvalue-expression

swap-operator:
  <=>
\end{syntax}

To implement the swap operation, the compiler uses temporary variables
as necessary.

\begin{example}
The following swap statement
\begin{chapel}
var a, b: real;

a <=> b;
\end{chapel}
is semantically equivalent to:
\begin{chapel}
const t = b;
b = a;
a = t;
\end{chapel}
\end{example}

\subsection{The Conditional Statement}
\label{The_Conditional_Statement}

\index{if@\chpl{if}}
\index{then@\chpl{then}}
\index{else@\chpl{else}}
\index{conditional!statement}
The conditional statement allows execution to choose between two
statements based on the evaluation of an expression of \chpl{bool}
type. The syntax for a conditional statement is given by
\begin{syntax}
conditional-statement:
  `if' expression `then' statement else-part[OPT]
  `if' expression block-level-statement else-part[OPT]

else-part:
  `else' statement
\end{syntax}

A conditional statement evaluates an expression of bool type. If the
expression evaluates to true, the first statement in the conditional
statement is executed.  If the expression evaluates to false and the
optional else-clause exists, the statement following the
\chpl{else} keyword is executed.

If the expression is a parameter, the conditional statement is folded
by the compiler. If the expression evaluates to true, the first
statement replaces the conditional statement. If the expression
evaluates to false, the second statement, if it exists, replaces the
conditional statement; if the second statement does not exist, the
conditional statement is removed.

\index{conditional statement!dangling else}
If the statement that immediately follows the optional \chpl{then}
keyword is a conditional statement and it is not in a block, the
else-clause is bound to the nearest preceding conditional statement
without an else-clause.

Each statement embedded in the {\em conditional-statement} has its own
scope whether or not an explicit block surrounds it.

\subsection{The Select Statement}
\label{The_Select_Statement}

\index{select@\chpl{select}}
\index{when@\chpl{when}}

The select statement is a multi-way variant of the conditional
statement.  The syntax is given by:
\begin{syntax}
select-statement:
  `select' expression { when-statements }

when-statements:
  when-statement
  when-statement when-statements

when-statement:
  `when' expression-list `do' statement
  `when' expression-list block-level-statement
  `otherwise' statement

expression-list:
  expression
  expression , expression-list
\end{syntax}
The expression that follows the keyword \chpl{select}, the select
expression, is compared with the list of expressions following the
keyword \chpl{when}, the case expressions, using the equality
operator \chpl{==}.  If the expressions cannot be compared with the
equality operator, a compile-time error is generated.  The first case
expression that contains an expression where that comparison
is \chpl{true} will be selected and control transferred to the
associated statement.  If the comparison is always \chpl{false}, the
statement associated with the keyword \chpl{otherwise}, if it exists,
will be selected and control transferred to it.  There may be at most
one \chpl{otherwise} statement and its location within the select
statement does not matter.

Each statement embedded in the {\em when-statement} has its own scope
whether or not an explicit block surrounds it.

\subsection{The While and Do While Loops}
\label{The_While_and_Do_While_Loops}

\index{while loops}
\index{while@\chpl{while}}

There are two variants of the while loop in Chapel.  The syntax of the
while-do loop is given by:
\begin{syntax}
while-do-statement:
  `while' expression `do' statement
  `while' expression block-level-statement
\end{syntax}
The syntax of the do-while loop is given by:
\begin{syntax}
do-while-statement:
  `do' statement `while' expression ;
\end{syntax}
In both variants, the expression evaluates to a value of type \chpl{bool}
which determines when the loop terminates and control continues with
the statement following the loop.

The while-do loop is executed as follows:
\begin{enumerate}
\item The expression is evaluated.
\item If the expression evaluates to \chpl{false}, the statement is
  not executed and control continues to the statement following the
  loop.
\item If the expression evaluates to \chpl{true}, the statement is
  executed and control continues to step 1, evaluating the expression
  again.
\end{enumerate}

The do-while loop is executed as follows:
\begin{enumerate}
\item The statement is executed.
\item The expression is evaluated.
\item If the expression evaluates to \chpl{false}, control continues
  to the statement following the loop.
\item If the expression evaluates to \chpl{true}, control continues to
  step 1 and the the statement is executed again.
\end{enumerate}
In this second form of the loop, note that the statement is executed
unconditionally the first time.

\subsection{The For Loop}
\label{The_For_Loop}

\index{for@\chpl{for}}
\index{for loops}

The for loop iterates over ranges, domains, arrays, iterators, or
any class that implements the structural iterator interface.  The
syntax of the for loop is given by:
\begin{syntax}
for-statement:
  `for' loop-control-part loop-body-part

loop-control-part:
  index-expression `in' iterator-expression
  iterator-expression

loop-body-part:
  `do' statement
  block-level-statement

index-expression:
  expression

iterator-expression:
  expression
\end{syntax}

The index-expression can be an identifier or a tuple of identifiers.
The identifiers are declared to be new variables for the scope of this
statement.  A for loop can be defined without an index expression.

If the iterator-expression is a tuple, the components of the tuple
must support iteration, e.g., a tuple of arrays, and those components
are iterated over using a zipper iteration defined
in~\rsec{Zipper_Iteration}.  If the iterator-expression is a tuple
delimited by square brackets, the components of the tuple must support
iteration and these components are iterated over using a tensor
product iteration defined in~\rsec{Tensor_Product_Iteration}.

\subsubsection{Zipper Iteration}
\label{Zipper_Iteration}
\index{zipper iteration}

When multiple iterators are iterated over in a zipper context, on each
iteration, each expression is iterated over, the values are returned
by the iterators in a tuple and assigned to the index, and the
statement is executed.

The shape of each iterator, the rank and the extents in each
dimension, must be identical.

\begin{example}
The output of
\begin{chapel}
for (i, j) in (1..3, 4..6) do
  write(i, " ", j, " ");
\end{chapel}
is ``1 4 2 5 3 6 ''.
\end{example}

\subsubsection{Tensor Product Iteration}
\label{Tensor_Product_Iteration}
\index{tensor product iterator}
When multiple iterators are iterated over in a tensor product context,
they are iterated over as if they were nested in distinct for loops.
There is no constraint on the iterators as there is in the zipper
context.

\begin{example}
The output of
\begin{chapel}
for (i, j) in [1..3, 4..6] do
  write(i, " ", j, " ");
\end{chapel}
is ``1 4 1 5 1 6 2 4 2 5 2 6 3 4 3 5 3 6 ''. The statement is
equivalent to
\begin{chapel}
for i in 1..3 do
  for j in 4..6 do
    write(i, " ", j, " ");
\end{chapel}
\end{example}

\subsubsection{Parameter For Loops}
\label{Parameter_For_Loops}

\index{for loops!parameters}
\index{for@\chpl{for}}
\index{param@\chpl{param}}

Parameter for loops are unrolled by the compiler so that the index
variable is a parameter rather than a variable.  The syntax for a
parameter for loop statement is given by:
\begin{syntax}
param-for-statement:
  `for' `param' identifier `in' range-literal `do' statement
  `for' `param' identifier `in' range-literal block-level-statement
\end{syntax}
Parameter for loops are restricted to iteration over range literals
the bounds of which must also be parameters.  The loop is then
unrolled for each iteration.

\subsection{The Use Statement}
\label{The_Use_Statement}
\index{use@\chpl{use}}
\index{modules!using}

The use statement makes symbols in modules available without accessing
them via the module name.  The syntax of the use statement is given
by:
\begin{syntax}
use-statement:
  `use' module-name-list ;

module-name-list:
  module-name
  module-name , module-name

module-name:
  identifier
  module-name . module-name
\end{syntax}
The use statement makes symbols in each listed module's scope available
in the scope where the use statement occurs.

It is an error for a variable, type or module to be defined both by a
\chpl{use} statement and by a declaration in the same scope.
Functions may be overloaded in this way.

\subsection{The Type Select Statement}
\label{The_Type_Select_Statement}

\index{type select statements}

A type select statement has two uses.  It can be used to determine the
type of a union, as discussed
in~\rsec{The_Type_Select_Statement_and_Unions}.  In its more general
form, it can be used to determine the types of one or more values
using the same mechanisms used to disambiguate function definitions.
It syntax is given by:
\begin{syntax}
type-select-statement:
  `type' `select' expression-list { type-when-statements }

type-when-statements:
  type-when-statement
  type-when-statement type-when-statements

type-when-statement:
  `when' type-list `do' statement
  `when' type-list block-level-statement
  `otherwise' statement

expression-list:
  expression
  expression , expression-list

type-list:
  type
  type , type-list
\end{syntax}

Call the expressions following the keyword \chpl{select}, the select
expressions.  The number of select expressions must be equal to the
number of types following each of the \chpl{when} keywords.  Like the
select statement, one of the statements associated with a \chpl{when}
will be executed.  In this case, that statement is chosen by the
function resolution mechanism.  The select expressions are the actual
arguments, the types following the \chpl{when} keywords are the types
of the formal arguments for different anonymous functions.  The
function that would be selected by function resolution determines the
statement that is executed.  If none of the functions are chosen, the
the statement associated with the keyword \chpl{otherwise}, if it
exists, will be selected.

As with function resolution, this can result in an ambiguous
situation.  Unlike with function resolution, in the event of an
ambiguity, the first statement in the list of when statements is
chosen.

\subsection{The Empty Statement}
\label{The_Empty_Statement}

An empty statement has no effect.  The syntax of an empty statement is
given by
\begin{syntax}
empty-statement:
  ;
\end{syntax}
