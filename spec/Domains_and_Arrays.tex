\sekshun{Domains and Arrays}
\label{Domains_and_Arrays}

A {\em domain} is a description of a collection of names for data.
These names are referred to as the {\em indices} of the domain.  All
indices for a particular domain are values with some common type.
Valid types for indices are primitive types and class references or
unions, tuples or records whose fields are valid types for indices.
This excludes sequences, domains, and arrays.  Like sequences, domains
have a rank and a total order on their elements.  An {\em array} is
generically a function that maps from a {\em domain} to a collection
of variables.  Chapel supports a variety of kinds of domains and
arrays defined over those domains as well as a mechanism to allow
application specific implementations of arrays.

Arrays abstract mappings from sets of values to variables.  This key
use of data structures coupled with the generic syntactic support for
array usage increases software reusability.  By separating the sets of
values into their own abstraction, domains, distributions can be
associated with sets rather than variables.  This enables the
orthogonality of data distributions.  Distributions are discussed
in~\rsec{Locality_and_Distribution}.

\subsection{Domains}
\label{Domains}

Domains are first-class ordered sets of indices.  There are five kinds
of domains:
\begin{itemize}
\item
Arithmetic domains are rectilinear sets of Cartesian indices that can
have an arbitrary rank.
\item
Sparse domains are subsets of indices in arithmetic domains.
\item
Indefinite domains are sets of indices where the type of the index is
some type that is not an array, domain, or sequence.  Indefinite
domains define dictionaries or associative arrays implemented via hash
tables.
\item
Opaque domains are sets of anonymous indices.  Opaque domains define
graphs and unspecified sets.
\item
Enumerated domains are sets of constants defined by some enumerated
type.
\end{itemize}

\subsubsection{Domain Types}
\label{Domain_Types}

Domain types vary based on the kind of the domain.  The type of an
arithmetic domain is parameterized by the rank of the domain and the
integral type of the indices.  The type of a sparse domain is
parameterized by the type of the arithmetic domain that defines the
superset of its indices.  The type of an indefinite domain is
parameterized by the type of the index.  The type of an opaque domain
is unique.  The type of an enumerated domain is parameterized by the
enumerated type.

\begin{example}
In the code
\begin{chapel}
var D: domain(2) = [1..n, 1..n];
\end{chapel}
\chpl{D} is defined as a two-dimensional arithmetic domain and is
initialized to contain the set of indices $(i,j)$ for all $i$ and $j$
such that $i \in {1, 2, \ldots, n}$ and $j \in {1, 2, \ldots, n}$.
\end{example}

\subsubsection{Index Types}
\label{Index_Types}

Each domain has a corresponding {\em index} type which is the type of
the domain's indices qualified by its status as an index.  Variables
of this type can be declared using the following syntax:
\begin{syntax}
index-type:
  `index' ( domain-expression )
\end{syntax}
If the type of the indices of the domain is \chpl{int}, then the index
type can be converted into this type.

A value with a type that is the same as the type of the indices in a
domain but is not the index type can be converted into the index type
using a special ``method'' called \chpl{index}.

\begin{example}
In the code
\begin{chapel}
var j = D.index(i);
\end{chapel}
the type of the variable \chpl{j} is the index type of
domain \chpl{D}.  The variable \chpl{i}, which must have the same type
as the underlying type of the indices of \chpl{D}, is verified to be
in domain \chpl{D} before it is assigned to \chpl{j}.
\end{example}

Values of index type are known to be valid and may have specialized
representations to facilitate accessing arrays defined for that
domain. It may therefore be less expensive to access arrays using
values of appropriate index type rather than values of the more
general type the domain is defined over.

\begin{implementation}
In the current implementation, the index type is not distinguished
from the underlying type of the indices.  The index method is not yet
implemented.
\end{implementation}

\subsubsection{Domain Assignment}
\label{Domain_Assignment}

Domain assignment is by value.  If arrays are declared over a domain,
domain assignment impacts these arrays as discussed
in~\rsec{Association_of_Arrays_to_Domains}, but the arrays remain
associated with the same domain regardless of the assignment.

\subsubsection{Formal Arguments of Domain Type}
\label{Formal_Arguments_of_Domain_Type}

Domains are passed to functions by reference.  Formal arguments that
receive domains are aliases of the actual arguments.  It is a
compile-time error to pass a domain to a formal argument that has a
non-blank intent.

\subsubsection{Iteration over Domains}
\label{Iteration_over_Domains}

All domains support iteration via forall and for loops over the
indices in the set that the domain defines.  The type of the indices
returned by iterating over a domain is the index type of the domain.

\subsubsection{Domain Promotion of Scalar Functions}
\label{Domain_Promotion_of_Scalar_Functions}
\index{domains!promotion}

Domain promotion of a scalar function is defined over the domain type
and the type of the indices of the domain (not the index type).
Domain promotion has the same semantics as sequence promotion where
the scalar type is the indices of the domain and the promotion type is
the domain type.

\begin{example}
Given an array \chpl{A} with element type \chpl{int} declared over a
one-dimensional domain \chpl{D} with integral type \chpl{int}, then
the array can be assigned the values given by the indices in the
domain by writing
\begin{chapel}
A = D;
\end{chapel}
\end{example}

\subsection{Arrays}
\label{Arrays}

Arrays associate variables or elements with the sets of indices in a
domain.  Arrays must be declared over domains and have a specified
element type.

\subsubsection{Array Types}
\label{Array_Types}

The type of an array is parameterized by the type of the domain that
it is declared over and the element type of the array.  Array types
are given by the following syntax:
\begin{syntax}
array-type:
  [ domain-expression ] type

domain-expression:
  expression
\end{syntax}
The \sntx{domain-expression} must specify a domain that the array can
be declared over.  This can be a domain literal.  If it is a domain
literal, the square brackets around the domain literal can be omitted.

\begin{example}
In the code
\begin{chapel}
var A: [D] real;
\end{chapel}
\chpl{A} is declared to be an array over domain \chpl{D} with
elements of type \chpl{real}.
\end{example}

\begin{implementation}
Arrays of arrays are not currently supported.
\end{implementation}

\subsubsection{Array Indexing}
\label{Array_Indexing}

Arrays can be indexed by indices in the domain they are declared over.
The indexing results in an access of the element that is mapped by
this index.

\begin{example}
If \chpl{A} is an array with element type \chpl{real} declared over a
one-dimensional arithmetic domain \chpl{[1..n]}, then the first
element in \chpl{A} can be accessed via the expression \chpl{A(1)} and
set to zero via the assignment \chpl{A(1) = 0.0}.
\end{example}

Indexing into an array with a domain is call array slicing and is
discussed in the next section.

Arithmetic arrays also support indexing over the components of their
indices for multidimensional arithmetic domains (where the indices are
tuples), as described in~\rsec{Arithmetic_Array_Indexing}.

\subsubsection{Array Slicing}
\label{Array_Slicing}

An array can be indexed by a domain that has the same type as the
domain which the array was declared over.  Indexing in this manner has
the effect of array slicing.  The result is a new array declared over
the indexing domain where the elements in the array alias the elements
in the array being indexed.

\begin{example}
Given the definitions
\begin{chapel}
var OuterD: domain(2) = [0..n+1, 0..n+1];
var InnerD: domain(2) = [1..n, 1..n];
var A, B: [OuterD] real;
\end{chapel}
the assignment given by
\begin{chapel}
A(InnerD) = B(InnerD);
\end{chapel}
assigns the elements in the interior of \chpl{B} to the elements in
the interior of \chpl{A}.
\end{example}

Arithmetic arrays also support slicing by indexing into them with
arithmetic sequences or tuples of arithmetic sequences as described
in~\rsec{Arithmetic_Array_Slicing}.

\subsubsection{Array Assignment}
\label{Array_Assignment}

Array assignment is by value.  Arrays can be assigned arrays,
sequences, or domains.  If \chpl{A} is an lvalue of array type
and \chpl{B} is an expression of either array, sequence, or domain
type, then the assignment
\begin{chapel}
A = B;
\end{chapel}
is equivalent to
\begin{chapel}
forall (i,e) in (A.domain,B) do
  A(i) = e;
\end{chapel}
If the zipper iteration is illegal, then the assignment is illegal.
Notice that the assignment is implemented with the semantics of
a \chpl{forall} loop.

Arrays can also be assigned single values of their element type.  In
this case, each element in the array is assigned this value.
If \chpl{e} is an expression of the element type of the array or a
type that can be implicitly converted to the element type of the
array, then the assignment
\begin{chapel}
A = e;
\end{chapel}
is equivalent to
\begin{chapel}
forall i in A.domain do
  A(i) = e;
\end{chapel}

\subsubsection{Formal Arguments of Array Type}
\label{Formal_Arguments_of_Array_Type}

Arrays are passed to functions by reference.  Formal arguments that
receive arrays are aliases of the actual arguments.  The ordinary rule
that disallows assignment to formal arguments of blank intent does not
apply to arrays.

When a formal argument has array type, the element type of the array
can be omitted and/or the domain of the array can be queried or
omitted.  In such cases, the argument is generic and is discussed
in~\rsec{Formal_Arguments_of_Generic_Array_Types}.

If a non-queried domain is specified in the array type of a formal
argument, the domain must match the domain of the actual argument.
This is verified at runtime.  There is an exception if the domain is
an arithmetic domain; it is described
in~\rsec{Formal_Arguments_of_Arithmetic_Array_Type}.

\subsubsection{Iteration over Arrays}
\label{Iteration_over_Arrays}

All arrays support iteration via forall and for loops over the
elements mapped to by the indices in the array's domain.

\subsubsection{Array Promotion of Scalar Functions}
\label{Array_Promotion_of_Scalar_Functions}

Array promotion of a scalar function is defined over the array type
and the element type of the array.  Array promotion has the same
semantics as sequence promotion where the scalar type is the element
type of the array and the promotion type is the array type.  The only
difference between sequence promotion and array promotion is that if a
function returns a value, the promoted function returns an array of
those values rather than a sequence of those values.  The array is
defined over the same domain as the array that was passed to the
function.  In the event of zipper promotion over multiple arrays or
both arrays and sequences, the promoted function returns a value based
on the first argument to the function that enables promotion.

\begin{implementation}
In the current implementation, promotion always returns sequences.
\end{implementation}

\begin{example}
Whole array operations is a special case of array promotion of scalar
functions.  In the code
\begin{chapel}
A = B + C;
\end{chapel}
if \chpl{A}, \chpl{B}, and \chpl{C} are arrays, this code assigns each
element in \chpl{A} the element-wise sum of the elements in \chpl{B}
and \chpl{C}.
\end{example}

\subsubsection{Array Initialization}
\label{Array_Initialization}

By default, the elements in an array are initialized to the default
values associated with the element type of the array.  There is an
expectation that this default initialization can be overridden for
performance reasons by explicitly marking the array type or variable.

The initialization expression in the declaration of an array can be
based on the indices in the domain using special array declaration
syntax that replaces both the type and initialization specifications
of the declaration:
\begin{syntax}
special-array-declaration:
  identifier-list indexed-array-type-part initialization-part

indexed-array-type-part:
  : array-type-forall-expression type

array-type-forall-expression:
  [ identifier `in' domain-expression ]

initialization-part:
  = expression
\end{syntax}
In this code, the \sntx{array-type-forall-expression} is syntactic
sugar for surrounding the \sntx{initialization-part} with this basic
forall-expression.

Given a domain expression \chpl{D}, an element type \chpl{t}, an
expression \chpl{e} that is of type \chpl{t} or that can be implicitly
converted to type \chpl{t}, then the declaration of array \chpl{A}
given by
\begin{chapel}
var A: [i in D] t = e;
\end{chapel}
is equivalent to
\begin{chapel}
var A: [D] t = [i in D] e;
\end{chapel}
The scope of the forall expression is as in the rewritten part so the
expression \chpl{e} can include references to index \chpl{i}.

\subsection{Arithmetic Domains and Arrays}
\label{Arithmetic_Domains_and_Arrays}

An arithmetic domain is a rectilinear set of Cartesian indices.
Arithmetic domains are specified as a tuple of arithmetic sequences
enclosed in square brackets.

\subsubsection{Arithmetic Domain Literals}
\label{Arithmetic_Domain_Literals}

An arithmetic domain literal is specified by the following syntax:
\begin{syntax}
arithmetic-domain-literal:
  [ arithmetic-sequence-expression-list ]

arithmetic-sequence-expression-list:
  arithmetic-sequence-expression
  arithmetic-sequence-expression , arithmetic-sequence-expression-list

arithmetic-sequence-expression:
  expression
\end{syntax}

\begin{example}
The expression \chpl{[1..5, 1..5]} defines a $5 \times 5$ arithmetic
domain with the indices $(1, 1), (1, 2), \ldots, (5, 5)$.
\end{example}

\subsubsection{Arithmetic Domain Types}
\label{Arithmetic_Domain_Types}

The type of an arithmetic domain is determined from the rank of the
arithmetic domain (the number of arithmetic sequences that define it)
and by an underlying integeral type called the {\em dimensional index
type} which must be identical to each of the integral element types of
the arithmetic sequences that define the arithmetic domain.  By
default, the dimensional index type of an arithmetic domain
is \chpl{int}.

The arithmetic domain type is specified by the syntax of a function
call to the keyword \chpl{domain} that takes at least an argument
called \chpl{rank} that is a parameter of type \chpl{int} and
optionally an integral type named \chpl{dim_type}.

\begin{example}
The expression \chpl{[1..5, 1..5]} defines an arithmetic domain with
type \chpl{domain(2,int)}.
\end{example}

\subsubsection{Strided Arithmetic Domains}
\label{Strided_Arithmetic_Domains_and_Arrays}

If the arithmetic sequences that define an arithmetic domain are
strided, then the arithmetic domain is said to be strided.

The \chpl{by} operator can be applied to any arithmetic domain to
create a strided arithmetic domain.  It is predefined over an
arithmetic domain and an integer or a tuple of integers.  In the
integer case, the arithmetic sequences in each dimension are strided
by the integer.  In the tuple of integers case, the size of the tuple
must match the rank of the domain; the integers stride each dimension
of the domain.  If the arithmetic sequences are already strided, the
strides applied by the \chpl{by} operator are multiplied to the
strides of the arithmetic sequneces.

\subsubsection{Arithmetic Domain Indexing}
\label{Arithmetic_Domain_Indexing}

Arithmetic domains support indexing by a value of type \chpl{int} that
is at least one and no more than the rank of the array.  Indexing into
an arithmetic domain returns the arithmetic sequence associated with
that dimension.

\begin{example}
In the code
\begin{chapel}
for i in D(1) do
  for j in D(2) do
    writeln(A(i,j));
\end{chapel}
domain \chpl{D} is iterated over by two nested loops.  The first
dimension of \chpl{D} is iterated over in the outer loop.  The second
dimension is iterated over in the inner loop.
\end{example}

\subsubsection{Arithmetic Array Indexing}
\label{Arithmetic_Array_Indexing}

In addition to being indexed by indices defined by their arithmetic
domains, arithmetic arrays can be indexed directly by values of the
dimensional index type where the number of values is equal to the rank
of the array.  This has the semantics of first moving the values into
a tuple and then indexing into the array.

\begin{example}
Given the definition
\begin{chapel}
  var ij = (i,j);
\end{chapel}
the indexing expressions \chpl{A(ij)} and \chpl{A(i,j)} are
equivalent.
\end{example}

\subsubsection{Arithmetic Array Slicing}
\label{Arithmetic_Array_Slicing}

In addition to slicing an arithmetic array by an arithmetic domain,
arithmetic arrays also support slicing by arithmetic sequences
directly.  If each dimension is indexed by an arithmetic sequence,
this is equivalent to slicing the domain by an arithmetic domain
defined by those arithmetic sequences.

\begin{implementation}
It is currently required that each dimension be indexed by an
arithmetic sequence.  There is an expectation that indexing some
dimensions directly by values of integral type will result in an array
slice of a different rank.
\end{implementation}

\subsubsection{Formal Arguments of Arithmetic Array Type}
\label{Formal_Arguments_of_Arithmetic_Array_Type}

Formal arguments of arithmetic array type allow an arithmetic domain
to be specified that does not match the arithmetic domain of the
actual arithmetic array that is passed to the formal argument.  In
this case, the shape (size in each dimension and rank) of the domain
of the actual array must match the shape of the domain of the formal
array.  The indices are translated in the formal array, which is a
reference to the actual array.

\begin{example}
In the code
\begin{chapel}
def foo(X: [1..5] int) { ... }
var A: [1..10 by 2] int;
foo(A);
\end{chapel}
the array \chpl{A} is strided and its elements can be indexed by the
odd integers between one and nine.  In the function \chpl{foo}, the
array \chpl{X} references array \chpl{A} and the same elements can be
indexed by the integers between one and five.
\end{example}

\subsection{Sparse Domains and Arrays}
\label{Sparse_Domains_and_Arrays}

\begin{implementation}
Sparse domains are not yet implemented.
\end{implementation}

A sparse domain type is given by the syntax
\begin{syntax}
sparse-domain-type:
  `sparse' `domain' ( domain-expression )

domain-expression:
  expression
\end{syntax}
A sparse domain is a domain that contains a subset of the indices in
the domain specified by the \sntx{domain-expression}, sometimes called
the {\em base domain}.

Arrays declared over sparse domains can be indexed by all of the
indices in the base domain.  If the index is not part of the sparse
domain, the element returned is called the {\em unrepresented
element}.  It is an error to assign a value to the unrepresented
element by indexing into the array and assigning it a value.  The
unrepresented element can be set to any value but by default contains
the default value associated with the element type of the array.

\subsubsection{Changing the Indices in Sparse Domains}

Indices can be added or removed to sparse domains.  Sparse domains
support a method \chpl{add} that takes an index and adds this index to
the sparse domain.  All arrays declared over this sparse domain can
now be assigned values corresponding to this index.

Sparse domains support a method \chpl{remove} that takes an index and
removes this index from the sparse domain.  The values in the arrays
indexed by the removed index are lost.

The operators \chpl{+=} and \chpl{-=} have special semantics for
sparse domains; they are interpreted as calls to the \chpl{add}
and \chpl{remove} methods respectively.  The statement
\begin{chapel}
D += i;
\end{chapel}
is equivalent to
\begin{chapel}
D.add(i);
\end{chapel}
Similarly, the statement
\begin{chapel}
D -= i;
\end{chapel}
is equivalent to
\begin{chapel}
D.remove(i);
\end{chapel}

\subsection{Indefinite Domains and Arrays}
\label{Indefinite_Domains_and_Arrays}

An indefinite domain type can be defined over any scalar type and is
given by the following syntax:
\begin{syntax}
sparse-domain-type:
  `domain' ( scalar-type )

scalar-type:
  type
\end{syntax}
A scalar type is any primitive type, tuple of scalar types, or class,
record, or union where all of the fields have scalar types.
Enumerated types are scalar types but domains declared over enumerated
types are described in~\rsec{Enumerated_Domains_and_Arrays}.  Arrays
declared over indefinite domains are dictionaries mapping from values
to variables.

\subsubsection{Changing the Indices in Indefinite Domains}

Like with sparse domains, indices can be added or removed to
indefinite domains.  Indefinite domains support a method \chpl{add}
that takes an index and adds this index to the indefinite domain.  All
arrays declared over this indefinite domain can now be assigned values
corresponding to this index.

Indefinite domains support a method \chpl{remove} that takes an index
and removes this index from the indefinite domain.  The values in the
arrays indexed by the removed index are lost.

The operators \chpl{+=} and \chpl{-=} have special semantics for
indefinite domains; they are interpreted as calls to the \chpl{add}
and \chpl{remove} methods respectively.  The statement
\begin{chapel}
D += i;
\end{chapel}
is equivalent to
\begin{chapel}
D.add(i);
\end{chapel}
Similarly, the statement
\begin{chapel}
D -= i;
\end{chapel}
is equivalent to
\begin{chapel}
D.remove(i);
\end{chapel}

\subsubsection{Testing Membership in Indefinite Domains}

An indefinite domain supports a \chpl{member?} method that can test
whether a particular value is part of the index set. It
returns \chpl{true} if the index is in the indefinite domain and
otherwise returns false.

\subsection{Opaque Domains and Arrays}
\label{Opaque_Domains_and_Arrays}

\begin{implementation}
Opaque domains are not yet implemented.
\end{implementation}

An opaque domain is a form of indefinite domain where there is no
algebra on the types of the indices.  The indices are, in essence,
opaque.  The opaque domain type is given by the following syntax:
\begin{syntax}
opaque-domain:
  `opaque' `domain'
\end{syntax}

New index values for opaque domains are explicitly requested via a
method called \chpl{new}.  Indices can be removed by a method
called \chpl{remove}.

Opaque domains permit more efficient implementations than indefinite
domains under the assumption that creation of new domain index values
is rare.

\subsection{Enumerated Domains and Arrays}
\label{Enumerated_Domains_and_Arrays}

\begin{implementation}
Enumerated domains are not yet implemented.
\end{implementation}

Enumerated domains are a special case of indefinite domains where the
indices are the constants defined by an enumerated type.  Enumerated
domains do not support the \chpl{add} or \chpl{remove} methods.  All
of the constants defined by the enumerated type are indices into the
enumerated domain.

An enumerated domain is specified as an indefinite domain would be
except the type is an enumerated type rather than some other scalar
type.

\subsection{Association of Arrays to Domains}
\label{Association_of_Arrays_to_Domains}

When an array is declared, it is linked during execution to the domain
over which it was declared.  This linkage is constant and cannot be
changed.

When indices are added or removed from a domain, the change impacts
the arrays declared over this particular domain.  In the case of
adding an index, an element is added to the array and initialized to
the default value associated with the element type.  In the case of
removing an index, the element in the array is removed.

When a domain is reassigned a new value, the array is also impacted.
Values that could be indexed by both the old domain and the new domain
are preserved in the array.  Values that could only be indexed by the
old domain are lost.  Values that can only be indexed by the new
domain have elements added to the new array and initialized to the
default value associated with their type.

For performance reasons, there is an expectation that a method will be
added to domains to allow non-preserving assignment, {\em i.e.}, all
values in the arrays associated with the assigned domain will be lost.

\subsection{Subdomains}
\label{Subdomains}

\begin{implementation}
Subdomains are not yet implemented.
\end{implementation}

A subdomain is a domain whose indices are indices of a {\em base
  domain}.  A subdomain is specified by the following syntax:
\begin{syntax}
subdomain-type:
  `domain' ( domain-expression )
\end{syntax}
The ordering of the indices in the subdomain is consistent with the
ordering of the indices in the base domain.

Subdomains are verified during execution even as domains are
reassigned.  The indices in a subdomain are known to be indices in a
domain, allowing for fast bounds-checking.

In the case of arithmetic domains, the subdomain literal may be
composed of indefinite arithmetic sequences.  In such cases, the
omitted bounds of the indefinite arithmetic sequences are taken from
the bounds of the base domain.

\subsection{Predefined Functions and Methods on Domains}

There is an expectation that this list of predefined functions and
methods will grow.

\begin{protohead}
def $Domain$.numIndices: dim_type
\end{protohead}
\begin{protobody}
Returns the number of indices in the domain.
\end{protobody}

\subsection{Predefined Functions and Methods on Arrays}

There is an expectation that this list of predefined functions and
methods will grow.

\begin{protohead}
def $Array$.numElements: this.domain.dim_type
\end{protohead}
\begin{protobody}
Returns the number of elements in the array.
\end{protobody}
