\sekshun{Standard Modules}
\label{Standard_Modules}
\index{standard modules}

This section describes predefined functions that are available to any
Chapel program as well as a set of standard modules that, when used,
define a set of functions and types available to Chapel programs.  The
standard modules include the following:

\begin{tabular}{lll}
\hspace{1pc} & \chpl{BitOps} & Bit manipulation routines \\
 & \chpl{Math} & ({\it used by default}) Math routines \\
 & \chpl{Random} & Random number generation routines \\
 & \chpl{Standard} & ({\it used by default}) Basic routines \\
 & \chpl{Time} & Types and routines related to time \\
 & \chpl{Types} & ({\it used by default}) Routines related to primitive types \\
\end{tabular}

There is an expectation that each of these modules will be extended
and that more standard modules will be defined.

\subsection{BitOps}
\label{BitOps}
\index{standard modules!BitOps}

The module \chpl{BitOps} defines routines that manipulate the bits of
values of integral types.

\vspace{1pc}

\begin{protohead}
def bitPop(i: integral): int
\end{protohead}
\begin{protobody}
Returns the number of bits set to one in the integral
argument \chpl{i}.
\end{protobody}

\begin{protohead}
def bitMatMultOr(i: uint(64), j: uint(64)): uint(64)
\end{protohead}
\begin{protobody}
Returns the bitwise matrix multiplication of \chpl{i} and \chpl{j}
where the values of \chpl{uint(64)} type are treated as $8 \times 8$
bit matrices and the combinator function is bitwise or.
\end{protobody}

\begin{protohead}
def bitRotLeft(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the left \chpl{shift} number of times.
\end{protobody}

\begin{protohead}
def bitRotRight(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the right \chpl{shift} number of times.
\end{protobody}

\subsection{Math}
\label{Math}
\index{standard modules!Math}

The module \chpl{Math} defines routines for mathematical computations.
This module is used by default; there is no need to explicitly used
this module.  The Math module defines routines that are derived from
and implemented via the standard C routines defined in \chpl{math.h}.

\vspace{1pc}

\begin{protohead}
def abs(i: int(?w)): int(w)
def abs(i: uint(?w)): uint(w)
def abs(x: real): real
def abs(x: complex): real
\end{protohead}
\begin{protobody}
Returns the absolute value of the argument.
\end{protobody}

\begin{protohead}
def acos(x: real): real
\end{protohead}
\begin{protobody}
Returns the arc cosine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
def acosh(x: real): real
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic cosine of the argument.  It is an error
if \chpl{x} is less than $1$.
\end{protobody}

\begin{protohead}
def asin(x: real): real
\end{protohead}
\begin{protobody}
Returns the arc sine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
def asinh(x: real): real
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
def atan(x: real): real
\end{protohead}
\begin{protobody}
Returns the arc tangent of the argument.
\end{protobody}

\begin{protohead}
def atan2(y: real, x: real): real
\end{protohead}
\begin{protobody}
Returns the arc tangent of the two arguments.  This is equivalent to
the arc tangent of \chpl{y / x} except that the signs of \chpl{y}
and \chpl{x} are used to determine the quadrant of the result.
\end{protobody}

\begin{protohead}
def atanh(x: real): real
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic tangent of the argument.  It is an error
if \chpl{x} is less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
def cbrt(x: real): real
\end{protohead}
\begin{protobody}
Returns the cube root of the argument.
\end{protobody}

\begin{protohead}
def ceil(x: real): real
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded up to the nearest integer.
\end{protobody}

\begin{protohead}
def conjg(a: complex(?w)): complex(w)
\end{protohead}
\begin{protobody}
Returns the conjugate of \chpl{a}.
\end{protobody}

\begin{protohead}
def cos(x: real): real
\end{protohead}
\begin{protobody}
Returns the cosine of the argument.
\end{protobody}

\begin{protohead}
def cosh(x: real): real
\end{protohead}
\begin{protobody}
Returns the hyperbolic cosine of the argument.
\end{protobody}

\begin{protohead}
def erf(x: real): real
\end{protohead}
\begin{protobody}
Returns the error function of the argument defined as
$$\frac{2}{\sqrt{\pi}}\int^x_0e^{-t^2}dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
def erfc(x: real): real
\end{protohead}
\begin{protobody}
Returns the complementary error function of the argument.  This is
equivalent to \chpl{1.0 - erf(x)}.
\end{protobody}

\begin{protohead}
def exp(x: real): real
\end{protohead}
\begin{protobody}
Returns the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
def exp2(x: real): real
\end{protohead}
\begin{protobody}
Returns the value of $2$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
def expm1(x: real): real
\end{protohead}
\begin{protobody}
Returns one less than the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
def floor(x: real): real
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded down to the nearest integer.
\end{protobody}

\begin{protohead}
def lgamma(x: real): real
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the absolute value of the gamma
function of the argument.
\end{protobody}

\begin{protohead}
def log(x: real): real
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
def log10(x: real): real
\end{protohead}
\begin{protobody}
Returns the base 10 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
def log1p(x: real): real
\end{protohead}
\begin{protobody}
Returns the natural logarithm of \chpl{x+1}.
\end{protobody}

\begin{protohead}
def log2(i: int(?w)): int(w)
def log2(i: uint(?w)): uint(w)
def log2(x: real): real
\end{protohead}
\begin{protobody}
Returns the base 2 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
def nearbyint(x: real): real
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rounding direction.
\end{protobody}

\begin{protohead}
def rint(x: real): real
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rounding direction.
\end{protobody}

\begin{protohead}
def round(x: real): real
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument.  Cases halfway
between two integral values are rounded towards zero.
\end{protobody}

\begin{protohead}
def sin(x: real): real
\end{protohead}
\begin{protobody}
Returns the sine of the argument.
\end{protobody}

\begin{protohead}
def sinh(x: real): real
\end{protohead}
\begin{protobody}
Returns the hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
def sqrt(x: real): real
\end{protohead}
\begin{protobody}
Returns the square root of the argument.  It is an error if the
argument is less than zero.
\end{protobody}

\begin{protohead}
def tan(x: real): real
\end{protohead}
\begin{protobody}
Returns the tangent of the argument.
\end{protobody}

\begin{protohead}
def tanh(x: real): real
\end{protohead}
\begin{protobody}
Returns the hyperbolic tangent of the argument.
\end{protobody}

\begin{protohead}
def tgamma(x: real): real
\end{protohead}
\begin{protobody}
Returns the gamma function of the argument defined as
$$\int_0^\infty t^{x-1} e^{-t} dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
def trunc(x: real): real
\end{protohead}
\begin{protobody}
Returns the nearest integral value to the argument that is not larger
than the argument in absolute value.
\end{protobody}

\subsection{Random}
\label{Random}
\index{standard modules!Random}

The module \chpl{Random} supports the generation of pseudo-random
values and streams of values.  The current interface is minimal and
should be expected to grow and evolve over time.

\begin{protohead}
class RandomStream
\end{protohead}
\begin{protobody}
Implements a pseudo-random stream of values.  Our current
implementation generates the values using a linear congruential
generator.  In future versions of this module, the RandomStream class
will offer a wider variety of algorithms for generating pseudo-random
values.
\end{protobody}

\begin{protohead}
const RandomStream.seed: int(64)
\end{protohead}
\begin{protobody}
The seed value for the random stream.  If no seed is specified in the
constructor, the millisecond value of the current time is used.  The
seed value must be an odd integer.  If an even integer is supplied,
the class constructor will increment it to obtain an odd integer.
\end{protobody}

\begin{protohead}
def RandomStream.fillRandom(x:[?D] real)
\end{protohead}
\begin{protobody}
Fill the argument array, \chpl{x}, with the next $|$\chpl{D}$|$ values
of the pseudo-random stream.  Arrays of arbitrary rank can be passed
to this routine, causing the 1D stream of values to be mapped to the
array elements according to the array's default iteration order.  Once
our implementation supports distributed arrays, this routine is
intended to fill the array's values in parallel.
\end{protobody}

\begin{protohead}
def RandomStream.fillRandom(x:[?D] complex)
\end{protohead}
\begin{protobody}
Similar to the previous routine, but for use with arrays of complex
values.  The elements are filled in the same order as above except
that pairs of values from the stream are assigned to each element, the
first to the real component, the second to the imaginary.  As this
module matures, we will support \chpl{fillRandom} for arrays of other
element types as well.
\end{protobody}

\begin{protohead}
SeedGenerator
\end{protohead}
\begin{protobody}
A symbol that can be used to generate seed values for the RandomStream
class.
\end{protobody}

\begin{protohead}
SeedGenerator.clockMS
\end{protohead}
\begin{protobody}
Generates a seed value using the milliseconds value from the current
time.  As this module matures, \chpl{SeedGenerator} will support
additional mechanisms for generating seed values.
\end{protobody}

\begin{protohead}
def fillRandom(x:[], initseed: int(64))
\end{protohead}
\begin{protobody}

A routine provided for convenience to support filling an array
\chpl{x} with pseudo-random values without explicitly constructing an
instance of the \chpl{RandomStream} class, useful for filling a single
array or multiple arrays which require no coherence between them.  The
\chpl{initseed} parameter corresponds to the \chpl{seed} member of the
\chpl{RandomStream} class and will default to the milliseconds value
of the current time if no seed value is provided.
\end{protobody}


\subsection{Search}
\label{Search}
\index{standard modules!Search}

The \chpl{Search} module is designed to support standard search
routines.  The current interface is minimal and should be expected to
grow and evolve over time.

\begin{protohead}
def LinearSearch(Data: [?Dom], val): (bool, index(Dom))
\end{protohead}
\begin{protobody}
Searches through the pre-sorted array \chpl{Data} looking for the
value \chpl{val} using a sequential linear search.  Returns a tuple
indicating (1) whether or not the value was found and (2) the location
of the value if it was found, or the location where the value should
have been if it was not found.
\end{protobody}


\begin{protohead}
def BinarySearch(Data: [?Dom], val, in lo = Dom.low, in hi = Dom.high);
\end{protohead}
\begin{protobody}
Searches through the pre-sorted array \chpl{Data} looking for the
value \chpl{val} using a sequential binary search.  If provided, only
the indices \chpl{lo} through \chpl{hi} will be considered, otherwise
the whole array will be searched.  Returns a tuple indicating (1)
whether or not the value was found and (2) the location of the value
if it was found, or the location where the value should have been if
it was not found.
\end{protobody}


\subsection{Sort}
\label{Sort}
\index{standard modules!Sort}

The \chpl{Sort} module is designed to support standard sorting
routines.  The current interface is minimal and should be expected to
grow and evolve over time.

\begin{protohead}
def InsertionSort(Data: [?Dom]) where Dom.rank == 1;
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential insertion
sort algorithm.
\end{protobody}

\begin{protohead}
def QuickSort(Data: [?Dom]) where Dom.rank == 1;
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential
implementation of the QuickSort algorithm.
\end{protobody}

\subsection{Standard}
\label{Standard}
\index{standard modules!Standard}

\begin{protohead}
def ascii(s: string): int
\end{protohead}
\begin{protobody}
Returns the ASCII code number of the first letter in the
argument \chpl{s}.
\end{protobody}

\begin{protohead}
def assert(test: bool) {
\end{protohead}
\begin{protobody}
Exits the program if \chpl{test} is false and prints to standard error
the location in the Chapel code of the call to \chpl{assert}.
If \chpl{test} is true, no action is taken.
\end{protobody}

\begin{protohead}
def assert(test: bool, args ...?numArgs) {
\end{protohead}
\begin{protobody}
Exits the program if \chpl{test} is false and prints to standard error
the location in the Chapel code of the call to \chpl{assert} as well
as the rest of the arguments to the call.  If \chpl{test} is true, no
action is taken.
\end{protobody}

\begin{protohead}
def complex.re: real
\end{protohead}
\begin{protobody}
Returns the real component of the complex number.
\end{protobody}

\begin{protohead}
def complex.im: real
\end{protohead}
\begin{protobody}
Returns the imaginary component of the complex number.
\end{protobody}

\begin{protohead}
def complex.=re(f: real)
\end{protohead}
\begin{protobody}
Sets the real component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
def complex.=im(f: real)
\end{protohead}
\begin{protobody}
Sets the imaginary component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
def exit(status: int)
\end{protohead}
\begin{protobody}
Exits the program with code \chpl{status}.
\end{protobody}

\begin{protohead}
def halt() {
\end{protohead}
\begin{protobody}
Exits the program and prints to standard error the location in the
Chapel code of the call to \chpl{halt} as well as the rest of the
arguments to the call.
\end{protobody}

\begin{protohead}
def halt(args ...?numArgs) {
\end{protohead}
\begin{protobody}
Exits the program and prints to standard error the location in the
Chapel code of the call to \chpl{halt} as well as the rest of the
arguments to the call.
\end{protobody}

\begin{protohead}
def length(s: string): int
\end{protohead}
\begin{protobody}
Returns the number of characters in the argument \chpl{s}.
\end{protobody}

\begin{protohead}
def max(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the maximum of the arguments when compared using the
``greater-than'' operator.  The return type is inferred from the types
of the arguments as allowed by implicit coercions.
\end{protobody}

\begin{protohead}
def min(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the minimum of the arguments when compared using the
``less-than'' operator.  The return type is inferred from the types of
the arguments as allowed by implicit coercions.
\end{protobody}

\begin{protohead}
def string.substring(x): string
\end{protohead}
\begin{protobody}
Returns a value of string type that is a substring of the base
expression.  If \chpl{x} is $i$, a value of type \chpl{int}, then the
result is the $i$th character.  If \chpl{x} is a range, the result is
the substring where the characters in the substring are given by the
values in the range.
\end{protobody}

\subsection{Time}
\label{Time}
\index{standard modules!Time}

The module \chpl{Time} defines routines that query the system time and
a record \chpl{Timer} that is useful for timing portions of code.

\vspace{1pc}

\begin{protohead}
record Timer
\end{protohead}
\begin{protobody}
A timer is used to time portions of code.  Its semantics are similar
to a stopwatch.
\end{protobody}

\begin{protohead}
enum TimeUnits { microseconds, milliseconds, seconds, minutes, hours };
\end{protohead}
\begin{protobody}
The enumeration TimeUnits defines units of time.  These units can be
supplied to routines in this module to specify the desired time units.
\end{protobody}

\begin{protohead}
def getCurrentDate(): (int, int, int)
\end{protohead}
\begin{protobody}
Returns the year, month, and day of the month as integers.  The year
is the year since 0.  The month is in the range 1 to 12.  The day is
in the range 1 to 31.
\end{protobody}

\begin{protohead}
def getCurrentTime(unit: TimeUnits = seconds): real
\end{protohead}
\begin{protobody}
Returns the elapsed time since midnight in the units specified.
\end{protobody}

\begin{protohead}
def Timer.clear()
\end{protohead}
\begin{protobody}
Clears the elapsed time stored in the Timer.
\end{protobody}

\begin{protohead}
def Timer.elapsed(unit: TimeUnits = seconds): real
\end{protohead}
\begin{protobody}
Returns the cumulative elapsed time, in the units specified, between
calls to \chpl{start} and \chpl{stop}.  If the timer is running, the
elapsed time since the last call to \chpl{start} is added to the
return value.
\end{protobody}

\begin{protohead}
def Timer.start()
\end{protohead}
\begin{protobody}
Start the timer.  It is an error to start a timer that is already
running.
\end{protobody}

\begin{protohead}
def Timer.stop()
\end{protohead}
\begin{protobody}
Stops the timer.  It is an error to stop a timer that is not running.
\end{protobody}

\begin{protohead}
def sleep(t: uint)
\end{protohead}
\begin{protobody}
Delays the computation for \chpl{t} seconds.
\end{protobody}

\subsection{Types}

\begin{protohead}
def numBits(type t) param : int
\end{protohead}
\begin{protobody}
Returns the number of bits used to store the values of type \chpl{t}.
This is implemented for all numeric types and \chpl{bool}.
\end{protobody}


\begin{protohead}
def numBytes(type t) param : int
\end{protohead}
\begin{protobody}
Returns the number of bytes used to store the values of type \chpl{t}.
This is implemented for all numeric types and \chpl{bool}.
\end{protobody}

\begin{protohead}
def max(type t): t
\end{protohead}
\begin{protobody}
Returns the maximum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}

\begin{protohead}
def min(type t): t
\end{protohead}
\begin{protobody}
Returns the minimum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}

