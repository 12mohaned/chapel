\sekshun{Standard Modules}
\label{Standard_Modules}

This section describes predefined functions that are available to any
Chapel program as well as a set of standard modules that, when used,
define a set of functions and types available to Chapel programs.  The
standard modules include the following:

\begin{tabular}{lll}
\hspace{1pc} & \chpl{BitOps} & Bit manipulation routines \\
 & \chpl{Math} & ({\it used by default}) Math routines \\
 & \chpl{Random} & Random number generation routines \\
 & \chpl{Standard} & ({\it used by default}) Basic routines \\
 & \chpl{Time} & Types and routines related to time \\
 & \chpl{Types} & ({\it used by default}) Routines related to primitive types \\
\end{tabular}

There is an expectation that each of these modules will be extended
and that more standard modules will be defined.

\subsection{BitOps}
\label{BitOps}

The module \chpl{BitOps} defines routines that manipulate the bits of
values of integral types.

\vspace{1pc}

\begin{protohead}
def bitPop(i: integral): int
\end{protohead}
\begin{protobody}
Returns the number of bits set to one in the integral
argument \chpl{i}.
\end{protobody}

\begin{protohead}
def bitMatMultOr(i: uint(64), j: uint(64)): uint(64)
\end{protohead}
\begin{protobody}
Returns the bitwise matrix multiplication of \chpl{i} and \chpl{j}
where the values of \chpl{uint(64)} type are treated as $8 \times 8$
bit matrices and the combinator function is bitwise or.
\end{protobody}

\begin{protohead}
def bitRotLeft(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the left \chpl{shift} number of times.
\end{protobody}

\begin{protohead}
def bitRotRight(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the right \chpl{shift} number of times.
\end{protobody}

\subsection{Math}
\label{Math}

The module \chpl{Math} defines routines for mathematical computations.
This module is used by default; there is no need to explictly used
this module.  The Math module defines routines that are derived from
and implemented via the standard C routines defined in \chpl{math.h}.

\vspace{1pc}

\begin{protohead}
def abs(i: int(?w)): int(w)
def abs(i: uint(?w)): uint(w)
def abs(x: real): real
def abs(x: complex): real
\end{protohead}
\begin{protobody}
Returns the absolute value of the argument.
\end{protobody}

\begin{protohead}
def acos(x: real): real
\end{protohead}
\begin{protobody}
Returns the arc cosine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
def acosh(x: real): real
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic cosine of the argument.  It is an error
if \chpl{x} is less than $1$.
\end{protobody}

\begin{protohead}
def asin(x: real): real
\end{protohead}
\begin{protobody}
Returns the arc sine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
def asinh(x: real): real
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
def atan(x: real): real
\end{protohead}
\begin{protobody}
Returns the arc tangent of the argument.
\end{protobody}

\begin{protohead}
def atan2(y: real, x: real): real
\end{protohead}
\begin{protobody}
Returns the arc tangent of the two arguments.  This is equivalent to
the arc tangent of \chpl{y / x} except that the signs of \chpl{y}
and \chpl{x} are used to determine the quadrant of the result.
\end{protobody}

\begin{protohead}
def atanh(x: real): real
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic tangent of the argument.  It is an error
if \chpl{x} is less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
def cbrt(x: real): real
\end{protohead}
\begin{protobody}
Returns the cube root of the argument.
\end{protobody}

\begin{protohead}
def ceil(x: real): real
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded up to the nearest integer.
\end{protobody}

\begin{protohead}
def cos(x: real): real
\end{protohead}
\begin{protobody}
Returns the cosine of the argument.
\end{protobody}

\begin{protohead}
def cosh(x: real): real
\end{protohead}
\begin{protobody}
Returns the hyperbolic cosine of the argument.
\end{protobody}

\begin{protohead}
def erf(x: real): real
\end{protohead}
\begin{protobody}
Returns the error function of the argument defined as
$$\frac{2}{\sqrt{\pi}}\int^x_0e^{-t^2}dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
def erfc(x: real): real
\end{protohead}
\begin{protobody}
Returns the complementary error function of the argument.  This is
equivalent to \chpl{1.0 - erf(x)}.
\end{protobody}

\begin{protohead}
def exp(x: real): real
\end{protohead}
\begin{protobody}
Returns the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
def exp2(x: real): real
\end{protohead}
\begin{protobody}
Returns the value of $2$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
def expm1(x: real): real
\end{protohead}
\begin{protobody}
Returns one less than the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
def floor(x: real): real
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded down to the nearest integer.
\end{protobody}

\begin{protohead}
def lgamma(x: real): real
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the absolute value of the gamma
function of the argument.
\end{protobody}

\begin{protohead}
def log(x: real): real
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
def log10(x: real): real
\end{protohead}
\begin{protobody}
Returns the base 10 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
def log1p(x: real): real
\end{protohead}
\begin{protobody}
Returns the natural logarithm of \chpl{x+1}.
\end{protobody}

\begin{protohead}
def log2(i: int(?w)): int(w)
def log2(i: uint(?w)): uint(w)
def log2(x: real): real
\end{protohead}
\begin{protobody}
Returns the base 2 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
def nearbyint(x: real): real
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rouding direction.
\end{protobody}

\begin{protohead}
def rint(x: real): real
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rouding direction.
\end{protobody}

\begin{protohead}
def round(x: real): real
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument.  Cases halfway
between two integral values are rounded towards zero.
\end{protobody}

\begin{protohead}
def sin(x: real): real
\end{protohead}
\begin{protobody}
Returns the sine of the argument.
\end{protobody}

\begin{protohead}
def sinh(x: real): real
\end{protohead}
\begin{protobody}
Returns the hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
def sqrt(x: real): real
\end{protohead}
\begin{protobody}
Returns the square root of the argument.  It is an error if the
argument is less than zero.
\end{protobody}

\begin{protohead}
def tan(x: real): real
\end{protohead}
\begin{protobody}
Returns the tangent of the argument.
\end{protobody}

\begin{protohead}
def tanh(x: real): real
\end{protohead}
\begin{protobody}
Returns the hyperbolic tangent of the argument.
\end{protobody}

\begin{protohead}
def tgamma(x: real): real
\end{protohead}
\begin{protobody}
Returns the gamma function of the argument defined as
$$\int_0^\infty t^{x-1} e^{-t} dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
def trunc(x: real): real
\end{protohead}
\begin{protobody}
Returns the nearest integral value to the argument that is not larger
than the argument in absolute value.
\end{protobody}

\subsection{Random}
\label{Random}

This section is forthcoming.

\subsection{Standard}
\label{Standard}

\begin{protohead}
def ascii(s: string): int
\end{protohead}
\begin{protobody}
Returns the ASCII code number of the first letter in the
argument \chpl{s}.
\end{protobody}

\begin{protohead}
def assert(test: bool) {
\end{protohead}
\begin{protobody}
Exits the program if \chpl{test} is false and prints to standard error
the location in the Chapel code of the call to \chpl{assert}.
If \chpl{test} is true, no action is taken.
\end{protobody}

\begin{protohead}
def assert(test: bool, args ...?numArgs) {
\end{protohead}
\begin{protobody}
Exits the program if \chpl{test} is false and prints to standard error
the location in the Chapel code of the call to \chpl{assert} as well
as the rest of the arguments to the call.  If \chpl{test} is true, no
action is taken.
\end{protobody}

\begin{protohead}
def complex.re: real
\end{protohead}
\begin{protobody}
Returns the real component of the complex number.
\end{protobody}

\begin{protohead}
def complex.im: real
\end{protohead}
\begin{protobody}
Returns the imaginary component of the complex number.
\end{protobody}

\begin{protohead}
def complex.=re(f: real)
\end{protohead}
\begin{protobody}
Sets the real component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
def complex.=im(f: real)
\end{protohead}
\begin{protobody}
Sets the imaginary component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
def conjg(a: complex(?w)): complex(w)
\end{protohead}
\begin{protobody}
Returns the conjugate of \chpl{a}.
\end{protobody}

\begin{protohead}
def exit(status: int)
\end{protohead}
\begin{protobody}
Exits the program with code \chpl{status}.
\end{protobody}

\begin{protohead}
def halt() {
\end{protohead}
\begin{protobody}
Exits the program and prints to standard error the location in the
Chapel code of the call to \chpl{halt} as well as the rest of the
arguments to the call.
\end{protobody}

\begin{protohead}
def halt(args ...?numArgs) {
\end{protohead}
\begin{protobody}
Exits the program and prints to standard error the location in the
Chapel code of the call to \chpl{halt} as well as the rest of the
arguments to the call.
\end{protobody}

\begin{protohead}
def length(s: string): int
\end{protohead}
\begin{protobody}
Returns the number of characters in the argument \chpl{s}.
\end{protobody}

\begin{protohead}
def max(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the maximum of the arguments when compared using the
``greater-than'' operator.  The return type is inferred from the types
of the arguments as allowed by implicit coercions.
\end{protobody}

\begin{protohead}
def min(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the minimum of the arguments when compared using the
``less-than'' operator.  The return type is inferred from the types of
the arguments as allowed by implicit coercions.
\end{protobody}

\begin{protohead}
def string.substring(x): string
\end{protohead}
\begin{protobody}
Returns a value of string type that is a substring of the base
expression.  If \chpl{x} is $i$, a value of type \chpl{int}, then the
result is the $i$th character.  If \chpl{x} is an arithmetic sequence,
the result is the substring where the characters in the substring are
given by the values in the arithmetic sequence.
\end{protobody}

\subsection{Time}
\label{Time}

The module \chpl{Time} defines routines that query the system time and
a record \chpl{Timer} that is useful for timing portions of code.

\vspace{1pc}

\begin{protohead}
record Timer
\end{protohead}
\begin{protobody}
A timer is used to time portions of code.  Its semantics are similar
to a stopwatch.
\end{protobody}

\begin{protohead}
enum TimeUnits { microseconds, milliseconds, seconds, minutes, hours };
\end{protohead}
\begin{protobody}
The enumeration TimeUnits defines units of time.  These units can be
supplied to routines in this module to specify the desired time units.
\end{protobody}

\begin{protohead}
def getCurrentDate(): (int, int, int)
\end{protohead}
\begin{protobody}
Returns the year, month, and day of the month as integers.  The year
is the year since 0.  The month is in the range 1 to 12.  The day is
in the range 1 to 31.
\end{protobody}

\begin{protohead}
def getCurrentTime(unit: TimeUnits = seconds): real
\end{protohead}
\begin{protobody}
Returns the elapsed time since midnight in the units specified.
\end{protobody}

\begin{protohead}
def Timer.clear()
\end{protohead}
\begin{protobody}
Clears the elapsed time stored in the Timer.
\end{protobody}

\begin{protohead}
def Timer.elapsed(unit: TimeUnits = seconds): real
\end{protohead}
\begin{protobody}
Returns the cumulative elapsed time, in the units specified, between
calls to \chpl{start} and \chpl{stop}.  If the timer is running, the
elapsed time since the last call to \chpl{start} is added to the
return value.
\end{protobody}

\begin{protohead}
def Timer.start()
\end{protohead}
\begin{protobody}
Start the timer.  It is an error to start a timer that is already
running.
\end{protobody}

\begin{protohead}
def Timer.stop()
\end{protohead}
\begin{protobody}
Stops the timer.  It is an error to stop a timer that is not running.
\end{protobody}

\begin{protohead}
def sleep(t: int)
\end{protohead}
\begin{protobody}
Delays the computation for \chpl{t} seconds.
\end{protobody}

\subsection{Types}

\begin{protohead}
def numBits(type t): int
\end{protohead}
\begin{protobody}
Returns the number of bits used to store the values of type \chpl{t}.
This is implemented for all numeric types and \chpl{bool}.
\end{protobody}

\begin{protohead}
def max(type t): t
\end{protohead}
\begin{protobody}
Returns the maximum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}

\begin{protohead}
def min(type t): t
\end{protohead}
\begin{protobody}
Returns the minimum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}

