\sekshun{Parallelism and Synchronization}
\label{Parallelism_and_Synchronization}

Chapel is an explicitly parallel programming language.  Parallelism is
introduced into a program by the user by parallel statements and
parallel expressions.  The syntax for such statements and expressions
is as follows:
\begin{syntax}
parallel-statement:
  forall-statement
  alternative-forall-statement
  ordered-forall-statement
  cobegin-statement
  coforall-statement
  begin-statement
  serial-statement
  atomic-statement

parallel-expression:
  forall-expression
  ordered-expression
\end{syntax}

In addition, some operations on arrays and domains, as well as
invocations of promotion, are executed in parallel.  Synchronization
is provided with \emph{synchronization variables} and \emph{atomic}
statements.  To avoid any unintended implications, the
terms \emph{computation} and \emph{sub-computation} will be used to
refer to distinct, concurrently executing portions of the program.

\subsection{The Forall Loop}
\label{Forall}
\index{forall@\chpl{forall}}
\index{forall loops}

The forall loop is a variant of the for loop that allows for the
concurrent execution of the loop body. The for loop is described
in~\rsec{The_For_Loop}. The syntax for the forall loop is given by
\begin{syntax}
forall-statement:
   `forall' loop-control-part loop-body-part
\end{syntax}

The forall loop evaluates the loop body once for each element in
the \sntx{iterator-expression}.  Each instance of the forall loop's
statement may be executed concurrently with each other, but this is
not guaranteed.  The compiler and runtime determine the actual
concurrency based on the specification of the iterator of the loop.
The keyword \chpl{ordered}, described in~\rsec{Ordered_Forall}, can be
used to constrain the parallelism to give a partial order on the
iterator.

Control continues with the statement following the forall loop only
after each iteration has been completely evaluated.  Control transfers
out of a loop body via \chpl{break}, \chpl{continue},
and \chpl{return} are not permitted.  Control can be transferred out
of the loop via a \chpl{yield} statement.

\begin{example}
In the code
\begin{chapel}
forall i in 1..N do
  a(i) = b(i);
\end{chapel}
the user has stated that the element-wise assignments can execute
concurrently.  This loop may be performed serially, with maximum
concurrency where each loop body iteration instance is executed in a
separate computation, or somewhere in between.
\end{example}

\begin{status}
The forall loop is currently executed serially.
\end{status}

\subsubsection{Alternative Forall Loop Syntax}
\label{Alternative_Forall_Loop_Syntax}
\index{forall loops!alternative syntax}

The forall loop may be alternatively specified with a more concise
syntax given by:
\begin{syntax}
alternative-forall-statement:
  [loop-control-part] statement
\end{syntax}
The semantics are unchanged.

\begin{example}
The previous \chpl{forall} example can be alternatively written as:
\begin{chapel}
[i in 1..N] a(i) = b(i);
\end{chapel}
\end{example}

\subsubsection{The Ordered Forall Loop}
\label{Ordered_Forall}
\index{forall loops!ordered}
\index{ordered@\chpl{ordered}}

By default a forall loop allows complete concurrent evaluation of the
iterator expression and among the loop instances. The
keyword \chpl{ordered} can be used to constrain the general
parallelism among instances of the loop to that expressed by an
iterator. This allows an iterator to both define an array of values
and to impose a partial order on that iterator.  This has the same
semantics as with the ordered expression which is explained
in \rsec{Ordered_Expressions}.  The syntax is:
\begin{syntax}
ordered-forall-statement:
   `ordered' `forall' loop-control-part loop-body-part
\end{syntax}

\begin{example}
In the code
\begin{chapel}
ordered forall i in walk(root) do
  work(i);

def walk(n: node) {
  yield n;
  forall c in 0..n.numOfChildren {
      yield n.child[c];
  }
}
\end{chapel}
there is a constraint on the parallel execution such that the
function \chpl{work} is evaluated on a node before any of its
immediate children nodes.  The work on sibling nodes can be executed
concurrently.
\end{example}

\begin{status}
The ordered forall loop is currently executed serially.
\end{status}

\subsection{The Forall Expression}
\label{Forall_Expressions}
\index{forall expressions}

A forall expression can be used to enable concurrent evaluation of
sub-expressions.  The sub-expressions are evaluated once for each
element in the iterator expression.  The syntax of a forall expression
is given by
\begin{syntax}
forall-expression:
   `forall' loop-control-part `do' expression
   [loop-control-part] expression
\end{syntax}

A forall expression is semantically equivalent to an iterator that
yields the expressions.

\begin{example}
The code
\begin{chapel}
[i in S] f(i);
\end{chapel}
is equivalent to
\begin{chapel}
def ff() {
  for i in S do
    yield f(i);
}
ff();
\end{chapel}
\end{example}

\begin{status}
Forall expressions are evaluated serially.
\end{status}

\subsubsection{Filtering Predicates in Forall Expressions}
\label{Filtering_Predicates_Forall}
\index{forall expressions!and conditional expressions}

An if expression that is immediately enclosed by a forall expression
does not require an else part.
\begin{example}
The following expression returns every other element starting with the
first:
\begin{chapel}
[i in 1..s.length] if i % 2 == 1 then s(i)
\end{chapel}
\end{example}

\subsection{The Cobegin Statement}
\label{Cobegin}
\index{cobegin@\chpl{cobegin}}

The cobegin statement is used to create parallelism among statements
within a block statement. The \chpl{cobegin} statement syntax is
\begin{syntax}
cobegin-statement:
  `cobegin' block-statement
\end{syntax}
Each statement within the block statement is executed concurrently and
is considered a separate computation.  Control continues after all of
the statements within the block statement have been evaluated.

As with the forall loop, control transfers are not permitted
either into or out of the cobegin's block statement. Similarly,
yield statements are allowed.

Variables declared in the cobegin statement are {\em single variables},
described in~\rsec{Single_Variables}.

\subsection{The Coforall Loop}
\label{Coforall}
\index{coforall@\chpl{coforall}}
\index{coforall loops}

The coforall loop is a variant of the cobegin statement and the forall
loop.  The syntax for the coforall loop is given by
\begin{syntax}
coforall-statement:
   `coforall' loop-control-part loop-body-part
\end{syntax}

The semantics of the \chpl{coforall} loop are identical to
the \chpl{forall} loop except that each iteration is guaranteed to run
concurrently.  It thus has potentially higher overhead than a forall
loop, but in cases where concurrency is required for correctness, it
is essential.

The semantics of the \chpl{coforall} loop are also identical to
a \chpl{cobegin} statement where each iteration of the \chpl{coforall}
loop is equivalent to a separate statement in a \chpl{cobegin} block.

Control continues with the statement following the \chpl{coforall}
loop only after each iteration has been completely evaluated.  Control
transfers out of a loop body via \chpl{break}, \chpl{continue},
and \chpl{return} are not permitted.  Control can be transferred out
of the loop via a \chpl{yield} statement.

\subsection{The Begin Statement}
\label{Begin}
\index{begin@\chpl{begin}}

The begin statement spawns a computation to execute a statement.
Control continues simultaneously with the statement following the
begin statement. The begin statement is an unstructured way to create
a new computation that is executed only for its side-effects. The
syntax for the begin statement is given by
\begin{syntax}
begin-statement:
  `begin' statement
\end{syntax}

The following statements cannot be contained in begin-statements:
break-statements, continue-statements, yield-statements, and
return-statements.

\subsection{The Ordered Expression}
\label{Ordered_Expressions}
\index{ordered@\chpl{ordered}}

\begin{status}
The ordered expression is not yet implemented.
\end{status}

The \chpl{ordered} keyword can be used as an unary operator to suppress
parallel execution among instances of an expression that can involve
side-effects to memory.  The \chpl{ordered} keyword does not inhibit
parallelism within the sub-expression.  The syntax is:
\begin{syntax}
ordered-expression:
   `ordered' expression
\end{syntax}

\begin{example}
In the code
\begin{chapel}
ordered [i in S] f(i) 
\end{chapel}
\chpl{f} is a function and \chpl{S} is an iterator expression. Each
instance of \chpl{f(i)} is executed once for each value in \chpl{S}
and in serial order. The \chpl{ordered} constraint does not propagate
to inhibit parallelism within \chpl{f}.
\end{example}

\subsection{The Serial Statement}
\label{Serial}
\index{serial@\chpl{serial}}

The \chpl{serial} statement can be used to dynamically control the
degree of parallelism.  The syntax is:
\begin{syntax}
serial-statement:
  `serial' expression block-level-statement
\end{syntax}
where the expression evaluates to a bool type.  Independent of that
value, the \sntx{block-level-statement} is evaluated. If the
expression is true, any dynamically encountered forall loop or cobegin
statement is executed serially within the current computation.  Any
dynamically encountered begin-statement is executed serially with the
current computation; no new computation is spawned.  Control continues
to the statement following the begin-statement after the
begin-statement finishes.

\begin{example}
In the code
\begin{chapel}
ordered forall i in walk(root) do
  work(i);

def walk(n: node) {
  yield n;
  serial n.depth > 4 forall c in 0..n.numOfChildren {
      yield n.child[c];
  }
}
\end{chapel}
the serial statement inhibits concurrent execution on the tree for
nodes that are deeper than four levels in the tree.
\end{example}

There is an expectation that functions that may be executed in a
serial context are cloned to avoid the overhead of testing and
suppressing parallelism.

\subsection{Synchronization Variables}
\label{Synchronization_Variables}
\index{synchronization variables}

{\em Synchronization variables} are used to coordinate computations
that share data.  The use of and assignment to these variables
implicitly controls the execution order of the computation.  There are
two kinds of synchronization variables, {\em single} and {\em sync}
variables.  A single variable can only be assigned once during its
lifetime.  A sync variable can be assigned multiple times during its
lifetime.

The normal use of and assignment to a synchronization variable is well
suited for producer-consumer data sharing.  Additional functions on
synchronization variable are provided such that other traditional
synchronization primitives, such as semaphores and mutexes, can be
constructed.

\subsubsection{Single Variables}
\label{Single_Variables}
\index{synchronization variables!single@\chpl{single}}
\index{single@\chpl{single}}

A single (assignment) variable can only be assigned once during its
lifetime.  A use of a single variable before it is assigned causes the
computation's execution to be suspended until the variable is
assigned. Otherwise, the use proceeds as with normal variables and the
computation continues.  After a single assignment variable is assigned,
all computations with pending uses resume in an unspecified order.  A
single variable is specified with a single type given by the following
syntax:
\begin{syntax}
single-type:
  `single' type-specifier
\end{syntax}

\begin{example}
In the code
\begin{chapel}
class Tree {
  var is_leaf : bool;
  var left    : Tree;
  var right   : Tree;
  var value   : int;

  def sum() {
    if (is_leaf) then 
       return value;

    var x : single int;
    begin x = left.sum();
    var y = right.sum();
    return x+y;
  }
}
\end{chapel}
the single variable \chpl{x} is assigned by an asynchronous
computation created with the begin statement. The computation
returning the sum waits on the reading of \chpl{x} until it has been
assigned.

While a \chpl{cobegin} might be a more suitable formulation, this
fragment creates an asynchronous computation to compute the sum of the
left sub-tree while the main computation continues with the right
sub-tree. The final reference to variable x will be delayed until the
assignment to x completes and that value will be used as a summand.
\end{example}

When a single variable has an initializer, the evaluation of
that initializer is implicitly performed as an asynchronous computation. 
\begin{example}
The code
\begin{chapel}
var x: single int = left.sum;
\end{chapel}
is equivalent to
\begin{chapel}
var x: single int;
x = left.sum;
\end{chapel}
\end{example}

\index{synchronization variables!implicit in cobegin@implicit in \chpl{cobegin}}
Any variable declaration within a cobegin statement is implicitly
treated as a single variable for references in other statements of the
cobegin statement.
\begin{example}
In the code
\begin{chapel}
def sum() {
  if (is_leaf) then 
    return value;
  var z;
  cobegin {
    var x = left.sum();
    var y = right.sum();
    z = x+y;
  }
  return z;
}
\end{chapel}
the computation with assignment to \chpl{z} waits for the other
computations to assign to \chpl{x} and \chpl{y} before it
references \chpl{x} and \chpl{y} in order to assign to \chpl{z}.  The
variables \chpl{x} and \chpl{y} are implicitly single.
\end{example}

\subsubsection{Sync Variables}
\label{Sync_Variables}
\index{synchronization variables!sync@\chpl{sync}}
\index{sync@\chpl{sync}}

A sync variable generalizes the single assignment variable to permit
multiple assignments to the variable. A sync variable is logically
either {\em full} or {\em empty}. When it is empty, computations that
attempt to read that variable are suspended until the variable becomes
full by the next assignment to it, which atomically changes the state
to full. When the variable is full, a read of that variable consumes
the value and atomically transitions the state to empty. If there is
more than one computation waiting on a sync variable, one is
non-deterministically selected to use the variable and resume
execution.  The other computations continue to wait for the next
assignment.

If a computation attempts to assign to a sync variable that is full,
the computation is suspended and the assignment is delayed. When the
sync variable becomes empty, the computation is resumed and the
assignment proceeds, transitioning the state back to full. If there
are multiple computations attempting such an assignment, one is
non-deterministically selected to proceed and the other assignments
continue to wait until the sync variable is emptied again.

A sync variable is specified with a sync type given by the following
syntax:
\begin{syntax}
sync-type:
  `sync' type-specifier
\end{syntax}

\subsubsection{Additional Synchronization Variable Functions}
\label{Functions_on_Synchronization_Variables}
\index{synchronization variables!built-in functions on}
\index{readFE@\chpl{readFE}}
\index{readFF@\chpl{readFF}}
\index{readXX@\chpl{readXX}}
\index{writeEF@\chpl{writeEF}}
\index{writeFF@\chpl{writeFF}}
\index{writeXF@\chpl{writeXF}}
\index{reset@\chpl{reset}}
\index{isFull@\chpl{isFull}}

Synchronization variables support additional methods that
can be used to bypass their semantics to provide new ones.
For a sync variable \chpl{s} of arbitrary type \chpl{t},
the following methods are defined in this class:

\begin{protohead}
def sync $t$.readFE(): t
\end{protohead}
\begin{protobody}
Wait for full, leave empty, and return \chpl{s}'s value.
\end{protobody}

\begin{protohead}
def sync $t$.readFF(): t
\end{protohead}
\begin{protobody}
Wait for full, leave full, and return \chpl{s}'s value.
\end{protobody}

\begin{protohead}
def sync $t$.readXX(): t
\end{protohead}
\begin{protobody}
No wait, leave F/E unchanged, and return \chpl{s}'s value.
\end{protobody}

\begin{protohead}
def sync $t$.writeEF(v: t)
\end{protohead}
\begin{protobody}
Wait for empty, assign \chpl{s=v}, and leave full.
\end{protobody}

\begin{protohead}
def sync $t$.writeFF(v: t)
\end{protohead}
\begin{protobody}
Wait for full, assign \chpl{s=v}, and leave full.
\end{protobody}

\begin{protohead}
def sync $t$.writeXF(v: t)
\end{protohead}
\begin{protobody}
No wait, assign \chpl{s=v}, and leave full.
\end{protobody}

\begin{protohead}
def sync $t$.reset()
\end{protohead}
\begin{protobody}
No wait, assign to \chpl{s} \chpl{t}'s default value, and leave empty.
\end{protobody}

\begin{protohead}
def sync $t$.isFull: bool
\end{protohead}
\begin{protobody}
No wait, returns \chpl{true} if \chpl{s} is full, \chpl{false} otherwise.
\end{protobody}

For single variables \chpl{s},
only \chpl{readFF} and \chpl{writeEF} are defined.

\begin{example}
Given the following declarations
\begin{chapel}
var x: single int;
var y: int;
\end{chapel}
the code
\begin{chapel}
x = 5;
y = x;
\end{chapel}
is equivalent to
\begin{chapel}
x.writeEF(5);
y = x.readFF();
\end{chapel}
\end{example}

\begin{rationale}
Although the \chpl{readFE}, \chpl{readFF}, and \chpl{writeEF} methods
are implicitly called
when referencing or assigning to sync or single variables,
making these methods available supports programmers who wish to
make the semantics of these operations more explicit.
It might be desirable to have a compiler option
that disables the implicit use of these methods.
\end{rationale}

\subsubsection{Synchronization Variables of Record and Class Types}
\label{Synchronization_Variables_of_Record_Type}
\index{synchronization variables!of record type}
\index{synchronization variables!of class type}

A variable of record or class type can be a single or sync
variable. The semantics of single and sync variables are applied only
to the variable and not to accesses of individual fields.  A record or
class type may have synchronization variable fields to get
synchronization semantics on individual field accesses.

\subsubsection{Synchronization Formal Arguments}
\label{Synchronization_Formal_Arguments}
\index{synchronization variables!formal arguments}

If an argument is a sync or single type, the actual is passed by
reference and the argument itself is a valid lvalue.

The unqualified types \chpl{sync} and \chpl{single} can also be used
to specify a generic formal argument.  In this case, the actual must
be a synchronization variable and it is passed by reference.  For
generic formal arguments of any type, an actual that is \chpl{sync}
or \chpl{single} is ``read'' before being passed to the function and
the generic formal argument is not a \chpl{sync} or \chpl{single}
type.

\subsection{Memory Consistency Model}
\label{Memory_Consistency}
\index{memory consistency model}

This section is forthcoming.

\subsection{Atomic Statement}
\label{Atomic_Transactions}
\index{atomic transactions}
\index{atomic@\chpl{atomic}}

\begin{status}
Atomic statements are not yet implemented.
\end{status}

The atomic statement creates an atomic transaction of a statement. The
statement is executed with transaction semantics in that the statement
executes entirely, the statement appears to have completed in a single
order and serially with respect to other atomic statements, and no
variable assignment is visible until the statement has completely
executed.

This definition of an atomic statement is sometimes called {\em strong
atomicity} because the semantics are atomic to the entire program.
{\em Weak atomicity} is defined so that an atomic statement is atomic
only with respect to other atomic statements.  If the performance
implications of strong atomicity are not tolerable, the semantics of
atomic transactions may be revisited, and could become weaker.

The syntax for the atomic statement is given by:
\begin{syntax}
atomic-statement:
  `atomic' statement
\end{syntax}

\begin{example}
The following code illustrates one possible use of atomic statements:
\begin{chapel}
var found = false;
atomic {
  if head == obj {
    found = true;
    head = obj.next;
  } else  {
    var last = head;
    while last != null {
    if last.next == obj {
      found = true;
      last.next = obj.next;
      break;
    }
    last = last.next;
  }
}
\end{chapel}
Inside the atomic statement is a sequential implementation of
removing a particular object denoted by \chpl{obj} from a singly
linked list.  This is an operation that is well-defined, assuming only
one computation is attempting it at a time. The atomic statement
ensures that, for example, the value of \chpl{head} does not change
after it is first in the first comparison and subsequently read to
initialize \chpl{last}. The variables eventually owned by this
computation are \chpl{found}, \chpl{head}, \chpl{obj}, and the various
\chpl{next} fields on examined objects.
\end{example}

The effect of an atomic statement is dynamic.

\begin{example}
If there is a method associated with a list that removes an object,
that method may not be parallel safe, but could be invoked safely inside an
atomic statement:
\begin{chapel}
atomic found = head.remove(obj);
\end{chapel}
\end{example}
