\sekshun{Parallelism and Synchronization}
\label{Parallelism_and_Synchronization}

Chapel is an explicitly parallel programming language. Parallelism is
introduced into a program by the user with three constructs,
\chpl{forall}, \chpl{cobegin}, and \chpl{begin}.  Synchronization is
provided with \emph{synchronizing variables} and atomic statements. To
avoid any unintended implications, we use the terms \emph{computation}
and \emph{sub-computation} to refer to distinct, concurrently
executing portions of the program.


\subsection{Forall}
\label{Forall}

The first form of explicitly creating parallelism is with the forall
loop. The forall loop is a variant of for loop that allows concurrent
execution of the loop body. The for loop is described
in \rsec{The_For_Loop}. The forall loop syntax is:
\begin{syntax}
forall-statement:
   `forall' index-expression `in' iterator-expression `do' statement
   `forall' index-expression `in' iterator-expression block-level-statement
\end{syntax}

The forall loop evaluates the loop body once for each element in the
sequence returned by the iterator expression. Each instance of the
forall loop's statement may be executed concurrently with each
other. The compiler and runtime will decide how many computations are
used and which loop instances are executed by each
computation. Similarly, the iterator expression may be executed
concurrently with the loop statement. The keyword \chpl{ordered} which is
later described in \rsec{Ordered_Forall} can be used to constrain the
parallelism to give a partial order on the sequence returned by an
iterator.

Control continues with the statement following the forall loop only
after all statement instances have been completely evaluated.  Control
transfers such as goto, break, continue, and return are not permitted
either into or out of the body of a forall loop.  However, yield
statements are permitted.

\begin{example}
\begin{chapel}
forall i in 1..N do
  a(i) = b(i);
\end{chapel}
In this example the user has stated that the element-wise assignments
can execute concurrently. The compiler and runtime will decide how
many computations are used to assign all \chpl{N} elements. This loop
may be performed with a single computation executing all N
assignments, N computations with one assignment each, or somewhere
in between such as $N/2$ computations with 2 assignments each.
\end{example}


\subsubsection{Alternative Forall Loop Syntax}
\label{Alternative_Forall_Loop_Syntax}

The forall loop may be alternatively specified with a more concise
syntax given by:
\begin{syntax}
alternative-forall-statement:
  [index-expression `in' iterator-expression] statement
\end{syntax}
The semantics of this alternative forall loop syntax are unchanged.

\begin{example}
The previous \chpl{forall} example can be alternatively written as:
\begin{chapel}
[i in 1..N] a(i) = b(i);
\end{chapel}
\end{example}


\subsubsection{Forall Expressions} %% SJD: Added this section
\label{Forall_Expressions}

Similar to the alternative forall loop syntax, a forall expression can
be used to enable concurrent evaluation of sub-expressions. The
sub-expressions are evaluated once for each element in the iterator
expression. As with the forall loop, the compiler and runtime will
decide how many computations are used. The syntax is:
\begin{syntax}
forall-expression:
   [index-expression `in' iterator-expression] expression
\end{syntax}

\begin{example}
\begin{chapel}
[i in S] f(i);
\end{chapel}
The function \chpl{f} is evaluated once for each $S_i$ and each evaluation
may be executed concurrently.
\end{example}


\subsubsection{Ordered Forall}
\label{Ordered_Forall}
By default a forall loop allows complete concurrent evaluation of the
iterator expression and among the loop instances. The
keyword \chpl{ordered} can be used to constrain the general
parallelism among instances of the loop to that expressed by an
iterator. This allows an iterator to both define a sequence of values
and to impose a partial order on that sequence. If the iterator
expression is a sequence value, there is no effect. This has the same
semantics as with the ordered expression which is explained
in \rsec{Ordered_Expression}.  The syntax is:
\begin{syntax}
ordered-forall-statement:
   ordered `forall' index-expression `in' iterator-expression `do' statement
   ordered `forall' index-expression `in' iterator-expression block-level-statement
\end{syntax}

\begin{example}
\begin{chapel}
ordered forall i in walk(root) do
  work(i);

iterator walk(n: node) {
  yield n;
  forall c in 0..n.numOfChildren {
      yield n.child[c];
  }
}
\end{chapel}
In this example the user has contrained the parallelism such that the
function \chpl{work} is evaluated on a node before any of its
immediate children nodes.  However, the user has still enabled concurrent
evaluation of \chpl{work} on siblings nodes and among non-immediate
family nodes.
\end{example}


\subsection{Cobegin}
\label{Cobegin}

The cobegin statement is used to create parallelism among statements
within a block statement. The \chpl{cobegin} statement syntax is
\begin{syntax}
cobegin-statement:
  `cobegin' block-statement
\end{syntax}
Each statement within the block statement is executed concurrently and
is considered a separate computation. Control continues after all of
the statements within the block statement have been evaluated.

With the forall loop semantics the degree of parallelism is
unspecified and is up to the compiler and runtime. The semantics of
the cobegin statement is more exact. A correct evaluation of the
cobegin statement has the semantics that each statement is evaluated
by a separate computation. It may not be safe to use less computations
than the number of statements. The compiler or runtime would have to
determine that semantics are the same to evaluate more than one
statement serial before using less computations.

As with the forall loop, control transfers are not permitted
either into or out of the cobegin's block statement. Similarly,
yield statements are allowed.

Variables declared in the cobegin statment are {\em single variables}
which are later described in \rsec{Single_Variables}.


\subsection{Begin}
\label{Begin}

The begin statement spawns a computation to execute the statement.
Control continues simultaneously with the statement following the
begin statement. The begin statement is an unstructured way to create
a new computation that is executed only for its side-effects. The
syntax for the begin statement is given by
\begin{syntax}
begin-statement:
  `begin' statement
  `begin' block-statement
\end{syntax}

The statement cannot be a control transfer statement--goto, break, 
continue, yield, or return statement. Those statements may not be
within the block statement either.


\subsection{Constraining Parallelism}
\label{Constraining_Parallelism}
\subsubsection{Ordered Expressions}
\label{Ordered_Expressions}

The \chpl{ordered} keyword can be used as an unary operator to
suppress parallel execution among instances of an expression that can
involve side-effects to memory. The \chpl{ordered} keyword does not
inhibit parallelism within the sub-expression. The syntax is:
\begin{syntax}
ordered-expression:
   `ordered' expression
\end{syntax}

\begin{example}
\begin{chapel}
ordered [i in S] f(i) 
\end{chapel}
In this example \chpl{f} is a function and \chpl{S} is a
sequence. Each instance of \chpl{f(i)} is executed once for each value
in \chpl{S} and in sequence order. The \chpl{ordered} constraint does
not propagate to inhibit parallelism within \chpl{f}.
\end{example}

% \footnote{It might be tempting to generate a warning when the
% keyword is ignored but those warnings may be spurious in a generic
% context where we are reusing an abstract function definition.}


\subsubsection{Serial}
\label{Serial}

The \chpl{serial} statement can be used to dynamically control the
degree of parallelism.  The syntax is:
\begin{syntax}
serial-statement:
  `serial' expression block-level-statement
\end{syntax}
where the expression is a bool type.  Independent of that value, the
block-level statement is evaluated. If the expression is true, any
dynamically encountered forall loop or cobegin statements is executed
sequentially within the current computation.

% WAW: what happens if we then encounter a begin?  Runtime halt?

\begin{example}
\begin{chapel}      
class Tree {
  var is_leaf : bool;
  var left    : Tree;
  var right   : Tree;

 iterator walk( height) {
  if (is_leaf) then
    yield this;
  else
    serial height <= 10 cobegin {
      yield left.walk(height-1);
      yield right.walk(height-1);
    }
 }
}
\end{chapel}
In this example, a recursive tree iterator, \chpl{walk}, uses the
tree's height to dynamically determine when additional computations
should be used to traverse the tree.
\end{example}

% DC: This iterator could be used in conjunction with an \chpl{ordered
% forall} to aggregate work to avoid parallelism overhead.\footnote{My
% expectation is that we clone functions that may be executed in a
% serial context so we can avoid the overhead of testing and suppressing
% parallelism.}

% iterator Tree.walk() {
%  if (is_leaf) then
%    yield this;
%  else
%    serial (height <= 10) cobegin {
%      yield left.walk();
%      yield right.walk();
%    }
% }

% WAW: this example does not def the iterator in class as that did
% not work when tested. Which to use in this example?



\subsection{Implicit Synchronization on Variables}
\label{Implicit_Synchronization_on_Variables}

{\em Synchronizing variables} can be used to coordinate computations.
There are two kinds of synchronizing variables, \chpl{single}
and \chpl{sync} variables, whose semantics include execution order and
memory consistency requirements.

\subsubsection{Single Variables}
\label{Single_Variables}

Single (assignment) variable can only be assigned once during their
dynamic lifetime.  A reference to a single assignment variable before
it is assigned to causes the computation's execution to be suspended
until the variable is assigned. Otherwise, the reference proceeds as
with normal variables and the computation continues.  After a single
assigment variable is assigned, all computations with pending
references are resumed in an unspecified order. The syntax of a single
assignment variable is:
\begin{chapel}
\end{chapel}

\begin{example}
\begin{chapel}
class Tree {
  var is_leaf : bool;
  var left    : Tree;
  var right   : Tree;
  var value   : int;

  def sum() {
    if (is_leaf) then 
       return value;

    var x : single int;
    begin x = left.sum();
    var y = right.sum();
    return x+y;
  }
}

\end{chapel}
In this example the single variable \chpl{x} is assigned by an
asynchronous computation. The computation returning the sum blocks
on the reading of \chpl{x} until it has been assigned.

% DC: While a \chpl{cobegin} might be a more suitable formulation, this
% fragment creates an asynchronous computation to compute the sum of the
% left sub-tree while the main computation continues with the right
% sub-tree. The final reference to variable x will be delayed until the
% assignment to x completes and that value will be used as a summand.

\end{example}

When a single variable has an initializer, the evaluation of
that initializer is implicitly performed as an asynchronous computation. 
\begin{example}
\begin{chapel}
def sum() {
  if (is_leaf) then 
     return value;
  var x: single int = left.sum;
  var y = right.sum();
  return x+y;
}
\end{chapel}
This is equivalent to the previous example where the declaration and
assignment are separate statements.
\end{example}

Any variable declaration within a cobegin statement is implicitly treated as
a single variable for references in other statements of the
\chpl{cobegin}.  
\begin{example}
\begin{chapel}
def sum() {
  if (is_leaf) then 
    return value;
  var z;
  cobegin {
    var x = left.sum();
    var y = right.sum();
    z = x+y;
  }
  return z;
}
\end{chapel}
The computation with assignment to z waits for the other computations 
to assign to x and y before it references x and y in order to assign to z.
\end{example}


\subsubsection{Sync Variables}
\label{Sync_Variables}

A sync variable generalizes the single assignment variable to
permit multiple assignments over its lifetime. Sync variables
are declared with the type attribute \chpl{sync}. The synchronized
variable syntax is
\begin{chapel}
\end{chapel}
A sync variable is logically either {\em full} or {\em empty}. When it
is empty, computations that attempt to read that variable are
suspended until it becomes full by the next assignment to it which
atomically changes the state to full. When the variable is full, a
variable reference consumes the value and atomically transitions the
state back to empty. If there are more than one computation waiting on
a sync variable, one is non-deterministically selected to reference the
variable resume execution.  The other computations continue to wait for
the next assignment. Otherwise, the state transistions to empty.

If a computation attempts to assign to a synchronized variable that is
full, the computation is suspended and the assignment is delayed. When
the sync variable becomes empty, the computation is resumed and the
assignment proceeds, transistioning the state back to full. If there
are multiple computations attempting such an assignment, one is
non-deterministically selected to proceed and the other assignments
continue to wait until the sync variable is emptied again.

Sync variables allow a sequence of values to be communicated
between computations using a single shared variable. They also can be
used as building blocks for more traditional synchronization
primitives such as semaphores and monitors.

\subsubsection{Functions on Synchronization Variables}
\label{Functions_on_Synchronization_Variables}

Synchronizing variables support a various special methods that
can be used to bypass their semantics to provide new ones. For
sync variable \chpl{s}, the following functions are defined:
\begin{chapel}
writeFE(s, v) // wait for full, assign s=v, and leave empty
writeXF(s, v) // no wait, assign s=v, and leave full
writeXE(s, v) // no wait, assign s=v, and leave empty
readFF(s)     // wait full, leave full, and return s's value
readXF(s)     // no wait, leave full, and return s's value
readXX(s)     // no wait, leave F/E unchanged, and return s's value
\end{chapel}

For single variable \chpl{s} only \chpl{readFF} is defined.


\subsubsection{Synchronizing Variables of Record Type}
\label{Synchronization_Variables_of_Record_Type}

A record variable can be a single or sync variable. The semantics of single 
and sync variables are applied only to the record variable and not
its individual fields. A record may have sychronizing variable fields,
but whole record references or assignments trigger the synchronizing
variable semantics. 

\subsubsection{Synchronizing Variables of Class Type}
\label{Synchronization_Variables_of_Class_Type}

A class variable can be a single or sync variable. The semantics of
single and sync variables are applied only to class reference and
assignment, not its individual fields. A class may have sychronizing
variable fields.


\subsection{Memory Consistency}
\label{Memory_Consistency}
The memory consistency model provided by Chapel will be defined in the future.

\subsection{Atomic Transactions}
\label{Atomic_Transactions}

The atomic statement creates an atomic transaction around a 
block statement.  The syntax for the atomic statement is given
by:
\begin{chapel}
atomic-statement:
  `atomic' block-level-statement
\end{chapel}

An {\em atomic transaction} is a region of the program that appears to
execute atomically. 

Here is an example of an atomic transaction:
\begin{example}
\begin{chapel}
var found = false;
atomic {
  if(head == obj) {
    found = true;
    head = obj.next;
  } else  {
    var last = head;
    while(last != null) {
    if (last.next == obj) {
      found = true;
      last.next = object.next;
      break;
    }
    last = last.next;
  }
}
\end{chapel}
Inside the atomic statement is a simple sequential implementation of
removing a particular object denoted by \chpl{obj} from a singly
linked list.  This is an operation that is well-defined, assuming only
one computation is attempting it at a time. The atomic statement
insures that, for example, the value of \chpl{head} does not change
after it is first in the first comparison and subsequently read to
initialize \chpl{last}. The variables eventually owned by this
computation are \chpl{found}, \chpl{head}, \chpl{obj}, and the various
\chpl{next} fields on examined objects.
\end{example}

The effect of an atomic statement extends into called functions. Thus
if we have some method associated with a list that removes an object,
that method may not be parallel safe but could be invoked inside an
atomic statement for safety:
\begin{chapel}
var found;
atomic found = head.remove(obj);
\end{chapel}

\subsubsection{Atomicity Model}
\label{Atomicity_Model}

Chapel provides strong atomicity. With strong atomicity, references
outside of explicit atomic sections behave as if they were
individual implicit atomic references.
