/*

Chapel module for the LAPACK library.

This module defines all the external types, enum types, and defines external procedures for all procedures found in the Netlibs LAPACK C interface (LAPACKE) header file (lapacke.h).

.. note::

  Because of the volume of procedures provided, and because the behavior and signatures of the procedures are virtually unchanged, no documentation about them is given here.
  
  Consult the documentation from `Netlibs <http://www.netlib.org/lapack/>`_, and `Intel LAPACK <https://software.intel.com/en-us/node/501008>`_ (provided by their MKL product) for those details.

Type Adjustments
----------------

The LAPACKE types ``lapack_int``, ``lapack_float``, ``lapack_double``, ``lapack_complex_float``, ``lapack_complex_double``, and ``lapack_logical`` are not defined at all, but rather are replaced by the types :type:`c_int`, :type:`c_float`, :type:`c_double`, :type:`complex(64)`, :type:`complex(128)`, and :type:`c_int` respectively.

Procedures can still take in :type:`c_char` (where applicable), but such procedures also have convenience wrappers (as there is no 'char' equivalent in Chapel) to take Chapel :type:`strings`.
These strings can be longer than one character, but only the first character is used (as is standard for LAPACK).

The :enum:`lapack_memory_order` enumeration is a replacement for the :type:`c_int` constants :data:`LAPACK_ROW_MAJOR` and :data:`LAPACK_COL_MAJOR` defined by LAPACK and used by ``matrix_order`` which is an argument present in essentially all procedures of LAPACK and :mod:`ChaLAPACK`.
The value of each enumeration is equivalent (both in type and value) of the LAPACK constants.
However the constants are also provided and can be used as well.

The ``LAPACK_SELECT`` types are function pointer types, whose functions need to be declared and implemented in C, then be declared as ``extern var`` on the Chapel side. 
See the :mod:`ChaLAPACK` dgees test for a concrete example.

Compiling with LAPACK
---------------------

You must have LAPACK on your system, as it is not bundled with Chapel. 

You can download and build the `Netlibs LAPACK <http://www.netlib.org/lapack/>`_ , if it is not already installed, and this section will assume usage of the Netlibs LAPACK.
You must also have libgfortran installed on your system (typically installed along with gcc).

To compile with LAPACK, Chapel needs to know:

1. Where the LAPACKE header (lapacke.h) is.

2. Where the libgfortran binary is (it tends not to be found by ``ld``).

3. Where the various LAPACK binaries (lapacke, lapack, and refblas) are.

Once the details are worked out, compiling is quite simple and nearly identical to how one would compile a C program to work with LAPACK.

.. code-block:: sh

  chpl -I$PATH_TO_LAPACKE_INCLUDE_DIR \
       -L$PATH_TO_LIBGFORTRAN -lgfortran \
       -L$PATH_TO_LAPACK_BINARIES -llapacke -lapack -lrefblas \
       source.chpl

As an example,

.. code-block:: sh

  chpl -I$HOME/LAPACK/lapacke/include \
       -L/usr/lib/gcc/stuff -lgfortran \
       -L$HOME/LAPACK -llapacke -lapack -lrefblas \
       source.chpl

would be the command to use if Netlibs LAPACK had been built in ``$HOME/LAPACK``, and the libgfortran binary found to be located in ``/usr/lib/gcc/stuff``

Types, Constants, and Enumerations
----------------------------------
      
*/
module LAPACK {
use ChaLAPACK;

/*External function pointer type LAPACK_C_SELECT1.

Defined in C by lapacke.h as::

 typedef lapack_logical (*LAPACK_C_SELECT1) ( const lapack_complex_float* )
 
*/
extern type LAPACK_C_SELECT1 ;
/*External function pointer type LAPACK_Z_SELECT1.

Defined in C by lapacke.h as::

 typedef lapack_logical (*LAPACK_Z_SELECT1) ( const lapack_complex_double* )

*/
extern type LAPACK_Z_SELECT1 ;
/*External function pointer type LAPACK_C_SELECT2.

Defined in C by lapacke.h as::

 typedef lapack_logical (*LAPACK_C_SELECT2) ( const lapack_complex_float*, const lapack_complex_float* )

*/
extern type LAPACK_C_SELECT2 ;
/*External function pointer type LAPACK_D_SELECT2.

Defined in C by lapacke.h as::

 typedef lapack_logical (*LAPACK_D_SELECT2) ( const double*, const double* )

*/
extern type LAPACK_D_SELECT2 ;
/*External function pointer type LAPACK_S_SELECT2.

Defined in C by lapacke.h as::

 typedef lapack_logical (*LAPACK_S_SELECT2) ( const float*, const float* )

*/
extern type LAPACK_S_SELECT2 ;
/*External function pointer type LAPACK_Z_SELECT2.

Defined in C by lapacke.h as::

 typedef lapack_logical (*LAPACK_Z_SELECT2) ( const lapack_complex_double*, const lapack_complex_double* )

*/
extern type LAPACK_Z_SELECT2 ;
/*External function pointer type LAPACK_S_SELECT3.

Defined in C by lapacke.h as::

 typedef lapack_logical (*LAPACK_S_SELECT3) ( const float*, const float*, const float* )

*/
extern type LAPACK_S_SELECT3 ;
/*External function pointer typeLAPACK_D_SELECT3.

Defined in C by lapacke.h as::

 typedef lapack_logical (*LAPACK_D_SELECT3) ( const double*, const double*, const double* )

*/
extern type LAPACK_D_SELECT3 ;


/*
External const LAPACK_ROW_MAJOR.

Defined in C by lapacke.h as::

 #define LAPACK_ROW_MAJOR 101
 
*/
extern const LAPACK_ROW_MAJOR : c_int ;
/*External const LAPACK_COL_MAJOR.

Defined in C by lapacke.h as::

 #define LAPACK_COL_MAJOR 102
*/
extern const LAPACK_COL_MAJOR : c_int ;
/*External const LAPACK_WORK_MEMORY_ERROR.

Defined in C by lapacke.h as::

 #define LAPACK_WORK_MEMORY_ERROR -1010
 
*/
extern const LAPACK_WORK_MEMORY_ERROR : c_int ;
/*External const LAPACK_TRANSPOSE_MEMORY_ERROR.

Defined in C by lapacke.h as::

 #define LAPACK_TRANSPOSE_MEMORY_ERROR -1011
 
*/
extern const LAPACK_TRANSPOSE_MEMORY_ERROR : c_int ;


/* Mirrors the :data:`LAPACK_ROW_MAJOR` and :data:`LAPACK_COL_MAJOR` consts defined by LAPACK.

The enum values values are the same as the const value such that ``lapack_memory_order.row_major == LAPACK_ROW_MAJOR`` and ``lapack_memory_order.column_major == LAPACK_COL_MAJOR``, allowing the enum to be used with pure LAPACK procedures.
 */
enum lapack_memory_order{row_major = 101 : c_int, column_major = 102 : c_int};


pragma"no doc"
/* 
External Procedure to lapack_make_complex_float
 */
extern proc lapack_make_complex_float(re : c_float, im : c_float) : complex(64);

pragma"no doc"
/* 
External Procedure to lapack_make_complex_double
 */
extern proc lapack_make_complex_double(re : c_double, im : c_double) : complex(128);

pragma"no doc"
/* 
External Procedure to LAPACK_lsame

Original Fortran LAPACK documentation for LSAME::

 LSAME returns .TRUE. if CA is the same letter as CB regardless of
 case.

 */
extern proc LAPACK_lsame(ref ca : c_char, ref cb : c_char, lca : c_int, lcb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sbdsdc

Original Fortran LAPACK documentation for SBDSDC::

 SBDSDC computes the singular value decomposition (SVD) of a real
 N-by-N (upper or lower) bidiagonal matrix B: B = U * S * VT,
 using a divide and conquer method, where S is a diagonal matrix
 with non-negative diagonal elements (the singular values of B), and
 U and VT are orthogonal matrices of left and right singular vectors,
 respectively. SBDSDC can be used to compute all singular values,
 and optionally, singular vectors or singular vectors in compact form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See SLASD3 for details.

 The code currently calls SLASDQ if singular values only are desired.
 However, it can be slightly modified to compute singular values
 using the divide and conquer method.

 */
extern proc LAPACKE_sbdsdc(matrix_order : lapack_memory_order, uplo : c_char, compq : c_char, n : c_int, d : [] c_float, e : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, q : [] c_float, iq : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sbdsdc
 */
inline proc LAPACKE_sbdsdc(matrix_order : lapack_memory_order, uplo : string, compq : string, n : c_int, d : [] c_float, e : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, q : [] c_float, iq : [] c_int) : c_int{
  return LAPACKE_sbdsdc(matrix_order, ascii(uplo) : c_char, ascii(compq) : c_char, n, d, e, u, ldu, vt, ldvt, q, iq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dbdsdc

Original Fortran LAPACK documentation for DBDSDC::

 DBDSDC computes the singular value decomposition (SVD) of a real
 N-by-N (upper or lower) bidiagonal matrix B: B = U * S * VT,
 using a divide and conquer method, where S is a diagonal matrix
 with non-negative diagonal elements (the singular values of B), and
 U and VT are orthogonal matrices of left and right singular vectors,
 respectively. DBDSDC can be used to compute all singular values,
 and optionally, singular vectors or singular vectors in compact form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See DLASD3 for details.

 The code currently calls DLASDQ if singular values only are desired.
 However, it can be slightly modified to compute singular values
 using the divide and conquer method.

 */
extern proc LAPACKE_dbdsdc(matrix_order : lapack_memory_order, uplo : c_char, compq : c_char, n : c_int, d : [] c_double, e : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, q : [] c_double, iq : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dbdsdc
 */
inline proc LAPACKE_dbdsdc(matrix_order : lapack_memory_order, uplo : string, compq : string, n : c_int, d : [] c_double, e : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, q : [] c_double, iq : [] c_int) : c_int{
  return LAPACKE_dbdsdc(matrix_order, ascii(uplo) : c_char, ascii(compq) : c_char, n, d, e, u, ldu, vt, ldvt, q, iq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sbdsqr

Original Fortran LAPACK documentation for SBDSQR::

 SBDSQR computes the singular values and, optionally, the right and/or
 left singular vectors from the singular value decomposition (SVD) of
 a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
 zero-shift QR algorithm. The SVD of B has the form
 
 B = Q * S * P**T
 
 where S is the diagonal matrix of singular values, Q is an orthogonal
 matrix of left singular vectors, and P is an orthogonal matrix of
 right singular vectors. If left singular vectors are requested, this
 subroutine actually returns U*Q instead of Q, and, if right singular
 vectors are requested, this subroutine returns P**T*VT instead of
 P**T, for given real input matrices U and VT. When U and VT are the
 orthogonal matrices that reduce a general matrix A to bidiagonal
 form: A = U*B*VT, as computed by SGEBRD, then
 
 A = (U*Q) * S * (P**T*VT)
 
 is the SVD of A. Optionally, the subroutine may also compute Q**T*C
 for a given real input matrix C.

 See "Computing Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
 no. 5, pp. 873-912, Sept 1990) and
 "Accurate singular values and differential qd algorithms," by
 B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
 Department, University of California at Berkeley, July 1992
 for a detailed description of the algorithm.

 */
extern proc LAPACKE_sbdsqr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_float, e : [] c_float, vt : [] c_float, ldvt : c_int, u : [] c_float, ldu : c_int, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sbdsqr
 */
inline proc LAPACKE_sbdsqr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_float, e : [] c_float, vt : [] c_float, ldvt : c_int, u : [] c_float, ldu : c_int, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sbdsqr(matrix_order, ascii(uplo) : c_char, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dbdsqr

Original Fortran LAPACK documentation for DBDSQR::

 DBDSQR computes the singular values and, optionally, the right and/or
 left singular vectors from the singular value decomposition (SVD) of
 a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
 zero-shift QR algorithm. The SVD of B has the form
 
 B = Q * S * P**T
 
 where S is the diagonal matrix of singular values, Q is an orthogonal
 matrix of left singular vectors, and P is an orthogonal matrix of
 right singular vectors. If left singular vectors are requested, this
 subroutine actually returns U*Q instead of Q, and, if right singular
 vectors are requested, this subroutine returns P**T*VT instead of
 P**T, for given real input matrices U and VT. When U and VT are the
 orthogonal matrices that reduce a general matrix A to bidiagonal
 form: A = U*B*VT, as computed by DGEBRD, then

 A = (U*Q) * S * (P**T*VT)

 is the SVD of A. Optionally, the subroutine may also compute Q**T*C
 for a given real input matrix C.

 See "Computing Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
 no. 5, pp. 873-912, Sept 1990) and
 "Accurate singular values and differential qd algorithms," by
 B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
 Department, University of California at Berkeley, July 1992
 for a detailed description of the algorithm.

 */
extern proc LAPACKE_dbdsqr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_double, e : [] c_double, vt : [] c_double, ldvt : c_int, u : [] c_double, ldu : c_int, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dbdsqr
 */
inline proc LAPACKE_dbdsqr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_double, e : [] c_double, vt : [] c_double, ldvt : c_int, u : [] c_double, ldu : c_int, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dbdsqr(matrix_order, ascii(uplo) : c_char, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cbdsqr

Original Fortran LAPACK documentation for CBDSQR::

 CBDSQR computes the singular values and, optionally, the right and/or
 left singular vectors from the singular value decomposition (SVD) of
 a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
 zero-shift QR algorithm. The SVD of B has the form
 
 B = Q * S * P**H
 
 where S is the diagonal matrix of singular values, Q is an orthogonal
 matrix of left singular vectors, and P is an orthogonal matrix of
 right singular vectors. If left singular vectors are requested, this
 subroutine actually returns U*Q instead of Q, and, if right singular
 vectors are requested, this subroutine returns P**H*VT instead of
 P**H, for given complex input matrices U and VT. When U and VT are
 the unitary matrices that reduce a general matrix A to bidiagonal
 form: A = U*B*VT, as computed by CGEBRD, then
 
 A = (U*Q) * S * (P**H*VT)
 
 is the SVD of A. Optionally, the subroutine may also compute Q**H*C
 for a given complex input matrix C.

 See "Computing Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
 no. 5, pp. 873-912, Sept 1990) and
 "Accurate singular values and differential qd algorithms," by
 B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
 Department, University of California at Berkeley, July 1992
 for a detailed description of the algorithm.

 */
extern proc LAPACKE_cbdsqr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_float, e : [] c_float, vt : [] complex(64), ldvt : c_int, u : [] complex(64), ldu : c_int, c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cbdsqr
 */
inline proc LAPACKE_cbdsqr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_float, e : [] c_float, vt : [] complex(64), ldvt : c_int, u : [] complex(64), ldu : c_int, c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cbdsqr(matrix_order, ascii(uplo) : c_char, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zbdsqr

Original Fortran LAPACK documentation for ZBDSQR::

 ZBDSQR computes the singular values and, optionally, the right and/or
 left singular vectors from the singular value decomposition (SVD) of
 a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
 zero-shift QR algorithm. The SVD of B has the form
 
 B = Q * S * P**H
 
 where S is the diagonal matrix of singular values, Q is an orthogonal
 matrix of left singular vectors, and P is an orthogonal matrix of
 right singular vectors. If left singular vectors are requested, this
 subroutine actually returns U*Q instead of Q, and, if right singular
 vectors are requested, this subroutine returns P**H*VT instead of
 P**H, for given complex input matrices U and VT. When U and VT are
 the unitary matrices that reduce a general matrix A to bidiagonal
 form: A = U*B*VT, as computed by ZGEBRD, then
 
 A = (U*Q) * S * (P**H*VT)
 
 is the SVD of A. Optionally, the subroutine may also compute Q**H*C
 for a given complex input matrix C.

 See "Computing Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
 no. 5, pp. 873-912, Sept 1990) and
 "Accurate singular values and differential qd algorithms," by
 B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
 Department, University of California at Berkeley, July 1992
 for a detailed description of the algorithm.

 */
extern proc LAPACKE_zbdsqr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_double, e : [] c_double, vt : [] complex(128), ldvt : c_int, u : [] complex(128), ldu : c_int, c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zbdsqr
 */
inline proc LAPACKE_zbdsqr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_double, e : [] c_double, vt : [] complex(128), ldvt : c_int, u : [] complex(128), ldu : c_int, c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zbdsqr(matrix_order, ascii(uplo) : c_char, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sdisna

Original Fortran LAPACK documentation for SDISNA::

 SDISNA computes the reciprocal condition numbers for the eigenvectors
 of a real symmetric or complex Hermitian matrix or for the left or
 right singular vectors of a general m-by-n matrix. The reciprocal
 condition number is the 'gap' between the corresponding eigenvalue or
 singular value and the nearest other one.

 The bound on the error, measured by angle in radians, in the I-th
 computed vector is given by

 SLAMCH( 'E' ) * ( ANORM / SEP( I ) )

 where ANORM = 2-norm(A) = max( abs( D(j) ) ). SEP(I) is not allowed
 to be smaller than SLAMCH( 'E' )*ANORM in order to limit the size of
 the error bound.

 SDISNA may also be used to compute error bounds for eigenvectors of
 the generalized symmetric definite eigenproblem.

 */
extern proc LAPACKE_sdisna(job : c_char, m : c_int, n : c_int, d : [] c_float, sep : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sdisna
 */
inline proc LAPACKE_sdisna(job : string, m : c_int, n : c_int, d : [] c_float, sep : [] c_float) : c_int{
  return LAPACKE_sdisna(ascii(job) : c_char, m, n, d, sep);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ddisna

Original Fortran LAPACK documentation for DDISNA::

 DDISNA computes the reciprocal condition numbers for the eigenvectors
 of a real symmetric or complex Hermitian matrix or for the left or
 right singular vectors of a general m-by-n matrix. The reciprocal
 condition number is the 'gap' between the corresponding eigenvalue or
 singular value and the nearest other one.

 The bound on the error, measured by angle in radians, in the I-th
 computed vector is given by

 DLAMCH( 'E' ) * ( ANORM / SEP( I ) )

 where ANORM = 2-norm(A) = max( abs( D(j) ) ). SEP(I) is not allowed
 to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
 the error bound.

 DDISNA may also be used to compute error bounds for eigenvectors of
 the generalized symmetric definite eigenproblem.

 */
extern proc LAPACKE_ddisna(job : c_char, m : c_int, n : c_int, d : [] c_double, sep : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ddisna
 */
inline proc LAPACKE_ddisna(job : string, m : c_int, n : c_int, d : [] c_double, sep : [] c_double) : c_int{
  return LAPACKE_ddisna(ascii(job) : c_char, m, n, d, sep);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbbrd

Original Fortran LAPACK documentation for SGBBRD::

 SGBBRD reduces a real general m-by-n band matrix A to upper
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 The routine computes B, and optionally forms Q or P**T, or computes
 Q**T*C for a given matrix C.

 */
extern proc LAPACKE_sgbbrd(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ldq : c_int, pt : [] c_float, ldpt : c_int, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbbrd
 */
inline proc LAPACKE_sgbbrd(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ldq : c_int, pt : [] c_float, ldpt : c_int, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sgbbrd(matrix_order, ascii(vect) : c_char, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbbrd

Original Fortran LAPACK documentation for DGBBRD::

 DGBBRD reduces a real general m-by-n band matrix A to upper
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 The routine computes B, and optionally forms Q or P**T, or computes
 Q**T*C for a given matrix C.

 */
extern proc LAPACKE_dgbbrd(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ldq : c_int, pt : [] c_double, ldpt : c_int, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbbrd
 */
inline proc LAPACKE_dgbbrd(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ldq : c_int, pt : [] c_double, ldpt : c_int, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dgbbrd(matrix_order, ascii(vect) : c_char, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbbrd

Original Fortran LAPACK documentation for CGBBRD::

 CGBBRD reduces a complex general m-by-n band matrix A to real upper
 bidiagonal form B by a unitary transformation: Q**H * A * P = B.

 The routine computes B, and optionally forms Q or P**H, or computes
 Q**H*C for a given matrix C.

 */
extern proc LAPACKE_cgbbrd(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ldq : c_int, pt : [] complex(64), ldpt : c_int, c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbbrd
 */
inline proc LAPACKE_cgbbrd(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ldq : c_int, pt : [] complex(64), ldpt : c_int, c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cgbbrd(matrix_order, ascii(vect) : c_char, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbbrd

Original Fortran LAPACK documentation for ZGBBRD::

 ZGBBRD reduces a complex general m-by-n band matrix A to real upper
 bidiagonal form B by a unitary transformation: Q**H * A * P = B.

 The routine computes B, and optionally forms Q or P**H, or computes
 Q**H*C for a given matrix C.

 */
extern proc LAPACKE_zgbbrd(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ldq : c_int, pt : [] complex(128), ldpt : c_int, c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbbrd
 */
inline proc LAPACKE_zgbbrd(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ldq : c_int, pt : [] complex(128), ldpt : c_int, c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zgbbrd(matrix_order, ascii(vect) : c_char, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbcon

Original Fortran LAPACK documentation for SGBCON::

 SGBCON estimates the reciprocal of the condition number of a real
 general band matrix A, in either the 1-norm or the infinity-norm,
 using the LU factorization computed by SGBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_sgbcon(matrix_order : lapack_memory_order, norm : c_char, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbcon
 */
inline proc LAPACKE_sgbcon(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_sgbcon(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbcon

Original Fortran LAPACK documentation for DGBCON::

 DGBCON estimates the reciprocal of the condition number of a real
 general band matrix A, in either the 1-norm or the infinity-norm,
 using the LU factorization computed by DGBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_dgbcon(matrix_order : lapack_memory_order, norm : c_char, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbcon
 */
inline proc LAPACKE_dgbcon(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_dgbcon(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbcon

Original Fortran LAPACK documentation for CGBCON::

 CGBCON estimates the reciprocal of the condition number of a complex
 general band matrix A, in either the 1-norm or the infinity-norm,
 using the LU factorization computed by CGBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_cgbcon(matrix_order : lapack_memory_order, norm : c_char, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbcon
 */
inline proc LAPACKE_cgbcon(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_cgbcon(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbcon

Original Fortran LAPACK documentation for ZGBCON::

 ZGBCON estimates the reciprocal of the condition number of a complex
 general band matrix A, in either the 1-norm or the infinity-norm,
 using the LU factorization computed by ZGBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_zgbcon(matrix_order : lapack_memory_order, norm : c_char, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbcon
 */
inline proc LAPACKE_zgbcon(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zgbcon(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbequ

Original Fortran LAPACK documentation for SGBEQU::

 SGBEQU computes row and column scalings intended to equilibrate an
 M-by-N band matrix A and reduce its condition number. R returns the
 row scale factors and C the column scale factors, chosen to try to
 make the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACKE_sgbequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbequ

Original Fortran LAPACK documentation for DGBEQU::

 DGBEQU computes row and column scalings intended to equilibrate an
 M-by-N band matrix A and reduce its condition number. R returns the
 row scale factors and C the column scale factors, chosen to try to
 make the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACKE_dgbequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbequ

Original Fortran LAPACK documentation for CGBEQU::

 CGBEQU computes row and column scalings intended to equilibrate an
 M-by-N band matrix A and reduce its condition number. R returns the
 row scale factors and C the column scale factors, chosen to try to
 make the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACKE_cgbequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbequ

Original Fortran LAPACK documentation for ZGBEQU::

 ZGBEQU computes row and column scalings intended to equilibrate an
 M-by-N band matrix A and reduce its condition number. R returns the
 row scale factors and C the column scale factors, chosen to try to
 make the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACKE_zgbequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbequb

Original Fortran LAPACK documentation for SGBEQUB::

 SGBEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from SGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACKE_sgbequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbequb

Original Fortran LAPACK documentation for DGBEQUB::

 DGBEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from DGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACKE_dgbequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbequb

Original Fortran LAPACK documentation for CGBEQUB::

 CGBEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from CGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACKE_cgbequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbequb

Original Fortran LAPACK documentation for ZGBEQUB::

 ZGBEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from ZGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACKE_zgbequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbrfs

Original Fortran LAPACK documentation for SGBRFS::

 SGBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is banded, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_sgbrfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbrfs
 */
inline proc LAPACKE_sgbrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_sgbrfs(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbrfs

Original Fortran LAPACK documentation for DGBRFS::

 DGBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is banded, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_dgbrfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbrfs
 */
inline proc LAPACKE_dgbrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dgbrfs(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbrfs

Original Fortran LAPACK documentation for CGBRFS::

 CGBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is banded, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_cgbrfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbrfs
 */
inline proc LAPACKE_cgbrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cgbrfs(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbrfs

Original Fortran LAPACK documentation for ZGBRFS::

 ZGBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is banded, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_zgbrfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbrfs
 */
inline proc LAPACKE_zgbrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zgbrfs(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbrfsx

Original Fortran LAPACK documentation for SGBRFSX::

 SGBRFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACKE_sgbrfsx(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbrfsx
 */
inline proc LAPACKE_sgbrfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_sgbrfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbrfsx

Original Fortran LAPACK documentation for DGBRFSX::

 DGBRFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACKE_dgbrfsx(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbrfsx
 */
inline proc LAPACKE_dgbrfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_dgbrfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbrfsx

Original Fortran LAPACK documentation for CGBRFSX::

 CGBRFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACKE_cgbrfsx(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbrfsx
 */
inline proc LAPACKE_cgbrfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_cgbrfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbrfsx

Original Fortran LAPACK documentation for ZGBRFSX::

 ZGBRFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACKE_zgbrfsx(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbrfsx
 */
inline proc LAPACKE_zgbrfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zgbrfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbsv

Original Fortran LAPACK documentation for SGBSV::

 SGBSV computes the solution to a real system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals. The factored form of A
 is then used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_sgbsv(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbsv

Original Fortran LAPACK documentation for DGBSV::

 DGBSV computes the solution to a real system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals. The factored form of A
 is then used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_dgbsv(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbsv

Original Fortran LAPACK documentation for CGBSV::

 CGBSV computes the solution to a complex system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals. The factored form of A
 is then used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_cgbsv(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbsv

Original Fortran LAPACK documentation for ZGBSV::

 ZGBSV computes the solution to a complex system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals. The factored form of A
 is then used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_zgbsv(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbsvx

Original Fortran LAPACK documentation for SGBSVX::

 SGBSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a band matrix of order N with KL subdiagonals and KU
 superdiagonals, and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_sgbsvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbsvx
 */
inline proc LAPACKE_sgbsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float) : c_int{
  return LAPACKE_sgbsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbsvx

Original Fortran LAPACK documentation for DGBSVX::

 DGBSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a band matrix of order N with KL subdiagonals and KU
 superdiagonals, and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_dgbsvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbsvx
 */
inline proc LAPACKE_dgbsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double) : c_int{
  return LAPACKE_dgbsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbsvx

Original Fortran LAPACK documentation for CGBSVX::

 CGBSVX uses the LU factorization to compute the solution to a complex
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a band matrix of order N with KL subdiagonals and KU
 superdiagonals, and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_cgbsvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbsvx
 */
inline proc LAPACKE_cgbsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float) : c_int{
  return LAPACKE_cgbsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbsvx

Original Fortran LAPACK documentation for ZGBSVX::

 ZGBSVX uses the LU factorization to compute the solution to a complex
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a band matrix of order N with KL subdiagonals and KU
 superdiagonals, and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zgbsvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbsvx
 */
inline proc LAPACKE_zgbsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double) : c_int{
  return LAPACKE_zgbsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbsvxx

Original Fortran LAPACK documentation for SGBSVXX::

 SGBSVXX uses the LU factorization to compute the solution to a
 real system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SGBSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SGBSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SGBSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SGBSVXX would itself produce.

 */
extern proc LAPACKE_sgbsvxx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbsvxx
 */
inline proc LAPACKE_sgbsvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_sgbsvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbsvxx

Original Fortran LAPACK documentation for DGBSVXX::

 DGBSVXX uses the LU factorization to compute the solution to a
 double precision system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. DGBSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 DGBSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 DGBSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what DGBSVXX would itself produce.

 */
extern proc LAPACKE_dgbsvxx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbsvxx
 */
inline proc LAPACKE_dgbsvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_dgbsvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbsvxx

Original Fortran LAPACK documentation for CGBSVXX::

 CGBSVXX uses the LU factorization to compute the solution to a
 complex system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CGBSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CGBSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CGBSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CGBSVXX would itself produce.

 */
extern proc LAPACKE_cgbsvxx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbsvxx
 */
inline proc LAPACKE_cgbsvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_cgbsvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbsvxx

Original Fortran LAPACK documentation for ZGBSVXX::

 ZGBSVXX uses the LU factorization to compute the solution to a
 complex*16 system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZGBSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZGBSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZGBSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZGBSVXX would itself produce.

 */
extern proc LAPACKE_zgbsvxx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbsvxx
 */
inline proc LAPACKE_zgbsvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zgbsvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbtrf

Original Fortran LAPACK documentation for SGBTRF::

 SGBTRF computes an LU factorization of a real m-by-n band matrix A
 using partial pivoting with row interchanges.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_sgbtrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbtrf

Original Fortran LAPACK documentation for DGBTRF::

 DGBTRF computes an LU factorization of a real m-by-n band matrix A
 using partial pivoting with row interchanges.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_dgbtrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbtrf

Original Fortran LAPACK documentation for CGBTRF::

 CGBTRF computes an LU factorization of a complex m-by-n band matrix A
 using partial pivoting with row interchanges.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_cgbtrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbtrf

Original Fortran LAPACK documentation for ZGBTRF::

 ZGBTRF computes an LU factorization of a complex m-by-n band matrix A
 using partial pivoting with row interchanges.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_zgbtrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbtrs

Original Fortran LAPACK documentation for SGBTRS::

 SGBTRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general band matrix A using the LU factorization computed
 by SGBTRF.

 */
extern proc LAPACKE_sgbtrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbtrs
 */
inline proc LAPACKE_sgbtrs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sgbtrs(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbtrs

Original Fortran LAPACK documentation for DGBTRS::

 DGBTRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general band matrix A using the LU factorization computed
 by DGBTRF.

 */
extern proc LAPACKE_dgbtrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbtrs
 */
inline proc LAPACKE_dgbtrs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dgbtrs(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbtrs

Original Fortran LAPACK documentation for CGBTRS::

 CGBTRS solves a system of linear equations
 A * X = B, A**T * X = B, or A**H * X = B
 with a general band matrix A using the LU factorization computed
 by CGBTRF.

 */
extern proc LAPACKE_cgbtrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbtrs
 */
inline proc LAPACKE_cgbtrs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cgbtrs(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbtrs

Original Fortran LAPACK documentation for ZGBTRS::

 ZGBTRS solves a system of linear equations
 A * X = B, A**T * X = B, or A**H * X = B
 with a general band matrix A using the LU factorization computed
 by ZGBTRF.

 */
extern proc LAPACKE_zgbtrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbtrs
 */
inline proc LAPACKE_zgbtrs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zgbtrs(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgebak

Original Fortran LAPACK documentation for SGEBAK::

 SGEBAK forms the right or left eigenvectors of a real general matrix
 by backward transformation on the computed eigenvectors of the
 balanced matrix output by SGEBAL.

 */
extern proc LAPACKE_sgebak(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_float, m : c_int, v : [] c_float, ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgebak
 */
inline proc LAPACKE_sgebak(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_float, m : c_int, v : [] c_float, ldv : c_int) : c_int{
  return LAPACKE_sgebak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, scale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgebak

Original Fortran LAPACK documentation for DGEBAK::

 DGEBAK forms the right or left eigenvectors of a real general matrix
 by backward transformation on the computed eigenvectors of the
 balanced matrix output by DGEBAL.

 */
extern proc LAPACKE_dgebak(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_double, m : c_int, v : [] c_double, ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgebak
 */
inline proc LAPACKE_dgebak(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_double, m : c_int, v : [] c_double, ldv : c_int) : c_int{
  return LAPACKE_dgebak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, scale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgebak

Original Fortran LAPACK documentation for CGEBAK::

 CGEBAK forms the right or left eigenvectors of a complex general
 matrix by backward transformation on the computed eigenvectors of the
 balanced matrix output by CGEBAL.

 */
extern proc LAPACKE_cgebak(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_float, m : c_int, v : [] complex(64), ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgebak
 */
inline proc LAPACKE_cgebak(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_float, m : c_int, v : [] complex(64), ldv : c_int) : c_int{
  return LAPACKE_cgebak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, scale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgebak

Original Fortran LAPACK documentation for ZGEBAK::

 ZGEBAK forms the right or left eigenvectors of a complex general
 matrix by backward transformation on the computed eigenvectors of the
 balanced matrix output by ZGEBAL.

 */
extern proc LAPACKE_zgebak(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_double, m : c_int, v : [] complex(128), ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgebak
 */
inline proc LAPACKE_zgebak(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_double, m : c_int, v : [] complex(128), ldv : c_int) : c_int{
  return LAPACKE_zgebak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, scale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgebal

Original Fortran LAPACK documentation for SGEBAL::

 SGEBAL balances a general real matrix A. This involves, first,
 permuting A by a similarity transformation to isolate eigenvalues
 in the first 1 to ILO-1 and last IHI+1 to N elements on the
 diagonal; and second, applying a diagonal similarity transformation
 to rows and columns ILO to IHI to make the rows and columns as
 close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrix, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors.

 */
extern proc LAPACKE_sgebal(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] c_float, lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgebal
 */
inline proc LAPACKE_sgebal(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] c_float, lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float) : c_int{
  return LAPACKE_sgebal(matrix_order, ascii(job) : c_char, n, a, lda, ilo, ihi, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgebal

Original Fortran LAPACK documentation for DGEBAL::

 DGEBAL balances a general real matrix A. This involves, first,
 permuting A by a similarity transformation to isolate eigenvalues
 in the first 1 to ILO-1 and last IHI+1 to N elements on the
 diagonal; and second, applying a diagonal similarity transformation
 to rows and columns ILO to IHI to make the rows and columns as
 close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrix, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors.

 */
extern proc LAPACKE_dgebal(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] c_double, lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgebal
 */
inline proc LAPACKE_dgebal(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] c_double, lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double) : c_int{
  return LAPACKE_dgebal(matrix_order, ascii(job) : c_char, n, a, lda, ilo, ihi, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgebal

Original Fortran LAPACK documentation for CGEBAL::

 CGEBAL balances a general complex matrix A. This involves, first,
 permuting A by a similarity transformation to isolate eigenvalues
 in the first 1 to ILO-1 and last IHI+1 to N elements on the
 diagonal; and second, applying a diagonal similarity transformation
 to rows and columns ILO to IHI to make the rows and columns as
 close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrix, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors.

 */
extern proc LAPACKE_cgebal(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] complex(64), lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgebal
 */
inline proc LAPACKE_cgebal(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] complex(64), lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float) : c_int{
  return LAPACKE_cgebal(matrix_order, ascii(job) : c_char, n, a, lda, ilo, ihi, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgebal

Original Fortran LAPACK documentation for ZGEBAL::

 ZGEBAL balances a general complex matrix A. This involves, first,
 permuting A by a similarity transformation to isolate eigenvalues
 in the first 1 to ILO-1 and last IHI+1 to N elements on the
 diagonal; and second, applying a diagonal similarity transformation
 to rows and columns ILO to IHI to make the rows and columns as
 close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrix, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors.

 */
extern proc LAPACKE_zgebal(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] complex(128), lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgebal
 */
inline proc LAPACKE_zgebal(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] complex(128), lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double) : c_int{
  return LAPACKE_zgebal(matrix_order, ascii(job) : c_char, n, a, lda, ilo, ihi, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgebrd

Original Fortran LAPACK documentation for SGEBRD::

 SGEBRD reduces a general real M-by-N matrix A to upper or lower
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

 */
extern proc LAPACKE_sgebrd(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, d : [] c_float, e : [] c_float, tauq : [] c_float, taup : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgebrd

Original Fortran LAPACK documentation for DGEBRD::

 DGEBRD reduces a general real M-by-N matrix A to upper or lower
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

 */
extern proc LAPACKE_dgebrd(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, d : [] c_double, e : [] c_double, tauq : [] c_double, taup : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgebrd

Original Fortran LAPACK documentation for CGEBRD::

 CGEBRD reduces a general complex M-by-N matrix A to upper or lower
 bidiagonal form B by a unitary transformation: Q**H * A * P = B.

 If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

 */
extern proc LAPACKE_cgebrd(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, d : [] c_float, e : [] c_float, tauq : [] complex(64), taup : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgebrd

Original Fortran LAPACK documentation for ZGEBRD::

 ZGEBRD reduces a general complex M-by-N matrix A to upper or lower
 bidiagonal form B by a unitary transformation: Q**H * A * P = B.

 If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

 */
extern proc LAPACKE_zgebrd(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, d : [] c_double, e : [] c_double, tauq : [] complex(128), taup : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgecon

Original Fortran LAPACK documentation for SGECON::

 SGECON estimates the reciprocal of the condition number of a general
 real matrix A, in either the 1-norm or the infinity-norm, using
 the LU factorization computed by SGETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_sgecon(matrix_order : lapack_memory_order, norm : c_char, n : c_int, a : [] c_float, lda : c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgecon
 */
inline proc LAPACKE_sgecon(matrix_order : lapack_memory_order, norm : string, n : c_int, a : [] c_float, lda : c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_sgecon(matrix_order, ascii(norm) : c_char, n, a, lda, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgecon

Original Fortran LAPACK documentation for DGECON::

 DGECON estimates the reciprocal of the condition number of a general
 real matrix A, in either the 1-norm or the infinity-norm, using
 the LU factorization computed by DGETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_dgecon(matrix_order : lapack_memory_order, norm : c_char, n : c_int, a : [] c_double, lda : c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgecon
 */
inline proc LAPACKE_dgecon(matrix_order : lapack_memory_order, norm : string, n : c_int, a : [] c_double, lda : c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_dgecon(matrix_order, ascii(norm) : c_char, n, a, lda, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgecon

Original Fortran LAPACK documentation for CGECON::

 CGECON estimates the reciprocal of the condition number of a general
 complex matrix A, in either the 1-norm or the infinity-norm, using
 the LU factorization computed by CGETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_cgecon(matrix_order : lapack_memory_order, norm : c_char, n : c_int, a : [] complex(64), lda : c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgecon
 */
inline proc LAPACKE_cgecon(matrix_order : lapack_memory_order, norm : string, n : c_int, a : [] complex(64), lda : c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_cgecon(matrix_order, ascii(norm) : c_char, n, a, lda, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgecon

Original Fortran LAPACK documentation for ZGECON::

 ZGECON estimates the reciprocal of the condition number of a general
 complex matrix A, in either the 1-norm or the infinity-norm, using
 the LU factorization computed by ZGETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_zgecon(matrix_order : lapack_memory_order, norm : c_char, n : c_int, a : [] complex(128), lda : c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgecon
 */
inline proc LAPACKE_zgecon(matrix_order : lapack_memory_order, norm : string, n : c_int, a : [] complex(128), lda : c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zgecon(matrix_order, ascii(norm) : c_char, n, a, lda, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeequ

Original Fortran LAPACK documentation for SGEEQU::

 SGEEQU computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACKE_sgeequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeequ

Original Fortran LAPACK documentation for DGEEQU::

 DGEEQU computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACKE_dgeequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeequ

Original Fortran LAPACK documentation for CGEEQU::

 CGEEQU computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACKE_cgeequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeequ

Original Fortran LAPACK documentation for ZGEEQU::

 ZGEEQU computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACKE_zgeequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeequb

Original Fortran LAPACK documentation for SGEEQUB::

 SGEEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from SGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACKE_sgeequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeequb

Original Fortran LAPACK documentation for DGEEQUB::

 DGEEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from DGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACKE_dgeequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeequb

Original Fortran LAPACK documentation for CGEEQUB::

 CGEEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from CGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACKE_cgeequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeequb

Original Fortran LAPACK documentation for ZGEEQUB::

 ZGEEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from ZGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACKE_zgeequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgees

Original Fortran LAPACK documentation for SGEES::

 SGEES computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left.
 The leading columns of Z then form an orthonormal basis for the
 invariant subspace corresponding to the selected eigenvalues.

 A matrix is in real Schur form if it is upper quasi-triangular with
 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
 form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

 */
extern proc LAPACKE_sgees(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_S_SELECT2, n : c_int, a : [] c_float, lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ldvs : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgees
 */
inline proc LAPACKE_sgees(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_S_SELECT2, n : c_int, a : [] c_float, lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ldvs : c_int) : c_int{
  return LAPACKE_sgees(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, n, a, lda, sdim, wr, wi, vs, ldvs);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgees

Original Fortran LAPACK documentation for DGEES::

 DGEES computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left.
 The leading columns of Z then form an orthonormal basis for the
 invariant subspace corresponding to the selected eigenvalues.

 A matrix is in real Schur form if it is upper quasi-triangular with
 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
 form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

 */
extern proc LAPACKE_dgees(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_D_SELECT2, n : c_int, a : [] c_double, lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ldvs : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgees
 */
inline proc LAPACKE_dgees(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_D_SELECT2, n : c_int, a : [] c_double, lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ldvs : c_int) : c_int{
  return LAPACKE_dgees(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, n, a, lda, sdim, wr, wi, vs, ldvs);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgees

Original Fortran LAPACK documentation for CGEES::

 CGEES computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues, the Schur form T, and, optionally, the matrix of Schur
 vectors Z. This gives the Schur factorization A = Z*T*(Z**H).

 Optionally, it also orders the eigenvalues on the diagonal of the
 Schur form so that selected eigenvalues are at the top left.
 The leading columns of Z then form an orthonormal basis for the
 invariant subspace corresponding to the selected eigenvalues.

 A complex matrix is in Schur form if it is upper triangular.

 */
extern proc LAPACKE_cgees(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_C_SELECT1, n : c_int, a : [] complex(64), lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ldvs : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgees
 */
inline proc LAPACKE_cgees(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_C_SELECT1, n : c_int, a : [] complex(64), lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ldvs : c_int) : c_int{
  return LAPACKE_cgees(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, n, a, lda, sdim, w, vs, ldvs);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgees

Original Fortran LAPACK documentation for ZGEES::

 ZGEES computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues, the Schur form T, and, optionally, the matrix of Schur
 vectors Z. This gives the Schur factorization A = Z*T*(Z**H).

 Optionally, it also orders the eigenvalues on the diagonal of the
 Schur form so that selected eigenvalues are at the top left.
 The leading columns of Z then form an orthonormal basis for the
 invariant subspace corresponding to the selected eigenvalues.

 A complex matrix is in Schur form if it is upper triangular.

 */
extern proc LAPACKE_zgees(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_Z_SELECT1, n : c_int, a : [] complex(128), lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ldvs : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgees
 */
inline proc LAPACKE_zgees(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_Z_SELECT1, n : c_int, a : [] complex(128), lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ldvs : c_int) : c_int{
  return LAPACKE_zgees(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, n, a, lda, sdim, w, vs, ldvs);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeesx

Original Fortran LAPACK documentation for SGEESX::

 SGEESX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left;
 computes a reciprocal condition number for the average of the
 selected eigenvalues (RCONDE); and computes a reciprocal condition
 number for the right invariant subspace corresponding to the
 selected eigenvalues (RCONDV). The leading columns of Z form an
 orthonormal basis for this invariant subspace.

 For further explanation of the reciprocal condition numbers RCONDE
 and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
 these quantities are called s and sep respectively).

 A real matrix is in real Schur form if it is upper quasi-triangular
 with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
 the form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

 */
extern proc LAPACKE_sgeesx(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_S_SELECT2, sense : c_char, n : c_int, a : [] c_float, lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ldvs : c_int, ref rconde : c_float, ref rcondv : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgeesx
 */
inline proc LAPACKE_sgeesx(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_S_SELECT2, sense : string, n : c_int, a : [] c_float, lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ldvs : c_int, ref rconde : c_float, ref rcondv : c_float) : c_int{
  return LAPACKE_sgeesx(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeesx

Original Fortran LAPACK documentation for DGEESX::

 DGEESX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left;
 computes a reciprocal condition number for the average of the
 selected eigenvalues (RCONDE); and computes a reciprocal condition
 number for the right invariant subspace corresponding to the
 selected eigenvalues (RCONDV). The leading columns of Z form an
 orthonormal basis for this invariant subspace.

 For further explanation of the reciprocal condition numbers RCONDE
 and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
 these quantities are called s and sep respectively).

 A real matrix is in real Schur form if it is upper quasi-triangular
 with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
 the form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

 */
extern proc LAPACKE_dgeesx(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_D_SELECT2, sense : c_char, n : c_int, a : [] c_double, lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ldvs : c_int, ref rconde : c_double, ref rcondv : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgeesx
 */
inline proc LAPACKE_dgeesx(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_D_SELECT2, sense : string, n : c_int, a : [] c_double, lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ldvs : c_int, ref rconde : c_double, ref rcondv : c_double) : c_int{
  return LAPACKE_dgeesx(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeesx

Original Fortran LAPACK documentation for CGEESX::

 CGEESX computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues, the Schur form T, and, optionally, the matrix of Schur
 vectors Z. This gives the Schur factorization A = Z*T*(Z**H).

 Optionally, it also orders the eigenvalues on the diagonal of the
 Schur form so that selected eigenvalues are at the top left;
 computes a reciprocal condition number for the average of the
 selected eigenvalues (RCONDE); and computes a reciprocal condition
 number for the right invariant subspace corresponding to the
 selected eigenvalues (RCONDV). The leading columns of Z form an
 orthonormal basis for this invariant subspace.

 For further explanation of the reciprocal condition numbers RCONDE
 and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
 these quantities are called s and sep respectively).

 A complex matrix is in Schur form if it is upper triangular.

 */
extern proc LAPACKE_cgeesx(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_C_SELECT1, sense : c_char, n : c_int, a : [] complex(64), lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ldvs : c_int, ref rconde : c_float, ref rcondv : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgeesx
 */
inline proc LAPACKE_cgeesx(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_C_SELECT1, sense : string, n : c_int, a : [] complex(64), lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ldvs : c_int, ref rconde : c_float, ref rcondv : c_float) : c_int{
  return LAPACKE_cgeesx(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeesx

Original Fortran LAPACK documentation for ZGEESX::

 ZGEESX computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues, the Schur form T, and, optionally, the matrix of Schur
 vectors Z. This gives the Schur factorization A = Z*T*(Z**H).

 Optionally, it also orders the eigenvalues on the diagonal of the
 Schur form so that selected eigenvalues are at the top left;
 computes a reciprocal condition number for the average of the
 selected eigenvalues (RCONDE); and computes a reciprocal condition
 number for the right invariant subspace corresponding to the
 selected eigenvalues (RCONDV). The leading columns of Z form an
 orthonormal basis for this invariant subspace.

 For further explanation of the reciprocal condition numbers RCONDE
 and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
 these quantities are called s and sep respectively).

 A complex matrix is in Schur form if it is upper triangular.

 */
extern proc LAPACKE_zgeesx(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_Z_SELECT1, sense : c_char, n : c_int, a : [] complex(128), lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ldvs : c_int, ref rconde : c_double, ref rcondv : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgeesx
 */
inline proc LAPACKE_zgeesx(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_Z_SELECT1, sense : string, n : c_int, a : [] complex(128), lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ldvs : c_int, ref rconde : c_double, ref rcondv : c_double) : c_int{
  return LAPACKE_zgeesx(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeev

Original Fortran LAPACK documentation for SGEEV::

 SGEEV computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 */
extern proc LAPACKE_sgeev(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] c_float, lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgeev
 */
inline proc LAPACKE_sgeev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] c_float, lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int) : c_int{
  return LAPACKE_sgeev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeev

Original Fortran LAPACK documentation for DGEEV::

 DGEEV computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 */
extern proc LAPACKE_dgeev(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] c_double, lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgeev
 */
inline proc LAPACKE_dgeev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] c_double, lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int) : c_int{
  return LAPACKE_dgeev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeev

Original Fortran LAPACK documentation for CGEEV::

 CGEEV computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 */
extern proc LAPACKE_cgeev(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] complex(64), lda : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgeev
 */
inline proc LAPACKE_cgeev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] complex(64), lda : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int) : c_int{
  return LAPACKE_cgeev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, w, vl, ldvl, vr, ldvr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeev

Original Fortran LAPACK documentation for ZGEEV::

 ZGEEV computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 */
extern proc LAPACKE_zgeev(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] complex(128), lda : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgeev
 */
inline proc LAPACKE_zgeev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] complex(128), lda : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int) : c_int{
  return LAPACKE_zgeev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, w, vl, ldvl, vr, ldvr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeevx

Original Fortran LAPACK documentation for SGEEVX::

 SGEEVX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
 (RCONDE), and reciprocal condition numbers for the right
 eigenvectors (RCONDV).

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 Balancing a matrix means permuting the rows and columns to make it
 more nearly upper triangular, and applying a diagonal similarity
 transformation D * A * D**(-1), where D is a diagonal matrix, to
 make its rows and columns closer in norm and the condition numbers
 of its eigenvalues and eigenvectors smaller. The computed
 reciprocal condition numbers correspond to the balanced matrix.
 Permuting rows and columns will not change the condition numbers
 (in exact arithmetic) but diagonal scaling will. For further
 explanation of balancing, see section 4.10.2 of the LAPACK
 Users' Guide.

 */
extern proc LAPACKE_sgeevx(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] c_float, lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgeevx
 */
inline proc LAPACKE_sgeevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] c_float, lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float) : c_int{
  return LAPACKE_sgeevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeevx

Original Fortran LAPACK documentation for DGEEVX::

 DGEEVX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
 (RCONDE), and reciprocal condition numbers for the right
 eigenvectors (RCONDV).

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 Balancing a matrix means permuting the rows and columns to make it
 more nearly upper triangular, and applying a diagonal similarity
 transformation D * A * D**(-1), where D is a diagonal matrix, to
 make its rows and columns closer in norm and the condition numbers
 of its eigenvalues and eigenvectors smaller. The computed
 reciprocal condition numbers correspond to the balanced matrix.
 Permuting rows and columns will not change the condition numbers
 (in exact arithmetic) but diagonal scaling will. For further
 explanation of balancing, see section 4.10.2 of the LAPACK
 Users' Guide.

 */
extern proc LAPACKE_dgeevx(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] c_double, lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgeevx
 */
inline proc LAPACKE_dgeevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] c_double, lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double) : c_int{
  return LAPACKE_dgeevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeevx

Original Fortran LAPACK documentation for CGEEVX::

 CGEEVX computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
 (RCONDE), and reciprocal condition numbers for the right
 eigenvectors (RCONDV).

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 Balancing a matrix means permuting the rows and columns to make it
 more nearly upper triangular, and applying a diagonal similarity
 transformation D * A * D**(-1), where D is a diagonal matrix, to
 make its rows and columns closer in norm and the condition numbers
 of its eigenvalues and eigenvectors smaller. The computed
 reciprocal condition numbers correspond to the balanced matrix.
 Permuting rows and columns will not change the condition numbers
 (in exact arithmetic) but diagonal scaling will. For further
 explanation of balancing, see section 4.10.2 of the LAPACK
 Users' Guide.

 */
extern proc LAPACKE_cgeevx(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] complex(64), lda : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgeevx
 */
inline proc LAPACKE_cgeevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] complex(64), lda : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float) : c_int{
  return LAPACKE_cgeevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeevx

Original Fortran LAPACK documentation for ZGEEVX::

 ZGEEVX computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
 (RCONDE), and reciprocal condition numbers for the right
 eigenvectors (RCONDV).

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 Balancing a matrix means permuting the rows and columns to make it
 more nearly upper triangular, and applying a diagonal similarity
 transformation D * A * D**(-1), where D is a diagonal matrix, to
 make its rows and columns closer in norm and the condition numbers
 of its eigenvalues and eigenvectors smaller. The computed
 reciprocal condition numbers correspond to the balanced matrix.
 Permuting rows and columns will not change the condition numbers
 (in exact arithmetic) but diagonal scaling will. For further
 explanation of balancing, see section 4.10.2 of the LAPACK
 Users' Guide.

 */
extern proc LAPACKE_zgeevx(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] complex(128), lda : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgeevx
 */
inline proc LAPACKE_zgeevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] complex(128), lda : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double) : c_int{
  return LAPACKE_zgeevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgehrd

Original Fortran LAPACK documentation for SGEHRD::

 SGEHRD reduces a real general matrix A to upper Hessenberg form H by
 an orthogonal similarity transformation: Q**T * A * Q = H .

 */
extern proc LAPACKE_sgehrd(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgehrd

Original Fortran LAPACK documentation for DGEHRD::

 DGEHRD reduces a real general matrix A to upper Hessenberg form H by
 an orthogonal similarity transformation: Q**T * A * Q = H .

 */
extern proc LAPACKE_dgehrd(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgehrd

Original Fortran LAPACK documentation for CGEHRD::

 CGEHRD reduces a complex general matrix A to upper Hessenberg form H by
 an unitary similarity transformation: Q**H * A * Q = H .

 */
extern proc LAPACKE_cgehrd(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgehrd

Original Fortran LAPACK documentation for ZGEHRD::

 ZGEHRD reduces a complex general matrix A to upper Hessenberg form H by
 an unitary similarity transformation: Q**H * A * Q = H .

 */
extern proc LAPACKE_zgehrd(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgejsv

Original Fortran LAPACK documentation for SGEJSV::

 SGEJSV computes the singular value decomposition (SVD) of a real M-by-N
 matrix [A], where M >= N. The SVD of [A] is written as

 [A] = [U] * [SIGMA] * [V]^t,

 where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
 diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
 [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
 the singular values of [A]. The columns of [U] and [V] are the left and
 the right singular vectors of [A], respectively. The matrices [U] and [V]
 are computed and stored in the arrays U and V, respectively. The diagonal
 of [SIGMA] is computed and stored in the array SVA.

 */
extern proc LAPACKE_sgejsv(matrix_order : lapack_memory_order, joba : c_char, jobu : c_char, jobv : c_char, jobr : c_char, jobt : c_char, jobp : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, sva : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, stat : [] c_float, istat : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgejsv
 */
inline proc LAPACKE_sgejsv(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, jobr : string, jobt : string, jobp : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, sva : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, stat : [] c_float, istat : [] c_int) : c_int{
  return LAPACKE_sgejsv(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobr) : c_char, ascii(jobt) : c_char, ascii(jobp) : c_char, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgejsv

Original Fortran LAPACK documentation for DGEJSV::

 DGEJSV computes the singular value decomposition (SVD) of a real M-by-N
 matrix [A], where M >= N. The SVD of [A] is written as

 [A] = [U] * [SIGMA] * [V]^t,

 where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
 diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
 [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
 the singular values of [A]. The columns of [U] and [V] are the left and
 the right singular vectors of [A], respectively. The matrices [U] and [V]
 are computed and stored in the arrays U and V, respectively. The diagonal
 of [SIGMA] is computed and stored in the array SVA.

 */
extern proc LAPACKE_dgejsv(matrix_order : lapack_memory_order, joba : c_char, jobu : c_char, jobv : c_char, jobr : c_char, jobt : c_char, jobp : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, sva : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, stat : [] c_double, istat : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgejsv
 */
inline proc LAPACKE_dgejsv(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, jobr : string, jobt : string, jobp : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, sva : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, stat : [] c_double, istat : [] c_int) : c_int{
  return LAPACKE_dgejsv(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobr) : c_char, ascii(jobt) : c_char, ascii(jobp) : c_char, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelq2

Original Fortran LAPACK documentation for SGELQ2::

 SGELQ2 computes an LQ factorization of a real m by n matrix A:
 A = L * Q.

 */
extern proc LAPACKE_sgelq2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelq2

Original Fortran LAPACK documentation for DGELQ2::

 DGELQ2 computes an LQ factorization of a real m by n matrix A:
 A = L * Q.

 */
extern proc LAPACKE_dgelq2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelq2

Original Fortran LAPACK documentation for CGELQ2::

 CGELQ2 computes an LQ factorization of a complex m by n matrix A:
 A = L * Q.

 */
extern proc LAPACKE_cgelq2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelq2

Original Fortran LAPACK documentation for ZGELQ2::

 ZGELQ2 computes an LQ factorization of a complex m by n matrix A:
 A = L * Q.

 */
extern proc LAPACKE_zgelq2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelqf

Original Fortran LAPACK documentation for SGELQF::

 SGELQF computes an LQ factorization of a real M-by-N matrix A:
 A = L * Q.

 */
extern proc LAPACKE_sgelqf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelqf

Original Fortran LAPACK documentation for DGELQF::

 DGELQF computes an LQ factorization of a real M-by-N matrix A:
 A = L * Q.

 */
extern proc LAPACKE_dgelqf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelqf

Original Fortran LAPACK documentation for CGELQF::

 CGELQF computes an LQ factorization of a complex M-by-N matrix A:
 A = L * Q.

 */
extern proc LAPACKE_cgelqf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelqf

Original Fortran LAPACK documentation for ZGELQF::

 ZGELQF computes an LQ factorization of a complex M-by-N matrix A:
 A = L * Q.

 */
extern proc LAPACKE_zgelqf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgels

Original Fortran LAPACK documentation for SGELS::

 SGELS solves overdetermined or underdetermined real linear systems
 involving an M-by-N matrix A, or its transpose, using a QR or LQ
 factorization of A. It is assumed that A has full rank.

 The following options are provided: 

 1. If TRANS = 'N' and m >= n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A*X ||.

 2. If TRANS = 'N' and m < n: find the minimum norm solution of
 an underdetermined system A * X = B.

 3. If TRANS = 'T' and m >= n: find the minimum norm solution of
 an undetermined system A**T * X = B.

 4. If TRANS = 'T' and m < n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A**T * X ||.

 Several right hand side vectors b and solution vectors x can be 
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution 
 matrix X.

 */
extern proc LAPACKE_sgels(matrix_order : lapack_memory_order, trans : c_char, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgels
 */
inline proc LAPACKE_sgels(matrix_order : lapack_memory_order, trans : string, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sgels(matrix_order, ascii(trans) : c_char, m, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgels

Original Fortran LAPACK documentation for DGELS::

 DGELS solves overdetermined or underdetermined real linear systems
 involving an M-by-N matrix A, or its transpose, using a QR or LQ
 factorization of A. It is assumed that A has full rank.

 The following options are provided:

 1. If TRANS = 'N' and m >= n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A*X ||.

 2. If TRANS = 'N' and m < n: find the minimum norm solution of
 an underdetermined system A * X = B.

 3. If TRANS = 'T' and m >= n: find the minimum norm solution of
 an undetermined system A**T * X = B.

 4. If TRANS = 'T' and m < n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A**T * X ||.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 */
extern proc LAPACKE_dgels(matrix_order : lapack_memory_order, trans : c_char, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgels
 */
inline proc LAPACKE_dgels(matrix_order : lapack_memory_order, trans : string, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dgels(matrix_order, ascii(trans) : c_char, m, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgels

Original Fortran LAPACK documentation for CGELS::

 CGELS solves overdetermined or underdetermined complex linear systems
 involving an M-by-N matrix A, or its conjugate-transpose, using a QR
 or LQ factorization of A. It is assumed that A has full rank.

 The following options are provided:

 1. If TRANS = 'N' and m >= n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A*X ||.

 2. If TRANS = 'N' and m < n: find the minimum norm solution of
 an underdetermined system A * X = B.

 3. If TRANS = 'C' and m >= n: find the minimum norm solution of
 an undetermined system A**H * X = B.

 4. If TRANS = 'C' and m < n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A**H * X ||.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 */
extern proc LAPACKE_cgels(matrix_order : lapack_memory_order, trans : c_char, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgels
 */
inline proc LAPACKE_cgels(matrix_order : lapack_memory_order, trans : string, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cgels(matrix_order, ascii(trans) : c_char, m, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgels

Original Fortran LAPACK documentation for ZGELS::

 ZGELS solves overdetermined or underdetermined complex linear systems
 involving an M-by-N matrix A, or its conjugate-transpose, using a QR
 or LQ factorization of A. It is assumed that A has full rank.

 The following options are provided:

 1. If TRANS = 'N' and m >= n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A*X ||.

 2. If TRANS = 'N' and m < n: find the minimum norm solution of
 an underdetermined system A * X = B.

 3. If TRANS = 'C' and m >= n: find the minimum norm solution of
 an undetermined system A**H * X = B.

 4. If TRANS = 'C' and m < n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A**H * X ||.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 */
extern proc LAPACKE_zgels(matrix_order : lapack_memory_order, trans : c_char, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgels
 */
inline proc LAPACKE_zgels(matrix_order : lapack_memory_order, trans : string, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zgels(matrix_order, ascii(trans) : c_char, m, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelsd

Original Fortran LAPACK documentation for SGELSD::

 SGELSD computes the minimum-norm solution to a real linear least
 squares problem:
 minimize 2-norm(| b - A*x |)
 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The problem is solved in three steps:
 (1) Reduce the coefficient matrix A to bidiagonal form with
 Householder transformations, reducing the original problem
 into a "bidiagonal least squares problem" (BLS)
 (2) Solve the BLS using a divide and conquer approach.
 (3) Apply back all the Householder tranformations to solve
 the original least squares problem.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_sgelsd(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, s : [] c_float, rcond : c_float, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelsd

Original Fortran LAPACK documentation for DGELSD::

 DGELSD computes the minimum-norm solution to a real linear least
 squares problem:
 minimize 2-norm(| b - A*x |)
 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The problem is solved in three steps:
 (1) Reduce the coefficient matrix A to bidiagonal form with
 Householder transformations, reducing the original problem
 into a "bidiagonal least squares problem" (BLS)
 (2) Solve the BLS using a divide and conquer approach.
 (3) Apply back all the Householder tranformations to solve
 the original least squares problem.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_dgelsd(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, s : [] c_double, rcond : c_double, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelsd

Original Fortran LAPACK documentation for CGELSD::

 CGELSD computes the minimum-norm solution to a real linear least
 squares problem:
 minimize 2-norm(| b - A*x |)
 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The problem is solved in three steps:
 (1) Reduce the coefficient matrix A to bidiagonal form with
 Householder tranformations, reducing the original problem
 into a "bidiagonal least squares problem" (BLS)
 (2) Solve the BLS using a divide and conquer approach.
 (3) Apply back all the Householder tranformations to solve
 the original least squares problem.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_cgelsd(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, s : [] c_float, rcond : c_float, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelsd

Original Fortran LAPACK documentation for ZGELSD::

 ZGELSD computes the minimum-norm solution to a real linear least
 squares problem:
 minimize 2-norm(| b - A*x |)
 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The problem is solved in three steps:
 (1) Reduce the coefficient matrix A to bidiagonal form with
 Householder tranformations, reducing the original problem
 into a "bidiagonal least squares problem" (BLS)
 (2) Solve the BLS using a divide and conquer approach.
 (3) Apply back all the Householder tranformations to solve
 the original least squares problem.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_zgelsd(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, s : [] c_double, rcond : c_double, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelss

Original Fortran LAPACK documentation for SGELSS::

 SGELSS computes the minimum norm solution to a real linear least
 squares problem:

 Minimize 2-norm(| b - A*x |).

 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
 X.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 */
extern proc LAPACKE_sgelss(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, s : [] c_float, rcond : c_float, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelss

Original Fortran LAPACK documentation for DGELSS::

 DGELSS computes the minimum norm solution to a real linear least
 squares problem:

 Minimize 2-norm(| b - A*x |).

 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
 X.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 */
extern proc LAPACKE_dgelss(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, s : [] c_double, rcond : c_double, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelss

Original Fortran LAPACK documentation for CGELSS::

 CGELSS computes the minimum norm solution to a complex linear
 least squares problem:

 Minimize 2-norm(| b - A*x |).

 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
 X.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 */
extern proc LAPACKE_cgelss(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, s : [] c_float, rcond : c_float, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelss

Original Fortran LAPACK documentation for ZGELSS::

 ZGELSS computes the minimum norm solution to a complex linear
 least squares problem:

 Minimize 2-norm(| b - A*x |).

 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
 X.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 */
extern proc LAPACKE_zgelss(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, s : [] c_double, rcond : c_double, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelsy

Original Fortran LAPACK documentation for SGELSY::

 SGELSY computes the minimum-norm solution to a real linear least
 squares problem:
 minimize || A * X - B ||
 using a complete orthogonal factorization of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The routine first computes a QR factorization with column pivoting:
 A * P = Q * [ R11 R12 ]
 [ 0 R22 ]
 with R11 defined as the largest leading submatrix whose estimated
 condition number is less than 1/RCOND. The order of R11, RANK,
 is the effective rank of A.

 Then, R22 is considered to be negligible, and R12 is annihilated
 by orthogonal transformations from the right, arriving at the
 complete orthogonal factorization:
 A * P = Q * [ T11 0 ] * Z
 [ 0 0 ]
 The minimum-norm solution is then
 X = P * Z**T [ inv(T11)*Q1**T*B ]
 [ 0 ]
 where Q1 consists of the first RANK columns of Q.

 This routine is basically identical to the original xGELSX except
 three differences:
 o The call to the subroutine xGEQPF has been substituted by the
 the call to the subroutine xGEQP3. This subroutine is a Blas-3
 version of the QR factorization with column pivoting.
 o Matrix B (the right hand side) is updated with Blas-3.
 o The permutation of matrix B (the right hand side) is faster and
 more simple.

 */
extern proc LAPACKE_sgelsy(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, jpvt : [] c_int, rcond : c_float, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelsy

Original Fortran LAPACK documentation for DGELSY::

 DGELSY computes the minimum-norm solution to a real linear least
 squares problem:
 minimize || A * X - B ||
 using a complete orthogonal factorization of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The routine first computes a QR factorization with column pivoting:
 A * P = Q * [ R11 R12 ]
 [ 0 R22 ]
 with R11 defined as the largest leading submatrix whose estimated
 condition number is less than 1/RCOND. The order of R11, RANK,
 is the effective rank of A.

 Then, R22 is considered to be negligible, and R12 is annihilated
 by orthogonal transformations from the right, arriving at the
 complete orthogonal factorization:
 A * P = Q * [ T11 0 ] * Z
 [ 0 0 ]
 The minimum-norm solution is then
 X = P * Z**T [ inv(T11)*Q1**T*B ]
 [ 0 ]
 where Q1 consists of the first RANK columns of Q.

 This routine is basically identical to the original xGELSX except
 three differences:
 o The call to the subroutine xGEQPF has been substituted by the
 the call to the subroutine xGEQP3. This subroutine is a Blas-3
 version of the QR factorization with column pivoting.
 o Matrix B (the right hand side) is updated with Blas-3.
 o The permutation of matrix B (the right hand side) is faster and
 more simple.

 */
extern proc LAPACKE_dgelsy(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, jpvt : [] c_int, rcond : c_double, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelsy

Original Fortran LAPACK documentation for CGELSY::

 CGELSY computes the minimum-norm solution to a complex linear least
 squares problem:
 minimize || A * X - B ||
 using a complete orthogonal factorization of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The routine first computes a QR factorization with column pivoting:
 A * P = Q * [ R11 R12 ]
 [ 0 R22 ]
 with R11 defined as the largest leading submatrix whose estimated
 condition number is less than 1/RCOND. The order of R11, RANK,
 is the effective rank of A.

 Then, R22 is considered to be negligible, and R12 is annihilated
 by unitary transformations from the right, arriving at the
 complete orthogonal factorization:
 A * P = Q * [ T11 0 ] * Z
 [ 0 0 ]
 The minimum-norm solution is then
 X = P * Z**H [ inv(T11)*Q1**H*B ]
 [ 0 ]
 where Q1 consists of the first RANK columns of Q.

 This routine is basically identical to the original xGELSX except
 three differences:
 o The permutation of matrix B (the right hand side) is faster and
 more simple.
 o The call to the subroutine xGEQPF has been substituted by the
 the call to the subroutine xGEQP3. This subroutine is a Blas-3
 version of the QR factorization with column pivoting.
 o Matrix B (the right hand side) is updated with Blas-3.

 */
extern proc LAPACKE_cgelsy(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, jpvt : [] c_int, rcond : c_float, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelsy

Original Fortran LAPACK documentation for ZGELSY::

 ZGELSY computes the minimum-norm solution to a complex linear least
 squares problem:
 minimize || A * X - B ||
 using a complete orthogonal factorization of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The routine first computes a QR factorization with column pivoting:
 A * P = Q * [ R11 R12 ]
 [ 0 R22 ]
 with R11 defined as the largest leading submatrix whose estimated
 condition number is less than 1/RCOND. The order of R11, RANK,
 is the effective rank of A.

 Then, R22 is considered to be negligible, and R12 is annihilated
 by unitary transformations from the right, arriving at the
 complete orthogonal factorization:
 A * P = Q * [ T11 0 ] * Z
 [ 0 0 ]
 The minimum-norm solution is then
 X = P * Z**H [ inv(T11)*Q1**H*B ]
 [ 0 ]
 where Q1 consists of the first RANK columns of Q.

 This routine is basically identical to the original xGELSX except
 three differences:
 o The permutation of matrix B (the right hand side) is faster and
 more simple.
 o The call to the subroutine xGEQPF has been substituted by the
 the call to the subroutine xGEQP3. This subroutine is a Blas-3
 version of the QR factorization with column pivoting.
 o Matrix B (the right hand side) is updated with Blas-3.

 */
extern proc LAPACKE_zgelsy(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, jpvt : [] c_int, rcond : c_double, ref rank : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqlf

Original Fortran LAPACK documentation for SGEQLF::

 SGEQLF computes a QL factorization of a real M-by-N matrix A:
 A = Q * L.

 */
extern proc LAPACKE_sgeqlf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqlf

Original Fortran LAPACK documentation for DGEQLF::

 DGEQLF computes a QL factorization of a real M-by-N matrix A:
 A = Q * L.

 */
extern proc LAPACKE_dgeqlf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqlf

Original Fortran LAPACK documentation for CGEQLF::

 CGEQLF computes a QL factorization of a complex M-by-N matrix A:
 A = Q * L.

 */
extern proc LAPACKE_cgeqlf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqlf

Original Fortran LAPACK documentation for ZGEQLF::

 ZGEQLF computes a QL factorization of a complex M-by-N matrix A:
 A = Q * L.

 */
extern proc LAPACKE_zgeqlf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqp3

Original Fortran LAPACK documentation for SGEQP3::

 SGEQP3 computes a QR factorization with column pivoting of a
 matrix A: A*P = Q*R using Level 3 BLAS.

 */
extern proc LAPACKE_sgeqp3(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, jpvt : [] c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqp3

Original Fortran LAPACK documentation for DGEQP3::

 DGEQP3 computes a QR factorization with column pivoting of a
 matrix A: A*P = Q*R using Level 3 BLAS.

 */
extern proc LAPACKE_dgeqp3(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, jpvt : [] c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqp3

Original Fortran LAPACK documentation for CGEQP3::

 CGEQP3 computes a QR factorization with column pivoting of a
 matrix A: A*P = Q*R using Level 3 BLAS.

 */
extern proc LAPACKE_cgeqp3(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, jpvt : [] c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqp3

Original Fortran LAPACK documentation for ZGEQP3::

 ZGEQP3 computes a QR factorization with column pivoting of a
 matrix A: A*P = Q*R using Level 3 BLAS.

 */
extern proc LAPACKE_zgeqp3(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, jpvt : [] c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqpf

Original Fortran LAPACK documentation for SGEQPF::

 This routine is deprecated and has been replaced by routine SGEQP3.

 SGEQPF computes a QR factorization with column pivoting of a
 real M-by-N matrix A: A*P = Q*R.

 */
extern proc LAPACKE_sgeqpf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, jpvt : [] c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqpf

Original Fortran LAPACK documentation for DGEQPF::

 This routine is deprecated and has been replaced by routine DGEQP3.

 DGEQPF computes a QR factorization with column pivoting of a
 real M-by-N matrix A: A*P = Q*R.

 */
extern proc LAPACKE_dgeqpf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, jpvt : [] c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqpf

Original Fortran LAPACK documentation for CGEQPF::

 This routine is deprecated and has been replaced by routine CGEQP3.

 CGEQPF computes a QR factorization with column pivoting of a
 complex M-by-N matrix A: A*P = Q*R.

 */
extern proc LAPACKE_cgeqpf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, jpvt : [] c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqpf

Original Fortran LAPACK documentation for ZGEQPF::

 This routine is deprecated and has been replaced by routine ZGEQP3.

 ZGEQPF computes a QR factorization with column pivoting of a
 complex M-by-N matrix A: A*P = Q*R.

 */
extern proc LAPACKE_zgeqpf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, jpvt : [] c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqr2

Original Fortran LAPACK documentation for SGEQR2::

 SGEQR2 computes a QR factorization of a real m by n matrix A:
 A = Q * R.

 */
extern proc LAPACKE_sgeqr2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqr2

Original Fortran LAPACK documentation for DGEQR2::

 DGEQR2 computes a QR factorization of a real m by n matrix A:
 A = Q * R.

 */
extern proc LAPACKE_dgeqr2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqr2

Original Fortran LAPACK documentation for CGEQR2::

 CGEQR2 computes a QR factorization of a complex m by n matrix A:
 A = Q * R.

 */
extern proc LAPACKE_cgeqr2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqr2

Original Fortran LAPACK documentation for ZGEQR2::

 ZGEQR2 computes a QR factorization of a complex m by n matrix A:
 A = Q * R.

 */
extern proc LAPACKE_zgeqr2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrf

Original Fortran LAPACK documentation for SGEQRF::

 SGEQRF computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACKE_sgeqrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrf

Original Fortran LAPACK documentation for DGEQRF::

 DGEQRF computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACKE_dgeqrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrf

Original Fortran LAPACK documentation for CGEQRF::

 CGEQRF computes a QR factorization of a complex M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACKE_cgeqrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrf

Original Fortran LAPACK documentation for ZGEQRF::

 ZGEQRF computes a QR factorization of a complex M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACKE_zgeqrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrfp

Original Fortran LAPACK documentation for SGEQRFP::

 SGEQRFP computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACKE_sgeqrfp(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrfp

Original Fortran LAPACK documentation for DGEQRFP::

 DGEQRFP computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACKE_dgeqrfp(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrfp

Original Fortran LAPACK documentation for CGEQRFP::

 CGEQRFP computes a QR factorization of a complex M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACKE_cgeqrfp(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrfp

Original Fortran LAPACK documentation for ZGEQRFP::

 ZGEQRFP computes a QR factorization of a complex M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACKE_zgeqrfp(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgerfs

Original Fortran LAPACK documentation for SGERFS::

 SGERFS improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates for
 the solution.

 */
extern proc LAPACKE_sgerfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgerfs
 */
inline proc LAPACKE_sgerfs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_sgerfs(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgerfs

Original Fortran LAPACK documentation for DGERFS::

 DGERFS improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates for
 the solution.

 */
extern proc LAPACKE_dgerfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgerfs
 */
inline proc LAPACKE_dgerfs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dgerfs(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgerfs

Original Fortran LAPACK documentation for CGERFS::

 CGERFS improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates for
 the solution.

 */
extern proc LAPACKE_cgerfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgerfs
 */
inline proc LAPACKE_cgerfs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cgerfs(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgerfs

Original Fortran LAPACK documentation for ZGERFS::

 ZGERFS improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates for
 the solution.

 */
extern proc LAPACKE_zgerfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgerfs
 */
inline proc LAPACKE_zgerfs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zgerfs(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgerfsx

Original Fortran LAPACK documentation for SGERFSX::

 SGERFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACKE_sgerfsx(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgerfsx
 */
inline proc LAPACKE_sgerfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_sgerfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgerfsx

Original Fortran LAPACK documentation for DGERFSX::

 DGERFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACKE_dgerfsx(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgerfsx
 */
inline proc LAPACKE_dgerfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_dgerfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgerfsx

Original Fortran LAPACK documentation for CGERFSX::

 CGERFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACKE_cgerfsx(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgerfsx
 */
inline proc LAPACKE_cgerfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_cgerfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgerfsx

Original Fortran LAPACK documentation for ZGERFSX::

 ZGERFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACKE_zgerfsx(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgerfsx
 */
inline proc LAPACKE_zgerfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zgerfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgerqf

Original Fortran LAPACK documentation for SGERQF::

 SGERQF computes an RQ factorization of a real M-by-N matrix A:
 A = R * Q.

 */
extern proc LAPACKE_sgerqf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgerqf

Original Fortran LAPACK documentation for DGERQF::

 DGERQF computes an RQ factorization of a real M-by-N matrix A:
 A = R * Q.

 */
extern proc LAPACKE_dgerqf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgerqf

Original Fortran LAPACK documentation for CGERQF::

 CGERQF computes an RQ factorization of a complex M-by-N matrix A:
 A = R * Q.

 */
extern proc LAPACKE_cgerqf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgerqf

Original Fortran LAPACK documentation for ZGERQF::

 ZGERQF computes an RQ factorization of a complex M-by-N matrix A:
 A = R * Q.

 */
extern proc LAPACKE_zgerqf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesdd

Original Fortran LAPACK documentation for SGESDD::

 SGESDD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and right singular
 vectors. If singular vectors are desired, it uses a
 divide-and-conquer algorithm.

 The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns VT = V**T, not V.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_sgesdd(matrix_order : lapack_memory_order, jobz : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesdd
 */
inline proc LAPACKE_sgesdd(matrix_order : lapack_memory_order, jobz : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int) : c_int{
  return LAPACKE_sgesdd(matrix_order, ascii(jobz) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesdd

Original Fortran LAPACK documentation for DGESDD::

 DGESDD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and right singular
 vectors. If singular vectors are desired, it uses a
 divide-and-conquer algorithm.

 The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns VT = V**T, not V.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_dgesdd(matrix_order : lapack_memory_order, jobz : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesdd
 */
inline proc LAPACKE_dgesdd(matrix_order : lapack_memory_order, jobz : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int) : c_int{
  return LAPACKE_dgesdd(matrix_order, ascii(jobz) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesdd

Original Fortran LAPACK documentation for CGESDD::

 CGESDD computes the singular value decomposition (SVD) of a complex
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors, by using divide-and-conquer method. The SVD is written

 A = U * SIGMA * conjugate-transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
 V is an N-by-N unitary matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns VT = V**H, not V.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_cgesdd(matrix_order : lapack_memory_order, jobz : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, u : [] complex(64), ldu : c_int, vt : [] complex(64), ldvt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgesdd
 */
inline proc LAPACKE_cgesdd(matrix_order : lapack_memory_order, jobz : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, u : [] complex(64), ldu : c_int, vt : [] complex(64), ldvt : c_int) : c_int{
  return LAPACKE_cgesdd(matrix_order, ascii(jobz) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesdd

Original Fortran LAPACK documentation for ZGESDD::

 ZGESDD computes the singular value decomposition (SVD) of a complex
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors, by using divide-and-conquer method. The SVD is written

 A = U * SIGMA * conjugate-transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
 V is an N-by-N unitary matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns VT = V**H, not V.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_zgesdd(matrix_order : lapack_memory_order, jobz : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, u : [] complex(128), ldu : c_int, vt : [] complex(128), ldvt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgesdd
 */
inline proc LAPACKE_zgesdd(matrix_order : lapack_memory_order, jobz : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, u : [] complex(128), ldu : c_int, vt : [] complex(128), ldvt : c_int) : c_int{
  return LAPACKE_zgesdd(matrix_order, ascii(jobz) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesv

Original Fortran LAPACK documentation for SGESV::

 SGESV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as
 A = P * L * U,
 where P is a permutation matrix, L is unit lower triangular, and U is
 upper triangular. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACKE_sgesv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesv

Original Fortran LAPACK documentation for DGESV::

 DGESV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as
 A = P * L * U,
 where P is a permutation matrix, L is unit lower triangular, and U is
 upper triangular. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACKE_dgesv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesv

Original Fortran LAPACK documentation for CGESV::

 CGESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as
 A = P * L * U,
 where P is a permutation matrix, L is unit lower triangular, and U is
 upper triangular. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACKE_cgesv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesv

Original Fortran LAPACK documentation for ZGESV::

 ZGESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as
 A = P * L * U,
 where P is a permutation matrix, L is unit lower triangular, and U is
 upper triangular. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACKE_zgesv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dsgesv

Original Fortran LAPACK documentation for DSGESV::

 DSGESV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 DSGESV first attempts to factorize the matrix in SINGLE PRECISION
 and use this factorization within an iterative refinement procedure
 to produce a solution with DOUBLE PRECISION normwise backward error
 quality (see below). If the approach fails the method switches to a
 DOUBLE PRECISION factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio SINGLE PRECISION performance over DOUBLE PRECISION
 performance is too small. A reasonable strategy should take the
 number of right-hand sides and the size of the matrix into account.
 This might be done with a call to ILAENV in the future. Up to now, we
 always try iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

 */
extern proc LAPACKE_dsgesv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref chlapack_iter : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zcgesv

Original Fortran LAPACK documentation for ZCGESV::

 ZCGESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 ZCGESV first attempts to factorize the matrix in COMPLEX and use this
 factorization within an iterative refinement procedure to produce a
 solution with COMPLEX*16 normwise backward error quality (see below).
 If the approach fails the method switches to a COMPLEX*16
 factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio COMPLEX performance over COMPLEX*16 performance is too
 small. A reasonable strategy should take the number of right-hand
 sides and the size of the matrix into account. This might be done
 with a call to ILAENV in the future. Up to now, we always try
 iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

 */
extern proc LAPACKE_zcgesv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref chlapack_iter : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesvd

Original Fortran LAPACK documentation for SGESVD::

 SGESVD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors. The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns V**T, not V.

 */
extern proc LAPACKE_sgesvd(matrix_order : lapack_memory_order, jobu : c_char, jobvt : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, superb : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesvd
 */
inline proc LAPACKE_sgesvd(matrix_order : lapack_memory_order, jobu : string, jobvt : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, superb : [] c_float) : c_int{
  return LAPACKE_sgesvd(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesvd

Original Fortran LAPACK documentation for DGESVD::

 DGESVD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors. The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns V**T, not V.

 */
extern proc LAPACKE_dgesvd(matrix_order : lapack_memory_order, jobu : c_char, jobvt : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, superb : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesvd
 */
inline proc LAPACKE_dgesvd(matrix_order : lapack_memory_order, jobu : string, jobvt : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, superb : [] c_double) : c_int{
  return LAPACKE_dgesvd(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesvd

Original Fortran LAPACK documentation for CGESVD::

 CGESVD computes the singular value decomposition (SVD) of a complex
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors. The SVD is written

 A = U * SIGMA * conjugate-transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
 V is an N-by-N unitary matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns V**H, not V.

 */
extern proc LAPACKE_cgesvd(matrix_order : lapack_memory_order, jobu : c_char, jobvt : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, u : [] complex(64), ldu : c_int, vt : [] complex(64), ldvt : c_int, superb : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgesvd
 */
inline proc LAPACKE_cgesvd(matrix_order : lapack_memory_order, jobu : string, jobvt : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, u : [] complex(64), ldu : c_int, vt : [] complex(64), ldvt : c_int, superb : [] c_float) : c_int{
  return LAPACKE_cgesvd(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesvd

Original Fortran LAPACK documentation for ZGESVD::

 ZGESVD computes the singular value decomposition (SVD) of a complex
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors. The SVD is written

 A = U * SIGMA * conjugate-transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
 V is an N-by-N unitary matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns V**H, not V.

 */
extern proc LAPACKE_zgesvd(matrix_order : lapack_memory_order, jobu : c_char, jobvt : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, u : [] complex(128), ldu : c_int, vt : [] complex(128), ldvt : c_int, superb : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgesvd
 */
inline proc LAPACKE_zgesvd(matrix_order : lapack_memory_order, jobu : string, jobvt : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, u : [] complex(128), ldu : c_int, vt : [] complex(128), ldvt : c_int, superb : [] c_double) : c_int{
  return LAPACKE_zgesvd(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesvj

Original Fortran LAPACK documentation for SGESVJ::

 SGESVJ computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, where M >= N. The SVD of A is written as
 [++] [xx] [x0] [xx]
 A = U * SIGMA * V^t, [++] = [xx] * [ox] * [xx]
 [++] [xx]
 where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
 matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
 of SIGMA are the singular values of A. The columns of U and V are the
 left and the right singular vectors of A, respectively.

 */
extern proc LAPACKE_sgesvj(matrix_order : lapack_memory_order, joba : c_char, jobu : c_char, jobv : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, sva : [] c_float, mv : c_int, v : [] c_float, ldv : c_int, stat : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesvj
 */
inline proc LAPACKE_sgesvj(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, sva : [] c_float, mv : c_int, v : [] c_float, ldv : c_int, stat : [] c_float) : c_int{
  return LAPACKE_sgesvj(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, m, n, a, lda, sva, mv, v, ldv, stat);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesvj

Original Fortran LAPACK documentation for DGESVJ::

 DGESVJ computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, where M >= N. The SVD of A is written as
 [++] [xx] [x0] [xx]
 A = U * SIGMA * V^t, [++] = [xx] * [ox] * [xx]
 [++] [xx]
 where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
 matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
 of SIGMA are the singular values of A. The columns of U and V are the
 left and the right singular vectors of A, respectively.

 */
extern proc LAPACKE_dgesvj(matrix_order : lapack_memory_order, joba : c_char, jobu : c_char, jobv : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, sva : [] c_double, mv : c_int, v : [] c_double, ldv : c_int, stat : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesvj
 */
inline proc LAPACKE_dgesvj(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, sva : [] c_double, mv : c_int, v : [] c_double, ldv : c_int, stat : [] c_double) : c_int{
  return LAPACKE_dgesvj(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, m, n, a, lda, sva, mv, v, ldv, stat);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesvx

Original Fortran LAPACK documentation for SGESVX::

 SGESVX uses the LU factorization to compute the solution to a real
 system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_sgesvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesvx
 */
inline proc LAPACKE_sgesvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float) : c_int{
  return LAPACKE_sgesvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesvx

Original Fortran LAPACK documentation for DGESVX::

 DGESVX uses the LU factorization to compute the solution to a real
 system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_dgesvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesvx
 */
inline proc LAPACKE_dgesvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double) : c_int{
  return LAPACKE_dgesvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesvx

Original Fortran LAPACK documentation for CGESVX::

 CGESVX uses the LU factorization to compute the solution to a complex
 system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_cgesvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgesvx
 */
inline proc LAPACKE_cgesvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float) : c_int{
  return LAPACKE_cgesvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesvx

Original Fortran LAPACK documentation for ZGESVX::

 ZGESVX uses the LU factorization to compute the solution to a complex
 system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zgesvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgesvx
 */
inline proc LAPACKE_zgesvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double) : c_int{
  return LAPACKE_zgesvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesvxx

Original Fortran LAPACK documentation for SGESVXX::

 SGESVXX uses the LU factorization to compute the solution to a
 real system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SGESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SGESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SGESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SGESVXX would itself produce.

 */
extern proc LAPACKE_sgesvxx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesvxx
 */
inline proc LAPACKE_sgesvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_sgesvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesvxx

Original Fortran LAPACK documentation for DGESVXX::

 DGESVXX uses the LU factorization to compute the solution to a
 double precision system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. DGESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 DGESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 DGESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what DGESVXX would itself produce.

 */
extern proc LAPACKE_dgesvxx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesvxx
 */
inline proc LAPACKE_dgesvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_dgesvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesvxx

Original Fortran LAPACK documentation for CGESVXX::

 CGESVXX uses the LU factorization to compute the solution to a
 complex system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CGESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CGESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CGESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CGESVXX would itself produce.

 */
extern proc LAPACKE_cgesvxx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgesvxx
 */
inline proc LAPACKE_cgesvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_cgesvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesvxx

Original Fortran LAPACK documentation for ZGESVXX::

 ZGESVXX uses the LU factorization to compute the solution to a
 complex*16 system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZGESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZGESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZGESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZGESVXX would itself produce.

 */
extern proc LAPACKE_zgesvxx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgesvxx
 */
inline proc LAPACKE_zgesvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zgesvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgetf2

Original Fortran LAPACK documentation for SGETF2::

 SGETF2 computes an LU factorization of a general m-by-n matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 2 BLAS version of the algorithm.

 */
extern proc LAPACKE_sgetf2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgetf2

Original Fortran LAPACK documentation for DGETF2::

 DGETF2 computes an LU factorization of a general m-by-n matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 2 BLAS version of the algorithm.

 */
extern proc LAPACKE_dgetf2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgetf2

Original Fortran LAPACK documentation for CGETF2::

 CGETF2 computes an LU factorization of a general m-by-n matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 2 BLAS version of the algorithm.

 */
extern proc LAPACKE_cgetf2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgetf2

Original Fortran LAPACK documentation for ZGETF2::

 ZGETF2 computes an LU factorization of a general m-by-n matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 2 BLAS version of the algorithm.

 */
extern proc LAPACKE_zgetf2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgetrf

Original Fortran LAPACK documentation for SGETRF::

 SGETRF computes an LU factorization of a general M-by-N matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_sgetrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgetrf

Original Fortran LAPACK documentation for DGETRF::

 DGETRF computes an LU factorization of a general M-by-N matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_dgetrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgetrf

Original Fortran LAPACK documentation for CGETRF::

 CGETRF computes an LU factorization of a general M-by-N matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_cgetrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgetrf

Original Fortran LAPACK documentation for ZGETRF::

 ZGETRF computes an LU factorization of a general M-by-N matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_zgetrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgetri

Original Fortran LAPACK documentation for SGETRI::

 SGETRI computes the inverse of a matrix using the LU factorization
 computed by SGETRF.

 This method inverts U and then computes inv(A) by solving the system
 inv(A)*L = inv(U) for inv(A).

 */
extern proc LAPACKE_sgetri(matrix_order : lapack_memory_order, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgetri

Original Fortran LAPACK documentation for DGETRI::

 DGETRI computes the inverse of a matrix using the LU factorization
 computed by DGETRF.

 This method inverts U and then computes inv(A) by solving the system
 inv(A)*L = inv(U) for inv(A).

 */
extern proc LAPACKE_dgetri(matrix_order : lapack_memory_order, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgetri

Original Fortran LAPACK documentation for CGETRI::

 CGETRI computes the inverse of a matrix using the LU factorization
 computed by CGETRF.

 This method inverts U and then computes inv(A) by solving the system
 inv(A)*L = inv(U) for inv(A).

 */
extern proc LAPACKE_cgetri(matrix_order : lapack_memory_order, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgetri

Original Fortran LAPACK documentation for ZGETRI::

 ZGETRI computes the inverse of a matrix using the LU factorization
 computed by ZGETRF.

 This method inverts U and then computes inv(A) by solving the system
 inv(A)*L = inv(U) for inv(A).

 */
extern proc LAPACKE_zgetri(matrix_order : lapack_memory_order, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgetrs

Original Fortran LAPACK documentation for SGETRS::

 SGETRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general N-by-N matrix A using the LU factorization computed
 by SGETRF.

 */
extern proc LAPACKE_sgetrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgetrs
 */
inline proc LAPACKE_sgetrs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sgetrs(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgetrs

Original Fortran LAPACK documentation for DGETRS::

 DGETRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general N-by-N matrix A using the LU factorization computed
 by DGETRF.

 */
extern proc LAPACKE_dgetrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgetrs
 */
inline proc LAPACKE_dgetrs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dgetrs(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgetrs

Original Fortran LAPACK documentation for CGETRS::

 CGETRS solves a system of linear equations
 A * X = B, A**T * X = B, or A**H * X = B
 with a general N-by-N matrix A using the LU factorization computed
 by CGETRF.

 */
extern proc LAPACKE_cgetrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgetrs
 */
inline proc LAPACKE_cgetrs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cgetrs(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgetrs

Original Fortran LAPACK documentation for ZGETRS::

 ZGETRS solves a system of linear equations
 A * X = B, A**T * X = B, or A**H * X = B
 with a general N-by-N matrix A using the LU factorization computed
 by ZGETRF.

 */
extern proc LAPACKE_zgetrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgetrs
 */
inline proc LAPACKE_zgetrs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zgetrs(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggbak

Original Fortran LAPACK documentation for SGGBAK::

 SGGBAK forms the right or left eigenvectors of a real generalized
 eigenvalue problem A*x = lambda*B*x, by backward transformation on
 the computed eigenvectors of the balanced pair of matrices output by
 SGGBAL.

 */
extern proc LAPACKE_sggbak(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, m : c_int, v : [] c_float, ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggbak
 */
inline proc LAPACKE_sggbak(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, m : c_int, v : [] c_float, ldv : c_int) : c_int{
  return LAPACKE_sggbak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, lscale, rscale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggbak

Original Fortran LAPACK documentation for DGGBAK::

 DGGBAK forms the right or left eigenvectors of a real generalized
 eigenvalue problem A*x = lambda*B*x, by backward transformation on
 the computed eigenvectors of the balanced pair of matrices output by
 DGGBAL.

 */
extern proc LAPACKE_dggbak(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, m : c_int, v : [] c_double, ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggbak
 */
inline proc LAPACKE_dggbak(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, m : c_int, v : [] c_double, ldv : c_int) : c_int{
  return LAPACKE_dggbak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, lscale, rscale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggbak

Original Fortran LAPACK documentation for CGGBAK::

 CGGBAK forms the right or left eigenvectors of a complex generalized
 eigenvalue problem A*x = lambda*B*x, by backward transformation on
 the computed eigenvectors of the balanced pair of matrices output by
 CGGBAL.

 */
extern proc LAPACKE_cggbak(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, m : c_int, v : [] complex(64), ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggbak
 */
inline proc LAPACKE_cggbak(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, m : c_int, v : [] complex(64), ldv : c_int) : c_int{
  return LAPACKE_cggbak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, lscale, rscale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggbak

Original Fortran LAPACK documentation for ZGGBAK::

 ZGGBAK forms the right or left eigenvectors of a complex generalized
 eigenvalue problem A*x = lambda*B*x, by backward transformation on
 the computed eigenvectors of the balanced pair of matrices output by
 ZGGBAL.

 */
extern proc LAPACKE_zggbak(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, m : c_int, v : [] complex(128), ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggbak
 */
inline proc LAPACKE_zggbak(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, m : c_int, v : [] complex(128), ldv : c_int) : c_int{
  return LAPACKE_zggbak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, lscale, rscale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggbal

Original Fortran LAPACK documentation for SGGBAL::

 SGGBAL balances a pair of general real matrices (A,B). This
 involves, first, permuting A and B by similarity transformations to
 isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
 elements on the diagonal; and second, applying a diagonal similarity
 transformation to rows and columns ILO to IHI to make the rows
 and columns as close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrices, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors in the
 generalized eigenvalue problem A*x = lambda*B*x.

 */
extern proc LAPACKE_sggbal(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggbal
 */
inline proc LAPACKE_sggbal(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float) : c_int{
  return LAPACKE_sggbal(matrix_order, ascii(job) : c_char, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggbal

Original Fortran LAPACK documentation for DGGBAL::

 DGGBAL balances a pair of general real matrices (A,B). This
 involves, first, permuting A and B by similarity transformations to
 isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
 elements on the diagonal; and second, applying a diagonal similarity
 transformation to rows and columns ILO to IHI to make the rows
 and columns as close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrices, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors in the
 generalized eigenvalue problem A*x = lambda*B*x.

 */
extern proc LAPACKE_dggbal(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggbal
 */
inline proc LAPACKE_dggbal(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double) : c_int{
  return LAPACKE_dggbal(matrix_order, ascii(job) : c_char, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggbal

Original Fortran LAPACK documentation for CGGBAL::

 CGGBAL balances a pair of general complex matrices (A,B). This
 involves, first, permuting A and B by similarity transformations to
 isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
 elements on the diagonal; and second, applying a diagonal similarity
 transformation to rows and columns ILO to IHI to make the rows
 and columns as close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrices, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors in the
 generalized eigenvalue problem A*x = lambda*B*x.

 */
extern proc LAPACKE_cggbal(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggbal
 */
inline proc LAPACKE_cggbal(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float) : c_int{
  return LAPACKE_cggbal(matrix_order, ascii(job) : c_char, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggbal

Original Fortran LAPACK documentation for ZGGBAL::

 ZGGBAL balances a pair of general complex matrices (A,B). This
 involves, first, permuting A and B by similarity transformations to
 isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
 elements on the diagonal; and second, applying a diagonal similarity
 transformation to rows and columns ILO to IHI to make the rows
 and columns as close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrices, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors in the
 generalized eigenvalue problem A*x = lambda*B*x.

 */
extern proc LAPACKE_zggbal(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggbal
 */
inline proc LAPACKE_zggbal(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double) : c_int{
  return LAPACKE_zggbal(matrix_order, ascii(job) : c_char, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgges

Original Fortran LAPACK documentation for SGGES::

 SGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
 the generalized eigenvalues, the generalized real Schur form (S,T),
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T.The
 leading columns of VSL and VSR then form an orthonormal basis for the
 corresponding left and right eigenspaces (deflating subspaces).

 (If only the generalized eigenvalues are needed, use the driver
 SGGEV instead, which is faster.)

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

 */
extern proc LAPACKE_sgges(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_S_SELECT3, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ldvsl : c_int, vsr : [] c_float, ldvsr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgges
 */
inline proc LAPACKE_sgges(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_S_SELECT3, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ldvsl : c_int, vsr : [] c_float, ldvsr : c_int) : c_int{
  return LAPACKE_sgges(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgges

Original Fortran LAPACK documentation for DGGES::

 DGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
 the generalized eigenvalues, the generalized real Schur form (S,T),
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T.The
 leading columns of VSL and VSR then form an orthonormal basis for the
 corresponding left and right eigenspaces (deflating subspaces).

 (If only the generalized eigenvalues are needed, use the driver
 DGGEV instead, which is faster.)

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

 */
extern proc LAPACKE_dgges(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_D_SELECT3, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ldvsl : c_int, vsr : [] c_double, ldvsr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgges
 */
inline proc LAPACKE_dgges(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_D_SELECT3, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ldvsl : c_int, vsr : [] c_double, ldvsr : c_int) : c_int{
  return LAPACKE_dgges(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgges

Original Fortran LAPACK documentation for CGGES::

 CGGES computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, the generalized complex Schur
 form (S, T), and optionally left and/or right Schur vectors (VSL
 and VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )

 where (VSR)**H is the conjugate-transpose of VSR.

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 triangular matrix S and the upper triangular matrix T. The leading
 columns of VSL and VSR then form an unitary basis for the
 corresponding left and right eigenspaces (deflating subspaces).

 (If only the generalized eigenvalues are needed, use the driver
 CGGEV instead, which is faster.)

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0, and even for both being zero.

 A pair of matrices (S,T) is in generalized complex Schur form if S
 and T are upper triangular and, in addition, the diagonal elements
 of T are non-negative real numbers.

 */
extern proc LAPACKE_cgges(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_C_SELECT2, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ldvsl : c_int, vsr : [] complex(64), ldvsr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgges
 */
inline proc LAPACKE_cgges(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_C_SELECT2, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ldvsl : c_int, vsr : [] complex(64), ldvsr : c_int) : c_int{
  return LAPACKE_cgges(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgges

Original Fortran LAPACK documentation for ZGGES::

 ZGGES computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, the generalized complex Schur
 form (S, T), and optionally left and/or right Schur vectors (VSL
 and VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )

 where (VSR)**H is the conjugate-transpose of VSR.

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 triangular matrix S and the upper triangular matrix T. The leading
 columns of VSL and VSR then form an unitary basis for the
 corresponding left and right eigenspaces (deflating subspaces).

 (If only the generalized eigenvalues are needed, use the driver
 ZGGEV instead, which is faster.)

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0, and even for both being zero.

 A pair of matrices (S,T) is in generalized complex Schur form if S
 and T are upper triangular and, in addition, the diagonal elements
 of T are non-negative real numbers.

 */
extern proc LAPACKE_zgges(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_Z_SELECT2, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ldvsl : c_int, vsr : [] complex(128), ldvsr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgges
 */
inline proc LAPACKE_zgges(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_Z_SELECT2, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ldvsl : c_int, vsr : [] complex(128), ldvsr : c_int) : c_int{
  return LAPACKE_zgges(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggesx

Original Fortran LAPACK documentation for SGGESX::

 SGGESX computes for a pair of N-by-N real nonsymmetric matrices
 (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T; computes
 a reciprocal condition number for the average of the selected
 eigenvalues (RCONDE); and computes a reciprocal condition number for
 the right and left deflating subspaces corresponding to the selected
 eigenvalues (RCONDV). The leading columns of VSL and VSR then form
 an orthonormal basis for the corresponding left and right eigenspaces
 (deflating subspaces).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or for both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

 */
extern proc LAPACKE_sggesx(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_S_SELECT3, sense : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ldvsl : c_int, vsr : [] c_float, ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggesx
 */
inline proc LAPACKE_sggesx(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_S_SELECT3, sense : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ldvsl : c_int, vsr : [] c_float, ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float) : c_int{
  return LAPACKE_sggesx(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggesx

Original Fortran LAPACK documentation for DGGESX::

 DGGESX computes for a pair of N-by-N real nonsymmetric matrices
 (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T; computes
 a reciprocal condition number for the average of the selected
 eigenvalues (RCONDE); and computes a reciprocal condition number for
 the right and left deflating subspaces corresponding to the selected
 eigenvalues (RCONDV). The leading columns of VSL and VSR then form
 an orthonormal basis for the corresponding left and right eigenspaces
 (deflating subspaces).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or for both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

 */
extern proc LAPACKE_dggesx(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_D_SELECT3, sense : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ldvsl : c_int, vsr : [] c_double, ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggesx
 */
inline proc LAPACKE_dggesx(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_D_SELECT3, sense : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ldvsl : c_int, vsr : [] c_double, ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double) : c_int{
  return LAPACKE_dggesx(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggesx

Original Fortran LAPACK documentation for CGGESX::

 CGGESX computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, the complex Schur form (S,T),
 and, optionally, the left and/or right matrices of Schur vectors (VSL
 and VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )

 where (VSR)**H is the conjugate-transpose of VSR.

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 triangular matrix S and the upper triangular matrix T; computes
 a reciprocal condition number for the average of the selected
 eigenvalues (RCONDE); and computes a reciprocal condition number for
 the right and left deflating subspaces corresponding to the selected
 eigenvalues (RCONDV). The leading columns of VSL and VSR then form
 an orthonormal basis for the corresponding left and right eigenspaces
 (deflating subspaces).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or for both being zero.

 A pair of matrices (S,T) is in generalized complex Schur form if T is
 upper triangular with non-negative diagonal and S is upper
 triangular.

 */
extern proc LAPACKE_cggesx(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_C_SELECT2, sense : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ldvsl : c_int, vsr : [] complex(64), ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggesx
 */
inline proc LAPACKE_cggesx(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_C_SELECT2, sense : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ldvsl : c_int, vsr : [] complex(64), ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float) : c_int{
  return LAPACKE_cggesx(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggesx

Original Fortran LAPACK documentation for ZGGESX::

 ZGGESX computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, the complex Schur form (S,T),
 and, optionally, the left and/or right matrices of Schur vectors (VSL
 and VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )

 where (VSR)**H is the conjugate-transpose of VSR.

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 triangular matrix S and the upper triangular matrix T; computes
 a reciprocal condition number for the average of the selected
 eigenvalues (RCONDE); and computes a reciprocal condition number for
 the right and left deflating subspaces corresponding to the selected
 eigenvalues (RCONDV). The leading columns of VSL and VSR then form
 an orthonormal basis for the corresponding left and right eigenspaces
 (deflating subspaces).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or for both being zero.

 A pair of matrices (S,T) is in generalized complex Schur form if T is
 upper triangular with non-negative diagonal and S is upper
 triangular.

 */
extern proc LAPACKE_zggesx(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_Z_SELECT2, sense : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ldvsl : c_int, vsr : [] complex(128), ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggesx
 */
inline proc LAPACKE_zggesx(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_Z_SELECT2, sense : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ldvsl : c_int, vsr : [] complex(128), ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double) : c_int{
  return LAPACKE_zggesx(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggev

Original Fortran LAPACK documentation for SGGEV::

 SGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j).

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B .

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACKE_sggev(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggev
 */
inline proc LAPACKE_sggev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int) : c_int{
  return LAPACKE_sggev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggev

Original Fortran LAPACK documentation for DGGEV::

 DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j).

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B .

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACKE_dggev(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggev
 */
inline proc LAPACKE_dggev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int) : c_int{
  return LAPACKE_dggev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggev

Original Fortran LAPACK documentation for CGGEV::

 CGGEV computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, and optionally, the left and/or
 right generalized eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right generalized eigenvector v(j) corresponding to the
 generalized eigenvalue lambda(j) of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j).

 The left generalized eigenvector u(j) corresponding to the
 generalized eigenvalues lambda(j) of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACKE_cggev(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggev
 */
inline proc LAPACKE_cggev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int) : c_int{
  return LAPACKE_cggev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggev

Original Fortran LAPACK documentation for ZGGEV::

 ZGGEV computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, and optionally, the left and/or
 right generalized eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right generalized eigenvector v(j) corresponding to the
 generalized eigenvalue lambda(j) of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j).

 The left generalized eigenvector u(j) corresponding to the
 generalized eigenvalues lambda(j) of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACKE_zggev(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggev
 */
inline proc LAPACKE_zggev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int) : c_int{
  return LAPACKE_zggev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggevx

Original Fortran LAPACK documentation for SGGEVX::

 SGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j) .

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B.

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACKE_sggevx(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggevx
 */
inline proc LAPACKE_sggevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float) : c_int{
  return LAPACKE_sggevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggevx

Original Fortran LAPACK documentation for DGGEVX::

 DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j) .

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B.

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACKE_dggevx(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggevx
 */
inline proc LAPACKE_dggevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double) : c_int{
  return LAPACKE_dggevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggevx

Original Fortran LAPACK documentation for CGGEVX::

 CGGEVX computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B) the generalized eigenvalues, and optionally, the left and/or
 right generalized eigenvectors.

 Optionally, it also computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies
 A * v(j) = lambda(j) * B * v(j) .
 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies
 u(j)**H * A = lambda(j) * u(j)**H * B.
 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACKE_cggevx(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggevx
 */
inline proc LAPACKE_cggevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float) : c_int{
  return LAPACKE_cggevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggevx

Original Fortran LAPACK documentation for ZGGEVX::

 ZGGEVX computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B) the generalized eigenvalues, and optionally, the left and/or
 right generalized eigenvectors.

 Optionally, it also computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies
 A * v(j) = lambda(j) * B * v(j) .
 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies
 u(j)**H * A = lambda(j) * u(j)**H * B.
 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACKE_zggevx(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggevx
 */
inline proc LAPACKE_zggevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double) : c_int{
  return LAPACKE_zggevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggglm

Original Fortran LAPACK documentation for SGGGLM::

 SGGGLM solves a general Gauss-Markov linear model (GLM) problem:

 minimize || y ||_2 subject to d = A*x + B*y
 x

 where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
 given N-vector. It is assumed that M <= N <= M+P, and

 rank(A) = M and rank( A B ) = N.

 Under these assumptions, the constrained equation is always
 consistent, and there is a unique solution x and a minimal 2-norm
 solution y, which is obtained using a generalized QR factorization
 of the matrices (A, B) given by

 A = Q*(R), B = Q*T*Z.
 (0)

 In particular, if matrix B is square nonsingular, then the problem
 GLM is equivalent to the following weighted linear least squares
 problem

 minimize || inv(B)*(d-A*x) ||_2
 x

 where inv(B) denotes the inverse of B.

 */
extern proc LAPACKE_sggglm(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, d : [] c_float, x : [] c_float, y : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dggglm

Original Fortran LAPACK documentation for DGGGLM::

 DGGGLM solves a general Gauss-Markov linear model (GLM) problem:

 minimize || y ||_2 subject to d = A*x + B*y
 x

 where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
 given N-vector. It is assumed that M <= N <= M+P, and

 rank(A) = M and rank( A B ) = N.

 Under these assumptions, the constrained equation is always
 consistent, and there is a unique solution x and a minimal 2-norm
 solution y, which is obtained using a generalized QR factorization
 of the matrices (A, B) given by

 A = Q*(R), B = Q*T*Z.
 (0)

 In particular, if matrix B is square nonsingular, then the problem
 GLM is equivalent to the following weighted linear least squares
 problem

 minimize || inv(B)*(d-A*x) ||_2
 x

 where inv(B) denotes the inverse of B.

 */
extern proc LAPACKE_dggglm(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, d : [] c_double, x : [] c_double, y : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cggglm

Original Fortran LAPACK documentation for CGGGLM::

 CGGGLM solves a general Gauss-Markov linear model (GLM) problem:

 minimize || y ||_2 subject to d = A*x + B*y
 x

 where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
 given N-vector. It is assumed that M <= N <= M+P, and

 rank(A) = M and rank( A B ) = N.

 Under these assumptions, the constrained equation is always
 consistent, and there is a unique solution x and a minimal 2-norm
 solution y, which is obtained using a generalized QR factorization
 of the matrices (A, B) given by

 A = Q*(R), B = Q*T*Z.
 (0)

 In particular, if matrix B is square nonsingular, then the problem
 GLM is equivalent to the following weighted linear least squares
 problem

 minimize || inv(B)*(d-A*x) ||_2
 x

 where inv(B) denotes the inverse of B.

 */
extern proc LAPACKE_cggglm(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, d : [] complex(64), x : [] complex(64), y : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zggglm

Original Fortran LAPACK documentation for ZGGGLM::

 ZGGGLM solves a general Gauss-Markov linear model (GLM) problem:

 minimize || y ||_2 subject to d = A*x + B*y
 x

 where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
 given N-vector. It is assumed that M <= N <= M+P, and

 rank(A) = M and rank( A B ) = N.

 Under these assumptions, the constrained equation is always
 consistent, and there is a unique solution x and a minimal 2-norm
 solution y, which is obtained using a generalized QR factorization
 of the matrices (A, B) given by

 A = Q*(R), B = Q*T*Z.
 (0)

 In particular, if matrix B is square nonsingular, then the problem
 GLM is equivalent to the following weighted linear least squares
 problem

 minimize || inv(B)*(d-A*x) ||_2
 x

 where inv(B) denotes the inverse of B.

 */
extern proc LAPACKE_zggglm(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, d : [] complex(128), x : [] complex(128), y : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgghrd

Original Fortran LAPACK documentation for SGGHRD::

 SGGHRD reduces a pair of real matrices (A,B) to generalized upper
 Hessenberg form using orthogonal transformations, where A is a
 general matrix and B is upper triangular. The form of the
 generalized eigenvalue problem is
 A*x = lambda*B*x,
 and B is typically made upper triangular by computing its QR
 factorization and moving the orthogonal matrix Q to the left side
 of the equation.

 This subroutine simultaneously reduces A to a Hessenberg matrix H:
 Q**T*A*Z = H
 and transforms B to another upper triangular matrix T:
 Q**T*B*Z = T
 in order to reduce the problem to its standard form
 H*y = lambda*T*y
 where y = Z**T*x.

 The orthogonal matrices Q and Z are determined as products of Givens
 rotations. They may either be formed explicitly, or they may be
 postmultiplied into input matrices Q1 and Z1, so that

 Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T

 Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T

 If Q1 is the orthogonal matrix from the QR factorization of B in the
 original equation A*x = lambda*B*x, then SGGHRD reduces the original
 problem to generalized Hessenberg form.

 */
extern proc LAPACKE_sgghrd(matrix_order : lapack_memory_order, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgghrd
 */
inline proc LAPACKE_sgghrd(matrix_order : lapack_memory_order, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_sgghrd(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgghrd

Original Fortran LAPACK documentation for DGGHRD::

 DGGHRD reduces a pair of real matrices (A,B) to generalized upper
 Hessenberg form using orthogonal transformations, where A is a
 general matrix and B is upper triangular. The form of the
 generalized eigenvalue problem is
 A*x = lambda*B*x,
 and B is typically made upper triangular by computing its QR
 factorization and moving the orthogonal matrix Q to the left side
 of the equation.

 This subroutine simultaneously reduces A to a Hessenberg matrix H:
 Q**T*A*Z = H
 and transforms B to another upper triangular matrix T:
 Q**T*B*Z = T
 in order to reduce the problem to its standard form
 H*y = lambda*T*y
 where y = Z**T*x.

 The orthogonal matrices Q and Z are determined as products of Givens
 rotations. They may either be formed explicitly, or they may be
 postmultiplied into input matrices Q1 and Z1, so that

 Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T

 Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T

 If Q1 is the orthogonal matrix from the QR factorization of B in the
 original equation A*x = lambda*B*x, then DGGHRD reduces the original
 problem to generalized Hessenberg form.

 */
extern proc LAPACKE_dgghrd(matrix_order : lapack_memory_order, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgghrd
 */
inline proc LAPACKE_dgghrd(matrix_order : lapack_memory_order, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dgghrd(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgghrd

Original Fortran LAPACK documentation for CGGHRD::

 CGGHRD reduces a pair of complex matrices (A,B) to generalized upper
 Hessenberg form using unitary transformations, where A is a
 general matrix and B is upper triangular. The form of the generalized
 eigenvalue problem is
 A*x = lambda*B*x,
 and B is typically made upper triangular by computing its QR
 factorization and moving the unitary matrix Q to the left side
 of the equation.

 This subroutine simultaneously reduces A to a Hessenberg matrix H:
 Q**H*A*Z = H
 and transforms B to another upper triangular matrix T:
 Q**H*B*Z = T
 in order to reduce the problem to its standard form
 H*y = lambda*T*y
 where y = Z**H*x.

 The unitary matrices Q and Z are determined as products of Givens
 rotations. They may either be formed explicitly, or they may be
 postmultiplied into input matrices Q1 and Z1, so that
 Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
 Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
 If Q1 is the unitary matrix from the QR factorization of B in the
 original equation A*x = lambda*B*x, then CGGHRD reduces the original
 problem to generalized Hessenberg form.

 */
extern proc LAPACKE_cgghrd(matrix_order : lapack_memory_order, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgghrd
 */
inline proc LAPACKE_cgghrd(matrix_order : lapack_memory_order, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_cgghrd(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgghrd

Original Fortran LAPACK documentation for ZGGHRD::

 ZGGHRD reduces a pair of complex matrices (A,B) to generalized upper
 Hessenberg form using unitary transformations, where A is a
 general matrix and B is upper triangular. The form of the
 generalized eigenvalue problem is
 A*x = lambda*B*x,
 and B is typically made upper triangular by computing its QR
 factorization and moving the unitary matrix Q to the left side
 of the equation.

 This subroutine simultaneously reduces A to a Hessenberg matrix H:
 Q**H*A*Z = H
 and transforms B to another upper triangular matrix T:
 Q**H*B*Z = T
 in order to reduce the problem to its standard form
 H*y = lambda*T*y
 where y = Z**H*x.

 The unitary matrices Q and Z are determined as products of Givens
 rotations. They may either be formed explicitly, or they may be
 postmultiplied into input matrices Q1 and Z1, so that
 Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
 Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
 If Q1 is the unitary matrix from the QR factorization of B in the
 original equation A*x = lambda*B*x, then ZGGHRD reduces the original
 problem to generalized Hessenberg form.

 */
extern proc LAPACKE_zgghrd(matrix_order : lapack_memory_order, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgghrd
 */
inline proc LAPACKE_zgghrd(matrix_order : lapack_memory_order, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zgghrd(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgglse

Original Fortran LAPACK documentation for SGGLSE::

 SGGLSE solves the linear equality-constrained least squares (LSE)
 problem:

 minimize || c - A*x ||_2 subject to B*x = d

 where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
 M-vector, and d is a given P-vector. It is assumed that
 P <= N <= M+P, and

 rank(B) = P and rank( (A) ) = N.
 ( (B) )

 These conditions ensure that the LSE problem has a unique solution,
 which is obtained using a generalized RQ factorization of the
 matrices (B, A) given by

 B = (0 R)*Q, A = Z*T*Q.

 */
extern proc LAPACKE_sgglse(matrix_order : lapack_memory_order, m : c_int, n : c_int, p : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, d : [] c_float, x : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgglse

Original Fortran LAPACK documentation for DGGLSE::

 DGGLSE solves the linear equality-constrained least squares (LSE)
 problem:

 minimize || c - A*x ||_2 subject to B*x = d

 where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
 M-vector, and d is a given P-vector. It is assumed that
 P <= N <= M+P, and

 rank(B) = P and rank( (A) ) = N.
 ( (B) )

 These conditions ensure that the LSE problem has a unique solution,
 which is obtained using a generalized RQ factorization of the
 matrices (B, A) given by

 B = (0 R)*Q, A = Z*T*Q.

 */
extern proc LAPACKE_dgglse(matrix_order : lapack_memory_order, m : c_int, n : c_int, p : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, d : [] c_double, x : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgglse

Original Fortran LAPACK documentation for CGGLSE::

 CGGLSE solves the linear equality-constrained least squares (LSE)
 problem:

 minimize || c - A*x ||_2 subject to B*x = d

 where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
 M-vector, and d is a given P-vector. It is assumed that
 P <= N <= M+P, and

 rank(B) = P and rank( (A) ) = N.
 ( (B) )

 These conditions ensure that the LSE problem has a unique solution,
 which is obtained using a generalized RQ factorization of the
 matrices (B, A) given by

 B = (0 R)*Q, A = Z*T*Q.

 */
extern proc LAPACKE_cgglse(matrix_order : lapack_memory_order, m : c_int, n : c_int, p : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), d : [] complex(64), x : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgglse

Original Fortran LAPACK documentation for ZGGLSE::

 ZGGLSE solves the linear equality-constrained least squares (LSE)
 problem:

 minimize || c - A*x ||_2 subject to B*x = d

 where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
 M-vector, and d is a given P-vector. It is assumed that
 P <= N <= M+P, and

 rank(B) = P and rank( (A) ) = N.
 ( (B) )

 These conditions ensure that the LSE problem has a unique solution,
 which is obtained using a generalized RQ factorization of the
 matrices (B, A) given by

 B = (0 R)*Q, A = Z*T*Q.

 */
extern proc LAPACKE_zgglse(matrix_order : lapack_memory_order, m : c_int, n : c_int, p : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), d : [] complex(128), x : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sggqrf

Original Fortran LAPACK documentation for SGGQRF::

 SGGQRF computes a generalized QR factorization of an N-by-M matrix A
 and an N-by-P matrix B:

 A = Q*R, B = Q*T*Z,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if N >= M, R = ( R11 ) M , or if N < M, R = ( R11 R12 ) N,
 ( 0 ) N-M N M-N
 M

 where R11 is upper triangular, and

 if N <= P, T = ( 0 T12 ) N, or if N > P, T = ( T11 ) N-P,
 P-N N ( T21 ) P
 P

 where T12 or T21 is upper triangular.

 In particular, if B is square and nonsingular, the GQR factorization
 of A and B implicitly gives the QR factorization of inv(B)*A:

 inv(B)*A = Z**T*(inv(T)*R)

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

 */
extern proc LAPACKE_sggqrf(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] c_float, lda : c_int, taua : [] c_float, b : [] c_float, ldb : c_int, taub : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dggqrf

Original Fortran LAPACK documentation for DGGQRF::

 DGGQRF computes a generalized QR factorization of an N-by-M matrix A
 and an N-by-P matrix B:

 A = Q*R, B = Q*T*Z,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if N >= M, R = ( R11 ) M , or if N < M, R = ( R11 R12 ) N,
 ( 0 ) N-M N M-N
 M

 where R11 is upper triangular, and

 if N <= P, T = ( 0 T12 ) N, or if N > P, T = ( T11 ) N-P,
 P-N N ( T21 ) P
 P

 where T12 or T21 is upper triangular.

 In particular, if B is square and nonsingular, the GQR factorization
 of A and B implicitly gives the QR factorization of inv(B)*A:

 inv(B)*A = Z**T*(inv(T)*R)

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

 */
extern proc LAPACKE_dggqrf(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] c_double, lda : c_int, taua : [] c_double, b : [] c_double, ldb : c_int, taub : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cggqrf

Original Fortran LAPACK documentation for CGGQRF::

 CGGQRF computes a generalized QR factorization of an N-by-M matrix A
 and an N-by-P matrix B:

 A = Q*R, B = Q*T*Z,

 where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
 and R and T assume one of the forms:

 if N >= M, R = ( R11 ) M , or if N < M, R = ( R11 R12 ) N,
 ( 0 ) N-M N M-N
 M

 where R11 is upper triangular, and

 if N <= P, T = ( 0 T12 ) N, or if N > P, T = ( T11 ) N-P,
 P-N N ( T21 ) P
 P

 where T12 or T21 is upper triangular.

 In particular, if B is square and nonsingular, the GQR factorization
 of A and B implicitly gives the QR factorization of inv(B)*A:

 inv(B)*A = Z**H * (inv(T)*R)

 where inv(B) denotes the inverse of the matrix B, and Z' denotes the
 conjugate transpose of matrix Z.

 */
extern proc LAPACKE_cggqrf(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] complex(64), lda : c_int, taua : [] complex(64), b : [] complex(64), ldb : c_int, taub : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zggqrf

Original Fortran LAPACK documentation for ZGGQRF::

 ZGGQRF computes a generalized QR factorization of an N-by-M matrix A
 and an N-by-P matrix B:

 A = Q*R, B = Q*T*Z,

 where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
 and R and T assume one of the forms:

 if N >= M, R = ( R11 ) M , or if N < M, R = ( R11 R12 ) N,
 ( 0 ) N-M N M-N
 M

 where R11 is upper triangular, and

 if N <= P, T = ( 0 T12 ) N, or if N > P, T = ( T11 ) N-P,
 P-N N ( T21 ) P
 P

 where T12 or T21 is upper triangular.

 In particular, if B is square and nonsingular, the GQR factorization
 of A and B implicitly gives the QR factorization of inv(B)*A:

 inv(B)*A = Z**H * (inv(T)*R)

 where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
 conjugate transpose of matrix Z.

 */
extern proc LAPACKE_zggqrf(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] complex(128), lda : c_int, taua : [] complex(128), b : [] complex(128), ldb : c_int, taub : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sggrqf

Original Fortran LAPACK documentation for SGGRQF::

 SGGRQF computes a generalized RQ factorization of an M-by-N matrix A
 and a P-by-N matrix B:

 A = R*Q, B = Z*T*Q,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if M <= N, R = ( 0 R12 ) M, or if M > N, R = ( R11 ) M-N,
 N-M M ( R21 ) N
 N

 where R12 or R21 is upper triangular, and

 if P >= N, T = ( T11 ) N , or if P < N, T = ( T11 T12 ) P,
 ( 0 ) P-N P N-P
 N

 where T11 is upper triangular.

 In particular, if B is square and nonsingular, the GRQ factorization
 of A and B implicitly gives the RQ factorization of A*inv(B):

 A*inv(B) = (R*inv(T))*Z**T

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

 */
extern proc LAPACKE_sggrqf(matrix_order : lapack_memory_order, m : c_int, p : c_int, n : c_int, a : [] c_float, lda : c_int, taua : [] c_float, b : [] c_float, ldb : c_int, taub : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dggrqf

Original Fortran LAPACK documentation for DGGRQF::

 DGGRQF computes a generalized RQ factorization of an M-by-N matrix A
 and a P-by-N matrix B:

 A = R*Q, B = Z*T*Q,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if M <= N, R = ( 0 R12 ) M, or if M > N, R = ( R11 ) M-N,
 N-M M ( R21 ) N
 N

 where R12 or R21 is upper triangular, and

 if P >= N, T = ( T11 ) N , or if P < N, T = ( T11 T12 ) P,
 ( 0 ) P-N P N-P
 N

 where T11 is upper triangular.

 In particular, if B is square and nonsingular, the GRQ factorization
 of A and B implicitly gives the RQ factorization of A*inv(B):

 A*inv(B) = (R*inv(T))*Z**T

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

 */
extern proc LAPACKE_dggrqf(matrix_order : lapack_memory_order, m : c_int, p : c_int, n : c_int, a : [] c_double, lda : c_int, taua : [] c_double, b : [] c_double, ldb : c_int, taub : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cggrqf

Original Fortran LAPACK documentation for CGGRQF::

 CGGRQF computes a generalized RQ factorization of an M-by-N matrix A
 and a P-by-N matrix B:

 A = R*Q, B = Z*T*Q,

 where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
 matrix, and R and T assume one of the forms:

 if M <= N, R = ( 0 R12 ) M, or if M > N, R = ( R11 ) M-N,
 N-M M ( R21 ) N
 N

 where R12 or R21 is upper triangular, and

 if P >= N, T = ( T11 ) N , or if P < N, T = ( T11 T12 ) P,
 ( 0 ) P-N P N-P
 N

 where T11 is upper triangular.

 In particular, if B is square and nonsingular, the GRQ factorization
 of A and B implicitly gives the RQ factorization of A*inv(B):

 A*inv(B) = (R*inv(T))*Z**H

 where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
 conjugate transpose of the matrix Z.

 */
extern proc LAPACKE_cggrqf(matrix_order : lapack_memory_order, m : c_int, p : c_int, n : c_int, a : [] complex(64), lda : c_int, taua : [] complex(64), b : [] complex(64), ldb : c_int, taub : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zggrqf

Original Fortran LAPACK documentation for ZGGRQF::

 ZGGRQF computes a generalized RQ factorization of an M-by-N matrix A
 and a P-by-N matrix B:

 A = R*Q, B = Z*T*Q,

 where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
 matrix, and R and T assume one of the forms:

 if M <= N, R = ( 0 R12 ) M, or if M > N, R = ( R11 ) M-N,
 N-M M ( R21 ) N
 N

 where R12 or R21 is upper triangular, and

 if P >= N, T = ( T11 ) N , or if P < N, T = ( T11 T12 ) P,
 ( 0 ) P-N P N-P
 N

 where T11 is upper triangular.

 In particular, if B is square and nonsingular, the GRQ factorization
 of A and B implicitly gives the RQ factorization of A*inv(B):

 A*inv(B) = (R*inv(T))*Z**H

 where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
 conjugate transpose of the matrix Z.

 */
extern proc LAPACKE_zggrqf(matrix_order : lapack_memory_order, m : c_int, p : c_int, n : c_int, a : [] complex(128), lda : c_int, taua : [] complex(128), b : [] complex(128), ldb : c_int, taub : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sggsvd

Original Fortran LAPACK documentation for SGGSVD::

 SGGSVD computes the generalized singular value decomposition (GSVD)
 of an M-by-N real matrix A and P-by-N real matrix B:

 U**T*A*Q = D1*( 0 R ), V**T*B*Q = D2*( 0 R )

 where U, V and Q are orthogonal matrices.
 Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,
 then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
 D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
 following structures, respectively:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 )
 L ( 0 0 R22 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The routine computes C, S, R, and optionally the orthogonal
 transformation matrices U, V and Q.

 In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
 A and B implicitly gives the SVD of A*inv(B):
 A*inv(B) = U*(D1*inv(D2))*V**T.
 If ( A**T,B**T)**T has orthonormal columns, then the GSVD of A and B is
 also equal to the CS decomposition of A and B. Furthermore, the GSVD
 can be used to derive the solution of the eigenvalue problem:
 A**T*A x = lambda* B**T*B x.
 In some literature, the GSVD of A and B is presented in the form
 U**T*A*X = ( 0 D1 ), V**T*B*X = ( 0 D2 )
 where U and V are orthogonal and X is nonsingular, D1 and D2 are
 ``diagonal''. The former GSVD form can be converted to the latter
 form by taking the nonsingular matrix X as

 X = Q*( I 0 )
 ( 0 inv(R) ).

 */
extern proc LAPACKE_sggsvd(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggsvd
 */
inline proc LAPACKE_sggsvd(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_sggsvd(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggsvd

Original Fortran LAPACK documentation for DGGSVD::

 DGGSVD computes the generalized singular value decomposition (GSVD)
 of an M-by-N real matrix A and P-by-N real matrix B:

 U**T*A*Q = D1*( 0 R ), V**T*B*Q = D2*( 0 R )

 where U, V and Q are orthogonal matrices.
 Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,
 then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
 D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
 following structures, respectively:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 )
 L ( 0 0 R22 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The routine computes C, S, R, and optionally the orthogonal
 transformation matrices U, V and Q.

 In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
 A and B implicitly gives the SVD of A*inv(B):
 A*inv(B) = U*(D1*inv(D2))*V**T.
 If ( A**T,B**T)**T has orthonormal columns, then the GSVD of A and B is
 also equal to the CS decomposition of A and B. Furthermore, the GSVD
 can be used to derive the solution of the eigenvalue problem:
 A**T*A x = lambda* B**T*B x.
 In some literature, the GSVD of A and B is presented in the form
 U**T*A*X = ( 0 D1 ), V**T*B*X = ( 0 D2 )
 where U and V are orthogonal and X is nonsingular, D1 and D2 are
 ``diagonal''. The former GSVD form can be converted to the latter
 form by taking the nonsingular matrix X as

 X = Q*( I 0 )
 ( 0 inv(R) ).

 */
extern proc LAPACKE_dggsvd(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggsvd
 */
inline proc LAPACKE_dggsvd(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_dggsvd(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggsvd

Original Fortran LAPACK documentation for CGGSVD::

 CGGSVD computes the generalized singular value decomposition (GSVD)
 of an M-by-N complex matrix A and P-by-N complex matrix B:

 U**H*A*Q = D1*( 0 R ), V**H*B*Q = D2*( 0 R )

 where U, V and Q are unitary matrices.
 Let K+L = the effective numerical rank of the
 matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
 triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
 matrices and of the following structures, respectively:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 )
 L ( 0 0 R22 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The routine computes C, S, R, and optionally the unitary
 transformation matrices U, V and Q.

 In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
 A and B implicitly gives the SVD of A*inv(B):
 A*inv(B) = U*(D1*inv(D2))*V**H.
 If ( A**H,B**H)**H has orthnormal columns, then the GSVD of A and B is also
 equal to the CS decomposition of A and B. Furthermore, the GSVD can
 be used to derive the solution of the eigenvalue problem:
 A**H*A x = lambda* B**H*B x.
 In some literature, the GSVD of A and B is presented in the form
 U**H*A*X = ( 0 D1 ), V**H*B*X = ( 0 D2 )
 where U and V are orthogonal and X is nonsingular, and D1 and D2 are
 ``diagonal''. The former GSVD form can be converted to the latter
 form by taking the nonsingular matrix X as

 X = Q*( I 0 )
 ( 0 inv(R) )

 */
extern proc LAPACKE_cggsvd(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggsvd
 */
inline proc LAPACKE_cggsvd(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_cggsvd(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggsvd

Original Fortran LAPACK documentation for ZGGSVD::

 ZGGSVD computes the generalized singular value decomposition (GSVD)
 of an M-by-N complex matrix A and P-by-N complex matrix B:

 U**H*A*Q = D1*( 0 R ), V**H*B*Q = D2*( 0 R )

 where U, V and Q are unitary matrices.
 Let K+L = the effective numerical rank of the
 matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
 triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
 matrices and of the following structures, respectively:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 )
 L ( 0 0 R22 )
 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The routine computes C, S, R, and optionally the unitary
 transformation matrices U, V and Q.

 In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
 A and B implicitly gives the SVD of A*inv(B):
 A*inv(B) = U*(D1*inv(D2))*V**H.
 If ( A**H,B**H)**H has orthnormal columns, then the GSVD of A and B is also
 equal to the CS decomposition of A and B. Furthermore, the GSVD can
 be used to derive the solution of the eigenvalue problem:
 A**H*A x = lambda* B**H*B x.
 In some literature, the GSVD of A and B is presented in the form
 U**H*A*X = ( 0 D1 ), V**H*B*X = ( 0 D2 )
 where U and V are orthogonal and X is nonsingular, and D1 and D2 are
 ``diagonal''. The former GSVD form can be converted to the latter
 form by taking the nonsingular matrix X as

 X = Q*( I 0 )
 ( 0 inv(R) )

 */
extern proc LAPACKE_zggsvd(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggsvd
 */
inline proc LAPACKE_zggsvd(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_zggsvd(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggsvp

Original Fortran LAPACK documentation for SGGSVP::

 SGGSVP computes orthogonal matrices U, V and Q such that

 N-K-L K L
 U**T*A*Q = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 V**T*B*Q = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective
 numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T. 

 This decomposition is the preprocessing step for computing the
 Generalized Singular Value Decomposition (GSVD), see subroutine
 SGGSVD.

 */
extern proc LAPACKE_sggsvp(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggsvp
 */
inline proc LAPACKE_sggsvp(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int) : c_int{
  return LAPACKE_sggsvp(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggsvp

Original Fortran LAPACK documentation for DGGSVP::

 DGGSVP computes orthogonal matrices U, V and Q such that

 N-K-L K L
 U**T*A*Q = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 V**T*B*Q = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective
 numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T. 

 This decomposition is the preprocessing step for computing the
 Generalized Singular Value Decomposition (GSVD), see subroutine
 DGGSVD.

 */
extern proc LAPACKE_dggsvp(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggsvp
 */
inline proc LAPACKE_dggsvp(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int) : c_int{
  return LAPACKE_dggsvp(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggsvp

Original Fortran LAPACK documentation for CGGSVP::

 CGGSVP computes unitary matrices U, V and Q such that

 N-K-L K L
 U**H*A*Q = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 V**H*B*Q = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective
 numerical rank of the (M+P)-by-N matrix (A**H,B**H)**H. 

 This decomposition is the preprocessing step for computing the
 Generalized Singular Value Decomposition (GSVD), see subroutine
 CGGSVD.

 */
extern proc LAPACKE_cggsvp(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggsvp
 */
inline proc LAPACKE_cggsvp(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int) : c_int{
  return LAPACKE_cggsvp(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggsvp

Original Fortran LAPACK documentation for ZGGSVP::

 ZGGSVP computes unitary matrices U, V and Q such that

 N-K-L K L
 U**H*A*Q = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 V**H*B*Q = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective
 numerical rank of the (M+P)-by-N matrix (A**H,B**H)**H. 

 This decomposition is the preprocessing step for computing the
 Generalized Singular Value Decomposition (GSVD), see subroutine
 ZGGSVD.

 */
extern proc LAPACKE_zggsvp(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggsvp
 */
inline proc LAPACKE_zggsvp(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int) : c_int{
  return LAPACKE_zggsvp(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgtcon

Original Fortran LAPACK documentation for SGTCON::

 SGTCON estimates the reciprocal of the condition number of a real
 tridiagonal matrix A using the LU factorization as computed by
 SGTTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_sgtcon(norm : c_char, n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgtcon
 */
inline proc LAPACKE_sgtcon(norm : string, n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_sgtcon(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgtcon

Original Fortran LAPACK documentation for DGTCON::

 DGTCON estimates the reciprocal of the condition number of a real
 tridiagonal matrix A using the LU factorization as computed by
 DGTTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_dgtcon(norm : c_char, n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgtcon
 */
inline proc LAPACKE_dgtcon(norm : string, n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_dgtcon(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgtcon

Original Fortran LAPACK documentation for CGTCON::

 CGTCON estimates the reciprocal of the condition number of a complex
 tridiagonal matrix A using the LU factorization as computed by
 CGTTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_cgtcon(norm : c_char, n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgtcon
 */
inline proc LAPACKE_cgtcon(norm : string, n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_cgtcon(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgtcon

Original Fortran LAPACK documentation for ZGTCON::

 ZGTCON estimates the reciprocal of the condition number of a complex
 tridiagonal matrix A using the LU factorization as computed by
 ZGTTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_zgtcon(norm : c_char, n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgtcon
 */
inline proc LAPACKE_zgtcon(norm : string, n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zgtcon(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgtrfs

Original Fortran LAPACK documentation for SGTRFS::

 SGTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is tridiagonal, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_sgtrfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgtrfs
 */
inline proc LAPACKE_sgtrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_sgtrfs(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgtrfs

Original Fortran LAPACK documentation for DGTRFS::

 DGTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is tridiagonal, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_dgtrfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgtrfs
 */
inline proc LAPACKE_dgtrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dgtrfs(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgtrfs

Original Fortran LAPACK documentation for CGTRFS::

 CGTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is tridiagonal, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_cgtrfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgtrfs
 */
inline proc LAPACKE_cgtrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cgtrfs(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgtrfs

Original Fortran LAPACK documentation for ZGTRFS::

 ZGTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is tridiagonal, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_zgtrfs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgtrfs
 */
inline proc LAPACKE_zgtrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zgtrfs(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgtsv

Original Fortran LAPACK documentation for SGTSV::

 SGTSV solves the equation

 A*X = B,

 where A is an n by n tridiagonal matrix, by Gaussian elimination with
 partial pivoting.

 Note that the equation A**T*X = B may be solved by interchanging the
 order of the arguments DU and DL.

 */
extern proc LAPACKE_sgtsv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgtsv

Original Fortran LAPACK documentation for DGTSV::

 DGTSV solves the equation

 A*X = B,

 where A is an n by n tridiagonal matrix, by Gaussian elimination with
 partial pivoting.

 Note that the equation A**T*X = B may be solved by interchanging the
 order of the arguments DU and DL.

 */
extern proc LAPACKE_dgtsv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgtsv

Original Fortran LAPACK documentation for CGTSV::

 CGTSV solves the equation

 A*X = B,

 where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
 partial pivoting.

 Note that the equation A**T *X = B may be solved by interchanging the
 order of the arguments DU and DL.

 */
extern proc LAPACKE_cgtsv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgtsv

Original Fortran LAPACK documentation for ZGTSV::

 ZGTSV solves the equation

 A*X = B,

 where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
 partial pivoting.

 Note that the equation A**T *X = B may be solved by interchanging the
 order of the arguments DU and DL.

 */
extern proc LAPACKE_zgtsv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgtsvx

Original Fortran LAPACK documentation for SGTSVX::

 SGTSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B or A**T * X = B,
 where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_sgtsvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgtsvx
 */
inline proc LAPACKE_sgtsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_sgtsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgtsvx

Original Fortran LAPACK documentation for DGTSVX::

 DGTSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B or A**T * X = B,
 where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_dgtsvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgtsvx
 */
inline proc LAPACKE_dgtsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dgtsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgtsvx

Original Fortran LAPACK documentation for CGTSVX::

 CGTSVX uses the LU factorization to compute the solution to a complex
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_cgtsvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgtsvx
 */
inline proc LAPACKE_cgtsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cgtsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgtsvx

Original Fortran LAPACK documentation for ZGTSVX::

 ZGTSVX uses the LU factorization to compute the solution to a complex
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zgtsvx(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgtsvx
 */
inline proc LAPACKE_zgtsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zgtsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgttrf

Original Fortran LAPACK documentation for SGTTRF::

 SGTTRF computes an LU factorization of a real tridiagonal matrix A
 using elimination with partial pivoting and row interchanges.

 The factorization has the form
 A = L * U
 where L is a product of permutation and unit lower bidiagonal
 matrices and U is upper triangular with nonzeros in only the main
 diagonal and first two superdiagonals.

 */
extern proc LAPACKE_sgttrf(n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgttrf

Original Fortran LAPACK documentation for DGTTRF::

 DGTTRF computes an LU factorization of a real tridiagonal matrix A
 using elimination with partial pivoting and row interchanges.

 The factorization has the form
 A = L * U
 where L is a product of permutation and unit lower bidiagonal
 matrices and U is upper triangular with nonzeros in only the main
 diagonal and first two superdiagonals.

 */
extern proc LAPACKE_dgttrf(n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgttrf

Original Fortran LAPACK documentation for CGTTRF::

 CGTTRF computes an LU factorization of a complex tridiagonal matrix A
 using elimination with partial pivoting and row interchanges.

 The factorization has the form
 A = L * U
 where L is a product of permutation and unit lower bidiagonal
 matrices and U is upper triangular with nonzeros in only the main
 diagonal and first two superdiagonals.

 */
extern proc LAPACKE_cgttrf(n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgttrf

Original Fortran LAPACK documentation for ZGTTRF::

 ZGTTRF computes an LU factorization of a complex tridiagonal matrix A
 using elimination with partial pivoting and row interchanges.

 The factorization has the form
 A = L * U
 where L is a product of permutation and unit lower bidiagonal
 matrices and U is upper triangular with nonzeros in only the main
 diagonal and first two superdiagonals.

 */
extern proc LAPACKE_zgttrf(n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgttrs

Original Fortran LAPACK documentation for SGTTRS::

 SGTTRS solves one of the systems of equations
 A*X = B or A**T*X = B,
 with a tridiagonal matrix A using the LU factorization computed
 by SGTTRF.

 */
extern proc LAPACKE_sgttrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgttrs
 */
inline proc LAPACKE_sgttrs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sgttrs(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgttrs

Original Fortran LAPACK documentation for DGTTRS::

 DGTTRS solves one of the systems of equations
 A*X = B or A**T*X = B,
 with a tridiagonal matrix A using the LU factorization computed
 by DGTTRF.

 */
extern proc LAPACKE_dgttrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgttrs
 */
inline proc LAPACKE_dgttrs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dgttrs(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgttrs

Original Fortran LAPACK documentation for CGTTRS::

 CGTTRS solves one of the systems of equations
 A * X = B, A**T * X = B, or A**H * X = B,
 with a tridiagonal matrix A using the LU factorization computed
 by CGTTRF.

 */
extern proc LAPACKE_cgttrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgttrs
 */
inline proc LAPACKE_cgttrs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cgttrs(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgttrs

Original Fortran LAPACK documentation for ZGTTRS::

 ZGTTRS solves one of the systems of equations
 A * X = B, A**T * X = B, or A**H * X = B,
 with a tridiagonal matrix A using the LU factorization computed
 by ZGTTRF.

 */
extern proc LAPACKE_zgttrs(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgttrs
 */
inline proc LAPACKE_zgttrs(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zgttrs(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbev

Original Fortran LAPACK documentation for CHBEV::

 CHBEV computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A.

 */
extern proc LAPACKE_chbev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, w : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbev
 */
inline proc LAPACKE_chbev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, w : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chbev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbev

Original Fortran LAPACK documentation for ZHBEV::

 ZHBEV computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A.

 */
extern proc LAPACKE_zhbev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, w : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbev
 */
inline proc LAPACKE_zhbev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, w : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhbev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbevd

Original Fortran LAPACK documentation for CHBEVD::

 CHBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_chbevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, w : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbevd
 */
inline proc LAPACKE_chbevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, w : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chbevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbevd

Original Fortran LAPACK documentation for ZHBEVD::

 ZHBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_zhbevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, w : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbevd
 */
inline proc LAPACKE_zhbevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, w : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhbevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbevx

Original Fortran LAPACK documentation for CHBEVX::

 CHBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian band matrix A. Eigenvalues and eigenvectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACKE_chbevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, q : [] complex(64), ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbevx
 */
inline proc LAPACKE_chbevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, q : [] complex(64), ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chbevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbevx

Original Fortran LAPACK documentation for ZHBEVX::

 ZHBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian band matrix A. Eigenvalues and eigenvectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACKE_zhbevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, q : [] complex(128), ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbevx
 */
inline proc LAPACKE_zhbevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, q : [] complex(128), ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhbevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbgst

Original Fortran LAPACK documentation for CHBGST::

 CHBGST reduces a complex Hermitian-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**H*S by CPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**H*A*X, where
 X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
 bandwidth of A.

 */
extern proc LAPACKE_chbgst(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, x : [] complex(64), ldx : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbgst
 */
inline proc LAPACKE_chbgst(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, x : [] complex(64), ldx : c_int) : c_int{
  return LAPACKE_chbgst(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbgst

Original Fortran LAPACK documentation for ZHBGST::

 ZHBGST reduces a complex Hermitian-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**H*S by ZPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**H*A*X, where
 X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
 bandwidth of A.

 */
extern proc LAPACKE_zhbgst(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, x : [] complex(128), ldx : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbgst
 */
inline proc LAPACKE_zhbgst(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, x : [] complex(128), ldx : c_int) : c_int{
  return LAPACKE_zhbgst(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbgv

Original Fortran LAPACK documentation for CHBGV::

 CHBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite.

 */
extern proc LAPACKE_chbgv(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, w : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbgv
 */
inline proc LAPACKE_chbgv(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, w : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chbgv(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbgv

Original Fortran LAPACK documentation for ZHBGV::

 ZHBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite.

 */
extern proc LAPACKE_zhbgv(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, w : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbgv
 */
inline proc LAPACKE_zhbgv(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, w : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhbgv(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbgvd

Original Fortran LAPACK documentation for CHBGVD::

 CHBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_chbgvd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, w : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbgvd
 */
inline proc LAPACKE_chbgvd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, w : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chbgvd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbgvd

Original Fortran LAPACK documentation for ZHBGVD::

 ZHBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_zhbgvd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, w : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbgvd
 */
inline proc LAPACKE_zhbgvd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, w : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhbgvd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbgvx

Original Fortran LAPACK documentation for CHBGVX::

 CHBGVX computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_chbgvx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, q : [] complex(64), ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbgvx
 */
inline proc LAPACKE_chbgvx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, q : [] complex(64), ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chbgvx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbgvx

Original Fortran LAPACK documentation for ZHBGVX::

 ZHBGVX computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_zhbgvx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, q : [] complex(128), ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbgvx
 */
inline proc LAPACKE_zhbgvx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, q : [] complex(128), ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhbgvx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbtrd

Original Fortran LAPACK documentation for CHBTRD::

 CHBTRD reduces a complex Hermitian band matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

 */
extern proc LAPACKE_chbtrd(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbtrd
 */
inline proc LAPACKE_chbtrd(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ldq : c_int) : c_int{
  return LAPACKE_chbtrd(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, d, e, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbtrd

Original Fortran LAPACK documentation for ZHBTRD::

 ZHBTRD reduces a complex Hermitian band matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

 */
extern proc LAPACKE_zhbtrd(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbtrd
 */
inline proc LAPACKE_zhbtrd(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ldq : c_int) : c_int{
  return LAPACKE_zhbtrd(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, d, e, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_checon

Original Fortran LAPACK documentation for CHECON::

 CHECON estimates the reciprocal of the condition number of a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_checon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_checon
 */
inline proc LAPACKE_checon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_checon(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhecon

Original Fortran LAPACK documentation for ZHECON::

 ZHECON estimates the reciprocal of the condition number of a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_zhecon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhecon
 */
inline proc LAPACKE_zhecon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zhecon(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheequb

Original Fortran LAPACK documentation for CHEEQUB::

 CHEEQUB computes row and column scalings intended to equilibrate a
 Hermitian matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_cheequb(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheequb
 */
inline proc LAPACKE_cheequb(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_cheequb(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheequb

Original Fortran LAPACK documentation for ZHEEQUB::

 ZHEEQUB computes row and column scalings intended to equilibrate a
 Hermitian matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_zheequb(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheequb
 */
inline proc LAPACKE_zheequb(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_zheequb(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheev

Original Fortran LAPACK documentation for CHEEV::

 CHEEV computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A.

 */
extern proc LAPACKE_cheev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, w : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheev
 */
inline proc LAPACKE_cheev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, w : [] c_float) : c_int{
  return LAPACKE_cheev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheev

Original Fortran LAPACK documentation for ZHEEV::

 ZHEEV computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A.

 */
extern proc LAPACKE_zheev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, w : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheev
 */
inline proc LAPACKE_zheev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, w : [] c_double) : c_int{
  return LAPACKE_zheev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheevd

Original Fortran LAPACK documentation for CHEEVD::

 CHEEVD computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_cheevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, w : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheevd
 */
inline proc LAPACKE_cheevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, w : [] c_float) : c_int{
  return LAPACKE_cheevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheevd

Original Fortran LAPACK documentation for ZHEEVD::

 ZHEEVD computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_zheevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, w : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheevd
 */
inline proc LAPACKE_zheevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, w : [] c_double) : c_int{
  return LAPACKE_zheevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheevr

Original Fortran LAPACK documentation for CHEEVR::

 CHEEVR computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 CHEEVR first reduces the matrix A to tridiagonal form T with a call
 to CHETRD. Then, whenever possible, CHEEVR calls CSTEMR to compute
 the eigenspectrum using Relatively Robust Representations. CSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see DSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : CHEEVR calls CSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 CHEEVR calls SSTEBZ and CSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of CSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACKE_cheevr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheevr
 */
inline proc LAPACKE_cheevr(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_cheevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheevr

Original Fortran LAPACK documentation for ZHEEVR::

 ZHEEVR computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 ZHEEVR first reduces the matrix A to tridiagonal form T with a call
 to ZHETRD. Then, whenever possible, ZHEEVR calls ZSTEMR to compute
 eigenspectrum using Relatively Robust Representations. ZSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see DSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : ZHEEVR calls ZSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 ZHEEVR calls DSTEBZ and ZSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of ZSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACKE_zheevr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheevr
 */
inline proc LAPACKE_zheevr(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_zheevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheevx

Original Fortran LAPACK documentation for CHEEVX::

 CHEEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACKE_cheevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheevx
 */
inline proc LAPACKE_cheevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_cheevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheevx

Original Fortran LAPACK documentation for ZHEEVX::

 ZHEEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACKE_zheevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheevx
 */
inline proc LAPACKE_zheevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zheevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chegst

Original Fortran LAPACK documentation for CHEGST::

 CHEGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by CPOTRF.

 */
extern proc LAPACKE_chegst(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chegst
 */
inline proc LAPACKE_chegst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chegst(matrix_order, itype, ascii(uplo) : c_char, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhegst

Original Fortran LAPACK documentation for ZHEGST::

 ZHEGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by ZPOTRF.

 */
extern proc LAPACKE_zhegst(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhegst
 */
inline proc LAPACKE_zhegst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhegst(matrix_order, itype, ascii(uplo) : c_char, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chegv

Original Fortran LAPACK documentation for CHEGV::

 CHEGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian and B is also
 positive definite.

 */
extern proc LAPACKE_chegv(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, w : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chegv
 */
inline proc LAPACKE_chegv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, w : [] c_float) : c_int{
  return LAPACKE_chegv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhegv

Original Fortran LAPACK documentation for ZHEGV::

 ZHEGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian and B is also
 positive definite.

 */
extern proc LAPACKE_zhegv(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, w : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhegv
 */
inline proc LAPACKE_zhegv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, w : [] c_double) : c_int{
  return LAPACKE_zhegv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chegvd

Original Fortran LAPACK documentation for CHEGVD::

 CHEGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_chegvd(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, w : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chegvd
 */
inline proc LAPACKE_chegvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, w : [] c_float) : c_int{
  return LAPACKE_chegvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhegvd

Original Fortran LAPACK documentation for ZHEGVD::

 ZHEGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_zhegvd(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, w : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhegvd
 */
inline proc LAPACKE_zhegvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, w : [] c_double) : c_int{
  return LAPACKE_zhegvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chegvx

Original Fortran LAPACK documentation for CHEGVX::

 CHEGVX computes selected eigenvalues, and optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_chegvx(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chegvx
 */
inline proc LAPACKE_chegvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chegvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhegvx

Original Fortran LAPACK documentation for ZHEGVX::

 ZHEGVX computes selected eigenvalues, and optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_zhegvx(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhegvx
 */
inline proc LAPACKE_zhegvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhegvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cherfs

Original Fortran LAPACK documentation for CHERFS::

 CHERFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_cherfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cherfs
 */
inline proc LAPACKE_cherfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cherfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zherfs

Original Fortran LAPACK documentation for ZHERFS::

 ZHERFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_zherfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zherfs
 */
inline proc LAPACKE_zherfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zherfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cherfsx

Original Fortran LAPACK documentation for CHERFSX::

 CHERFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_cherfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cherfsx
 */
inline proc LAPACKE_cherfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_cherfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zherfsx

Original Fortran LAPACK documentation for ZHERFSX::

 ZHERFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_zherfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zherfsx
 */
inline proc LAPACKE_zherfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zherfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chesv

Original Fortran LAPACK documentation for CHESV::

 CHESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_chesv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chesv
 */
inline proc LAPACKE_chesv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chesv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhesv

Original Fortran LAPACK documentation for ZHESV::

 ZHESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_zhesv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhesv
 */
inline proc LAPACKE_zhesv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhesv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chesvx

Original Fortran LAPACK documentation for CHESVX::

 CHESVX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_chesvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chesvx
 */
inline proc LAPACKE_chesvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_chesvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhesvx

Original Fortran LAPACK documentation for ZHESVX::

 ZHESVX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zhesvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhesvx
 */
inline proc LAPACKE_zhesvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zhesvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chesvxx

Original Fortran LAPACK documentation for CHESVXX::

 CHESVXX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B, where
 A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CHESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CHESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CHESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CHESVXX would itself produce.

 */
extern proc LAPACKE_chesvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chesvxx
 */
inline proc LAPACKE_chesvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_chesvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhesvxx

Original Fortran LAPACK documentation for ZHESVXX::

 ZHESVXX uses the diagonal pivoting factorization to compute the
 solution to a complex*16 system of linear equations A * X = B, where
 A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZHESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZHESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZHESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZHESVXX would itself produce.

 */
extern proc LAPACKE_zhesvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhesvxx
 */
inline proc LAPACKE_zhesvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zhesvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetrd

Original Fortran LAPACK documentation for CHETRD::

 CHETRD reduces a complex Hermitian matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

 */
extern proc LAPACKE_chetrd(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, d : [] c_float, e : [] c_float, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetrd
 */
inline proc LAPACKE_chetrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, d : [] c_float, e : [] c_float, tau : [] complex(64)) : c_int{
  return LAPACKE_chetrd(matrix_order, ascii(uplo) : c_char, n, a, lda, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetrd

Original Fortran LAPACK documentation for ZHETRD::

 ZHETRD reduces a complex Hermitian matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

 */
extern proc LAPACKE_zhetrd(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, d : [] c_double, e : [] c_double, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetrd
 */
inline proc LAPACKE_zhetrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, d : [] c_double, e : [] c_double, tau : [] complex(128)) : c_int{
  return LAPACKE_zhetrd(matrix_order, ascii(uplo) : c_char, n, a, lda, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetrf

Original Fortran LAPACK documentation for CHETRF::

 CHETRF computes the factorization of a complex Hermitian matrix A
 using the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with 
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_chetrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetrf
 */
inline proc LAPACKE_chetrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_chetrf(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetrf

Original Fortran LAPACK documentation for ZHETRF::

 ZHETRF computes the factorization of a complex Hermitian matrix A
 using the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_zhetrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetrf
 */
inline proc LAPACKE_zhetrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_zhetrf(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetri

Original Fortran LAPACK documentation for CHETRI::

 CHETRI computes the inverse of a complex Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 CHETRF.

 */
extern proc LAPACKE_chetri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetri
 */
inline proc LAPACKE_chetri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_chetri(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetri

Original Fortran LAPACK documentation for ZHETRI::

 ZHETRI computes the inverse of a complex Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 ZHETRF.

 */
extern proc LAPACKE_zhetri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetri
 */
inline proc LAPACKE_zhetri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_zhetri(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetrs

Original Fortran LAPACK documentation for CHETRS::

 CHETRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHETRF.

 */
extern proc LAPACKE_chetrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetrs
 */
inline proc LAPACKE_chetrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chetrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetrs

Original Fortran LAPACK documentation for ZHETRS::

 ZHETRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHETRF.

 */
extern proc LAPACKE_zhetrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetrs
 */
inline proc LAPACKE_zhetrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhetrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chfrk

Original Fortran LAPACK documentation for CHFRK::

 Level 3 BLAS like routine for C in RFP Format.

 CHFRK performs one of the Hermitian rank--k operations

 C := alpha*A*A**H + beta*C,

 or

 C := alpha*A**H*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n Hermitian
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

 */
extern proc LAPACKE_chfrk(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, trans : c_char, n : c_int, k : c_int, alpha : c_float, a : [] complex(64), lda : c_int, beta : c_float, c : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chfrk
 */
inline proc LAPACKE_chfrk(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, n : c_int, k : c_int, alpha : c_float, a : [] complex(64), lda : c_int, beta : c_float, c : [] complex(64)) : c_int{
  return LAPACKE_chfrk(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, n, k, alpha, a, lda, beta, c);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhfrk

Original Fortran LAPACK documentation for ZHFRK::

 Level 3 BLAS like routine for C in RFP Format.

 ZHFRK performs one of the Hermitian rank--k operations

 C := alpha*A*A**H + beta*C,

 or

 C := alpha*A**H*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n Hermitian
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

 */
extern proc LAPACKE_zhfrk(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, trans : c_char, n : c_int, k : c_int, alpha : c_double, a : [] complex(128), lda : c_int, beta : c_double, c : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhfrk
 */
inline proc LAPACKE_zhfrk(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, n : c_int, k : c_int, alpha : c_double, a : [] complex(128), lda : c_int, beta : c_double, c : [] complex(128)) : c_int{
  return LAPACKE_zhfrk(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, n, k, alpha, a, lda, beta, c);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_shgeqz

Original Fortran LAPACK documentation for SHGEQZ::

 SHGEQZ computes the eigenvalues of a real matrix pair (H,T),
 where H is an upper Hessenberg matrix and T is upper triangular,
 using the double-shift QZ method.
 Matrix pairs of this type are produced by the reduction to
 generalized upper Hessenberg form of a real matrix pair (A,B):

 A = Q1*H*Z1**T, B = Q1*T*Z1**T,

 as computed by SGGHRD.

 If JOB='S', then the Hessenberg-triangular pair (H,T) is
 also reduced to generalized Schur form,
 
 H = Q*S*Z**T, T = Q*P*Z**T,
 
 where Q and Z are orthogonal matrices, P is an upper triangular
 matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
 diagonal blocks.

 The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
 (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
 eigenvalues.

 Additionally, the 2-by-2 upper triangular diagonal blocks of P
 corresponding to 2-by-2 blocks of S are reduced to positive diagonal
 form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
 P(j,j) > 0, and P(j+1,j+1) > 0.

 Optionally, the orthogonal matrix Q from the generalized Schur
 factorization may be postmultiplied into an input matrix Q1, and the
 orthogonal matrix Z may be postmultiplied into an input matrix Z1.
 If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced
 the matrix pair (A,B) to generalized upper Hessenberg form, then the
 output matrices Q1*Q and Z1*Z are the orthogonal factors from the
 generalized Schur factorization of (A,B):

 A = (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T.
 
 To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
 of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
 complex and beta real.
 If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
 generalized nonsymmetric eigenvalue problem (GNEP)
 A*x = lambda*B*x
 and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
 alternate form of the GNEP
 mu*A*y = B*y.
 Real eigenvalues can be read directly from the generalized Schur
 form: 
 alpha = S(i,i), beta = P(i,i).

 Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
 Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241--256.

 */
extern proc LAPACKE_shgeqz(matrix_order : lapack_memory_order, job : c_char, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] c_float, ldh : c_int, t : [] c_float, ldt : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_shgeqz
 */
inline proc LAPACKE_shgeqz(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] c_float, ldh : c_int, t : [] c_float, ldt : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_shgeqz(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dhgeqz

Original Fortran LAPACK documentation for DHGEQZ::

 DHGEQZ computes the eigenvalues of a real matrix pair (H,T),
 where H is an upper Hessenberg matrix and T is upper triangular,
 using the double-shift QZ method.
 Matrix pairs of this type are produced by the reduction to
 generalized upper Hessenberg form of a real matrix pair (A,B):

 A = Q1*H*Z1**T, B = Q1*T*Z1**T,

 as computed by DGGHRD.

 If JOB='S', then the Hessenberg-triangular pair (H,T) is
 also reduced to generalized Schur form,
 
 H = Q*S*Z**T, T = Q*P*Z**T,
 
 where Q and Z are orthogonal matrices, P is an upper triangular
 matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
 diagonal blocks.

 The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
 (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
 eigenvalues.

 Additionally, the 2-by-2 upper triangular diagonal blocks of P
 corresponding to 2-by-2 blocks of S are reduced to positive diagonal
 form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
 P(j,j) > 0, and P(j+1,j+1) > 0.

 Optionally, the orthogonal matrix Q from the generalized Schur
 factorization may be postmultiplied into an input matrix Q1, and the
 orthogonal matrix Z may be postmultiplied into an input matrix Z1.
 If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
 the matrix pair (A,B) to generalized upper Hessenberg form, then the
 output matrices Q1*Q and Z1*Z are the orthogonal factors from the
 generalized Schur factorization of (A,B):

 A = (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T.
 
 To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
 of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
 complex and beta real.
 If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
 generalized nonsymmetric eigenvalue problem (GNEP)
 A*x = lambda*B*x
 and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
 alternate form of the GNEP
 mu*A*y = B*y.
 Real eigenvalues can be read directly from the generalized Schur
 form: 
 alpha = S(i,i), beta = P(i,i).

 Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
 Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241--256.

 */
extern proc LAPACKE_dhgeqz(matrix_order : lapack_memory_order, job : c_char, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] c_double, ldh : c_int, t : [] c_double, ldt : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dhgeqz
 */
inline proc LAPACKE_dhgeqz(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] c_double, ldh : c_int, t : [] c_double, ldt : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dhgeqz(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chgeqz

Original Fortran LAPACK documentation for CHGEQZ::

 CHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
 where H is an upper Hessenberg matrix and T is upper triangular,
 using the single-shift QZ method.
 Matrix pairs of this type are produced by the reduction to
 generalized upper Hessenberg form of a complex matrix pair (A,B):
 
 A = Q1*H*Z1**H, B = Q1*T*Z1**H,
 
 as computed by CGGHRD.
 
 If JOB='S', then the Hessenberg-triangular pair (H,T) is
 also reduced to generalized Schur form,
 
 H = Q*S*Z**H, T = Q*P*Z**H,
 
 where Q and Z are unitary matrices and S and P are upper triangular.
 
 Optionally, the unitary matrix Q from the generalized Schur
 factorization may be postmultiplied into an input matrix Q1, and the
 unitary matrix Z may be postmultiplied into an input matrix Z1.
 If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
 the matrix pair (A,B) to generalized Hessenberg form, then the output
 matrices Q1*Q and Z1*Z are the unitary factors from the generalized
 Schur factorization of (A,B):
 
 A = (Q1*Q)*S*(Z1*Z)**H, B = (Q1*Q)*P*(Z1*Z)**H.
 
 To avoid overflow, eigenvalues of the matrix pair (H,T)
 (equivalently, of (A,B)) are computed as a pair of complex values
 (alpha,beta). If beta is nonzero, lambda = alpha / beta is an
 eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
 A*x = lambda*B*x
 and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
 alternate form of the GNEP
 mu*A*y = B*y.
 The values of alpha and beta for the i-th eigenvalue can be read
 directly from the generalized Schur form: alpha = S(i,i),
 beta = P(i,i).

 Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
 Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241--256.

 */
extern proc LAPACKE_chgeqz(matrix_order : lapack_memory_order, job : c_char, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(64), ldh : c_int, t : [] complex(64), ldt : c_int, alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chgeqz
 */
inline proc LAPACKE_chgeqz(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(64), ldh : c_int, t : [] complex(64), ldt : c_int, alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chgeqz(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhgeqz

Original Fortran LAPACK documentation for ZHGEQZ::

 ZHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
 where H is an upper Hessenberg matrix and T is upper triangular,
 using the single-shift QZ method.
 Matrix pairs of this type are produced by the reduction to
 generalized upper Hessenberg form of a complex matrix pair (A,B):
 
 A = Q1*H*Z1**H, B = Q1*T*Z1**H,
 
 as computed by ZGGHRD.
 
 If JOB='S', then the Hessenberg-triangular pair (H,T) is
 also reduced to generalized Schur form,
 
 H = Q*S*Z**H, T = Q*P*Z**H,
 
 where Q and Z are unitary matrices and S and P are upper triangular.
 
 Optionally, the unitary matrix Q from the generalized Schur
 factorization may be postmultiplied into an input matrix Q1, and the
 unitary matrix Z may be postmultiplied into an input matrix Z1.
 If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced
 the matrix pair (A,B) to generalized Hessenberg form, then the output
 matrices Q1*Q and Z1*Z are the unitary factors from the generalized
 Schur factorization of (A,B):
 
 A = (Q1*Q)*S*(Z1*Z)**H, B = (Q1*Q)*P*(Z1*Z)**H.
 
 To avoid overflow, eigenvalues of the matrix pair (H,T)
 (equivalently, of (A,B)) are computed as a pair of complex values
 (alpha,beta). If beta is nonzero, lambda = alpha / beta is an
 eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
 A*x = lambda*B*x
 and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
 alternate form of the GNEP
 mu*A*y = B*y.
 The values of alpha and beta for the i-th eigenvalue can be read
 directly from the generalized Schur form: alpha = S(i,i),
 beta = P(i,i).

 Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
 Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241--256.

 */
extern proc LAPACKE_zhgeqz(matrix_order : lapack_memory_order, job : c_char, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(128), ldh : c_int, t : [] complex(128), ldt : c_int, alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhgeqz
 */
inline proc LAPACKE_zhgeqz(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(128), ldh : c_int, t : [] complex(128), ldt : c_int, alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhgeqz(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpcon

Original Fortran LAPACK documentation for CHPCON::

 CHPCON estimates the reciprocal of the condition number of a complex
 Hermitian packed matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_chpcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpcon
 */
inline proc LAPACKE_chpcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_chpcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpcon

Original Fortran LAPACK documentation for ZHPCON::

 ZHPCON estimates the reciprocal of the condition number of a complex
 Hermitian packed matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_zhpcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpcon
 */
inline proc LAPACKE_zhpcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zhpcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpev

Original Fortran LAPACK documentation for CHPEV::

 CHPEV computes all the eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix in packed storage.

 */
extern proc LAPACKE_chpev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpev
 */
inline proc LAPACKE_chpev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chpev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpev

Original Fortran LAPACK documentation for ZHPEV::

 ZHPEV computes all the eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix in packed storage.

 */
extern proc LAPACKE_zhpev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpev
 */
inline proc LAPACKE_zhpev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhpev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpevd

Original Fortran LAPACK documentation for CHPEVD::

 CHPEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_chpevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpevd
 */
inline proc LAPACKE_chpevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chpevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpevd

Original Fortran LAPACK documentation for ZHPEVD::

 ZHPEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_zhpevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpevd
 */
inline proc LAPACKE_zhpevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhpevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpevx

Original Fortran LAPACK documentation for CHPEVX::

 CHPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A in packed storage.
 Eigenvalues/vectors can be selected by specifying either a range of
 values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_chpevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpevx
 */
inline proc LAPACKE_chpevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chpevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpevx

Original Fortran LAPACK documentation for ZHPEVX::

 ZHPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A in packed storage.
 Eigenvalues/vectors can be selected by specifying either a range of
 values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_zhpevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpevx
 */
inline proc LAPACKE_zhpevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhpevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpgst

Original Fortran LAPACK documentation for CHPGST::

 CHPGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by CPPTRF.

 */
extern proc LAPACKE_chpgst(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, ap : [] complex(64), bp : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpgst
 */
inline proc LAPACKE_chpgst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64)) : c_int{
  return LAPACKE_chpgst(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpgst

Original Fortran LAPACK documentation for ZHPGST::

 ZHPGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by ZPPTRF.

 */
extern proc LAPACKE_zhpgst(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, ap : [] complex(128), bp : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpgst
 */
inline proc LAPACKE_zhpgst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128)) : c_int{
  return LAPACKE_zhpgst(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpgv

Original Fortran LAPACK documentation for CHPGV::

 CHPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian, stored in packed format,
 and B is also positive definite.

 */
extern proc LAPACKE_chpgv(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpgv
 */
inline proc LAPACKE_chpgv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chpgv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpgv

Original Fortran LAPACK documentation for ZHPGV::

 ZHPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian, stored in packed format,
 and B is also positive definite.

 */
extern proc LAPACKE_zhpgv(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpgv
 */
inline proc LAPACKE_zhpgv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhpgv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpgvd

Original Fortran LAPACK documentation for CHPGVD::

 CHPGVD computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_chpgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpgvd
 */
inline proc LAPACKE_chpgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chpgvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpgvd

Original Fortran LAPACK documentation for ZHPGVD::

 ZHPGVD computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_zhpgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpgvd
 */
inline proc LAPACKE_zhpgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhpgvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpgvx

Original Fortran LAPACK documentation for CHPGVX::

 CHPGVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite. Eigenvalues and eigenvectors can be selected by
 specifying either a range of values or a range of indices for the
 desired eigenvalues.

 */
extern proc LAPACKE_chpgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] complex(64), bp : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpgvx
 */
inline proc LAPACKE_chpgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chpgvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpgvx

Original Fortran LAPACK documentation for ZHPGVX::

 ZHPGVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite. Eigenvalues and eigenvectors can be selected by
 specifying either a range of values or a range of indices for the
 desired eigenvalues.

 */
extern proc LAPACKE_zhpgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] complex(128), bp : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpgvx
 */
inline proc LAPACKE_zhpgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhpgvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chprfs

Original Fortran LAPACK documentation for CHPRFS::

 CHPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_chprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chprfs
 */
inline proc LAPACKE_chprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_chprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhprfs

Original Fortran LAPACK documentation for ZHPRFS::

 ZHPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_zhprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhprfs
 */
inline proc LAPACKE_zhprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zhprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpsv

Original Fortran LAPACK documentation for CHPSV::

 CHPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is Hermitian and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACKE_chpsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpsv
 */
inline proc LAPACKE_chpsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chpsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpsv

Original Fortran LAPACK documentation for ZHPSV::

 ZHPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is Hermitian and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACKE_zhpsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpsv
 */
inline proc LAPACKE_zhpsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhpsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpsvx

Original Fortran LAPACK documentation for CHPSVX::

 CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
 A = L*D*L**H to compute the solution to a complex system of linear
 equations A * X = B, where A is an N-by-N Hermitian matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_chpsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpsvx
 */
inline proc LAPACKE_chpsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_chpsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpsvx

Original Fortran LAPACK documentation for ZHPSVX::

 ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
 A = L*D*L**H to compute the solution to a complex system of linear
 equations A * X = B, where A is an N-by-N Hermitian matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zhpsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpsvx
 */
inline proc LAPACKE_zhpsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zhpsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chptrd

Original Fortran LAPACK documentation for CHPTRD::

 CHPTRD reduces a complex Hermitian matrix A stored in packed form to
 real symmetric tridiagonal form T by a unitary similarity
 transformation: Q**H * A * Q = T.

 */
extern proc LAPACKE_chptrd(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), d : [] c_float, e : [] c_float, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chptrd
 */
inline proc LAPACKE_chptrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), d : [] c_float, e : [] c_float, tau : [] complex(64)) : c_int{
  return LAPACKE_chptrd(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhptrd

Original Fortran LAPACK documentation for ZHPTRD::

 ZHPTRD reduces a complex Hermitian matrix A stored in packed form to
 real symmetric tridiagonal form T by a unitary similarity
 transformation: Q**H * A * Q = T.

 */
extern proc LAPACKE_zhptrd(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), d : [] c_double, e : [] c_double, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhptrd
 */
inline proc LAPACKE_zhptrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), d : [] c_double, e : [] c_double, tau : [] complex(128)) : c_int{
  return LAPACKE_zhptrd(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chptrf

Original Fortran LAPACK documentation for CHPTRF::

 CHPTRF computes the factorization of a complex Hermitian packed
 matrix A using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACKE_chptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chptrf
 */
inline proc LAPACKE_chptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int{
  return LAPACKE_chptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhptrf

Original Fortran LAPACK documentation for ZHPTRF::

 ZHPTRF computes the factorization of a complex Hermitian packed
 matrix A using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACKE_zhptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhptrf
 */
inline proc LAPACKE_zhptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int{
  return LAPACKE_zhptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chptri

Original Fortran LAPACK documentation for CHPTRI::

 CHPTRI computes the inverse of a complex Hermitian indefinite matrix
 A in packed storage using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHPTRF.

 */
extern proc LAPACKE_chptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chptri
 */
inline proc LAPACKE_chptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int{
  return LAPACKE_chptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhptri

Original Fortran LAPACK documentation for ZHPTRI::

 ZHPTRI computes the inverse of a complex Hermitian indefinite matrix
 A in packed storage using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHPTRF.

 */
extern proc LAPACKE_zhptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhptri
 */
inline proc LAPACKE_zhptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int{
  return LAPACKE_zhptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chptrs

Original Fortran LAPACK documentation for CHPTRS::

 CHPTRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A stored in packed format using the factorization
 A = U*D*U**H or A = L*D*L**H computed by CHPTRF.

 */
extern proc LAPACKE_chptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chptrs
 */
inline proc LAPACKE_chptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhptrs

Original Fortran LAPACK documentation for ZHPTRS::

 ZHPTRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A stored in packed format using the factorization
 A = U*D*U**H or A = L*D*L**H computed by ZHPTRF.

 */
extern proc LAPACKE_zhptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhptrs
 */
inline proc LAPACKE_zhptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_shsein

Original Fortran LAPACK documentation for SHSEIN::

 SHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a real upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

 H * x = w * x, y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.

 */
extern proc LAPACKE_shsein(matrix_order : lapack_memory_order, job : c_char, eigsrc : c_char, initv : c_char, chlapack_select : [] c_int, n : c_int, h : [] c_float, ldh : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_shsein
 */
inline proc LAPACKE_shsein(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, n : c_int, h : [] c_float, ldh : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int) : c_int{
  return LAPACKE_shsein(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dhsein

Original Fortran LAPACK documentation for DHSEIN::

 DHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a real upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

 H * x = w * x, y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.

 */
extern proc LAPACKE_dhsein(matrix_order : lapack_memory_order, job : c_char, eigsrc : c_char, initv : c_char, chlapack_select : [] c_int, n : c_int, h : [] c_double, ldh : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dhsein
 */
inline proc LAPACKE_dhsein(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, n : c_int, h : [] c_double, ldh : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int) : c_int{
  return LAPACKE_dhsein(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chsein

Original Fortran LAPACK documentation for CHSEIN::

 CHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a complex upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

 H * x = w * x, y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.

 */
extern proc LAPACKE_chsein(matrix_order : lapack_memory_order, job : c_char, eigsrc : c_char, initv : c_char, chlapack_select : [] c_int, n : c_int, h : [] complex(64), ldh : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chsein
 */
inline proc LAPACKE_chsein(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, n : c_int, h : [] complex(64), ldh : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int) : c_int{
  return LAPACKE_chsein(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhsein

Original Fortran LAPACK documentation for ZHSEIN::

 ZHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a complex upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

 H * x = w * x, y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.

 */
extern proc LAPACKE_zhsein(matrix_order : lapack_memory_order, job : c_char, eigsrc : c_char, initv : c_char, chlapack_select : [] c_int, n : c_int, h : [] complex(128), ldh : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhsein
 */
inline proc LAPACKE_zhsein(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, n : c_int, h : [] complex(128), ldh : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int) : c_int{
  return LAPACKE_zhsein(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_shseqr

Original Fortran LAPACK documentation for SHSEQR::

 SHSEQR computes the eigenvalues of a Hessenberg matrix H
 and, optionally, the matrices T and Z from the Schur decomposition
 H = Z T Z**T, where T is an upper quasi-triangular matrix (the
 Schur form), and Z is the orthogonal matrix of Schur vectors.

 Optionally Z may be postmultiplied into an input orthogonal
 matrix Q so that this routine can give the Schur factorization
 of a matrix A which has been reduced to the Hessenberg form H
 by the orthogonal matrix Q: A = Q*H*Q**T = (QZ)*T*(QZ)**T.

 */
extern proc LAPACKE_shseqr(matrix_order : lapack_memory_order, job : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] c_float, ldh : c_int, wr : [] c_float, wi : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_shseqr
 */
inline proc LAPACKE_shseqr(matrix_order : lapack_memory_order, job : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] c_float, ldh : c_int, wr : [] c_float, wi : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_shseqr(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dhseqr

Original Fortran LAPACK documentation for DHSEQR::

 DHSEQR computes the eigenvalues of a Hessenberg matrix H
 and, optionally, the matrices T and Z from the Schur decomposition
 H = Z T Z**T, where T is an upper quasi-triangular matrix (the
 Schur form), and Z is the orthogonal matrix of Schur vectors.

 Optionally Z may be postmultiplied into an input orthogonal
 matrix Q so that this routine can give the Schur factorization
 of a matrix A which has been reduced to the Hessenberg form H
 by the orthogonal matrix Q: A = Q*H*Q**T = (QZ)*T*(QZ)**T.

 */
extern proc LAPACKE_dhseqr(matrix_order : lapack_memory_order, job : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] c_double, ldh : c_int, wr : [] c_double, wi : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dhseqr
 */
inline proc LAPACKE_dhseqr(matrix_order : lapack_memory_order, job : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] c_double, ldh : c_int, wr : [] c_double, wi : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dhseqr(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chseqr

Original Fortran LAPACK documentation for CHSEQR::

 CHSEQR computes the eigenvalues of a Hessenberg matrix H
 and, optionally, the matrices T and Z from the Schur decomposition
 H = Z T Z**H, where T is an upper triangular matrix (the
 Schur form), and Z is the unitary matrix of Schur vectors.

 Optionally Z may be postmultiplied into an input unitary
 matrix Q so that this routine can give the Schur factorization
 of a matrix A which has been reduced to the Hessenberg form H
 by the unitary matrix Q: A = Q*H*Q**H = (QZ)*T*(QZ)**H.

 */
extern proc LAPACKE_chseqr(matrix_order : lapack_memory_order, job : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(64), ldh : c_int, w : [] complex(64), z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chseqr
 */
inline proc LAPACKE_chseqr(matrix_order : lapack_memory_order, job : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(64), ldh : c_int, w : [] complex(64), z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_chseqr(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhseqr

Original Fortran LAPACK documentation for ZHSEQR::

 ZHSEQR computes the eigenvalues of a Hessenberg matrix H
 and, optionally, the matrices T and Z from the Schur decomposition
 H = Z T Z**H, where T is an upper triangular matrix (the
 Schur form), and Z is the unitary matrix of Schur vectors.

 Optionally Z may be postmultiplied into an input unitary
 matrix Q so that this routine can give the Schur factorization
 of a matrix A which has been reduced to the Hessenberg form H
 by the unitary matrix Q: A = Q*H*Q**H = (QZ)*T*(QZ)**H.

 */
extern proc LAPACKE_zhseqr(matrix_order : lapack_memory_order, job : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(128), ldh : c_int, w : [] complex(128), z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhseqr
 */
inline proc LAPACKE_zhseqr(matrix_order : lapack_memory_order, job : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(128), ldh : c_int, w : [] complex(128), z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zhseqr(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clacgv

Original Fortran LAPACK documentation for CLACGV::

 CLACGV conjugates a complex vector of length N.

 */
extern proc LAPACKE_clacgv(n : c_int, x : [] complex(64), incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlacgv

Original Fortran LAPACK documentation for ZLACGV::

 ZLACGV conjugates a complex vector of length N.

 */
extern proc LAPACKE_zlacgv(n : c_int, x : [] complex(128), incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slacn2

Original Fortran LAPACK documentation for SLACN2::

 SLACN2 estimates the 1-norm of a square, real matrix A.
 Reverse communication is used for evaluating matrix-vector products.

 */
extern proc LAPACKE_slacn2(n : c_int, v : [] c_float, x : [] c_float, isgn : [] c_int, ref est : c_float, ref kase : c_int, isave : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlacn2

Original Fortran LAPACK documentation for DLACN2::

 DLACN2 estimates the 1-norm of a square, real matrix A.
 Reverse communication is used for evaluating matrix-vector products.

 */
extern proc LAPACKE_dlacn2(n : c_int, v : [] c_double, x : [] c_double, isgn : [] c_int, ref est : c_double, ref kase : c_int, isave : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clacn2

Original Fortran LAPACK documentation for CLACN2::

 CLACN2 estimates the 1-norm of a square, complex matrix A.
 Reverse communication is used for evaluating matrix-vector products.

 */
extern proc LAPACKE_clacn2(n : c_int, v : [] complex(64), x : [] complex(64), ref est : c_float, ref kase : c_int, isave : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlacn2

Original Fortran LAPACK documentation for ZLACN2::

 ZLACN2 estimates the 1-norm of a square, complex matrix A.
 Reverse communication is used for evaluating matrix-vector products.

 */
extern proc LAPACKE_zlacn2(n : c_int, v : [] complex(128), x : [] complex(128), ref est : c_double, ref kase : c_int, isave : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slacpy

Original Fortran LAPACK documentation for SLACPY::

 SLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.

 */
extern proc LAPACKE_slacpy(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slacpy
 */
inline proc LAPACKE_slacpy(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_slacpy(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlacpy

Original Fortran LAPACK documentation for DLACPY::

 DLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.

 */
extern proc LAPACKE_dlacpy(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlacpy
 */
inline proc LAPACKE_dlacpy(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dlacpy(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clacpy

Original Fortran LAPACK documentation for CLACPY::

 CLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.

 */
extern proc LAPACKE_clacpy(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clacpy
 */
inline proc LAPACKE_clacpy(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_clacpy(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlacpy

Original Fortran LAPACK documentation for ZLACPY::

 ZLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.

 */
extern proc LAPACKE_zlacpy(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlacpy
 */
inline proc LAPACKE_zlacpy(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zlacpy(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clacp2

Original Fortran LAPACK documentation for CLACP2::

 CLACP2 copies all or part of a real two-dimensional matrix A to a
 complex matrix B.

 */
extern proc LAPACKE_clacp2(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clacp2
 */
inline proc LAPACKE_clacp2(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_clacp2(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlacp2

Original Fortran LAPACK documentation for ZLACP2::

 ZLACP2 copies all or part of a real two-dimensional matrix A to a
 complex matrix B.

 */
extern proc LAPACKE_zlacp2(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlacp2
 */
inline proc LAPACKE_zlacp2(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zlacp2(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlag2c

Original Fortran LAPACK documentation for ZLAG2C::

 ZLAG2C converts a COMPLEX*16 matrix, SA, to a COMPLEX matrix, A.

 RMAX is the overflow for the SINGLE PRECISION arithmetic
 ZLAG2C checks that all the entries of A are between -RMAX and
 RMAX. If not the convertion is aborted and a flag is raised.

 This is an auxiliary routine so there is no argument checking.

 */
extern proc LAPACKE_zlag2c(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, sa : [] complex(64), ldsa : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slag2d

Original Fortran LAPACK documentation for SLAG2D::

 SLAG2D converts a SINGLE PRECISION matrix, SA, to a DOUBLE
 PRECISION matrix, A.

 Note that while it is possible to overflow while converting
 from double to single, it is not possible to overflow when
 converting from single to double.

 This is an auxiliary routine so there is no argument checking.

 */
extern proc LAPACKE_slag2d(matrix_order : lapack_memory_order, m : c_int, n : c_int, sa : [] c_float, ldsa : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlag2s

Original Fortran LAPACK documentation for DLAG2S::

 DLAG2S converts a DOUBLE PRECISION matrix, SA, to a SINGLE
 PRECISION matrix, A.

 RMAX is the overflow for the SINGLE PRECISION arithmetic
 DLAG2S checks that all the entries of A are between -RMAX and
 RMAX. If not the convertion is aborted and a flag is raised.

 This is an auxiliary routine so there is no argument checking.

 */
extern proc LAPACKE_dlag2s(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, sa : [] c_float, ldsa : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clag2z

Original Fortran LAPACK documentation for CLAG2Z::

 CLAG2Z converts a COMPLEX matrix, SA, to a COMPLEX*16 matrix, A.

 Note that while it is possible to overflow while converting
 from double to single, it is not possible to overflow when
 converting from single to double.

 This is an auxiliary routine so there is no argument checking.

 */
extern proc LAPACKE_clag2z(matrix_order : lapack_memory_order, m : c_int, n : c_int, sa : [] complex(64), ldsa : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slagge

Original Fortran LAPACK documentation for SLAGGE::

 SLAGGE generates a real general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random orthogonal matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional orthogonal transformations.

 */
extern proc LAPACKE_slagge(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, d : [] c_float, a : [] c_float, lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlagge

Original Fortran LAPACK documentation for DLAGGE::

 DLAGGE generates a real general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random orthogonal matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional orthogonal transformations.

 */
extern proc LAPACKE_dlagge(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, d : [] c_double, a : [] c_double, lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clagge

Original Fortran LAPACK documentation for CLAGGE::

 CLAGGE generates a complex general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random unitary matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional unitary transformations.

 */
extern proc LAPACKE_clagge(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, d : [] c_float, a : [] complex(64), lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlagge

Original Fortran LAPACK documentation for ZLAGGE::

 ZLAGGE generates a complex general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random unitary matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional unitary transformations.

 */
extern proc LAPACKE_zlagge(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, d : [] c_double, a : [] complex(128), lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slamch
 */
extern proc LAPACKE_slamch(cmach : c_char) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slamch
 */
inline proc LAPACKE_slamch(cmach : string) : c_float{
  return LAPACKE_slamch(ascii(cmach) : c_char);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlamch
 */
extern proc LAPACKE_dlamch(cmach : c_char) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlamch
 */
inline proc LAPACKE_dlamch(cmach : string) : c_double{
  return LAPACKE_dlamch(ascii(cmach) : c_char);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slange

Original Fortran LAPACK documentation for SLANGE::

 SLANGE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real matrix A.

 */
extern proc LAPACKE_slange(matrix_order : lapack_memory_order, norm : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slange
 */
inline proc LAPACKE_slange(matrix_order : lapack_memory_order, norm : string, m : c_int, n : c_int, a : [] c_float, lda : c_int) : c_float{
  return LAPACKE_slange(matrix_order, ascii(norm) : c_char, m, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlange

Original Fortran LAPACK documentation for DLANGE::

 DLANGE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real matrix A.

 */
extern proc LAPACKE_dlange(matrix_order : lapack_memory_order, norm : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlange
 */
inline proc LAPACKE_dlange(matrix_order : lapack_memory_order, norm : string, m : c_int, n : c_int, a : [] c_double, lda : c_int) : c_double{
  return LAPACKE_dlange(matrix_order, ascii(norm) : c_char, m, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clange

Original Fortran LAPACK documentation for CLANGE::

 CLANGE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex matrix A.

 */
extern proc LAPACKE_clange(matrix_order : lapack_memory_order, norm : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clange
 */
inline proc LAPACKE_clange(matrix_order : lapack_memory_order, norm : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int) : c_float{
  return LAPACKE_clange(matrix_order, ascii(norm) : c_char, m, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlange

Original Fortran LAPACK documentation for ZLANGE::

 ZLANGE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex matrix A.

 */
extern proc LAPACKE_zlange(matrix_order : lapack_memory_order, norm : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlange
 */
inline proc LAPACKE_zlange(matrix_order : lapack_memory_order, norm : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int) : c_double{
  return LAPACKE_zlange(matrix_order, ascii(norm) : c_char, m, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clanhe

Original Fortran LAPACK documentation for CLANHE::

 CLANHE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex hermitian matrix A.

 */
extern proc LAPACKE_clanhe(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clanhe
 */
inline proc LAPACKE_clanhe(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int) : c_float{
  return LAPACKE_clanhe(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlanhe

Original Fortran LAPACK documentation for ZLANHE::

 ZLANHE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex hermitian matrix A.

 */
extern proc LAPACKE_zlanhe(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlanhe
 */
inline proc LAPACKE_zlanhe(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int) : c_double{
  return LAPACKE_zlanhe(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slansy

Original Fortran LAPACK documentation for SLANSY::

 SLANSY returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real symmetric matrix A.

 */
extern proc LAPACKE_slansy(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slansy
 */
inline proc LAPACKE_slansy(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] c_float, lda : c_int) : c_float{
  return LAPACKE_slansy(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlansy

Original Fortran LAPACK documentation for DLANSY::

 DLANSY returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real symmetric matrix A.

 */
extern proc LAPACKE_dlansy(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlansy
 */
inline proc LAPACKE_dlansy(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] c_double, lda : c_int) : c_double{
  return LAPACKE_dlansy(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clansy

Original Fortran LAPACK documentation for CLANSY::

 CLANSY returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex symmetric matrix A.

 */
extern proc LAPACKE_clansy(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clansy
 */
inline proc LAPACKE_clansy(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int) : c_float{
  return LAPACKE_clansy(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlansy

Original Fortran LAPACK documentation for ZLANSY::

 ZLANSY returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex symmetric matrix A.

 */
extern proc LAPACKE_zlansy(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlansy
 */
inline proc LAPACKE_zlansy(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int) : c_double{
  return LAPACKE_zlansy(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slantr

Original Fortran LAPACK documentation for SLANTR::

 SLANTR returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 trapezoidal or triangular matrix A.

 */
extern proc LAPACKE_slantr(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slantr
 */
inline proc LAPACKE_slantr(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, m : c_int, n : c_int, a : [] c_float, lda : c_int) : c_float{
  return LAPACKE_slantr(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, m, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlantr

Original Fortran LAPACK documentation for DLANTR::

 DLANTR returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 trapezoidal or triangular matrix A.

 */
extern proc LAPACKE_dlantr(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlantr
 */
inline proc LAPACKE_dlantr(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, m : c_int, n : c_int, a : [] c_double, lda : c_int) : c_double{
  return LAPACKE_dlantr(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, m, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clantr

Original Fortran LAPACK documentation for CLANTR::

 CLANTR returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 trapezoidal or triangular matrix A.

 */
extern proc LAPACKE_clantr(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clantr
 */
inline proc LAPACKE_clantr(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int) : c_float{
  return LAPACKE_clantr(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, m, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlantr

Original Fortran LAPACK documentation for ZLANTR::

 ZLANTR returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 trapezoidal or triangular matrix A.

 */
extern proc LAPACKE_zlantr(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlantr
 */
inline proc LAPACKE_zlantr(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int) : c_double{
  return LAPACKE_zlantr(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, m, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slarfb

Original Fortran LAPACK documentation for SLARFB::

 SLARFB applies a real block reflector H or its transpose H**T to a
 real m by n matrix C, from either the left or the right.

 */
extern proc LAPACKE_slarfb(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slarfb
 */
inline proc LAPACKE_slarfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_slarfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, v, ldv, t, ldt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarfb

Original Fortran LAPACK documentation for DLARFB::

 DLARFB applies a real block reflector H or its transpose H**T to a
 real m by n matrix C, from either the left or the right.

 */
extern proc LAPACKE_dlarfb(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlarfb
 */
inline proc LAPACKE_dlarfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dlarfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, v, ldv, t, ldt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clarfb

Original Fortran LAPACK documentation for CLARFB::

 CLARFB applies a complex block reflector H or its transpose H**H to a
 complex M-by-N matrix C, from either the left or the right.

 */
extern proc LAPACKE_clarfb(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clarfb
 */
inline proc LAPACKE_clarfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_clarfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, v, ldv, t, ldt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarfb

Original Fortran LAPACK documentation for ZLARFB::

 ZLARFB applies a complex block reflector H or its transpose H**H to a
 complex M-by-N matrix C, from either the left or the right.

 */
extern proc LAPACKE_zlarfb(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlarfb
 */
inline proc LAPACKE_zlarfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zlarfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, v, ldv, t, ldt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slarfg

Original Fortran LAPACK documentation for SLARFG::

 SLARFG generates a real elementary reflector H of order n, such
 that

 H * ( alpha ) = ( beta ), H**T * H = I.
 ( x ) ( 0 )

 where alpha and beta are scalars, and x is an (n-1)-element real
 vector. H is represented in the form

 H = I - tau * ( 1 ) * ( 1 v**T ) ,
 ( v )

 where tau is a real scalar and v is a real (n-1)-element
 vector.

 If the elements of x are all zero, then tau = 0 and H is taken to be
 the unit matrix.

 Otherwise 1 <= tau <= 2.

 */
extern proc LAPACKE_slarfg(n : c_int, ref alpha : c_float, x : [] c_float, incx : c_int, ref tau : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarfg

Original Fortran LAPACK documentation for DLARFG::

 DLARFG generates a real elementary reflector H of order n, such
 that

 H * ( alpha ) = ( beta ), H**T * H = I.
 ( x ) ( 0 )

 where alpha and beta are scalars, and x is an (n-1)-element real
 vector. H is represented in the form

 H = I - tau * ( 1 ) * ( 1 v**T ) ,
 ( v )

 where tau is a real scalar and v is a real (n-1)-element
 vector.

 If the elements of x are all zero, then tau = 0 and H is taken to be
 the unit matrix.

 Otherwise 1 <= tau <= 2.

 */
extern proc LAPACKE_dlarfg(n : c_int, ref alpha : c_double, x : [] c_double, incx : c_int, ref tau : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clarfg

Original Fortran LAPACK documentation for CLARFG::

 CLARFG generates a complex elementary reflector H of order n, such
 that

 H**H * ( alpha ) = ( beta ), H**H * H = I.
 ( x ) ( 0 )

 where alpha and beta are scalars, with beta real, and x is an
 (n-1)-element complex vector. H is represented in the form

 H = I - tau * ( 1 ) * ( 1 v**H ) ,
 ( v )

 where tau is a complex scalar and v is a complex (n-1)-element
 vector. Note that H is not hermitian.

 If the elements of x are all zero and alpha is real, then tau = 0
 and H is taken to be the unit matrix.

 Otherwise 1 <= real(tau) <= 2 and abs(tau-1) <= 1 .

 */
extern proc LAPACKE_clarfg(n : c_int, ref alpha : complex(64), x : [] complex(64), incx : c_int, ref tau : complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarfg

Original Fortran LAPACK documentation for ZLARFG::

 ZLARFG generates a complex elementary reflector H of order n, such
 that

 H**H * ( alpha ) = ( beta ), H**H * H = I.
 ( x ) ( 0 )

 where alpha and beta are scalars, with beta real, and x is an
 (n-1)-element complex vector. H is represented in the form

 H = I - tau * ( 1 ) * ( 1 v**H ) ,
 ( v )

 where tau is a complex scalar and v is a complex (n-1)-element
 vector. Note that H is not hermitian.

 If the elements of x are all zero and alpha is real, then tau = 0
 and H is taken to be the unit matrix.

 Otherwise 1 <= real(tau) <= 2 and abs(tau-1) <= 1 .

 */
extern proc LAPACKE_zlarfg(n : c_int, ref alpha : complex(128), x : [] complex(128), incx : c_int, ref tau : complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slarft

Original Fortran LAPACK documentation for SLARFT::

 SLARFT forms the triangular factor T of a real block reflector H
 of order n, which is defined as a product of k elementary reflectors.

 If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

 If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

 If STOREV = 'C', the vector which defines the elementary reflector
 H(i) is stored in the i-th column of the array V, and

 H = I - V * T * V**T

 If STOREV = 'R', the vector which defines the elementary reflector
 H(i) is stored in the i-th row of the array V, and

 H = I - V**T * T * V

 */
extern proc LAPACKE_slarft(matrix_order : lapack_memory_order, direct : c_char, storev : c_char, n : c_int, k : c_int, v : [] c_float, ldv : c_int, tau : [] c_float, t : [] c_float, ldt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slarft
 */
inline proc LAPACKE_slarft(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] c_float, ldv : c_int, tau : [] c_float, t : [] c_float, ldt : c_int) : c_int{
  return LAPACKE_slarft(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, ldv, tau, t, ldt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarft

Original Fortran LAPACK documentation for DLARFT::

 DLARFT forms the triangular factor T of a real block reflector H
 of order n, which is defined as a product of k elementary reflectors.

 If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

 If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

 If STOREV = 'C', the vector which defines the elementary reflector
 H(i) is stored in the i-th column of the array V, and

 H = I - V * T * V**T

 If STOREV = 'R', the vector which defines the elementary reflector
 H(i) is stored in the i-th row of the array V, and

 H = I - V**T * T * V

 */
extern proc LAPACKE_dlarft(matrix_order : lapack_memory_order, direct : c_char, storev : c_char, n : c_int, k : c_int, v : [] c_double, ldv : c_int, tau : [] c_double, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlarft
 */
inline proc LAPACKE_dlarft(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] c_double, ldv : c_int, tau : [] c_double, t : [] c_double, ldt : c_int) : c_int{
  return LAPACKE_dlarft(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, ldv, tau, t, ldt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clarft

Original Fortran LAPACK documentation for CLARFT::

 CLARFT forms the triangular factor T of a complex block reflector H
 of order n, which is defined as a product of k elementary reflectors.

 If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

 If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

 If STOREV = 'C', the vector which defines the elementary reflector
 H(i) is stored in the i-th column of the array V, and

 H = I - V * T * V**H

 If STOREV = 'R', the vector which defines the elementary reflector
 H(i) is stored in the i-th row of the array V, and

 H = I - V**H * T * V

 */
extern proc LAPACKE_clarft(matrix_order : lapack_memory_order, direct : c_char, storev : c_char, n : c_int, k : c_int, v : [] complex(64), ldv : c_int, tau : [] complex(64), t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clarft
 */
inline proc LAPACKE_clarft(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] complex(64), ldv : c_int, tau : [] complex(64), t : [] complex(64), ldt : c_int) : c_int{
  return LAPACKE_clarft(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, ldv, tau, t, ldt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarft

Original Fortran LAPACK documentation for ZLARFT::

 ZLARFT forms the triangular factor T of a complex block reflector H
 of order n, which is defined as a product of k elementary reflectors.

 If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

 If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

 If STOREV = 'C', the vector which defines the elementary reflector
 H(i) is stored in the i-th column of the array V, and

 H = I - V * T * V**H

 If STOREV = 'R', the vector which defines the elementary reflector
 H(i) is stored in the i-th row of the array V, and

 H = I - V**H * T * V

 */
extern proc LAPACKE_zlarft(matrix_order : lapack_memory_order, direct : c_char, storev : c_char, n : c_int, k : c_int, v : [] complex(128), ldv : c_int, tau : [] complex(128), t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlarft
 */
inline proc LAPACKE_zlarft(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] complex(128), ldv : c_int, tau : [] complex(128), t : [] complex(128), ldt : c_int) : c_int{
  return LAPACKE_zlarft(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, ldv, tau, t, ldt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slarfx

Original Fortran LAPACK documentation for SLARFX::

 SLARFX applies a real elementary reflector H to a real m by n
 matrix C, from either the left or the right. H is represented in the
 form

 H = I - tau * v * v**T

 where tau is a real scalar and v is a real vector.

 If tau = 0, then H is taken to be the unit matrix

 This version uses inline code if H has order < 11.

 */
extern proc LAPACKE_slarfx(matrix_order : lapack_memory_order, side : c_char, m : c_int, n : c_int, v : [] c_float, tau : c_float, c : [] c_float, ldc : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slarfx
 */
inline proc LAPACKE_slarfx(matrix_order : lapack_memory_order, side : string, m : c_int, n : c_int, v : [] c_float, tau : c_float, c : [] c_float, ldc : c_int, work : [] c_float) : c_int{
  return LAPACKE_slarfx(matrix_order, ascii(side) : c_char, m, n, v, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarfx

Original Fortran LAPACK documentation for DLARFX::

 DLARFX applies a real elementary reflector H to a real m by n
 matrix C, from either the left or the right. H is represented in the
 form

 H = I - tau * v * v**T

 where tau is a real scalar and v is a real vector.

 If tau = 0, then H is taken to be the unit matrix

 This version uses inline code if H has order < 11.

 */
extern proc LAPACKE_dlarfx(matrix_order : lapack_memory_order, side : c_char, m : c_int, n : c_int, v : [] c_double, tau : c_double, c : [] c_double, ldc : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlarfx
 */
inline proc LAPACKE_dlarfx(matrix_order : lapack_memory_order, side : string, m : c_int, n : c_int, v : [] c_double, tau : c_double, c : [] c_double, ldc : c_int, work : [] c_double) : c_int{
  return LAPACKE_dlarfx(matrix_order, ascii(side) : c_char, m, n, v, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clarfx

Original Fortran LAPACK documentation for CLARFX::

 CLARFX applies a complex elementary reflector H to a complex m by n
 matrix C, from either the left or the right. H is represented in the
 form

 H = I - tau * v * v**H

 where tau is a complex scalar and v is a complex vector.

 If tau = 0, then H is taken to be the unit matrix

 This version uses inline code if H has order < 11.

 */
extern proc LAPACKE_clarfx(matrix_order : lapack_memory_order, side : c_char, m : c_int, n : c_int, v : [] complex(64), tau : complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clarfx
 */
inline proc LAPACKE_clarfx(matrix_order : lapack_memory_order, side : string, m : c_int, n : c_int, v : [] complex(64), tau : complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_clarfx(matrix_order, ascii(side) : c_char, m, n, v, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarfx

Original Fortran LAPACK documentation for ZLARFX::

 ZLARFX applies a complex elementary reflector H to a complex m by n
 matrix C, from either the left or the right. H is represented in the
 form

 H = I - tau * v * v**H

 where tau is a complex scalar and v is a complex vector.

 If tau = 0, then H is taken to be the unit matrix

 This version uses inline code if H has order < 11.

 */
extern proc LAPACKE_zlarfx(matrix_order : lapack_memory_order, side : c_char, m : c_int, n : c_int, v : [] complex(128), tau : complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlarfx
 */
inline proc LAPACKE_zlarfx(matrix_order : lapack_memory_order, side : string, m : c_int, n : c_int, v : [] complex(128), tau : complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zlarfx(matrix_order, ascii(side) : c_char, m, n, v, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slarnv

Original Fortran LAPACK documentation for SLARNV::

 SLARNV returns a vector of n random real numbers from a uniform or
 normal distribution.

 */
extern proc LAPACKE_slarnv(idist : c_int, iseed : [] c_int, n : c_int, x : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarnv

Original Fortran LAPACK documentation for DLARNV::

 DLARNV returns a vector of n random real numbers from a uniform or
 normal distribution.

 */
extern proc LAPACKE_dlarnv(idist : c_int, iseed : [] c_int, n : c_int, x : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clarnv

Original Fortran LAPACK documentation for CLARNV::

 CLARNV returns a vector of n random complex numbers from a uniform or
 normal distribution.

 */
extern proc LAPACKE_clarnv(idist : c_int, iseed : [] c_int, n : c_int, x : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarnv

Original Fortran LAPACK documentation for ZLARNV::

 ZLARNV returns a vector of n random complex numbers from a uniform or
 normal distribution.

 */
extern proc LAPACKE_zlarnv(idist : c_int, iseed : [] c_int, n : c_int, x : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slaset

Original Fortran LAPACK documentation for SLASET::

 SLASET initializes an m-by-n matrix A to BETA on the diagonal and
 ALPHA on the offdiagonals.

 */
extern proc LAPACKE_slaset(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, alpha : c_float, beta : c_float, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slaset
 */
inline proc LAPACKE_slaset(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, alpha : c_float, beta : c_float, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_slaset(matrix_order, ascii(uplo) : c_char, m, n, alpha, beta, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlaset

Original Fortran LAPACK documentation for DLASET::

 DLASET initializes an m-by-n matrix A to BETA on the diagonal and
 ALPHA on the offdiagonals.

 */
extern proc LAPACKE_dlaset(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, alpha : c_double, beta : c_double, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlaset
 */
inline proc LAPACKE_dlaset(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, alpha : c_double, beta : c_double, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dlaset(matrix_order, ascii(uplo) : c_char, m, n, alpha, beta, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_claset

Original Fortran LAPACK documentation for CLASET::

 CLASET initializes a 2-D array A to BETA on the diagonal and
 ALPHA on the offdiagonals.

 */
extern proc LAPACKE_claset(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, alpha : complex(64), beta : complex(64), a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_claset
 */
inline proc LAPACKE_claset(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, alpha : complex(64), beta : complex(64), a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_claset(matrix_order, ascii(uplo) : c_char, m, n, alpha, beta, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlaset

Original Fortran LAPACK documentation for ZLASET::

 ZLASET initializes a 2-D array A to BETA on the diagonal and
 ALPHA on the offdiagonals.

 */
extern proc LAPACKE_zlaset(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, alpha : complex(128), beta : complex(128), a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlaset
 */
inline proc LAPACKE_zlaset(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, alpha : complex(128), beta : complex(128), a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zlaset(matrix_order, ascii(uplo) : c_char, m, n, alpha, beta, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slasrt

Original Fortran LAPACK documentation for SLASRT::

 Sort the numbers in D in increasing order (if ID = 'I') or
 in decreasing order (if ID = 'D' ).

 Use Quick Sort, reverting to Insertion sort on arrays of
 size <= 20. Dimension of STACK limits N to about 2**32.

 */
extern proc LAPACKE_slasrt(id : c_char, n : c_int, d : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slasrt
 */
inline proc LAPACKE_slasrt(id : string, n : c_int, d : [] c_float) : c_int{
  return LAPACKE_slasrt(ascii(id) : c_char, n, d);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlasrt

Original Fortran LAPACK documentation for DLASRT::

 Sort the numbers in D in increasing order (if ID = 'I') or
 in decreasing order (if ID = 'D' ).

 Use Quick Sort, reverting to Insertion sort on arrays of
 size <= 20. Dimension of STACK limits N to about 2**32.

 */
extern proc LAPACKE_dlasrt(id : c_char, n : c_int, d : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlasrt
 */
inline proc LAPACKE_dlasrt(id : string, n : c_int, d : [] c_double) : c_int{
  return LAPACKE_dlasrt(ascii(id) : c_char, n, d);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slaswp

Original Fortran LAPACK documentation for SLASWP::

 SLASWP performs a series of row interchanges on the matrix A.
 One row interchange is initiated for each of rows K1 through K2 of A.

 */
extern proc LAPACKE_slaswp(matrix_order : lapack_memory_order, n : c_int, a : [] c_float, lda : c_int, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlaswp

Original Fortran LAPACK documentation for DLASWP::

 DLASWP performs a series of row interchanges on the matrix A.
 One row interchange is initiated for each of rows K1 through K2 of A.

 */
extern proc LAPACKE_dlaswp(matrix_order : lapack_memory_order, n : c_int, a : [] c_double, lda : c_int, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_claswp

Original Fortran LAPACK documentation for CLASWP::

 CLASWP performs a series of row interchanges on the matrix A.
 One row interchange is initiated for each of rows K1 through K2 of A.

 */
extern proc LAPACKE_claswp(matrix_order : lapack_memory_order, n : c_int, a : [] complex(64), lda : c_int, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlaswp

Original Fortran LAPACK documentation for ZLASWP::

 ZLASWP performs a series of row interchanges on the matrix A.
 One row interchange is initiated for each of rows K1 through K2 of A.

 */
extern proc LAPACKE_zlaswp(matrix_order : lapack_memory_order, n : c_int, a : [] complex(128), lda : c_int, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slatms

Original Fortran LAPACK documentation for SLATMS::

 SLATMS generates random matrices with specified singular values
 (or symmetric/hermitian with specified eigenvalues)
 for testing LAPACK programs.

 SLATMS operates by applying the following sequence of
 operations:

 Set the diagonal to D, where D may be input or
 computed according to MODE, COND, DMAX, and SYM
 as described below.

 Generate a matrix with the appropriate band structure, by one
 of two methods:

 Method A:
 Generate a dense M x N matrix by multiplying D on the left
 and the right by random unitary matrices, then:

 Reduce the bandwidth according to KL and KU, using
 Householder transformations.

 Method B:
 Convert the bandwidth-0 (i.e., diagonal) matrix to a
 bandwidth-1 matrix using Givens rotations, "chasing"
 out-of-band elements back, much as in QR; then
 convert the bandwidth-1 to a bandwidth-2 matrix, etc.
 Note that for reasonably small bandwidths (relative to
 M and N) this requires less storage, as a dense matrix
 is not generated. Also, for symmetric matrices, only
 one triangle is generated.

 Method A is chosen if the bandwidth is a large fraction of the
 order of the matrix, and LDA is at least M (so a dense
 matrix can be stored.) Method B is chosen if the bandwidth
 is small (< 1/2 N for symmetric, < .3 N+M for
 non-symmetric), or LDA is less than M and not less than the
 bandwidth.

 Pack the matrix if desired. Options specified by PACK are:
 no packing
 zero out upper half (if symmetric)
 zero out lower half (if symmetric)
 store the upper half columnwise (if symmetric or upper
 triangular)
 store the lower half columnwise (if symmetric or lower
 triangular)
 store the lower triangle in banded format (if symmetric
 or lower triangular)
 store the upper triangle in banded format (if symmetric
 or upper triangular)
 store the entire matrix in banded format
 If Method B is chosen, and band format is specified, then the
 matrix will be generated in the band format, so no repacking
 will be necessary.

 */
extern proc LAPACKE_slatms(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : c_char, iseed : [] c_int, sym : c_char, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : c_char, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slatms
 */
inline proc LAPACKE_slatms(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : string, iseed : [] c_int, sym : string, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : string, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_slatms(matrix_order, m, n, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlatms

Original Fortran LAPACK documentation for DLATMS::

 DLATMS generates random matrices with specified singular values
 (or symmetric/hermitian with specified eigenvalues)
 for testing LAPACK programs.

 DLATMS operates by applying the following sequence of
 operations:

 Set the diagonal to D, where D may be input or
 computed according to MODE, COND, DMAX, and SYM
 as described below.

 Generate a matrix with the appropriate band structure, by one
 of two methods:

 Method A:
 Generate a dense M x N matrix by multiplying D on the left
 and the right by random unitary matrices, then:

 Reduce the bandwidth according to KL and KU, using
 Householder transformations.

 Method B:
 Convert the bandwidth-0 (i.e., diagonal) matrix to a
 bandwidth-1 matrix using Givens rotations, "chasing"
 out-of-band elements back, much as in QR; then
 convert the bandwidth-1 to a bandwidth-2 matrix, etc.
 Note that for reasonably small bandwidths (relative to
 M and N) this requires less storage, as a dense matrix
 is not generated. Also, for symmetric matrices, only
 one triangle is generated.

 Method A is chosen if the bandwidth is a large fraction of the
 order of the matrix, and LDA is at least M (so a dense
 matrix can be stored.) Method B is chosen if the bandwidth
 is small (< 1/2 N for symmetric, < .3 N+M for
 non-symmetric), or LDA is less than M and not less than the
 bandwidth.

 Pack the matrix if desired. Options specified by PACK are:
 no packing
 zero out upper half (if symmetric)
 zero out lower half (if symmetric)
 store the upper half columnwise (if symmetric or upper
 triangular)
 store the lower half columnwise (if symmetric or lower
 triangular)
 store the lower triangle in banded format (if symmetric
 or lower triangular)
 store the upper triangle in banded format (if symmetric
 or upper triangular)
 store the entire matrix in banded format
 If Method B is chosen, and band format is specified, then the
 matrix will be generated in the band format, so no repacking
 will be necessary.

 */
extern proc LAPACKE_dlatms(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : c_char, iseed : [] c_int, sym : c_char, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : c_char, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlatms
 */
inline proc LAPACKE_dlatms(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : string, iseed : [] c_int, sym : string, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : string, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dlatms(matrix_order, m, n, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clatms

Original Fortran LAPACK documentation for CLATMS::

 CLATMS generates random matrices with specified singular values
 (or hermitian with specified eigenvalues)
 for testing LAPACK programs.

 CLATMS operates by applying the following sequence of
 operations:

 Set the diagonal to D, where D may be input or
 computed according to MODE, COND, DMAX, and SYM
 as described below.

 Generate a matrix with the appropriate band structure, by one
 of two methods:

 Method A:
 Generate a dense M x N matrix by multiplying D on the left
 and the right by random unitary matrices, then:

 Reduce the bandwidth according to KL and KU, using
 Householder transformations.

 Method B:
 Convert the bandwidth-0 (i.e., diagonal) matrix to a
 bandwidth-1 matrix using Givens rotations, "chasing"
 out-of-band elements back, much as in QR; then convert
 the bandwidth-1 to a bandwidth-2 matrix, etc. Note
 that for reasonably small bandwidths (relative to M and
 N) this requires less storage, as a dense matrix is not
 generated. Also, for hermitian or symmetric matrices,
 only one triangle is generated.

 Method A is chosen if the bandwidth is a large fraction of the
 order of the matrix, and LDA is at least M (so a dense
 matrix can be stored.) Method B is chosen if the bandwidth
 is small (< 1/2 N for hermitian or symmetric, < .3 N+M for
 non-symmetric), or LDA is less than M and not less than the
 bandwidth.

 Pack the matrix if desired. Options specified by PACK are:
 no packing
 zero out upper half (if hermitian)
 zero out lower half (if hermitian)
 store the upper half columnwise (if hermitian or upper
 triangular)
 store the lower half columnwise (if hermitian or lower
 triangular)
 store the lower triangle in banded format (if hermitian or
 lower triangular)
 store the upper triangle in banded format (if hermitian or
 upper triangular)
 store the entire matrix in banded format
 If Method B is chosen, and band format is specified, then the
 matrix will be generated in the band format, so no repacking
 will be necessary.

 */
extern proc LAPACKE_clatms(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : c_char, iseed : [] c_int, sym : c_char, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : c_char, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clatms
 */
inline proc LAPACKE_clatms(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : string, iseed : [] c_int, sym : string, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : string, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_clatms(matrix_order, m, n, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlatms

Original Fortran LAPACK documentation for ZLATMS::

 ZLATMS generates random matrices with specified singular values
 (or hermitian with specified eigenvalues)
 for testing LAPACK programs.

 ZLATMS operates by applying the following sequence of
 operations:

 Set the diagonal to D, where D may be input or
 computed according to MODE, COND, DMAX, and SYM
 as described below.

 Generate a matrix with the appropriate band structure, by one
 of two methods:

 Method A:
 Generate a dense M x N matrix by multiplying D on the left
 and the right by random unitary matrices, then:

 Reduce the bandwidth according to KL and KU, using
 Householder transformations.

 Method B:
 Convert the bandwidth-0 (i.e., diagonal) matrix to a
 bandwidth-1 matrix using Givens rotations, "chasing"
 out-of-band elements back, much as in QR; then convert
 the bandwidth-1 to a bandwidth-2 matrix, etc. Note
 that for reasonably small bandwidths (relative to M and
 N) this requires less storage, as a dense matrix is not
 generated. Also, for hermitian or symmetric matrices,
 only one triangle is generated.

 Method A is chosen if the bandwidth is a large fraction of the
 order of the matrix, and LDA is at least M (so a dense
 matrix can be stored.) Method B is chosen if the bandwidth
 is small (< 1/2 N for hermitian or symmetric, < .3 N+M for
 non-symmetric), or LDA is less than M and not less than the
 bandwidth.

 Pack the matrix if desired. Options specified by PACK are:
 no packing
 zero out upper half (if hermitian)
 zero out lower half (if hermitian)
 store the upper half columnwise (if hermitian or upper
 triangular)
 store the lower half columnwise (if hermitian or lower
 triangular)
 store the lower triangle in banded format (if hermitian or
 lower triangular)
 store the upper triangle in banded format (if hermitian or
 upper triangular)
 store the entire matrix in banded format
 If Method B is chosen, and band format is specified, then the
 matrix will be generated in the band format, so no repacking
 will be necessary.

 */
extern proc LAPACKE_zlatms(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : c_char, iseed : [] c_int, sym : c_char, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : c_char, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlatms
 */
inline proc LAPACKE_zlatms(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : string, iseed : [] c_int, sym : string, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : string, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zlatms(matrix_order, m, n, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slauum

Original Fortran LAPACK documentation for SLAUUM::

 SLAUUM computes the product U * U**T or L**T * L, where the triangular
 factor U or L is stored in the upper or lower triangular part of
 the array A.

 If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
 overwriting the factor U in A.
 If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
 overwriting the factor L in A.

 This is the blocked form of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_slauum(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slauum
 */
inline proc LAPACKE_slauum(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_slauum(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlauum

Original Fortran LAPACK documentation for DLAUUM::

 DLAUUM computes the product U * U**T or L**T * L, where the triangular
 factor U or L is stored in the upper or lower triangular part of
 the array A.

 If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
 overwriting the factor U in A.
 If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
 overwriting the factor L in A.

 This is the blocked form of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_dlauum(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlauum
 */
inline proc LAPACKE_dlauum(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dlauum(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clauum

Original Fortran LAPACK documentation for CLAUUM::

 CLAUUM computes the product U * U**H or L**H * L, where the triangular
 factor U or L is stored in the upper or lower triangular part of
 the array A.

 If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
 overwriting the factor U in A.
 If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
 overwriting the factor L in A.

 This is the blocked form of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_clauum(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clauum
 */
inline proc LAPACKE_clauum(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_clauum(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlauum

Original Fortran LAPACK documentation for ZLAUUM::

 ZLAUUM computes the product U * U**H or L**H * L, where the triangular
 factor U or L is stored in the upper or lower triangular part of
 the array A.

 If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
 overwriting the factor U in A.
 If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
 overwriting the factor L in A.

 This is the blocked form of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_zlauum(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlauum
 */
inline proc LAPACKE_zlauum(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zlauum(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sopgtr

Original Fortran LAPACK documentation for SOPGTR::

 SOPGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 SSPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACKE_sopgtr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, tau : [] c_float, q : [] c_float, ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sopgtr
 */
inline proc LAPACKE_sopgtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, tau : [] c_float, q : [] c_float, ldq : c_int) : c_int{
  return LAPACKE_sopgtr(matrix_order, ascii(uplo) : c_char, n, ap, tau, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dopgtr

Original Fortran LAPACK documentation for DOPGTR::

 DOPGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 DSPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACKE_dopgtr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, tau : [] c_double, q : [] c_double, ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dopgtr
 */
inline proc LAPACKE_dopgtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, tau : [] c_double, q : [] c_double, ldq : c_int) : c_int{
  return LAPACKE_dopgtr(matrix_order, ascii(uplo) : c_char, n, ap, tau, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sopmtr

Original Fortran LAPACK documentation for SOPMTR::

 SOPMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by SSPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACKE_sopmtr(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, ap : [] c_float, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sopmtr
 */
inline proc LAPACKE_sopmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, ap : [] c_float, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sopmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, ap, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dopmtr

Original Fortran LAPACK documentation for DOPMTR::

 DOPMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by DSPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACKE_dopmtr(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, ap : [] c_double, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dopmtr
 */
inline proc LAPACKE_dopmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, ap : [] c_double, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dopmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, ap, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgbr

Original Fortran LAPACK documentation for SORGBR::

 SORGBR generates one of the real orthogonal matrices Q or P**T
 determined by SGEBRD when reducing a real matrix A to bidiagonal
 form: A = Q * B * P**T. Q and P**T are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
 is of order N:
 if k < n, P**T = G(k) . . . G(2) G(1) and SORGBR returns the first m
 rows of P**T, where n >= m >= k;
 if k >= n, P**T = G(n-1) . . . G(2) G(1) and SORGBR returns P**T as
 an N-by-N matrix.

 */
extern proc LAPACKE_sorgbr(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sorgbr
 */
inline proc LAPACKE_sorgbr(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int{
  return LAPACKE_sorgbr(matrix_order, ascii(vect) : c_char, m, n, k, a, lda, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgbr

Original Fortran LAPACK documentation for DORGBR::

 DORGBR generates one of the real orthogonal matrices Q or P**T
 determined by DGEBRD when reducing a real matrix A to bidiagonal
 form: A = Q * B * P**T. Q and P**T are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
 is of order N:
 if k < n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
 rows of P**T, where n >= m >= k;
 if k >= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
 an N-by-N matrix.

 */
extern proc LAPACKE_dorgbr(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dorgbr
 */
inline proc LAPACKE_dorgbr(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int{
  return LAPACKE_dorgbr(matrix_order, ascii(vect) : c_char, m, n, k, a, lda, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sorghr

Original Fortran LAPACK documentation for SORGHR::

 SORGHR generates a real orthogonal matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 SGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACKE_sorghr(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorghr

Original Fortran LAPACK documentation for DORGHR::

 DORGHR generates a real orthogonal matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 DGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACKE_dorghr(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorglq

Original Fortran LAPACK documentation for SORGLQ::

 SORGLQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k) . . . H(2) H(1)

 as returned by SGELQF.

 */
extern proc LAPACKE_sorglq(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorglq

Original Fortran LAPACK documentation for DORGLQ::

 DORGLQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k) . . . H(2) H(1)

 as returned by DGELQF.

 */
extern proc LAPACKE_dorglq(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgql

Original Fortran LAPACK documentation for SORGQL::

 SORGQL generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by SGEQLF.

 */
extern proc LAPACKE_sorgql(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgql

Original Fortran LAPACK documentation for DORGQL::

 DORGQL generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by DGEQLF.

 */
extern proc LAPACKE_dorgql(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgqr

Original Fortran LAPACK documentation for SORGQR::

 SORGQR generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by SGEQRF.

 */
extern proc LAPACKE_sorgqr(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgqr

Original Fortran LAPACK documentation for DORGQR::

 DORGQR generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by DGEQRF.

 */
extern proc LAPACKE_dorgqr(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgrq

Original Fortran LAPACK documentation for SORGRQ::

 SORGRQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1) H(2) . . . H(k)

 as returned by SGERQF.

 */
extern proc LAPACKE_sorgrq(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgrq

Original Fortran LAPACK documentation for DORGRQ::

 DORGRQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1) H(2) . . . H(k)

 as returned by DGERQF.

 */
extern proc LAPACKE_dorgrq(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgtr

Original Fortran LAPACK documentation for SORGTR::

 SORGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 SSYTRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACKE_sorgtr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sorgtr
 */
inline proc LAPACKE_sorgtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int{
  return LAPACKE_sorgtr(matrix_order, ascii(uplo) : c_char, n, a, lda, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgtr

Original Fortran LAPACK documentation for DORGTR::

 DORGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 DSYTRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACKE_dorgtr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dorgtr
 */
inline proc LAPACKE_dorgtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int{
  return LAPACKE_dorgtr(matrix_order, ascii(uplo) : c_char, n, a, lda, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormbr

Original Fortran LAPACK documentation for SORMBR::

 If VECT = 'Q', SORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 If VECT = 'P', SORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'T': P**T * C C * P**T

 Here Q and P**T are the orthogonal matrices determined by SGEBRD when
 reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
 P**T are defined as products of elementary reflectors H(i) and G(i)
 respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the orthogonal matrix Q or P**T that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

 */
extern proc LAPACKE_sormbr(matrix_order : lapack_memory_order, vect : c_char, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormbr
 */
inline proc LAPACKE_sormbr(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sormbr(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormbr

Original Fortran LAPACK documentation for DORMBR::

 If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'T': P**T * C C * P**T

 Here Q and P**T are the orthogonal matrices determined by DGEBRD when
 reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
 P**T are defined as products of elementary reflectors H(i) and G(i)
 respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the orthogonal matrix Q or P**T that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

 */
extern proc LAPACKE_dormbr(matrix_order : lapack_memory_order, vect : c_char, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormbr
 */
inline proc LAPACKE_dormbr(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dormbr(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormhr

Original Fortran LAPACK documentation for SORMHR::

 SORMHR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by SGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACKE_sormhr(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormhr
 */
inline proc LAPACKE_sormhr(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sormhr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, ilo, ihi, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormhr

Original Fortran LAPACK documentation for DORMHR::

 DORMHR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by DGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACKE_dormhr(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormhr
 */
inline proc LAPACKE_dormhr(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dormhr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, ilo, ihi, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormlq

Original Fortran LAPACK documentation for SORMLQ::

 SORMLQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by SGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_sormlq(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormlq
 */
inline proc LAPACKE_sormlq(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sormlq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormlq

Original Fortran LAPACK documentation for DORMLQ::

 DORMLQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_dormlq(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormlq
 */
inline proc LAPACKE_dormlq(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dormlq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormql

Original Fortran LAPACK documentation for SORMQL::

 SORMQL overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_sormql(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormql
 */
inline proc LAPACKE_sormql(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sormql(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormql

Original Fortran LAPACK documentation for DORMQL::

 DORMQL overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_dormql(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormql
 */
inline proc LAPACKE_dormql(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dormql(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormqr

Original Fortran LAPACK documentation for SORMQR::

 SORMQR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_sormqr(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormqr
 */
inline proc LAPACKE_sormqr(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sormqr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormqr

Original Fortran LAPACK documentation for DORMQR::

 DORMQR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_dormqr(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormqr
 */
inline proc LAPACKE_dormqr(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dormqr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormrq

Original Fortran LAPACK documentation for SORMRQ::

 SORMRQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by SGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_sormrq(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormrq
 */
inline proc LAPACKE_sormrq(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sormrq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormrq

Original Fortran LAPACK documentation for DORMRQ::

 DORMRQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_dormrq(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormrq
 */
inline proc LAPACKE_dormrq(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dormrq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormrz

Original Fortran LAPACK documentation for SORMRZ::

 SORMRZ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by STZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_sormrz(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormrz
 */
inline proc LAPACKE_sormrz(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sormrz(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormrz

Original Fortran LAPACK documentation for DORMRZ::

 DORMRZ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_dormrz(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormrz
 */
inline proc LAPACKE_dormrz(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dormrz(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormtr

Original Fortran LAPACK documentation for SORMTR::

 SORMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by SSYTRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACKE_sormtr(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormtr
 */
inline proc LAPACKE_sormtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sormtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormtr

Original Fortran LAPACK documentation for DORMTR::

 DORMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by DSYTRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACKE_dormtr(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormtr
 */
inline proc LAPACKE_dormtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dormtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbcon

Original Fortran LAPACK documentation for SPBCON::

 SPBCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite band matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_spbcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbcon
 */
inline proc LAPACKE_spbcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_spbcon(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbcon

Original Fortran LAPACK documentation for DPBCON::

 DPBCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite band matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by DPBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_dpbcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbcon
 */
inline proc LAPACKE_dpbcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_dpbcon(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbcon

Original Fortran LAPACK documentation for CPBCON::

 CPBCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite band matrix using
 the Cholesky factorization A = U**H*U or A = L*L**H computed by
 CPBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_cpbcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbcon
 */
inline proc LAPACKE_cpbcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_cpbcon(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbcon

Original Fortran LAPACK documentation for ZPBCON::

 ZPBCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite band matrix using
 the Cholesky factorization A = U**H*U or A = L*L**H computed by
 ZPBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_zpbcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbcon
 */
inline proc LAPACKE_zpbcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zpbcon(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbequ

Original Fortran LAPACK documentation for SPBEQU::

 SPBEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite band matrix A and reduce its condition
 number (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_spbequ(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbequ
 */
inline proc LAPACKE_spbequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_spbequ(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbequ

Original Fortran LAPACK documentation for DPBEQU::

 DPBEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite band matrix A and reduce its condition
 number (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_dpbequ(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbequ
 */
inline proc LAPACKE_dpbequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_dpbequ(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbequ

Original Fortran LAPACK documentation for CPBEQU::

 CPBEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite band matrix A and reduce its condition
 number (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_cpbequ(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbequ
 */
inline proc LAPACKE_cpbequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_cpbequ(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbequ

Original Fortran LAPACK documentation for ZPBEQU::

 ZPBEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite band matrix A and reduce its condition
 number (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_zpbequ(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbequ
 */
inline proc LAPACKE_zpbequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_zpbequ(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbrfs

Original Fortran LAPACK documentation for SPBRFS::

 SPBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and banded, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_spbrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbrfs
 */
inline proc LAPACKE_spbrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_spbrfs(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbrfs

Original Fortran LAPACK documentation for DPBRFS::

 DPBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and banded, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_dpbrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbrfs
 */
inline proc LAPACKE_dpbrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dpbrfs(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbrfs

Original Fortran LAPACK documentation for CPBRFS::

 CPBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and banded, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_cpbrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbrfs
 */
inline proc LAPACKE_cpbrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cpbrfs(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbrfs

Original Fortran LAPACK documentation for ZPBRFS::

 ZPBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and banded, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_zpbrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbrfs
 */
inline proc LAPACKE_zpbrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zpbrfs(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbstf

Original Fortran LAPACK documentation for SPBSTF::

 SPBSTF computes a split Cholesky factorization of a real
 symmetric positive definite band matrix A.

 This routine is designed to be used in conjunction with SSBGST.

 The factorization has the form A = S**T*S where S is a band matrix
 of the same bandwidth as A and the following structure:

 S = ( U )
 ( M L )

 where U is upper triangular of order m = (n+kd)/2, and L is lower
 triangular of order n-m.

 */
extern proc LAPACKE_spbstf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kb : c_int, bb : [] c_float, ldbb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbstf
 */
inline proc LAPACKE_spbstf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] c_float, ldbb : c_int) : c_int{
  return LAPACKE_spbstf(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbstf

Original Fortran LAPACK documentation for DPBSTF::

 DPBSTF computes a split Cholesky factorization of a real
 symmetric positive definite band matrix A.

 This routine is designed to be used in conjunction with DSBGST.

 The factorization has the form A = S**T*S where S is a band matrix
 of the same bandwidth as A and the following structure:

 S = ( U )
 ( M L )

 where U is upper triangular of order m = (n+kd)/2, and L is lower
 triangular of order n-m.

 */
extern proc LAPACKE_dpbstf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kb : c_int, bb : [] c_double, ldbb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbstf
 */
inline proc LAPACKE_dpbstf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] c_double, ldbb : c_int) : c_int{
  return LAPACKE_dpbstf(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbstf

Original Fortran LAPACK documentation for CPBSTF::

 CPBSTF computes a split Cholesky factorization of a complex
 Hermitian positive definite band matrix A.

 This routine is designed to be used in conjunction with CHBGST.

 The factorization has the form A = S**H*S where S is a band matrix
 of the same bandwidth as A and the following structure:

 S = ( U )
 ( M L )

 where U is upper triangular of order m = (n+kd)/2, and L is lower
 triangular of order n-m.

 */
extern proc LAPACKE_cpbstf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kb : c_int, bb : [] complex(64), ldbb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbstf
 */
inline proc LAPACKE_cpbstf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] complex(64), ldbb : c_int) : c_int{
  return LAPACKE_cpbstf(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbstf

Original Fortran LAPACK documentation for ZPBSTF::

 ZPBSTF computes a split Cholesky factorization of a complex
 Hermitian positive definite band matrix A.

 This routine is designed to be used in conjunction with ZHBGST.

 The factorization has the form A = S**H*S where S is a band matrix
 of the same bandwidth as A and the following structure:

 S = ( U )
 ( M L )

 where U is upper triangular of order m = (n+kd)/2, and L is lower
 triangular of order n-m.

 */
extern proc LAPACKE_zpbstf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kb : c_int, bb : [] complex(128), ldbb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbstf
 */
inline proc LAPACKE_zpbstf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] complex(128), ldbb : c_int) : c_int{
  return LAPACKE_zpbstf(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbsv

Original Fortran LAPACK documentation for SPBSV::

 SPBSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular band matrix, and L is a lower
 triangular band matrix, with the same number of superdiagonals or
 subdiagonals as A. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACKE_spbsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbsv
 */
inline proc LAPACKE_spbsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spbsv(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbsv

Original Fortran LAPACK documentation for DPBSV::

 DPBSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular band matrix, and L is a lower
 triangular band matrix, with the same number of superdiagonals or
 subdiagonals as A. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACKE_dpbsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbsv
 */
inline proc LAPACKE_dpbsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpbsv(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbsv

Original Fortran LAPACK documentation for CPBSV::

 CPBSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite band matrix and X
 and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular band matrix, and L is a lower
 triangular band matrix, with the same number of superdiagonals or
 subdiagonals as A. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACKE_cpbsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbsv
 */
inline proc LAPACKE_cpbsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpbsv(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbsv

Original Fortran LAPACK documentation for ZPBSV::

 ZPBSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite band matrix and X
 and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular band matrix, and L is a lower
 triangular band matrix, with the same number of superdiagonals or
 subdiagonals as A. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACKE_zpbsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbsv
 */
inline proc LAPACKE_zpbsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpbsv(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbsvx

Original Fortran LAPACK documentation for SPBSVX::

 SPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_spbsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbsvx
 */
inline proc LAPACKE_spbsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_spbsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbsvx

Original Fortran LAPACK documentation for DPBSVX::

 DPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_dpbsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbsvx
 */
inline proc LAPACKE_dpbsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dpbsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbsvx

Original Fortran LAPACK documentation for CPBSVX::

 CPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite band matrix and X
 and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_cpbsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbsvx
 */
inline proc LAPACKE_cpbsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cpbsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbsvx

Original Fortran LAPACK documentation for ZPBSVX::

 ZPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite band matrix and X
 and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zpbsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbsvx
 */
inline proc LAPACKE_zpbsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zpbsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbtrf

Original Fortran LAPACK documentation for SPBTRF::

 SPBTRF computes the Cholesky factorization of a real symmetric
 positive definite band matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACKE_spbtrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbtrf
 */
inline proc LAPACKE_spbtrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int) : c_int{
  return LAPACKE_spbtrf(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbtrf

Original Fortran LAPACK documentation for DPBTRF::

 DPBTRF computes the Cholesky factorization of a real symmetric
 positive definite band matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACKE_dpbtrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbtrf
 */
inline proc LAPACKE_dpbtrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int) : c_int{
  return LAPACKE_dpbtrf(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbtrf

Original Fortran LAPACK documentation for CPBTRF::

 CPBTRF computes the Cholesky factorization of a complex Hermitian
 positive definite band matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACKE_cpbtrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbtrf
 */
inline proc LAPACKE_cpbtrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int) : c_int{
  return LAPACKE_cpbtrf(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbtrf

Original Fortran LAPACK documentation for ZPBTRF::

 ZPBTRF computes the Cholesky factorization of a complex Hermitian
 positive definite band matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACKE_zpbtrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbtrf
 */
inline proc LAPACKE_zpbtrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int) : c_int{
  return LAPACKE_zpbtrf(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbtrs

Original Fortran LAPACK documentation for SPBTRS::

 SPBTRS solves a system of linear equations A*X = B with a symmetric
 positive definite band matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by SPBTRF.

 */
extern proc LAPACKE_spbtrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbtrs
 */
inline proc LAPACKE_spbtrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spbtrs(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbtrs

Original Fortran LAPACK documentation for DPBTRS::

 DPBTRS solves a system of linear equations A*X = B with a symmetric
 positive definite band matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by DPBTRF.

 */
extern proc LAPACKE_dpbtrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbtrs
 */
inline proc LAPACKE_dpbtrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpbtrs(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbtrs

Original Fortran LAPACK documentation for CPBTRS::

 CPBTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite band matrix A using the Cholesky factorization
 A = U**H*U or A = L*L**H computed by CPBTRF.

 */
extern proc LAPACKE_cpbtrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbtrs
 */
inline proc LAPACKE_cpbtrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpbtrs(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbtrs

Original Fortran LAPACK documentation for ZPBTRS::

 ZPBTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite band matrix A using the Cholesky factorization
 A = U**H *U or A = L*L**H computed by ZPBTRF.

 */
extern proc LAPACKE_zpbtrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbtrs
 */
inline proc LAPACKE_zpbtrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpbtrs(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spftrf

Original Fortran LAPACK documentation for SPFTRF::

 SPFTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_spftrf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spftrf
 */
inline proc LAPACKE_spftrf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_float) : c_int{
  return LAPACKE_spftrf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpftrf

Original Fortran LAPACK documentation for DPFTRF::

 DPFTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_dpftrf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpftrf
 */
inline proc LAPACKE_dpftrf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_double) : c_int{
  return LAPACKE_dpftrf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpftrf

Original Fortran LAPACK documentation for CPFTRF::

 CPFTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_cpftrf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpftrf
 */
inline proc LAPACKE_cpftrf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(64)) : c_int{
  return LAPACKE_cpftrf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpftrf

Original Fortran LAPACK documentation for ZPFTRF::

 ZPFTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_zpftrf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpftrf
 */
inline proc LAPACKE_zpftrf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(128)) : c_int{
  return LAPACKE_zpftrf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spftri

Original Fortran LAPACK documentation for SPFTRI::

 SPFTRI computes the inverse of a real (symmetric) positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by SPFTRF.

 */
extern proc LAPACKE_spftri(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spftri
 */
inline proc LAPACKE_spftri(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_float) : c_int{
  return LAPACKE_spftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpftri

Original Fortran LAPACK documentation for DPFTRI::

 DPFTRI computes the inverse of a (real) symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by DPFTRF.

 */
extern proc LAPACKE_dpftri(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpftri
 */
inline proc LAPACKE_dpftri(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_double) : c_int{
  return LAPACKE_dpftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpftri

Original Fortran LAPACK documentation for CPFTRI::

 CPFTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by CPFTRF.

 */
extern proc LAPACKE_cpftri(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpftri
 */
inline proc LAPACKE_cpftri(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(64)) : c_int{
  return LAPACKE_cpftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpftri

Original Fortran LAPACK documentation for ZPFTRI::

 ZPFTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by ZPFTRF.

 */
extern proc LAPACKE_zpftri(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpftri
 */
inline proc LAPACKE_zpftri(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(128)) : c_int{
  return LAPACKE_zpftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spftrs

Original Fortran LAPACK documentation for SPFTRS::

 SPFTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by SPFTRF.

 */
extern proc LAPACKE_spftrs(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spftrs
 */
inline proc LAPACKE_spftrs(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spftrs(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, nrhs, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpftrs

Original Fortran LAPACK documentation for DPFTRS::

 DPFTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by DPFTRF.

 */
extern proc LAPACKE_dpftrs(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpftrs
 */
inline proc LAPACKE_dpftrs(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpftrs(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, nrhs, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpftrs

Original Fortran LAPACK documentation for CPFTRS::

 CPFTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A using the Cholesky factorization
 A = U**H*U or A = L*L**H computed by CPFTRF.

 */
extern proc LAPACKE_cpftrs(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpftrs
 */
inline proc LAPACKE_cpftrs(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpftrs(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, nrhs, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpftrs

Original Fortran LAPACK documentation for ZPFTRS::

 ZPFTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A using the Cholesky factorization
 A = U**H*U or A = L*L**H computed by ZPFTRF.

 */
extern proc LAPACKE_zpftrs(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpftrs
 */
inline proc LAPACKE_zpftrs(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpftrs(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, nrhs, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spocon

Original Fortran LAPACK documentation for SPOCON::

 SPOCON estimates the reciprocal of the condition number (in the 
 1-norm) of a real symmetric positive definite matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_spocon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spocon
 */
inline proc LAPACKE_spocon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_spocon(matrix_order, ascii(uplo) : c_char, n, a, lda, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpocon

Original Fortran LAPACK documentation for DPOCON::

 DPOCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by DPOTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_dpocon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpocon
 */
inline proc LAPACKE_dpocon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_dpocon(matrix_order, ascii(uplo) : c_char, n, a, lda, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpocon

Original Fortran LAPACK documentation for CPOCON::

 CPOCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite matrix using the
 Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_cpocon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpocon
 */
inline proc LAPACKE_cpocon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_cpocon(matrix_order, ascii(uplo) : c_char, n, a, lda, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpocon

Original Fortran LAPACK documentation for ZPOCON::

 ZPOCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite matrix using the
 Cholesky factorization A = U**H*U or A = L*L**H computed by ZPOTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_zpocon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpocon
 */
inline proc LAPACKE_zpocon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zpocon(matrix_order, ascii(uplo) : c_char, n, a, lda, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spoequ

Original Fortran LAPACK documentation for SPOEQU::

 SPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_spoequ(matrix_order : lapack_memory_order, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dpoequ

Original Fortran LAPACK documentation for DPOEQU::

 DPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_dpoequ(matrix_order : lapack_memory_order, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cpoequ

Original Fortran LAPACK documentation for CPOEQU::

 CPOEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_cpoequ(matrix_order : lapack_memory_order, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zpoequ

Original Fortran LAPACK documentation for ZPOEQU::

 ZPOEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_zpoequ(matrix_order : lapack_memory_order, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_spoequb

Original Fortran LAPACK documentation for SPOEQUB::

 SPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_spoequb(matrix_order : lapack_memory_order, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dpoequb

Original Fortran LAPACK documentation for DPOEQUB::

 DPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_dpoequb(matrix_order : lapack_memory_order, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cpoequb

Original Fortran LAPACK documentation for CPOEQUB::

 CPOEQUB computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_cpoequb(matrix_order : lapack_memory_order, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zpoequb

Original Fortran LAPACK documentation for ZPOEQUB::

 ZPOEQUB computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_zpoequb(matrix_order : lapack_memory_order, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sporfs

Original Fortran LAPACK documentation for SPORFS::

 SPORFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite,
 and provides error bounds and backward error estimates for the
 solution.

 */
extern proc LAPACKE_sporfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sporfs
 */
inline proc LAPACKE_sporfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_sporfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dporfs

Original Fortran LAPACK documentation for DPORFS::

 DPORFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite,
 and provides error bounds and backward error estimates for the
 solution.

 */
extern proc LAPACKE_dporfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dporfs
 */
inline proc LAPACKE_dporfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dporfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cporfs

Original Fortran LAPACK documentation for CPORFS::

 CPORFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite,
 and provides error bounds and backward error estimates for the
 solution.

 */
extern proc LAPACKE_cporfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cporfs
 */
inline proc LAPACKE_cporfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cporfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zporfs

Original Fortran LAPACK documentation for ZPORFS::

 ZPORFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite,
 and provides error bounds and backward error estimates for the
 solution.

 */
extern proc LAPACKE_zporfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zporfs
 */
inline proc LAPACKE_zporfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zporfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sporfsx

Original Fortran LAPACK documentation for SPORFSX::

 SPORFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive
 definite, and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_sporfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sporfsx
 */
inline proc LAPACKE_sporfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_sporfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dporfsx

Original Fortran LAPACK documentation for DPORFSX::

 DPORFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive
 definite, and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_dporfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dporfsx
 */
inline proc LAPACKE_dporfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_dporfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cporfsx

Original Fortran LAPACK documentation for CPORFSX::

 CPORFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive
 definite, and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_cporfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cporfsx
 */
inline proc LAPACKE_cporfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_cporfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zporfsx

Original Fortran LAPACK documentation for ZPORFSX::

 ZPORFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive
 definite, and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_zporfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zporfsx
 */
inline proc LAPACKE_zporfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zporfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sposv

Original Fortran LAPACK documentation for SPOSV::

 SPOSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACKE_sposv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sposv
 */
inline proc LAPACKE_sposv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sposv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dposv

Original Fortran LAPACK documentation for DPOSV::

 DPOSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACKE_dposv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dposv
 */
inline proc LAPACKE_dposv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dposv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cposv

Original Fortran LAPACK documentation for CPOSV::

 CPOSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H* U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACKE_cposv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cposv
 */
inline proc LAPACKE_cposv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cposv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zposv

Original Fortran LAPACK documentation for ZPOSV::

 ZPOSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H* U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACKE_zposv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zposv
 */
inline proc LAPACKE_zposv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zposv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsposv

Original Fortran LAPACK documentation for DSPOSV::

 DSPOSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 DSPOSV first attempts to factorize the matrix in SINGLE PRECISION
 and use this factorization within an iterative refinement procedure
 to produce a solution with DOUBLE PRECISION normwise backward error
 quality (see below). If the approach fails the method switches to a
 DOUBLE PRECISION factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio SINGLE PRECISION performance over DOUBLE PRECISION
 performance is too small. A reasonable strategy should take the
 number of right-hand sides and the size of the matrix into account.
 This might be done with a call to ILAENV in the future. Up to now, we
 always try iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

 */
extern proc LAPACKE_dsposv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref chlapack_iter : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsposv
 */
inline proc LAPACKE_dsposv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref chlapack_iter : c_int) : c_int{
  return LAPACKE_dsposv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, chlapack_iter);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zcposv

Original Fortran LAPACK documentation for ZCPOSV::

 ZCPOSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 ZCPOSV first attempts to factorize the matrix in COMPLEX and use this
 factorization within an iterative refinement procedure to produce a
 solution with COMPLEX*16 normwise backward error quality (see below).
 If the approach fails the method switches to a COMPLEX*16
 factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio COMPLEX performance over COMPLEX*16 performance is too
 small. A reasonable strategy should take the number of right-hand
 sides and the size of the matrix into account. This might be done
 with a call to ILAENV in the future. Up to now, we always try
 iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

 */
extern proc LAPACKE_zcposv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref chlapack_iter : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zcposv
 */
inline proc LAPACKE_zcposv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref chlapack_iter : c_int) : c_int{
  return LAPACKE_zcposv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, chlapack_iter);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sposvx

Original Fortran LAPACK documentation for SPOSVX::

 SPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_sposvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sposvx
 */
inline proc LAPACKE_sposvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_sposvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dposvx

Original Fortran LAPACK documentation for DPOSVX::

 DPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_dposvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dposvx
 */
inline proc LAPACKE_dposvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dposvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cposvx

Original Fortran LAPACK documentation for CPOSVX::

 CPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_cposvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cposvx
 */
inline proc LAPACKE_cposvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cposvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zposvx

Original Fortran LAPACK documentation for ZPOSVX::

 ZPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zposvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zposvx
 */
inline proc LAPACKE_zposvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zposvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sposvxx

Original Fortran LAPACK documentation for SPOSVXX::

 SPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
 to compute the solution to a real system of linear equations
 A * X = B, where A is an N-by-N symmetric positive definite matrix
 and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SPOSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SPOSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SPOSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SPOSVXX would itself produce.

 */
extern proc LAPACKE_sposvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sposvxx
 */
inline proc LAPACKE_sposvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_sposvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dposvxx

Original Fortran LAPACK documentation for DPOSVXX::

 DPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
 to compute the solution to a double precision system of linear equations
 A * X = B, where A is an N-by-N symmetric positive definite matrix
 and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. DPOSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 DPOSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 DPOSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what DPOSVXX would itself produce.

 */
extern proc LAPACKE_dposvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dposvxx
 */
inline proc LAPACKE_dposvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_dposvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cposvxx

Original Fortran LAPACK documentation for CPOSVXX::

 CPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
 to compute the solution to a complex system of linear equations
 A * X = B, where A is an N-by-N symmetric positive definite matrix
 and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CPOSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CPOSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CPOSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CPOSVXX would itself produce.

 */
extern proc LAPACKE_cposvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cposvxx
 */
inline proc LAPACKE_cposvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_cposvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zposvxx

Original Fortran LAPACK documentation for ZPOSVXX::

 ZPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
 to compute the solution to a complex*16 system of linear equations
 A * X = B, where A is an N-by-N symmetric positive definite matrix
 and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZPOSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZPOSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZPOSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZPOSVXX would itself produce.

 */
extern proc LAPACKE_zposvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zposvxx
 */
inline proc LAPACKE_zposvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zposvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spotrf

Original Fortran LAPACK documentation for SPOTRF::

 SPOTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_spotrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spotrf
 */
inline proc LAPACKE_spotrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_spotrf(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpotrf

Original Fortran LAPACK documentation for DPOTRF::

 DPOTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_dpotrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpotrf
 */
inline proc LAPACKE_dpotrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dpotrf(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpotrf

Original Fortran LAPACK documentation for CPOTRF::

 CPOTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_cpotrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpotrf
 */
inline proc LAPACKE_cpotrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_cpotrf(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpotrf

Original Fortran LAPACK documentation for ZPOTRF::

 ZPOTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_zpotrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpotrf
 */
inline proc LAPACKE_zpotrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zpotrf(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spotri

Original Fortran LAPACK documentation for SPOTRI::

 SPOTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by SPOTRF.

 */
extern proc LAPACKE_spotri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spotri
 */
inline proc LAPACKE_spotri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_spotri(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpotri

Original Fortran LAPACK documentation for DPOTRI::

 DPOTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by DPOTRF.

 */
extern proc LAPACKE_dpotri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpotri
 */
inline proc LAPACKE_dpotri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dpotri(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpotri

Original Fortran LAPACK documentation for CPOTRI::

 CPOTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by CPOTRF.

 */
extern proc LAPACKE_cpotri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpotri
 */
inline proc LAPACKE_cpotri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_cpotri(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpotri

Original Fortran LAPACK documentation for ZPOTRI::

 ZPOTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by ZPOTRF.

 */
extern proc LAPACKE_zpotri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpotri
 */
inline proc LAPACKE_zpotri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zpotri(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spotrs

Original Fortran LAPACK documentation for SPOTRS::

 SPOTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by SPOTRF.

 */
extern proc LAPACKE_spotrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spotrs
 */
inline proc LAPACKE_spotrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spotrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpotrs

Original Fortran LAPACK documentation for DPOTRS::

 DPOTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by DPOTRF.

 */
extern proc LAPACKE_dpotrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpotrs
 */
inline proc LAPACKE_dpotrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpotrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpotrs

Original Fortran LAPACK documentation for CPOTRS::

 CPOTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A using the Cholesky factorization 
 A = U**H*U or A = L*L**H computed by CPOTRF.

 */
extern proc LAPACKE_cpotrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpotrs
 */
inline proc LAPACKE_cpotrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpotrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpotrs

Original Fortran LAPACK documentation for ZPOTRS::

 ZPOTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A using the Cholesky factorization
 A = U**H * U or A = L * L**H computed by ZPOTRF.

 */
extern proc LAPACKE_zpotrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpotrs
 */
inline proc LAPACKE_zpotrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpotrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sppcon

Original Fortran LAPACK documentation for SPPCON::

 SPPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite packed matrix using
 the Cholesky factorization A = U**T*U or A = L*L**T computed by
 SPPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_sppcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sppcon
 */
inline proc LAPACKE_sppcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_sppcon(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dppcon

Original Fortran LAPACK documentation for DPPCON::

 DPPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite packed matrix using
 the Cholesky factorization A = U**T*U or A = L*L**T computed by
 DPPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_dppcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dppcon
 */
inline proc LAPACKE_dppcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_dppcon(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cppcon

Original Fortran LAPACK documentation for CPPCON::

 CPPCON estimates the reciprocal of the condition number (in the 
 1-norm) of a complex Hermitian positive definite packed matrix using
 the Cholesky factorization A = U**H*U or A = L*L**H computed by
 CPPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_cppcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cppcon
 */
inline proc LAPACKE_cppcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_cppcon(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zppcon

Original Fortran LAPACK documentation for ZPPCON::

 ZPPCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite packed matrix using
 the Cholesky factorization A = U**H*U or A = L*L**H computed by
 ZPPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_zppcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zppcon
 */
inline proc LAPACKE_zppcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zppcon(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sppequ

Original Fortran LAPACK documentation for SPPEQU::

 SPPEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A in packed storage and reduce
 its condition number (with respect to the two-norm). S contains the
 scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
 B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
 This choice of S puts the condition number of B within a factor N of
 the smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_sppequ(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sppequ
 */
inline proc LAPACKE_sppequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_sppequ(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dppequ

Original Fortran LAPACK documentation for DPPEQU::

 DPPEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A in packed storage and reduce
 its condition number (with respect to the two-norm). S contains the
 scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
 B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
 This choice of S puts the condition number of B within a factor N of
 the smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_dppequ(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dppequ
 */
inline proc LAPACKE_dppequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_dppequ(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cppequ

Original Fortran LAPACK documentation for CPPEQU::

 CPPEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite matrix A in packed storage and reduce
 its condition number (with respect to the two-norm). S contains the
 scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
 B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
 This choice of S puts the condition number of B within a factor N of
 the smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_cppequ(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cppequ
 */
inline proc LAPACKE_cppequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_cppequ(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zppequ

Original Fortran LAPACK documentation for ZPPEQU::

 ZPPEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite matrix A in packed storage and reduce
 its condition number (with respect to the two-norm). S contains the
 scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
 B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
 This choice of S puts the condition number of B within a factor N of
 the smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_zppequ(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zppequ
 */
inline proc LAPACKE_zppequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_zppequ(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spprfs

Original Fortran LAPACK documentation for SPPRFS::

 SPPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_spprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spprfs
 */
inline proc LAPACKE_spprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_spprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpprfs

Original Fortran LAPACK documentation for DPPRFS::

 DPPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_dpprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpprfs
 */
inline proc LAPACKE_dpprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dpprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpprfs

Original Fortran LAPACK documentation for CPPRFS::

 CPPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_cpprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpprfs
 */
inline proc LAPACKE_cpprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cpprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpprfs

Original Fortran LAPACK documentation for ZPPRFS::

 ZPPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_zpprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpprfs
 */
inline proc LAPACKE_zpprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zpprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sppsv

Original Fortran LAPACK documentation for SPPSV::

 SPPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACKE_sppsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sppsv
 */
inline proc LAPACKE_sppsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sppsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dppsv

Original Fortran LAPACK documentation for DPPSV::

 DPPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACKE_dppsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dppsv
 */
inline proc LAPACKE_dppsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dppsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cppsv

Original Fortran LAPACK documentation for CPPSV::

 CPPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACKE_cppsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cppsv
 */
inline proc LAPACKE_cppsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cppsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zppsv

Original Fortran LAPACK documentation for ZPPSV::

 ZPPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACKE_zppsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zppsv
 */
inline proc LAPACKE_zppsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zppsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sppsvx

Original Fortran LAPACK documentation for SPPSVX::

 SPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_sppsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sppsvx
 */
inline proc LAPACKE_sppsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_sppsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dppsvx

Original Fortran LAPACK documentation for DPPSVX::

 DPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_dppsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dppsvx
 */
inline proc LAPACKE_dppsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dppsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cppsvx

Original Fortran LAPACK documentation for CPPSVX::

 CPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_cppsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cppsvx
 */
inline proc LAPACKE_cppsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cppsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zppsvx

Original Fortran LAPACK documentation for ZPPSVX::

 ZPPSVX uses the Cholesky factorization A = U**H * U or A = L * L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zppsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zppsvx
 */
inline proc LAPACKE_zppsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zppsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spptrf

Original Fortran LAPACK documentation for SPPTRF::

 SPPTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A stored in packed format.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACKE_spptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spptrf
 */
inline proc LAPACKE_spptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float) : c_int{
  return LAPACKE_spptrf(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpptrf

Original Fortran LAPACK documentation for DPPTRF::

 DPPTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A stored in packed format.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACKE_dpptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpptrf
 */
inline proc LAPACKE_dpptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double) : c_int{
  return LAPACKE_dpptrf(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpptrf

Original Fortran LAPACK documentation for CPPTRF::

 CPPTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A stored in packed format.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACKE_cpptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpptrf
 */
inline proc LAPACKE_cpptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64)) : c_int{
  return LAPACKE_cpptrf(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpptrf

Original Fortran LAPACK documentation for ZPPTRF::

 ZPPTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A stored in packed format.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACKE_zpptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpptrf
 */
inline proc LAPACKE_zpptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128)) : c_int{
  return LAPACKE_zpptrf(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spptri

Original Fortran LAPACK documentation for SPPTRI::

 SPPTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by SPPTRF.

 */
extern proc LAPACKE_spptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spptri
 */
inline proc LAPACKE_spptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float) : c_int{
  return LAPACKE_spptri(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpptri

Original Fortran LAPACK documentation for DPPTRI::

 DPPTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by DPPTRF.

 */
extern proc LAPACKE_dpptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpptri
 */
inline proc LAPACKE_dpptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double) : c_int{
  return LAPACKE_dpptri(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpptri

Original Fortran LAPACK documentation for CPPTRI::

 CPPTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by CPPTRF.

 */
extern proc LAPACKE_cpptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpptri
 */
inline proc LAPACKE_cpptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64)) : c_int{
  return LAPACKE_cpptri(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpptri

Original Fortran LAPACK documentation for ZPPTRI::

 ZPPTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by ZPPTRF.

 */
extern proc LAPACKE_zpptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpptri
 */
inline proc LAPACKE_zpptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128)) : c_int{
  return LAPACKE_zpptri(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spptrs

Original Fortran LAPACK documentation for SPPTRS::

 SPPTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A in packed storage using the Cholesky
 factorization A = U**T*U or A = L*L**T computed by SPPTRF.

 */
extern proc LAPACKE_spptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spptrs
 */
inline proc LAPACKE_spptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpptrs

Original Fortran LAPACK documentation for DPPTRS::

 DPPTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A in packed storage using the Cholesky
 factorization A = U**T*U or A = L*L**T computed by DPPTRF.

 */
extern proc LAPACKE_dpptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpptrs
 */
inline proc LAPACKE_dpptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpptrs

Original Fortran LAPACK documentation for CPPTRS::

 CPPTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A in packed storage using the Cholesky
 factorization A = U**H*U or A = L*L**H computed by CPPTRF.

 */
extern proc LAPACKE_cpptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpptrs
 */
inline proc LAPACKE_cpptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpptrs

Original Fortran LAPACK documentation for ZPPTRS::

 ZPPTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A in packed storage using the Cholesky
 factorization A = U**H * U or A = L * L**H computed by ZPPTRF.

 */
extern proc LAPACKE_zpptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpptrs
 */
inline proc LAPACKE_zpptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spstrf

Original Fortran LAPACK documentation for SPSTRF::

 SPSTRF computes the Cholesky factorization with complete
 pivoting of a real symmetric positive semidefinite matrix A.

 The factorization has the form
 P**T * A * P = U**T * U , if UPLO = 'U',
 P**T * A * P = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular, and
 P is stored as vector PIV.

 This algorithm does not attempt to check that A is positive
 semidefinite. This version of the algorithm calls level 3 BLAS.

 */
extern proc LAPACKE_spstrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spstrf
 */
inline proc LAPACKE_spstrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_float) : c_int{
  return LAPACKE_spstrf(matrix_order, ascii(uplo) : c_char, n, a, lda, piv, rank, tol);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpstrf

Original Fortran LAPACK documentation for DPSTRF::

 DPSTRF computes the Cholesky factorization with complete
 pivoting of a real symmetric positive semidefinite matrix A.

 The factorization has the form
 P**T * A * P = U**T * U , if UPLO = 'U',
 P**T * A * P = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular, and
 P is stored as vector PIV.

 This algorithm does not attempt to check that A is positive
 semidefinite. This version of the algorithm calls level 3 BLAS.

 */
extern proc LAPACKE_dpstrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpstrf
 */
inline proc LAPACKE_dpstrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_double) : c_int{
  return LAPACKE_dpstrf(matrix_order, ascii(uplo) : c_char, n, a, lda, piv, rank, tol);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpstrf

Original Fortran LAPACK documentation for CPSTRF::

 CPSTRF computes the Cholesky factorization with complete
 pivoting of a complex Hermitian positive semidefinite matrix A.

 The factorization has the form
 P**T * A * P = U**H * U , if UPLO = 'U',
 P**T * A * P = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular, and
 P is stored as vector PIV.

 This algorithm does not attempt to check that A is positive
 semidefinite. This version of the algorithm calls level 3 BLAS.

 */
extern proc LAPACKE_cpstrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpstrf
 */
inline proc LAPACKE_cpstrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_float) : c_int{
  return LAPACKE_cpstrf(matrix_order, ascii(uplo) : c_char, n, a, lda, piv, rank, tol);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpstrf

Original Fortran LAPACK documentation for ZPSTRF::

 ZPSTRF computes the Cholesky factorization with complete
 pivoting of a complex Hermitian positive semidefinite matrix A.

 The factorization has the form
 P**T * A * P = U**H * U , if UPLO = 'U',
 P**T * A * P = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular, and
 P is stored as vector PIV.

 This algorithm does not attempt to check that A is positive
 semidefinite. This version of the algorithm calls level 3 BLAS.

 */
extern proc LAPACKE_zpstrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpstrf
 */
inline proc LAPACKE_zpstrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_double) : c_int{
  return LAPACKE_zpstrf(matrix_order, ascii(uplo) : c_char, n, a, lda, piv, rank, tol);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sptcon

Original Fortran LAPACK documentation for SPTCON::

 SPTCON computes the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite tridiagonal matrix
 using the factorization A = L*D*L**T or A = U**T*D*U computed by
 SPTTRF.

 Norm(inv(A)) is computed by a direct method, and the reciprocal of
 the condition number is computed as
 RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_sptcon(n : c_int, d : [] c_float, e : [] c_float, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dptcon

Original Fortran LAPACK documentation for DPTCON::

 DPTCON computes the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite tridiagonal matrix
 using the factorization A = L*D*L**T or A = U**T*D*U computed by
 DPTTRF.

 Norm(inv(A)) is computed by a direct method, and the reciprocal of
 the condition number is computed as
 RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_dptcon(n : c_int, d : [] c_double, e : [] c_double, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cptcon

Original Fortran LAPACK documentation for CPTCON::

 CPTCON computes the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite tridiagonal matrix
 using the factorization A = L*D*L**H or A = U**H*D*U computed by
 CPTTRF.

 Norm(inv(A)) is computed by a direct method, and the reciprocal of
 the condition number is computed as
 RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_cptcon(n : c_int, d : [] c_float, e : [] complex(64), anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zptcon

Original Fortran LAPACK documentation for ZPTCON::

 ZPTCON computes the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite tridiagonal matrix
 using the factorization A = L*D*L**H or A = U**H*D*U computed by
 ZPTTRF.

 Norm(inv(A)) is computed by a direct method, and the reciprocal of
 the condition number is computed as
 RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_zptcon(n : c_int, d : [] c_double, e : [] complex(128), anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_spteqr

Original Fortran LAPACK documentation for SPTEQR::

 SPTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric positive definite tridiagonal matrix by first factoring the
 matrix using SPTTRF, and then calling SBDSQR to compute the singular
 values of the bidiagonal factor.

 This routine computes the eigenvalues of the positive definite
 tridiagonal matrix to high relative accuracy. This means that if the
 eigenvalues range over many orders of magnitude in size, then the
 small eigenvalues and corresponding eigenvectors will be computed
 more accurately than, for example, with the standard QR method.

 The eigenvectors of a full or band symmetric positive definite matrix
 can also be found if SSYTRD, SSPTRD, or SSBTRD has been used to
 reduce this matrix to tridiagonal form. (The reduction to tridiagonal
 form, however, may preclude the possibility of obtaining high
 relative accuracy in the small eigenvalues of the original matrix, if
 these eigenvalues range over many orders of magnitude.)

 */
extern proc LAPACKE_spteqr(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spteqr
 */
inline proc LAPACKE_spteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_spteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpteqr

Original Fortran LAPACK documentation for DPTEQR::

 DPTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric positive definite tridiagonal matrix by first factoring the
 matrix using DPTTRF, and then calling DBDSQR to compute the singular
 values of the bidiagonal factor.

 This routine computes the eigenvalues of the positive definite
 tridiagonal matrix to high relative accuracy. This means that if the
 eigenvalues range over many orders of magnitude in size, then the
 small eigenvalues and corresponding eigenvectors will be computed
 more accurately than, for example, with the standard QR method.

 The eigenvectors of a full or band symmetric positive definite matrix
 can also be found if DSYTRD, DSPTRD, or DSBTRD has been used to
 reduce this matrix to tridiagonal form. (The reduction to tridiagonal
 form, however, may preclude the possibility of obtaining high
 relative accuracy in the small eigenvalues of the original matrix, if
 these eigenvalues range over many orders of magnitude.)

 */
extern proc LAPACKE_dpteqr(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpteqr
 */
inline proc LAPACKE_dpteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dpteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpteqr

Original Fortran LAPACK documentation for CPTEQR::

 CPTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric positive definite tridiagonal matrix by first factoring the
 matrix using SPTTRF and then calling CBDSQR to compute the singular
 values of the bidiagonal factor.

 This routine computes the eigenvalues of the positive definite
 tridiagonal matrix to high relative accuracy. This means that if the
 eigenvalues range over many orders of magnitude in size, then the
 small eigenvalues and corresponding eigenvectors will be computed
 more accurately than, for example, with the standard QR method.

 The eigenvectors of a full or band positive definite Hermitian matrix
 can also be found if CHETRD, CHPTRD, or CHBTRD has been used to
 reduce this matrix to tridiagonal form. (The reduction to
 tridiagonal form, however, may preclude the possibility of obtaining
 high relative accuracy in the small eigenvalues of the original
 matrix, if these eigenvalues range over many orders of magnitude.)

 */
extern proc LAPACKE_cpteqr(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpteqr
 */
inline proc LAPACKE_cpteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_cpteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpteqr

Original Fortran LAPACK documentation for ZPTEQR::

 ZPTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric positive definite tridiagonal matrix by first factoring the
 matrix using DPTTRF and then calling ZBDSQR to compute the singular
 values of the bidiagonal factor.

 This routine computes the eigenvalues of the positive definite
 tridiagonal matrix to high relative accuracy. This means that if the
 eigenvalues range over many orders of magnitude in size, then the
 small eigenvalues and corresponding eigenvectors will be computed
 more accurately than, for example, with the standard QR method.

 The eigenvectors of a full or band positive definite Hermitian matrix
 can also be found if ZHETRD, ZHPTRD, or ZHBTRD has been used to
 reduce this matrix to tridiagonal form. (The reduction to
 tridiagonal form, however, may preclude the possibility of obtaining
 high relative accuracy in the small eigenvalues of the original
 matrix, if these eigenvalues range over many orders of magnitude.)

 */
extern proc LAPACKE_zpteqr(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpteqr
 */
inline proc LAPACKE_zpteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zpteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sptrfs

Original Fortran LAPACK documentation for SPTRFS::

 SPTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and tridiagonal, and provides error bounds and backward error
 estimates for the solution.

 */
extern proc LAPACKE_sptrfs(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dptrfs

Original Fortran LAPACK documentation for DPTRFS::

 DPTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and tridiagonal, and provides error bounds and backward error
 estimates for the solution.

 */
extern proc LAPACKE_dptrfs(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cptrfs

Original Fortran LAPACK documentation for CPTRFS::

 CPTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and tridiagonal, and provides error bounds and backward error
 estimates for the solution.

 */
extern proc LAPACKE_cptrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cptrfs
 */
inline proc LAPACKE_cptrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cptrfs(matrix_order, ascii(uplo) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zptrfs

Original Fortran LAPACK documentation for ZPTRFS::

 ZPTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and tridiagonal, and provides error bounds and backward error
 estimates for the solution.

 */
extern proc LAPACKE_zptrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zptrfs
 */
inline proc LAPACKE_zptrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zptrfs(matrix_order, ascii(uplo) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sptsv

Original Fortran LAPACK documentation for SPTSV::

 SPTSV computes the solution to a real system of linear equations
 A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
 matrix, and X and B are N-by-NRHS matrices.

 A is factored as A = L*D*L**T, and the factored form of A is then
 used to solve the system of equations.

 */
extern proc LAPACKE_sptsv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dptsv

Original Fortran LAPACK documentation for DPTSV::

 DPTSV computes the solution to a real system of linear equations
 A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
 matrix, and X and B are N-by-NRHS matrices.

 A is factored as A = L*D*L**T, and the factored form of A is then
 used to solve the system of equations.

 */
extern proc LAPACKE_dptsv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cptsv

Original Fortran LAPACK documentation for CPTSV::

 CPTSV computes the solution to a complex system of linear equations
 A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
 matrix, and X and B are N-by-NRHS matrices.

 A is factored as A = L*D*L**H, and the factored form of A is then
 used to solve the system of equations.

 */
extern proc LAPACKE_cptsv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zptsv

Original Fortran LAPACK documentation for ZPTSV::

 ZPTSV computes the solution to a complex system of linear equations
 A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
 matrix, and X and B are N-by-NRHS matrices.

 A is factored as A = L*D*L**H, and the factored form of A is then
 used to solve the system of equations.

 */
extern proc LAPACKE_zptsv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sptsvx

Original Fortran LAPACK documentation for SPTSVX::

 SPTSVX uses the factorization A = L*D*L**T to compute the solution
 to a real system of linear equations A*X = B, where A is an N-by-N
 symmetric positive definite tridiagonal matrix and X and B are
 N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_sptsvx(matrix_order : lapack_memory_order, fact : c_char, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sptsvx
 */
inline proc LAPACKE_sptsvx(matrix_order : lapack_memory_order, fact : string, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_sptsvx(matrix_order, ascii(fact) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dptsvx

Original Fortran LAPACK documentation for DPTSVX::

 DPTSVX uses the factorization A = L*D*L**T to compute the solution
 to a real system of linear equations A*X = B, where A is an N-by-N
 symmetric positive definite tridiagonal matrix and X and B are
 N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_dptsvx(matrix_order : lapack_memory_order, fact : c_char, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dptsvx
 */
inline proc LAPACKE_dptsvx(matrix_order : lapack_memory_order, fact : string, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dptsvx(matrix_order, ascii(fact) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cptsvx

Original Fortran LAPACK documentation for CPTSVX::

 CPTSVX uses the factorization A = L*D*L**H to compute the solution
 to a complex system of linear equations A*X = B, where A is an
 N-by-N Hermitian positive definite tridiagonal matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_cptsvx(matrix_order : lapack_memory_order, fact : c_char, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cptsvx
 */
inline proc LAPACKE_cptsvx(matrix_order : lapack_memory_order, fact : string, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cptsvx(matrix_order, ascii(fact) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zptsvx

Original Fortran LAPACK documentation for ZPTSVX::

 ZPTSVX uses the factorization A = L*D*L**H to compute the solution
 to a complex system of linear equations A*X = B, where A is an
 N-by-N Hermitian positive definite tridiagonal matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zptsvx(matrix_order : lapack_memory_order, fact : c_char, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zptsvx
 */
inline proc LAPACKE_zptsvx(matrix_order : lapack_memory_order, fact : string, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zptsvx(matrix_order, ascii(fact) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spttrf

Original Fortran LAPACK documentation for SPTTRF::

 SPTTRF computes the L*D*L**T factorization of a real symmetric
 positive definite tridiagonal matrix A. The factorization may also
 be regarded as having the form A = U**T*D*U.

 */
extern proc LAPACKE_spttrf(n : c_int, d : [] c_float, e : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dpttrf

Original Fortran LAPACK documentation for DPTTRF::

 DPTTRF computes the L*D*L**T factorization of a real symmetric
 positive definite tridiagonal matrix A. The factorization may also
 be regarded as having the form A = U**T*D*U.

 */
extern proc LAPACKE_dpttrf(n : c_int, d : [] c_double, e : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cpttrf

Original Fortran LAPACK documentation for CPTTRF::

 CPTTRF computes the L*D*L**H factorization of a complex Hermitian
 positive definite tridiagonal matrix A. The factorization may also
 be regarded as having the form A = U**H *D*U.

 */
extern proc LAPACKE_cpttrf(n : c_int, d : [] c_float, e : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zpttrf

Original Fortran LAPACK documentation for ZPTTRF::

 ZPTTRF computes the L*D*L**H factorization of a complex Hermitian
 positive definite tridiagonal matrix A. The factorization may also
 be regarded as having the form A = U**H *D*U.

 */
extern proc LAPACKE_zpttrf(n : c_int, d : [] c_double, e : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_spttrs

Original Fortran LAPACK documentation for SPTTRS::

 SPTTRS solves a tridiagonal system of the form
 A * X = B
 using the L*D*L**T factorization of A computed by SPTTRF. D is a
 diagonal matrix specified in the vector D, L is a unit bidiagonal
 matrix whose subdiagonal is specified in the vector E, and X and B
 are N by NRHS matrices.

 */
extern proc LAPACKE_spttrs(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dpttrs

Original Fortran LAPACK documentation for DPTTRS::

 DPTTRS solves a tridiagonal system of the form
 A * X = B
 using the L*D*L**T factorization of A computed by DPTTRF. D is a
 diagonal matrix specified in the vector D, L is a unit bidiagonal
 matrix whose subdiagonal is specified in the vector E, and X and B
 are N by NRHS matrices.

 */
extern proc LAPACKE_dpttrs(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cpttrs

Original Fortran LAPACK documentation for CPTTRS::

 CPTTRS solves a tridiagonal system of the form
 A * X = B
 using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.
 D is a diagonal matrix specified in the vector D, U (or L) is a unit
 bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
 the vector E, and X and B are N by NRHS matrices.

 */
extern proc LAPACKE_cpttrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpttrs
 */
inline proc LAPACKE_cpttrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpttrs(matrix_order, ascii(uplo) : c_char, n, nrhs, d, e, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpttrs

Original Fortran LAPACK documentation for ZPTTRS::

 ZPTTRS solves a tridiagonal system of the form
 A * X = B
 using the factorization A = U**H *D* U or A = L*D*L**H computed by ZPTTRF.
 D is a diagonal matrix specified in the vector D, U (or L) is a unit
 bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
 the vector E, and X and B are N by NRHS matrices.

 */
extern proc LAPACKE_zpttrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpttrs
 */
inline proc LAPACKE_zpttrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpttrs(matrix_order, ascii(uplo) : c_char, n, nrhs, d, e, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbev

Original Fortran LAPACK documentation for SSBEV::

 SSBEV computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A.

 */
extern proc LAPACKE_ssbev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, w : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbev
 */
inline proc LAPACKE_ssbev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, w : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_ssbev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbev

Original Fortran LAPACK documentation for DSBEV::

 DSBEV computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A.

 */
extern proc LAPACKE_dsbev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, w : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbev
 */
inline proc LAPACKE_dsbev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, w : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dsbev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbevd

Original Fortran LAPACK documentation for SSBEVD::

 SSBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A. If eigenvectors are desired, it uses
 a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_ssbevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, w : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbevd
 */
inline proc LAPACKE_ssbevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, w : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_ssbevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbevd

Original Fortran LAPACK documentation for DSBEVD::

 DSBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A. If eigenvectors are desired, it uses
 a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_dsbevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, w : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbevd
 */
inline proc LAPACKE_dsbevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, w : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dsbevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbevx

Original Fortran LAPACK documentation for SSBEVX::

 SSBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric band matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACKE_ssbevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, q : [] c_float, ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbevx
 */
inline proc LAPACKE_ssbevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, q : [] c_float, ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_ssbevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbevx

Original Fortran LAPACK documentation for DSBEVX::

 DSBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric band matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACKE_dsbevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, q : [] c_double, ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbevx
 */
inline proc LAPACKE_dsbevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, q : [] c_double, ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dsbevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbgst

Original Fortran LAPACK documentation for SSBGST::

 SSBGST reduces a real symmetric-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**T*S by SPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**T*A*X, where
 X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
 bandwidth of A.

 */
extern proc LAPACKE_ssbgst(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, x : [] c_float, ldx : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbgst
 */
inline proc LAPACKE_ssbgst(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, x : [] c_float, ldx : c_int) : c_int{
  return LAPACKE_ssbgst(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbgst

Original Fortran LAPACK documentation for DSBGST::

 DSBGST reduces a real symmetric-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**T*S by DPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**T*A*X, where
 X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
 bandwidth of A.

 */
extern proc LAPACKE_dsbgst(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, x : [] c_double, ldx : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbgst
 */
inline proc LAPACKE_dsbgst(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, x : [] c_double, ldx : c_int) : c_int{
  return LAPACKE_dsbgst(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbgv

Original Fortran LAPACK documentation for SSBGV::

 SSBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite.

 */
extern proc LAPACKE_ssbgv(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, w : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbgv
 */
inline proc LAPACKE_ssbgv(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, w : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_ssbgv(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbgv

Original Fortran LAPACK documentation for DSBGV::

 DSBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite.

 */
extern proc LAPACKE_dsbgv(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, w : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbgv
 */
inline proc LAPACKE_dsbgv(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, w : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dsbgv(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbgvd

Original Fortran LAPACK documentation for SSBGVD::

 SSBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of the
 form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and
 banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_ssbgvd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, w : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbgvd
 */
inline proc LAPACKE_ssbgvd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, w : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_ssbgvd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbgvd

Original Fortran LAPACK documentation for DSBGVD::

 DSBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of the
 form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and
 banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_dsbgvd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, w : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbgvd
 */
inline proc LAPACKE_dsbgvd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, w : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dsbgvd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbgvx

Original Fortran LAPACK documentation for SSBGVX::

 SSBGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_ssbgvx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, q : [] c_float, ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbgvx
 */
inline proc LAPACKE_ssbgvx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, q : [] c_float, ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_ssbgvx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbgvx

Original Fortran LAPACK documentation for DSBGVX::

 DSBGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_dsbgvx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, q : [] c_double, ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbgvx
 */
inline proc LAPACKE_dsbgvx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, q : [] c_double, ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dsbgvx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbtrd

Original Fortran LAPACK documentation for SSBTRD::

 SSBTRD reduces a real symmetric band matrix A to symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

 */
extern proc LAPACKE_ssbtrd(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbtrd
 */
inline proc LAPACKE_ssbtrd(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ldq : c_int) : c_int{
  return LAPACKE_ssbtrd(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, d, e, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbtrd

Original Fortran LAPACK documentation for DSBTRD::

 DSBTRD reduces a real symmetric band matrix A to symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

 */
extern proc LAPACKE_dsbtrd(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbtrd
 */
inline proc LAPACKE_dsbtrd(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ldq : c_int) : c_int{
  return LAPACKE_dsbtrd(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, d, e, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssfrk

Original Fortran LAPACK documentation for SSFRK::

 Level 3 BLAS like routine for C in RFP Format.

 SSFRK performs one of the symmetric rank--k operations

 C := alpha*A*A**T + beta*C,

 or

 C := alpha*A**T*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n symmetric
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

 */
extern proc LAPACKE_ssfrk(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, trans : c_char, n : c_int, k : c_int, alpha : c_float, a : [] c_float, lda : c_int, beta : c_float, c : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssfrk
 */
inline proc LAPACKE_ssfrk(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, n : c_int, k : c_int, alpha : c_float, a : [] c_float, lda : c_int, beta : c_float, c : [] c_float) : c_int{
  return LAPACKE_ssfrk(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, n, k, alpha, a, lda, beta, c);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsfrk

Original Fortran LAPACK documentation for DSFRK::

 Level 3 BLAS like routine for C in RFP Format.

 DSFRK performs one of the symmetric rank--k operations

 C := alpha*A*A**T + beta*C,

 or

 C := alpha*A**T*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n symmetric
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

 */
extern proc LAPACKE_dsfrk(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, trans : c_char, n : c_int, k : c_int, alpha : c_double, a : [] c_double, lda : c_int, beta : c_double, c : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsfrk
 */
inline proc LAPACKE_dsfrk(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, n : c_int, k : c_int, alpha : c_double, a : [] c_double, lda : c_int, beta : c_double, c : [] c_double) : c_int{
  return LAPACKE_dsfrk(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, n, k, alpha, a, lda, beta, c);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspcon

Original Fortran LAPACK documentation for SSPCON::

 SSPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric packed matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by SSPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_sspcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspcon
 */
inline proc LAPACKE_sspcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_sspcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspcon

Original Fortran LAPACK documentation for DSPCON::

 DSPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric packed matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by DSPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_dspcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspcon
 */
inline proc LAPACKE_dspcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_dspcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cspcon

Original Fortran LAPACK documentation for CSPCON::

 CSPCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex symmetric packed matrix A using the
 factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_cspcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cspcon
 */
inline proc LAPACKE_cspcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_cspcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zspcon

Original Fortran LAPACK documentation for ZSPCON::

 ZSPCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex symmetric packed matrix A using the
 factorization A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_zspcon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zspcon
 */
inline proc LAPACKE_zspcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zspcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspev

Original Fortran LAPACK documentation for SSPEV::

 SSPEV computes all the eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A in packed storage.

 */
extern proc LAPACKE_sspev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspev
 */
inline proc LAPACKE_sspev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_sspev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspev

Original Fortran LAPACK documentation for DSPEV::

 DSPEV computes all the eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A in packed storage.

 */
extern proc LAPACKE_dspev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspev
 */
inline proc LAPACKE_dspev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dspev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspevd

Original Fortran LAPACK documentation for SSPEVD::

 SSPEVD computes all the eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_sspevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspevd
 */
inline proc LAPACKE_sspevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_sspevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspevd

Original Fortran LAPACK documentation for DSPEVD::

 DSPEVD computes all the eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_dspevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspevd
 */
inline proc LAPACKE_dspevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dspevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspevx

Original Fortran LAPACK documentation for SSPEVX::

 SSPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. Eigenvalues/vectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACKE_sspevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspevx
 */
inline proc LAPACKE_sspevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_sspevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspevx

Original Fortran LAPACK documentation for DSPEVX::

 DSPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. Eigenvalues/vectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACKE_dspevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspevx
 */
inline proc LAPACKE_dspevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dspevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspgst

Original Fortran LAPACK documentation for SSPGST::

 SSPGST reduces a real symmetric-definite generalized eigenproblem
 to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by SPPTRF.

 */
extern proc LAPACKE_sspgst(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, ap : [] c_float, bp : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspgst
 */
inline proc LAPACKE_sspgst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float) : c_int{
  return LAPACKE_sspgst(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspgst

Original Fortran LAPACK documentation for DSPGST::

 DSPGST reduces a real symmetric-definite generalized eigenproblem
 to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by DPPTRF.

 */
extern proc LAPACKE_dspgst(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, ap : [] c_double, bp : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspgst
 */
inline proc LAPACKE_dspgst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double) : c_int{
  return LAPACKE_dspgst(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspgv

Original Fortran LAPACK documentation for SSPGV::

 SSPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric, stored in packed format,
 and B is also positive definite.

 */
extern proc LAPACKE_sspgv(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspgv
 */
inline proc LAPACKE_sspgv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_sspgv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspgv

Original Fortran LAPACK documentation for DSPGV::

 DSPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric, stored in packed format,
 and B is also positive definite.

 */
extern proc LAPACKE_dspgv(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspgv
 */
inline proc LAPACKE_dspgv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dspgv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspgvd

Original Fortran LAPACK documentation for SSPGVD::

 SSPGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_sspgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspgvd
 */
inline proc LAPACKE_sspgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_sspgvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspgvd

Original Fortran LAPACK documentation for DSPGVD::

 DSPGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_dspgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspgvd
 */
inline proc LAPACKE_dspgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dspgvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspgvx

Original Fortran LAPACK documentation for SSPGVX::

 SSPGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric, stored in packed storage, and B
 is also positive definite. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

 */
extern proc LAPACKE_sspgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] c_float, bp : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspgvx
 */
inline proc LAPACKE_sspgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_sspgvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspgvx

Original Fortran LAPACK documentation for DSPGVX::

 DSPGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric, stored in packed storage, and B
 is also positive definite. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

 */
extern proc LAPACKE_dspgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] c_double, bp : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspgvx
 */
inline proc LAPACKE_dspgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dspgvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssprfs

Original Fortran LAPACK documentation for SSPRFS::

 SSPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_ssprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssprfs
 */
inline proc LAPACKE_ssprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_ssprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsprfs

Original Fortran LAPACK documentation for DSPRFS::

 DSPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_dsprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsprfs
 */
inline proc LAPACKE_dsprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dsprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csprfs

Original Fortran LAPACK documentation for CSPRFS::

 CSPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_csprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csprfs
 */
inline proc LAPACKE_csprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_csprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsprfs

Original Fortran LAPACK documentation for ZSPRFS::

 ZSPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACKE_zsprfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsprfs
 */
inline proc LAPACKE_zsprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zsprfs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspsv

Original Fortran LAPACK documentation for SSPSV::

 SSPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is symmetric and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACKE_sspsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspsv
 */
inline proc LAPACKE_sspsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sspsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspsv

Original Fortran LAPACK documentation for DSPSV::

 DSPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is symmetric and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACKE_dspsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspsv
 */
inline proc LAPACKE_dspsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dspsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cspsv

Original Fortran LAPACK documentation for CSPSV::

 CSPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is symmetric and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACKE_cspsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cspsv
 */
inline proc LAPACKE_cspsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cspsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zspsv

Original Fortran LAPACK documentation for ZSPSV::

 ZSPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is symmetric and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACKE_zspsv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zspsv
 */
inline proc LAPACKE_zspsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zspsv(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspsvx

Original Fortran LAPACK documentation for SSPSVX::

 SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a real system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_sspsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspsvx
 */
inline proc LAPACKE_sspsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_sspsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspsvx

Original Fortran LAPACK documentation for DSPSVX::

 DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a real system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_dspsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspsvx
 */
inline proc LAPACKE_dspsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dspsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cspsvx

Original Fortran LAPACK documentation for CSPSVX::

 CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a complex system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_cspsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cspsvx
 */
inline proc LAPACKE_cspsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_cspsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zspsvx

Original Fortran LAPACK documentation for ZSPSVX::

 ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a complex system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zspsvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zspsvx
 */
inline proc LAPACKE_zspsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zspsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssptrd

Original Fortran LAPACK documentation for SSPTRD::

 SSPTRD reduces a real symmetric matrix A stored in packed form to
 symmetric tridiagonal form T by an orthogonal similarity
 transformation: Q**T * A * Q = T.

 */
extern proc LAPACKE_ssptrd(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, d : [] c_float, e : [] c_float, tau : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssptrd
 */
inline proc LAPACKE_ssptrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, d : [] c_float, e : [] c_float, tau : [] c_float) : c_int{
  return LAPACKE_ssptrd(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsptrd

Original Fortran LAPACK documentation for DSPTRD::

 DSPTRD reduces a real symmetric matrix A stored in packed form to
 symmetric tridiagonal form T by an orthogonal similarity
 transformation: Q**T * A * Q = T.

 */
extern proc LAPACKE_dsptrd(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, d : [] c_double, e : [] c_double, tau : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsptrd
 */
inline proc LAPACKE_dsptrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, d : [] c_double, e : [] c_double, tau : [] c_double) : c_int{
  return LAPACKE_dsptrd(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssptrf

Original Fortran LAPACK documentation for SSPTRF::

 SSPTRF computes the factorization of a real symmetric matrix A stored
 in packed format using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACKE_ssptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssptrf
 */
inline proc LAPACKE_ssptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int) : c_int{
  return LAPACKE_ssptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsptrf

Original Fortran LAPACK documentation for DSPTRF::

 DSPTRF computes the factorization of a real symmetric matrix A stored
 in packed format using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACKE_dsptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsptrf
 */
inline proc LAPACKE_dsptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int) : c_int{
  return LAPACKE_dsptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csptrf

Original Fortran LAPACK documentation for CSPTRF::

 CSPTRF computes the factorization of a complex symmetric matrix A
 stored in packed format using the Bunch-Kaufman diagonal pivoting
 method:

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACKE_csptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csptrf
 */
inline proc LAPACKE_csptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int{
  return LAPACKE_csptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsptrf

Original Fortran LAPACK documentation for ZSPTRF::

 ZSPTRF computes the factorization of a complex symmetric matrix A
 stored in packed format using the Bunch-Kaufman diagonal pivoting
 method:

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACKE_zsptrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsptrf
 */
inline proc LAPACKE_zsptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int{
  return LAPACKE_zsptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssptri

Original Fortran LAPACK documentation for SSPTRI::

 SSPTRI computes the inverse of a real symmetric indefinite matrix
 A in packed storage using the factorization A = U*D*U**T or
 A = L*D*L**T computed by SSPTRF.

 */
extern proc LAPACKE_ssptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssptri
 */
inline proc LAPACKE_ssptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int) : c_int{
  return LAPACKE_ssptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsptri

Original Fortran LAPACK documentation for DSPTRI::

 DSPTRI computes the inverse of a real symmetric indefinite matrix
 A in packed storage using the factorization A = U*D*U**T or
 A = L*D*L**T computed by DSPTRF.

 */
extern proc LAPACKE_dsptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsptri
 */
inline proc LAPACKE_dsptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int) : c_int{
  return LAPACKE_dsptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csptri

Original Fortran LAPACK documentation for CSPTRI::

 CSPTRI computes the inverse of a complex symmetric indefinite matrix
 A in packed storage using the factorization A = U*D*U**T or
 A = L*D*L**T computed by CSPTRF.

 */
extern proc LAPACKE_csptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csptri
 */
inline proc LAPACKE_csptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int{
  return LAPACKE_csptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsptri

Original Fortran LAPACK documentation for ZSPTRI::

 ZSPTRI computes the inverse of a complex symmetric indefinite matrix
 A in packed storage using the factorization A = U*D*U**T or
 A = L*D*L**T computed by ZSPTRF.

 */
extern proc LAPACKE_zsptri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsptri
 */
inline proc LAPACKE_zsptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int{
  return LAPACKE_zsptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssptrs

Original Fortran LAPACK documentation for SSPTRS::

 SSPTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A stored in packed format using the factorization
 A = U*D*U**T or A = L*D*L**T computed by SSPTRF.

 */
extern proc LAPACKE_ssptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssptrs
 */
inline proc LAPACKE_ssptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_ssptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsptrs

Original Fortran LAPACK documentation for DSPTRS::

 DSPTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A stored in packed format using the factorization
 A = U*D*U**T or A = L*D*L**T computed by DSPTRF.

 */
extern proc LAPACKE_dsptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsptrs
 */
inline proc LAPACKE_dsptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dsptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csptrs

Original Fortran LAPACK documentation for CSPTRS::

 CSPTRS solves a system of linear equations A*X = B with a complex
 symmetric matrix A stored in packed format using the factorization
 A = U*D*U**T or A = L*D*L**T computed by CSPTRF.

 */
extern proc LAPACKE_csptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csptrs
 */
inline proc LAPACKE_csptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_csptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsptrs

Original Fortran LAPACK documentation for ZSPTRS::

 ZSPTRS solves a system of linear equations A*X = B with a complex
 symmetric matrix A stored in packed format using the factorization
 A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.

 */
extern proc LAPACKE_zsptrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsptrs
 */
inline proc LAPACKE_zsptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zsptrs(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstebz

Original Fortran LAPACK documentation for SSTEBZ::

 SSTEBZ computes the eigenvalues of a symmetric tridiagonal
 matrix T. The user may ask for all eigenvalues, all eigenvalues
 in the half-open interval (VL, VU], or the IL-th through IU-th
 eigenvalues.

 To avoid overflow, the matrix must be scaled so that its
 largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
 accuracy, it should not be much smaller than that.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966.

 */
extern proc LAPACKE_sstebz(range : c_char, order : c_char, n : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, d : [] c_float, e : [] c_float, ref m : c_int, ref nsplit : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstebz
 */
inline proc LAPACKE_sstebz(range : string, order : string, n : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, d : [] c_float, e : [] c_float, ref m : c_int, ref nsplit : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int) : c_int{
  return LAPACKE_sstebz(ascii(range) : c_char, ascii(order) : c_char, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstebz

Original Fortran LAPACK documentation for DSTEBZ::

 DSTEBZ computes the eigenvalues of a symmetric tridiagonal
 matrix T. The user may ask for all eigenvalues, all eigenvalues
 in the half-open interval (VL, VU], or the IL-th through IU-th
 eigenvalues.

 To avoid overflow, the matrix must be scaled so that its
 largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
 accuracy, it should not be much smaller than that.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966.

 */
extern proc LAPACKE_dstebz(range : c_char, order : c_char, n : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, d : [] c_double, e : [] c_double, ref m : c_int, ref nsplit : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstebz
 */
inline proc LAPACKE_dstebz(range : string, order : string, n : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, d : [] c_double, e : [] c_double, ref m : c_int, ref nsplit : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int) : c_int{
  return LAPACKE_dstebz(ascii(range) : c_char, ascii(order) : c_char, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstedc

Original Fortran LAPACK documentation for SSTEDC::

 SSTEDC computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the divide and conquer method.
 The eigenvectors of a full or band real symmetric matrix can also be
 found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this
 matrix to tridiagonal form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See SLAED3 for details.

 */
extern proc LAPACKE_sstedc(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstedc
 */
inline proc LAPACKE_sstedc(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_sstedc(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstedc

Original Fortran LAPACK documentation for DSTEDC::

 DSTEDC computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the divide and conquer method.
 The eigenvectors of a full or band real symmetric matrix can also be
 found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
 matrix to tridiagonal form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See DLAED3 for details.

 */
extern proc LAPACKE_dstedc(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstedc
 */
inline proc LAPACKE_dstedc(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dstedc(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cstedc

Original Fortran LAPACK documentation for CSTEDC::

 CSTEDC computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the divide and conquer method.
 The eigenvectors of a full or band complex Hermitian matrix can also
 be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
 matrix to tridiagonal form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See SLAED3 for details.

 */
extern proc LAPACKE_cstedc(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cstedc
 */
inline proc LAPACKE_cstedc(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_cstedc(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zstedc

Original Fortran LAPACK documentation for ZSTEDC::

 ZSTEDC computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the divide and conquer method.
 The eigenvectors of a full or band complex Hermitian matrix can also
 be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
 matrix to tridiagonal form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See DLAED3 for details.

 */
extern proc LAPACKE_zstedc(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zstedc
 */
inline proc LAPACKE_zstedc(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zstedc(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstegr

Original Fortran LAPACK documentation for SSTEGR::

 SSTEGR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 SSTEGR is a compatability wrapper around the improved SSTEMR routine.
 See SSTEMR for further details.

 One important change is that the ABSTOL parameter no longer provides any
 benefit and hence is no longer used.

 Note : SSTEGR and SSTEMR work only on machines which follow
 IEEE-754 floating-point standard in their handling of infinities and
 NaNs. Normal execution may create these exceptiona values and hence
 may abort due to a floating point exception in environments which
 do not conform to the IEEE-754 standard.

 */
extern proc LAPACKE_sstegr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstegr
 */
inline proc LAPACKE_sstegr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_sstegr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstegr

Original Fortran LAPACK documentation for DSTEGR::

 DSTEGR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 DSTEGR is a compatability wrapper around the improved DSTEMR routine.
 See DSTEMR for further details.

 One important change is that the ABSTOL parameter no longer provides any
 benefit and hence is no longer used.

 Note : DSTEGR and DSTEMR work only on machines which follow
 IEEE-754 floating-point standard in their handling of infinities and
 NaNs. Normal execution may create these exceptiona values and hence
 may abort due to a floating point exception in environments which
 do not conform to the IEEE-754 standard.

 */
extern proc LAPACKE_dstegr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstegr
 */
inline proc LAPACKE_dstegr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_dstegr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cstegr

Original Fortran LAPACK documentation for CSTEGR::

 CSTEGR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 CSTEGR is a compatability wrapper around the improved CSTEMR routine.
 See SSTEMR for further details.

 One important change is that the ABSTOL parameter no longer provides any
 benefit and hence is no longer used.

 Note : CSTEGR and CSTEMR work only on machines which follow
 IEEE-754 floating-point standard in their handling of infinities and
 NaNs. Normal execution may create these exceptiona values and hence
 may abort due to a floating point exception in environments which
 do not conform to the IEEE-754 standard.

 */
extern proc LAPACKE_cstegr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cstegr
 */
inline proc LAPACKE_cstegr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_cstegr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zstegr

Original Fortran LAPACK documentation for ZSTEGR::

 ZSTEGR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 ZSTEGR is a compatability wrapper around the improved ZSTEMR routine.
 See DSTEMR for further details.

 One important change is that the ABSTOL parameter no longer provides any
 benefit and hence is no longer used.

 Note : ZSTEGR and ZSTEMR work only on machines which follow
 IEEE-754 floating-point standard in their handling of infinities and
 NaNs. Normal execution may create these exceptiona values and hence
 may abort due to a floating point exception in environments which
 do not conform to the IEEE-754 standard.

 */
extern proc LAPACKE_zstegr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zstegr
 */
inline proc LAPACKE_zstegr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_zstegr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstein

Original Fortran LAPACK documentation for SSTEIN::

 SSTEIN computes the eigenvectors of a real symmetric tridiagonal
 matrix T corresponding to specified eigenvalues, using inverse
 iteration.

 The maximum number of iterations allowed for each eigenvector is
 specified by an internal parameter MAXITS (currently set to 5).

 */
extern proc LAPACKE_sstein(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] c_float, m : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, z : [] c_float, ldz : c_int, ifailv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dstein

Original Fortran LAPACK documentation for DSTEIN::

 DSTEIN computes the eigenvectors of a real symmetric tridiagonal
 matrix T corresponding to specified eigenvalues, using inverse
 iteration.

 The maximum number of iterations allowed for each eigenvector is
 specified by an internal parameter MAXITS (currently set to 5).

 */
extern proc LAPACKE_dstein(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] c_double, m : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, z : [] c_double, ldz : c_int, ifailv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cstein

Original Fortran LAPACK documentation for CSTEIN::

 CSTEIN computes the eigenvectors of a real symmetric tridiagonal
 matrix T corresponding to specified eigenvalues, using inverse
 iteration.

 The maximum number of iterations allowed for each eigenvector is
 specified by an internal parameter MAXITS (currently set to 5).

 Although the eigenvectors are real, they are stored in a complex
 array, which may be passed to CUNMTR or CUPMTR for back
 transformation to the eigenvectors of a complex Hermitian matrix
 which was reduced to tridiagonal form.

 */
extern proc LAPACKE_cstein(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] c_float, m : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, z : [] complex(64), ldz : c_int, ifailv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zstein

Original Fortran LAPACK documentation for ZSTEIN::

 ZSTEIN computes the eigenvectors of a real symmetric tridiagonal
 matrix T corresponding to specified eigenvalues, using inverse
 iteration.

 The maximum number of iterations allowed for each eigenvector is
 specified by an internal parameter MAXITS (currently set to 5).

 Although the eigenvectors are real, they are stored in a complex
 array, which may be passed to ZUNMTR or ZUPMTR for back
 transformation to the eigenvectors of a complex Hermitian matrix
 which was reduced to tridiagonal form.

 */
extern proc LAPACKE_zstein(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] c_double, m : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, z : [] complex(128), ldz : c_int, ifailv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sstemr

Original Fortran LAPACK documentation for SSTEMR::

 SSTEMR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 Depending on the number of desired eigenvalues, these are computed either
 by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
 computed by the use of various suitable L D L^T factorizations near clusters
 of close eigenvalues (referred to as RRRs, Relatively Robust
 Representations). An informal sketch of the algorithm follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 For more details, see:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.

 Further Details
 1.SSTEMR works only on machines which follow IEEE-754
 floating-point standard in their handling of infinities and NaNs.
 This permits the use of efficient inner loops avoiding a check for
 zero divisors.

 */
extern proc LAPACKE_sstemr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstemr
 */
inline proc LAPACKE_sstemr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int) : c_int{
  return LAPACKE_sstemr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstemr

Original Fortran LAPACK documentation for DSTEMR::

 DSTEMR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 Depending on the number of desired eigenvalues, these are computed either
 by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
 computed by the use of various suitable L D L^T factorizations near clusters
 of close eigenvalues (referred to as RRRs, Relatively Robust
 Representations). An informal sketch of the algorithm follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 For more details, see:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.

 Further Details
 1.DSTEMR works only on machines which follow IEEE-754
 floating-point standard in their handling of infinities and NaNs.
 This permits the use of efficient inner loops avoiding a check for
 zero divisors.

 */
extern proc LAPACKE_dstemr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstemr
 */
inline proc LAPACKE_dstemr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int) : c_int{
  return LAPACKE_dstemr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cstemr

Original Fortran LAPACK documentation for CSTEMR::

 CSTEMR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 Depending on the number of desired eigenvalues, these are computed either
 by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
 computed by the use of various suitable L D L^T factorizations near clusters
 of close eigenvalues (referred to as RRRs, Relatively Robust
 Representations). An informal sketch of the algorithm follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 For more details, see:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.

 Further Details
 1.CSTEMR works only on machines which follow IEEE-754
 floating-point standard in their handling of infinities and NaNs.
 This permits the use of efficient inner loops avoiding a check for
 zero divisors.

 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
 real symmetric tridiagonal form.

 (Any complex Hermitean tridiagonal matrix has real values on its diagonal
 and potentially complex numbers on its off-diagonals. By applying a
 similarity transform with an appropriate diagonal matrix
 diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
 matrix can be transformed into a real symmetric matrix and complex
 arithmetic can be entirely avoided.)

 While the eigenvectors of the real symmetric tridiagonal matrix are real,
 the eigenvectors of original complex Hermitean matrix have complex entries
 in general.
 Since LAPACK drivers overwrite the matrix data with the eigenvectors,
 CSTEMR accepts complex workspace to facilitate interoperability
 with CUNMTR or CUPMTR.

 */
extern proc LAPACKE_cstemr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cstemr
 */
inline proc LAPACKE_cstemr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int) : c_int{
  return LAPACKE_cstemr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zstemr

Original Fortran LAPACK documentation for ZSTEMR::

 ZSTEMR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 Depending on the number of desired eigenvalues, these are computed either
 by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
 computed by the use of various suitable L D L^T factorizations near clusters
 of close eigenvalues (referred to as RRRs, Relatively Robust
 Representations). An informal sketch of the algorithm follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 For more details, see:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.

 Further Details
 1.ZSTEMR works only on machines which follow IEEE-754
 floating-point standard in their handling of infinities and NaNs.
 This permits the use of efficient inner loops avoiding a check for
 zero divisors.

 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
 real symmetric tridiagonal form.

 (Any complex Hermitean tridiagonal matrix has real values on its diagonal
 and potentially complex numbers on its off-diagonals. By applying a
 similarity transform with an appropriate diagonal matrix
 diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
 matrix can be transformed into a real symmetric matrix and complex
 arithmetic can be entirely avoided.)

 While the eigenvectors of the real symmetric tridiagonal matrix are real,
 the eigenvectors of original complex Hermitean matrix have complex entries
 in general.
 Since LAPACK drivers overwrite the matrix data with the eigenvectors,
 ZSTEMR accepts complex workspace to facilitate interoperability
 with ZUNMTR or ZUPMTR.

 */
extern proc LAPACKE_zstemr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zstemr
 */
inline proc LAPACKE_zstemr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int) : c_int{
  return LAPACKE_zstemr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssteqr

Original Fortran LAPACK documentation for SSTEQR::

 SSTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the implicit QL or QR method.
 The eigenvectors of a full or band symmetric matrix can also be found
 if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to
 tridiagonal form.

 */
extern proc LAPACKE_ssteqr(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssteqr
 */
inline proc LAPACKE_ssteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_ssteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsteqr

Original Fortran LAPACK documentation for DSTEQR::

 DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the implicit QL or QR method.
 The eigenvectors of a full or band symmetric matrix can also be found
 if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
 tridiagonal form.

 */
extern proc LAPACKE_dsteqr(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsteqr
 */
inline proc LAPACKE_dsteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dsteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csteqr

Original Fortran LAPACK documentation for CSTEQR::

 CSTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the implicit QL or QR method.
 The eigenvectors of a full or band complex Hermitian matrix can also
 be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
 matrix to tridiagonal form.

 */
extern proc LAPACKE_csteqr(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csteqr
 */
inline proc LAPACKE_csteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_csteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsteqr

Original Fortran LAPACK documentation for ZSTEQR::

 ZSTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the implicit QL or QR method.
 The eigenvectors of a full or band complex Hermitian matrix can also
 be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
 matrix to tridiagonal form.

 */
extern proc LAPACKE_zsteqr(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsteqr
 */
inline proc LAPACKE_zsteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zsteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssterf

Original Fortran LAPACK documentation for SSTERF::

 SSTERF computes all eigenvalues of a symmetric tridiagonal matrix
 using the Pal-Walker-Kahan variant of the QL or QR algorithm.

 */
extern proc LAPACKE_ssterf(n : c_int, d : [] c_float, e : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dsterf

Original Fortran LAPACK documentation for DSTERF::

 DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
 using the Pal-Walker-Kahan variant of the QL or QR algorithm.

 */
extern proc LAPACKE_dsterf(n : c_int, d : [] c_double, e : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sstev

Original Fortran LAPACK documentation for SSTEV::

 SSTEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix A.

 */
extern proc LAPACKE_sstev(matrix_order : lapack_memory_order, jobz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstev
 */
inline proc LAPACKE_sstev(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_sstev(matrix_order, ascii(jobz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstev

Original Fortran LAPACK documentation for DSTEV::

 DSTEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix A.

 */
extern proc LAPACKE_dstev(matrix_order : lapack_memory_order, jobz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstev
 */
inline proc LAPACKE_dstev(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dstev(matrix_order, ascii(jobz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstevd

Original Fortran LAPACK documentation for SSTEVD::

 SSTEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_sstevd(matrix_order : lapack_memory_order, jobz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstevd
 */
inline proc LAPACKE_sstevd(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_sstevd(matrix_order, ascii(jobz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstevd

Original Fortran LAPACK documentation for DSTEVD::

 DSTEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_dstevd(matrix_order : lapack_memory_order, jobz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstevd
 */
inline proc LAPACKE_dstevd(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dstevd(matrix_order, ascii(jobz) : c_char, n, d, e, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstevr

Original Fortran LAPACK documentation for SSTEVR::

 SSTEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

 Whenever possible, SSTEVR calls SSTEMR to compute the
 eigenspectrum using Relatively Robust Representations. SSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows. For the i-th
 unreduced block of T,
 (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
 is a relatively robust representation,
 (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
 relative accuracy by the dqds algorithm,
 (c) If there is a cluster of close eigenvalues, "choose" sigma_i
 close to the cluster, and go to step (a),
 (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
 compute the corresponding eigenvector by forming a
 rank-revealing twisted factorization.
 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
 Computer Science Division Technical Report No. UCB//CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : SSTEVR calls SSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 SSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of SSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACKE_sstevr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstevr
 */
inline proc LAPACKE_sstevr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_sstevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstevr

Original Fortran LAPACK documentation for DSTEVR::

 DSTEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

 Whenever possible, DSTEVR calls DSTEMR to compute the
 eigenspectrum using Relatively Robust Representations. DSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows. For the i-th
 unreduced block of T,
 (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
 is a relatively robust representation,
 (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
 relative accuracy by the dqds algorithm,
 (c) If there is a cluster of close eigenvalues, "choose" sigma_i
 close to the cluster, and go to step (a),
 (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
 compute the corresponding eigenvector by forming a
 rank-revealing twisted factorization.
 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
 Computer Science Division Technical Report No. UCB//CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : DSTEVR calls DSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 DSTEVR calls DSTEBZ and DSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of DSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACKE_dstevr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstevr
 */
inline proc LAPACKE_dstevr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_dstevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstevx

Original Fortran LAPACK documentation for SSTEVX::

 SSTEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix A. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_sstevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstevx
 */
inline proc LAPACKE_sstevx(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_sstevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstevx

Original Fortran LAPACK documentation for DSTEVX::

 DSTEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix A. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_dstevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstevx
 */
inline proc LAPACKE_dstevx(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dstevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssycon

Original Fortran LAPACK documentation for SSYCON::

 SSYCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by SSYTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_ssycon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssycon
 */
inline proc LAPACKE_ssycon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_ssycon(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsycon

Original Fortran LAPACK documentation for DSYCON::

 DSYCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by DSYTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_dsycon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsycon
 */
inline proc LAPACKE_dsycon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_dsycon(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csycon

Original Fortran LAPACK documentation for CSYCON::

 CSYCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex symmetric matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by CSYTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_csycon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csycon
 */
inline proc LAPACKE_csycon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float) : c_int{
  return LAPACKE_csycon(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsycon

Original Fortran LAPACK documentation for ZSYCON::

 ZSYCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex symmetric matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by ZSYTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACKE_zsycon(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsycon
 */
inline proc LAPACKE_zsycon(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double) : c_int{
  return LAPACKE_zsycon(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyequb

Original Fortran LAPACK documentation for SSYEQUB::

 SSYEQUB computes row and column scalings intended to equilibrate a
 symmetric matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_ssyequb(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyequb
 */
inline proc LAPACKE_ssyequb(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_ssyequb(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyequb

Original Fortran LAPACK documentation for DSYEQUB::

 DSYEQUB computes row and column scalings intended to equilibrate a
 symmetric matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_dsyequb(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyequb
 */
inline proc LAPACKE_dsyequb(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_dsyequb(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyequb

Original Fortran LAPACK documentation for CSYEQUB::

 CSYEQUB computes row and column scalings intended to equilibrate a
 symmetric matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_csyequb(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyequb
 */
inline proc LAPACKE_csyequb(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_csyequb(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyequb

Original Fortran LAPACK documentation for ZSYEQUB::

 ZSYEQUB computes row and column scalings intended to equilibrate a
 symmetric matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACKE_zsyequb(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyequb
 */
inline proc LAPACKE_zsyequb(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_zsyequb(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyev

Original Fortran LAPACK documentation for SSYEV::

 SSYEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A.

 */
extern proc LAPACKE_ssyev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, w : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyev
 */
inline proc LAPACKE_ssyev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, w : [] c_float) : c_int{
  return LAPACKE_ssyev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyev

Original Fortran LAPACK documentation for DSYEV::

 DSYEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A.

 */
extern proc LAPACKE_dsyev(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, w : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyev
 */
inline proc LAPACKE_dsyev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, w : [] c_double) : c_int{
  return LAPACKE_dsyev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyevd

Original Fortran LAPACK documentation for SSYEVD::

 SSYEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 Because of large use of BLAS of level 3, SSYEVD needs N**2 more
 workspace than SSYEVX.

 */
extern proc LAPACKE_ssyevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, w : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyevd
 */
inline proc LAPACKE_ssyevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, w : [] c_float) : c_int{
  return LAPACKE_ssyevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyevd

Original Fortran LAPACK documentation for DSYEVD::

 DSYEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 Because of large use of BLAS of level 3, DSYEVD needs N**2 more
 workspace than DSYEVX.

 */
extern proc LAPACKE_dsyevd(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, w : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyevd
 */
inline proc LAPACKE_dsyevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, w : [] c_double) : c_int{
  return LAPACKE_dsyevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyevr

Original Fortran LAPACK documentation for SSYEVR::

 SSYEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 SSYEVR first reduces the matrix A to tridiagonal form T with a call
 to SSYTRD. Then, whenever possible, SSYEVR calls SSTEMR to compute
 the eigenspectrum using Relatively Robust Representations. SSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see SSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : SSYEVR calls SSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 SSYEVR calls SSTEBZ and SSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of SSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACKE_ssyevr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyevr
 */
inline proc LAPACKE_ssyevr(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_ssyevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyevr

Original Fortran LAPACK documentation for DSYEVR::

 DSYEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 DSYEVR first reduces the matrix A to tridiagonal form T with a call
 to DSYTRD. Then, whenever possible, DSYEVR calls DSTEMR to compute
 the eigenspectrum using Relatively Robust Representations. DSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see DSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : DSYEVR calls DSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 DSYEVR calls DSTEBZ and SSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of DSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACKE_dsyevr(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyevr
 */
inline proc LAPACKE_dsyevr(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int) : c_int{
  return LAPACKE_dsyevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyevx

Original Fortran LAPACK documentation for SSYEVX::

 SSYEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

 */
extern proc LAPACKE_ssyevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyevx
 */
inline proc LAPACKE_ssyevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_ssyevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyevx

Original Fortran LAPACK documentation for DSYEVX::

 DSYEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

 */
extern proc LAPACKE_dsyevx(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyevx
 */
inline proc LAPACKE_dsyevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dsyevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssygst

Original Fortran LAPACK documentation for SSYGST::

 SSYGST reduces a real symmetric-definite generalized eigenproblem
 to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by SPOTRF.

 */
extern proc LAPACKE_ssygst(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssygst
 */
inline proc LAPACKE_ssygst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_ssygst(matrix_order, itype, ascii(uplo) : c_char, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsygst

Original Fortran LAPACK documentation for DSYGST::

 DSYGST reduces a real symmetric-definite generalized eigenproblem
 to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by DPOTRF.

 */
extern proc LAPACKE_dsygst(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsygst
 */
inline proc LAPACKE_dsygst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dsygst(matrix_order, itype, ascii(uplo) : c_char, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssygv

Original Fortran LAPACK documentation for SSYGV::

 SSYGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric and B is also
 positive definite.

 */
extern proc LAPACKE_ssygv(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, w : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssygv
 */
inline proc LAPACKE_ssygv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, w : [] c_float) : c_int{
  return LAPACKE_ssygv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsygv

Original Fortran LAPACK documentation for DSYGV::

 DSYGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric and B is also
 positive definite.

 */
extern proc LAPACKE_dsygv(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, w : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsygv
 */
inline proc LAPACKE_dsygv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, w : [] c_double) : c_int{
  return LAPACKE_dsygv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssygvd

Original Fortran LAPACK documentation for SSYGVD::

 SSYGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_ssygvd(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, w : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssygvd
 */
inline proc LAPACKE_ssygvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, w : [] c_float) : c_int{
  return LAPACKE_ssygvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsygvd

Original Fortran LAPACK documentation for DSYGVD::

 DSYGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACKE_dsygvd(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, w : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsygvd
 */
inline proc LAPACKE_dsygvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, w : [] c_double) : c_int{
  return LAPACKE_dsygvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssygvx

Original Fortran LAPACK documentation for SSYGVX::

 SSYGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_ssygvx(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssygvx
 */
inline proc LAPACKE_ssygvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_ssygvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsygvx

Original Fortran LAPACK documentation for DSYGVX::

 DSYGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACKE_dsygvx(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsygvx
 */
inline proc LAPACKE_dsygvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dsygvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyrfs

Original Fortran LAPACK documentation for SSYRFS::

 SSYRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_ssyrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyrfs
 */
inline proc LAPACKE_ssyrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_ssyrfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyrfs

Original Fortran LAPACK documentation for DSYRFS::

 DSYRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_dsyrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyrfs
 */
inline proc LAPACKE_dsyrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dsyrfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyrfs

Original Fortran LAPACK documentation for CSYRFS::

 CSYRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_csyrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyrfs
 */
inline proc LAPACKE_csyrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_csyrfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyrfs

Original Fortran LAPACK documentation for ZSYRFS::

 ZSYRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACKE_zsyrfs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyrfs
 */
inline proc LAPACKE_zsyrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zsyrfs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyrfsx

Original Fortran LAPACK documentation for SSYRFSX::

 SSYRFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_ssyrfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyrfsx
 */
inline proc LAPACKE_ssyrfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_ssyrfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyrfsx

Original Fortran LAPACK documentation for DSYRFSX::

 DSYRFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_dsyrfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyrfsx
 */
inline proc LAPACKE_dsyrfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_dsyrfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyrfsx

Original Fortran LAPACK documentation for CSYRFSX::

 CSYRFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_csyrfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyrfsx
 */
inline proc LAPACKE_csyrfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_csyrfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyrfsx

Original Fortran LAPACK documentation for ZSYRFSX::

 ZSYRFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACKE_zsyrfsx(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyrfsx
 */
inline proc LAPACKE_zsyrfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zsyrfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssysv

Original Fortran LAPACK documentation for SSYSV::

 SSYSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_ssysv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssysv
 */
inline proc LAPACKE_ssysv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_ssysv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsysv

Original Fortran LAPACK documentation for DSYSV::

 DSYSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_dsysv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsysv
 */
inline proc LAPACKE_dsysv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dsysv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csysv

Original Fortran LAPACK documentation for CSYSV::

 CSYSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_csysv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csysv
 */
inline proc LAPACKE_csysv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_csysv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsysv

Original Fortran LAPACK documentation for ZSYSV::

 ZSYSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACKE_zsysv(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsysv
 */
inline proc LAPACKE_zsysv(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zsysv(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssysvx

Original Fortran LAPACK documentation for SSYSVX::

 SSYSVX uses the diagonal pivoting factorization to compute the
 solution to a real system of linear equations A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_ssysvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssysvx
 */
inline proc LAPACKE_ssysvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_ssysvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsysvx

Original Fortran LAPACK documentation for DSYSVX::

 DSYSVX uses the diagonal pivoting factorization to compute the
 solution to a real system of linear equations A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_dsysvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsysvx
 */
inline proc LAPACKE_dsysvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dsysvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csysvx

Original Fortran LAPACK documentation for CSYSVX::

 CSYSVX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_csysvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csysvx
 */
inline proc LAPACKE_csysvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_csysvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsysvx

Original Fortran LAPACK documentation for ZSYSVX::

 ZSYSVX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACKE_zsysvx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsysvx
 */
inline proc LAPACKE_zsysvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_zsysvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssysvxx

Original Fortran LAPACK documentation for SSYSVXX::

 SSYSVXX uses the diagonal pivoting factorization to compute the
 solution to a real system of linear equations A * X = B, where A
 is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SSYSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SSYSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SSYSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SSYSVXX would itself produce.

 */
extern proc LAPACKE_ssysvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssysvxx
 */
inline proc LAPACKE_ssysvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_ssysvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsysvxx

Original Fortran LAPACK documentation for DSYSVXX::

 DSYSVXX uses the diagonal pivoting factorization to compute the
 solution to a double precision system of linear equations A * X = B, where A
 is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. DSYSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 DSYSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 DSYSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what DSYSVXX would itself produce.

 */
extern proc LAPACKE_dsysvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsysvxx
 */
inline proc LAPACKE_dsysvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_dsysvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csysvxx

Original Fortran LAPACK documentation for CSYSVXX::

 CSYSVXX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B, where
 A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CSYSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CSYSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CSYSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CSYSVXX would itself produce.

 */
extern proc LAPACKE_csysvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csysvxx
 */
inline proc LAPACKE_csysvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float) : c_int{
  return LAPACKE_csysvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsysvxx

Original Fortran LAPACK documentation for ZSYSVXX::

 ZSYSVXX uses the diagonal pivoting factorization to compute the
 solution to a complex*16 system of linear equations A * X = B, where
 A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZSYSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZSYSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZSYSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZSYSVXX would itself produce.

 */
extern proc LAPACKE_zsysvxx(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsysvxx
 */
inline proc LAPACKE_zsysvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double) : c_int{
  return LAPACKE_zsysvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytrd

Original Fortran LAPACK documentation for SSYTRD::

 SSYTRD reduces a real symmetric matrix A to real symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

 */
extern proc LAPACKE_ssytrd(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, d : [] c_float, e : [] c_float, tau : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytrd
 */
inline proc LAPACKE_ssytrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, d : [] c_float, e : [] c_float, tau : [] c_float) : c_int{
  return LAPACKE_ssytrd(matrix_order, ascii(uplo) : c_char, n, a, lda, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytrd

Original Fortran LAPACK documentation for DSYTRD::

 DSYTRD reduces a real symmetric matrix A to real symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

 */
extern proc LAPACKE_dsytrd(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, d : [] c_double, e : [] c_double, tau : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytrd
 */
inline proc LAPACKE_dsytrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, d : [] c_double, e : [] c_double, tau : [] c_double) : c_int{
  return LAPACKE_dsytrd(matrix_order, ascii(uplo) : c_char, n, a, lda, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytrf

Original Fortran LAPACK documentation for SSYTRF::

 SSYTRF computes the factorization of a real symmetric matrix A using
 the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with 
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_ssytrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytrf
 */
inline proc LAPACKE_ssytrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_ssytrf(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytrf

Original Fortran LAPACK documentation for DSYTRF::

 DSYTRF computes the factorization of a real symmetric matrix A using
 the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_dsytrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytrf
 */
inline proc LAPACKE_dsytrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_dsytrf(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytrf

Original Fortran LAPACK documentation for CSYTRF::

 CSYTRF computes the factorization of a complex symmetric matrix A
 using the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 with 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_csytrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytrf
 */
inline proc LAPACKE_csytrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_csytrf(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytrf

Original Fortran LAPACK documentation for ZSYTRF::

 ZSYTRF computes the factorization of a complex symmetric matrix A
 using the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 with 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACKE_zsytrf(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytrf
 */
inline proc LAPACKE_zsytrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_zsytrf(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytri

Original Fortran LAPACK documentation for SSYTRI::

 SSYTRI computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 SSYTRF.

 */
extern proc LAPACKE_ssytri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytri
 */
inline proc LAPACKE_ssytri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_ssytri(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytri

Original Fortran LAPACK documentation for DSYTRI::

 DSYTRI computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 DSYTRF.

 */
extern proc LAPACKE_dsytri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytri
 */
inline proc LAPACKE_dsytri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_dsytri(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytri

Original Fortran LAPACK documentation for CSYTRI::

 CSYTRI computes the inverse of a complex symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CSYTRF.

 */
extern proc LAPACKE_csytri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytri
 */
inline proc LAPACKE_csytri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_csytri(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytri

Original Fortran LAPACK documentation for ZSYTRI::

 ZSYTRI computes the inverse of a complex symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 ZSYTRF.

 */
extern proc LAPACKE_zsytri(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytri
 */
inline proc LAPACKE_zsytri(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_zsytri(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytrs

Original Fortran LAPACK documentation for SSYTRS::

 SSYTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by SSYTRF.

 */
extern proc LAPACKE_ssytrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytrs
 */
inline proc LAPACKE_ssytrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_ssytrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytrs

Original Fortran LAPACK documentation for DSYTRS::

 DSYTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by DSYTRF.

 */
extern proc LAPACKE_dsytrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytrs
 */
inline proc LAPACKE_dsytrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dsytrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytrs

Original Fortran LAPACK documentation for CSYTRS::

 CSYTRS solves a system of linear equations A*X = B with a complex
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by CSYTRF.

 */
extern proc LAPACKE_csytrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytrs
 */
inline proc LAPACKE_csytrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_csytrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytrs

Original Fortran LAPACK documentation for ZSYTRS::

 ZSYTRS solves a system of linear equations A*X = B with a complex
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by ZSYTRF.

 */
extern proc LAPACKE_zsytrs(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytrs
 */
inline proc LAPACKE_zsytrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zsytrs(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stbcon

Original Fortran LAPACK documentation for STBCON::

 STBCON estimates the reciprocal of the condition number of a
 triangular band matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_stbcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stbcon
 */
inline proc LAPACKE_stbcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, ref rcond : c_float) : c_int{
  return LAPACKE_stbcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, ldab, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtbcon

Original Fortran LAPACK documentation for DTBCON::

 DTBCON estimates the reciprocal of the condition number of a
 triangular band matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_dtbcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtbcon
 */
inline proc LAPACKE_dtbcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, ref rcond : c_double) : c_int{
  return LAPACKE_dtbcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, ldab, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctbcon

Original Fortran LAPACK documentation for CTBCON::

 CTBCON estimates the reciprocal of the condition number of a
 triangular band matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_ctbcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctbcon
 */
inline proc LAPACKE_ctbcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, ref rcond : c_float) : c_int{
  return LAPACKE_ctbcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, ldab, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztbcon

Original Fortran LAPACK documentation for ZTBCON::

 ZTBCON estimates the reciprocal of the condition number of a
 triangular band matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_ztbcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztbcon
 */
inline proc LAPACKE_ztbcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, ref rcond : c_double) : c_int{
  return LAPACKE_ztbcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, ldab, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stbrfs

Original Fortran LAPACK documentation for STBRFS::

 STBRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular band
 coefficient matrix.

 The solution matrix X must be computed by STBTRS or some other
 means before entering this routine. STBRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_stbrfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stbrfs
 */
inline proc LAPACKE_stbrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_stbrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtbrfs

Original Fortran LAPACK documentation for DTBRFS::

 DTBRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular band
 coefficient matrix.

 The solution matrix X must be computed by DTBTRS or some other
 means before entering this routine. DTBRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_dtbrfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtbrfs
 */
inline proc LAPACKE_dtbrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dtbrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctbrfs

Original Fortran LAPACK documentation for CTBRFS::

 CTBRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular band
 coefficient matrix.

 The solution matrix X must be computed by CTBTRS or some other
 means before entering this routine. CTBRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_ctbrfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctbrfs
 */
inline proc LAPACKE_ctbrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_ctbrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztbrfs

Original Fortran LAPACK documentation for ZTBRFS::

 ZTBRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular band
 coefficient matrix.

 The solution matrix X must be computed by ZTBTRS or some other
 means before entering this routine. ZTBRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_ztbrfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztbrfs
 */
inline proc LAPACKE_ztbrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_ztbrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stbtrs

Original Fortran LAPACK documentation for STBTRS::

 STBTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular band matrix of order N, and B is an
 N-by NRHS matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACKE_stbtrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stbtrs
 */
inline proc LAPACKE_stbtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_stbtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtbtrs

Original Fortran LAPACK documentation for DTBTRS::

 DTBTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular band matrix of order N, and B is an
 N-by NRHS matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACKE_dtbtrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtbtrs
 */
inline proc LAPACKE_dtbtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtbtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctbtrs

Original Fortran LAPACK documentation for CTBTRS::

 CTBTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular band matrix of order N, and B is an
 N-by-NRHS matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACKE_ctbtrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctbtrs
 */
inline proc LAPACKE_ctbtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctbtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztbtrs

Original Fortran LAPACK documentation for ZTBTRS::

 ZTBTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular band matrix of order N, and B is an
 N-by-NRHS matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACKE_ztbtrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztbtrs
 */
inline proc LAPACKE_ztbtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztbtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stfsm

Original Fortran LAPACK documentation for STFSM::

 Level 3 BLAS like routine for A in RFP Format.

 STFSM solves the matrix equation

 op( A )*X = alpha*B or X*op( A ) = alpha*B

 where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 non-unit, upper or lower triangular matrix and op( A ) is one of

 op( A ) = A or op( A ) = A**T.

 A is in Rectangular Full Packed (RFP) Format.

 The matrix X is overwritten on B.

 */
extern proc LAPACKE_stfsm(matrix_order : lapack_memory_order, transr : c_char, side : c_char, uplo : c_char, trans : c_char, diag : c_char, m : c_int, n : c_int, alpha : c_float, a : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stfsm
 */
inline proc LAPACKE_stfsm(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, m : c_int, n : c_int, alpha : c_float, a : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_stfsm(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, m, n, alpha, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtfsm

Original Fortran LAPACK documentation for DTFSM::

 Level 3 BLAS like routine for A in RFP Format.

 DTFSM solves the matrix equation

 op( A )*X = alpha*B or X*op( A ) = alpha*B

 where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 non-unit, upper or lower triangular matrix and op( A ) is one of

 op( A ) = A or op( A ) = A**T.

 A is in Rectangular Full Packed (RFP) Format.

 The matrix X is overwritten on B.

 */
extern proc LAPACKE_dtfsm(matrix_order : lapack_memory_order, transr : c_char, side : c_char, uplo : c_char, trans : c_char, diag : c_char, m : c_int, n : c_int, alpha : c_double, a : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtfsm
 */
inline proc LAPACKE_dtfsm(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, m : c_int, n : c_int, alpha : c_double, a : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtfsm(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, m, n, alpha, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctfsm

Original Fortran LAPACK documentation for CTFSM::

 Level 3 BLAS like routine for A in RFP Format.

 CTFSM solves the matrix equation

 op( A )*X = alpha*B or X*op( A ) = alpha*B

 where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 non-unit, upper or lower triangular matrix and op( A ) is one of

 op( A ) = A or op( A ) = A**H.

 A is in Rectangular Full Packed (RFP) Format.

 The matrix X is overwritten on B.

 */
extern proc LAPACKE_ctfsm(matrix_order : lapack_memory_order, transr : c_char, side : c_char, uplo : c_char, trans : c_char, diag : c_char, m : c_int, n : c_int, alpha : complex(64), a : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctfsm
 */
inline proc LAPACKE_ctfsm(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, m : c_int, n : c_int, alpha : complex(64), a : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctfsm(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, m, n, alpha, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztfsm

Original Fortran LAPACK documentation for ZTFSM::

 Level 3 BLAS like routine for A in RFP Format.

 ZTFSM solves the matrix equation

 op( A )*X = alpha*B or X*op( A ) = alpha*B

 where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 non-unit, upper or lower triangular matrix and op( A ) is one of

 op( A ) = A or op( A ) = A**H.

 A is in Rectangular Full Packed (RFP) Format.

 The matrix X is overwritten on B.

 */
extern proc LAPACKE_ztfsm(matrix_order : lapack_memory_order, transr : c_char, side : c_char, uplo : c_char, trans : c_char, diag : c_char, m : c_int, n : c_int, alpha : complex(128), a : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztfsm
 */
inline proc LAPACKE_ztfsm(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, m : c_int, n : c_int, alpha : complex(128), a : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztfsm(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, m, n, alpha, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stftri

Original Fortran LAPACK documentation for STFTRI::

 STFTRI computes the inverse of a triangular matrix A stored in RFP
 format.

 This is a Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_stftri(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stftri
 */
inline proc LAPACKE_stftri(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, n : c_int, a : [] c_float) : c_int{
  return LAPACKE_stftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtftri

Original Fortran LAPACK documentation for DTFTRI::

 DTFTRI computes the inverse of a triangular matrix A stored in RFP
 format.

 This is a Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_dtftri(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtftri
 */
inline proc LAPACKE_dtftri(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, n : c_int, a : [] c_double) : c_int{
  return LAPACKE_dtftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctftri

Original Fortran LAPACK documentation for CTFTRI::

 CTFTRI computes the inverse of a triangular matrix A stored in RFP
 format.

 This is a Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_ctftri(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctftri
 */
inline proc LAPACKE_ctftri(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, n : c_int, a : [] complex(64)) : c_int{
  return LAPACKE_ctftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztftri

Original Fortran LAPACK documentation for ZTFTRI::

 ZTFTRI computes the inverse of a triangular matrix A stored in RFP
 format.

 This is a Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_ztftri(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztftri
 */
inline proc LAPACKE_ztftri(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, n : c_int, a : [] complex(128)) : c_int{
  return LAPACKE_ztftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stfttp

Original Fortran LAPACK documentation for STFTTP::

 STFTTP copies a triangular matrix A from rectangular full packed
 format (TF) to standard packed format (TP).

 */
extern proc LAPACKE_stfttp(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] c_float, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stfttp
 */
inline proc LAPACKE_stfttp(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_float, ap : [] c_float) : c_int{
  return LAPACKE_stfttp(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtfttp

Original Fortran LAPACK documentation for DTFTTP::

 DTFTTP copies a triangular matrix A from rectangular full packed
 format (TF) to standard packed format (TP).

 */
extern proc LAPACKE_dtfttp(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] c_double, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtfttp
 */
inline proc LAPACKE_dtfttp(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_double, ap : [] c_double) : c_int{
  return LAPACKE_dtfttp(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctfttp

Original Fortran LAPACK documentation for CTFTTP::

 CTFTTP copies a triangular matrix A from rectangular full packed
 format (TF) to standard packed format (TP).

 */
extern proc LAPACKE_ctfttp(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] complex(64), ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctfttp
 */
inline proc LAPACKE_ctfttp(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(64), ap : [] complex(64)) : c_int{
  return LAPACKE_ctfttp(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztfttp

Original Fortran LAPACK documentation for ZTFTTP::

 ZTFTTP copies a triangular matrix A from rectangular full packed
 format (TF) to standard packed format (TP).

 */
extern proc LAPACKE_ztfttp(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] complex(128), ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztfttp
 */
inline proc LAPACKE_ztfttp(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(128), ap : [] complex(128)) : c_int{
  return LAPACKE_ztfttp(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stfttr

Original Fortran LAPACK documentation for STFTTR::

 STFTTR copies a triangular matrix A from rectangular full packed
 format (TF) to standard full format (TR).

 */
extern proc LAPACKE_stfttr(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] c_float, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stfttr
 */
inline proc LAPACKE_stfttr(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_float, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_stfttr(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtfttr

Original Fortran LAPACK documentation for DTFTTR::

 DTFTTR copies a triangular matrix A from rectangular full packed
 format (TF) to standard full format (TR).

 */
extern proc LAPACKE_dtfttr(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] c_double, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtfttr
 */
inline proc LAPACKE_dtfttr(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_double, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dtfttr(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctfttr

Original Fortran LAPACK documentation for CTFTTR::

 CTFTTR copies a triangular matrix A from rectangular full packed
 format (TF) to standard full format (TR).

 */
extern proc LAPACKE_ctfttr(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] complex(64), a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctfttr
 */
inline proc LAPACKE_ctfttr(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(64), a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_ctfttr(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztfttr

Original Fortran LAPACK documentation for ZTFTTR::

 ZTFTTR copies a triangular matrix A from rectangular full packed
 format (TF) to standard full format (TR).

 */
extern proc LAPACKE_ztfttr(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] complex(128), a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztfttr
 */
inline proc LAPACKE_ztfttr(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(128), a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_ztfttr(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stgevc

Original Fortran LAPACK documentation for STGEVC::

 STGEVC computes some or all of the right and/or left eigenvectors of
 a pair of real matrices (S,P), where S is a quasi-triangular matrix
 and P is upper triangular. Matrix pairs of this type are produced by
 the generalized Schur factorization of a matrix pair (A,B):

 A = Q*S*Z**T, B = Q*P*Z**T

 as computed by SGGHRD + SHGEQZ.

 The right eigenvector x and the left eigenvector y of (S,P)
 corresponding to an eigenvalue w are defined by:
 
 S*x = w*P*x, (y**H)*S = w*(y**H)*P,
 
 where y**H denotes the conjugate tranpose of y.
 The eigenvalues are not input to this routine, but are computed
 directly from the diagonal blocks of S and P.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 where Z and Q are input matrices.
 If Q and Z are the orthogonal factors from the generalized Schur
 factorization of a matrix pair (A,B), then Z*X and Q*Y
 are the matrices of right and left eigenvectors of (A,B).

 */
extern proc LAPACKE_stgevc(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, s : [] c_float, lds : c_int, p : [] c_float, ldp : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stgevc
 */
inline proc LAPACKE_stgevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, s : [] c_float, lds : c_int, p : [] c_float, ldp : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_stgevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgevc

Original Fortran LAPACK documentation for DTGEVC::

 DTGEVC computes some or all of the right and/or left eigenvectors of
 a pair of real matrices (S,P), where S is a quasi-triangular matrix
 and P is upper triangular. Matrix pairs of this type are produced by
 the generalized Schur factorization of a matrix pair (A,B):

 A = Q*S*Z**T, B = Q*P*Z**T

 as computed by DGGHRD + DHGEQZ.

 The right eigenvector x and the left eigenvector y of (S,P)
 corresponding to an eigenvalue w are defined by:
 
 S*x = w*P*x, (y**H)*S = w*(y**H)*P,
 
 where y**H denotes the conjugate tranpose of y.
 The eigenvalues are not input to this routine, but are computed
 directly from the diagonal blocks of S and P.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 where Z and Q are input matrices.
 If Q and Z are the orthogonal factors from the generalized Schur
 factorization of a matrix pair (A,B), then Z*X and Q*Y
 are the matrices of right and left eigenvectors of (A,B).

 */
extern proc LAPACKE_dtgevc(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, s : [] c_double, lds : c_int, p : [] c_double, ldp : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtgevc
 */
inline proc LAPACKE_dtgevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, s : [] c_double, lds : c_int, p : [] c_double, ldp : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_dtgevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgevc

Original Fortran LAPACK documentation for CTGEVC::

 CTGEVC computes some or all of the right and/or left eigenvectors of
 a pair of complex matrices (S,P), where S and P are upper triangular.
 Matrix pairs of this type are produced by the generalized Schur
 factorization of a complex matrix pair (A,B):
 
 A = Q*S*Z**H, B = Q*P*Z**H
 
 as computed by CGGHRD + CHGEQZ.
 
 The right eigenvector x and the left eigenvector y of (S,P)
 corresponding to an eigenvalue w are defined by:
 
 S*x = w*P*x, (y**H)*S = w*(y**H)*P,
 
 where y**H denotes the conjugate tranpose of y.
 The eigenvalues are not input to this routine, but are computed
 directly from the diagonal elements of S and P.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 where Z and Q are input matrices.
 If Q and Z are the unitary factors from the generalized Schur
 factorization of a matrix pair (A,B), then Z*X and Q*Y
 are the matrices of right and left eigenvectors of (A,B).

 */
extern proc LAPACKE_ctgevc(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, s : [] complex(64), lds : c_int, p : [] complex(64), ldp : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctgevc
 */
inline proc LAPACKE_ctgevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, s : [] complex(64), lds : c_int, p : [] complex(64), ldp : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_ctgevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgevc

Original Fortran LAPACK documentation for ZTGEVC::

 ZTGEVC computes some or all of the right and/or left eigenvectors of
 a pair of complex matrices (S,P), where S and P are upper triangular.
 Matrix pairs of this type are produced by the generalized Schur
 factorization of a complex matrix pair (A,B):
 
 A = Q*S*Z**H, B = Q*P*Z**H
 
 as computed by ZGGHRD + ZHGEQZ.
 
 The right eigenvector x and the left eigenvector y of (S,P)
 corresponding to an eigenvalue w are defined by:
 
 S*x = w*P*x, (y**H)*S = w*(y**H)*P,
 
 where y**H denotes the conjugate tranpose of y.
 The eigenvalues are not input to this routine, but are computed
 directly from the diagonal elements of S and P.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 where Z and Q are input matrices.
 If Q and Z are the unitary factors from the generalized Schur
 factorization of a matrix pair (A,B), then Z*X and Q*Y
 are the matrices of right and left eigenvectors of (A,B).

 */
extern proc LAPACKE_ztgevc(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, s : [] complex(128), lds : c_int, p : [] complex(128), ldp : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztgevc
 */
inline proc LAPACKE_ztgevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, s : [] complex(128), lds : c_int, p : [] complex(128), ldp : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_ztgevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stgexc

Original Fortran LAPACK documentation for STGEXC::

 STGEXC reorders the generalized real Schur decomposition of a real
 matrix pair (A,B) using an orthogonal equivalence transformation

 (A, B) = Q * (A, B) * Z**T,

 so that the diagonal block of (A, B) with row index IFST is moved
 to row ILST.

 (A, B) must be in generalized real Schur canonical form (as returned
 by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
 diagonal blocks. B is upper triangular.

 Optionally, the matrices Q and Z of generalized Schur vectors are
 updated.

 Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
 Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T

 */
extern proc LAPACKE_stgexc(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int, ref ifst : c_int, ref ilst : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgexc

Original Fortran LAPACK documentation for DTGEXC::

 DTGEXC reorders the generalized real Schur decomposition of a real
 matrix pair (A,B) using an orthogonal equivalence transformation

 (A, B) = Q * (A, B) * Z**T,

 so that the diagonal block of (A, B) with row index IFST is moved
 to row ILST.

 (A, B) must be in generalized real Schur canonical form (as returned
 by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
 diagonal blocks. B is upper triangular.

 Optionally, the matrices Q and Z of generalized Schur vectors are
 updated.

 Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
 Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T

 */
extern proc LAPACKE_dtgexc(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int, ref ifst : c_int, ref ilst : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgexc

Original Fortran LAPACK documentation for CTGEXC::

 CTGEXC reorders the generalized Schur decomposition of a complex
 matrix pair (A,B), using an unitary equivalence transformation
 (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
 row index IFST is moved to row ILST.

 (A, B) must be in generalized Schur canonical form, that is, A and
 B are both upper triangular.

 Optionally, the matrices Q and Z of generalized Schur vectors are
 updated.

 Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
 Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H

 */
extern proc LAPACKE_ctgexc(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int, ifst : c_int, ilst : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgexc

Original Fortran LAPACK documentation for ZTGEXC::

 ZTGEXC reorders the generalized Schur decomposition of a complex
 matrix pair (A,B), using an unitary equivalence transformation
 (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
 row index IFST is moved to row ILST.

 (A, B) must be in generalized Schur canonical form, that is, A and
 B are both upper triangular.

 Optionally, the matrices Q and Z of generalized Schur vectors are
 updated.

 Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
 Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H

 */
extern proc LAPACKE_ztgexc(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int, ifst : c_int, ilst : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stgsen

Original Fortran LAPACK documentation for STGSEN::

 STGSEN reorders the generalized real Schur decomposition of a real
 matrix pair (A, B) (in terms of an orthonormal equivalence trans-
 formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
 appears in the leading diagonal blocks of the upper quasi-triangular
 matrix A and the upper triangular B. The leading columns of Q and
 Z form orthonormal bases of the corresponding left and right eigen-
 spaces (deflating subspaces). (A, B) must be in generalized real
 Schur canonical form (as returned by SGGES), i.e. A is block upper
 triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
 triangular.

 STGSEN also computes the generalized eigenvalues

 w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)

 of the reordered matrix pair (A, B).

 Optionally, STGSEN computes the estimates of reciprocal condition
 numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
 (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
 between the matrix pairs (A11, B11) and (A22,B22) that correspond to
 the selected cluster and the eigenvalues outside the cluster, resp.,
 and norms of "projections" onto left and right eigenspaces w.r.t.
 the selected cluster in the (1,1)-block.

 */
extern proc LAPACKE_stgsen(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int, ref m : c_int, ref pl : c_float, ref pr : c_float, dif : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgsen

Original Fortran LAPACK documentation for DTGSEN::

 DTGSEN reorders the generalized real Schur decomposition of a real
 matrix pair (A, B) (in terms of an orthonormal equivalence trans-
 formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
 appears in the leading diagonal blocks of the upper quasi-triangular
 matrix A and the upper triangular B. The leading columns of Q and
 Z form orthonormal bases of the corresponding left and right eigen-
 spaces (deflating subspaces). (A, B) must be in generalized real
 Schur canonical form (as returned by DGGES), i.e. A is block upper
 triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
 triangular.

 DTGSEN also computes the generalized eigenvalues

 w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)

 of the reordered matrix pair (A, B).

 Optionally, DTGSEN computes the estimates of reciprocal condition
 numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
 (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
 between the matrix pairs (A11, B11) and (A22,B22) that correspond to
 the selected cluster and the eigenvalues outside the cluster, resp.,
 and norms of "projections" onto left and right eigenspaces w.r.t.
 the selected cluster in the (1,1)-block.

 */
extern proc LAPACKE_dtgsen(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int, ref m : c_int, ref pl : c_double, ref pr : c_double, dif : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgsen

Original Fortran LAPACK documentation for CTGSEN::

 CTGSEN reorders the generalized Schur decomposition of a complex
 matrix pair (A, B) (in terms of an unitary equivalence trans-
 formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
 appears in the leading diagonal blocks of the pair (A,B). The leading
 columns of Q and Z form unitary bases of the corresponding left and
 right eigenspaces (deflating subspaces). (A, B) must be in
 generalized Schur canonical form, that is, A and B are both upper
 triangular.

 CTGSEN also computes the generalized eigenvalues

 w(j)= ALPHA(j) / BETA(j)

 of the reordered matrix pair (A, B).

 Optionally, the routine computes estimates of reciprocal condition
 numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
 (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
 between the matrix pairs (A11, B11) and (A22,B22) that correspond to
 the selected cluster and the eigenvalues outside the cluster, resp.,
 and norms of "projections" onto left and right eigenspaces w.r.t.
 the selected cluster in the (1,1)-block.

 */
extern proc LAPACKE_ctgsen(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int, ref m : c_int, ref pl : c_float, ref pr : c_float, dif : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgsen

Original Fortran LAPACK documentation for ZTGSEN::

 ZTGSEN reorders the generalized Schur decomposition of a complex
 matrix pair (A, B) (in terms of an unitary equivalence trans-
 formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
 appears in the leading diagonal blocks of the pair (A,B). The leading
 columns of Q and Z form unitary bases of the corresponding left and
 right eigenspaces (deflating subspaces). (A, B) must be in
 generalized Schur canonical form, that is, A and B are both upper
 triangular.

 ZTGSEN also computes the generalized eigenvalues

 w(j)= ALPHA(j) / BETA(j)

 of the reordered matrix pair (A, B).

 Optionally, the routine computes estimates of reciprocal condition
 numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
 (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
 between the matrix pairs (A11, B11) and (A22,B22) that correspond to
 the selected cluster and the eigenvalues outside the cluster, resp.,
 and norms of "projections" onto left and right eigenspaces w.r.t.
 the selected cluster in the (1,1)-block.

 */
extern proc LAPACKE_ztgsen(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int, ref m : c_int, ref pl : c_double, ref pr : c_double, dif : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stgsja

Original Fortran LAPACK documentation for STGSJA::

 STGSJA computes the generalized singular value decomposition (GSVD)
 of two real upper triangular (or trapezoidal) matrices A and B.

 On entry, it is assumed that matrices A and B have the following
 forms, which may be obtained by the preprocessing subroutine SGGSVP
 from a general M-by-N matrix A and P-by-N matrix B:

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 B = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal.

 On exit,

 U**T *A*Q = D1*( 0 R ), V**T *B*Q = D2*( 0 R ),

 where U, V and Q are orthogonal matrices.
 R is a nonsingular upper triangular matrix, and D1 and D2 are
 ``diagonal'' matrices, which are of the following structures:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 ) K
 L ( 0 0 R22 ) L

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where
 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The computation of the orthogonal transformation matrices U, V or Q
 is optional. These matrices may either be formed explicitly, or they
 may be postmultiplied into input matrices U1, V1, or Q1.

 */
extern proc LAPACKE_stgsja(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, ref ncycle : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stgsja
 */
inline proc LAPACKE_stgsja(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, ref ncycle : c_int) : c_int{
  return LAPACKE_stgsja(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgsja

Original Fortran LAPACK documentation for DTGSJA::

 DTGSJA computes the generalized singular value decomposition (GSVD)
 of two real upper triangular (or trapezoidal) matrices A and B.

 On entry, it is assumed that matrices A and B have the following
 forms, which may be obtained by the preprocessing subroutine DGGSVP
 from a general M-by-N matrix A and P-by-N matrix B:

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 B = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal.

 On exit,

 U**T *A*Q = D1*( 0 R ), V**T *B*Q = D2*( 0 R ),

 where U, V and Q are orthogonal matrices.
 R is a nonsingular upper triangular matrix, and D1 and D2 are
 ``diagonal'' matrices, which are of the following structures:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 ) K
 L ( 0 0 R22 ) L

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where
 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The computation of the orthogonal transformation matrices U, V or Q
 is optional. These matrices may either be formed explicitly, or they
 may be postmultiplied into input matrices U1, V1, or Q1.

 */
extern proc LAPACKE_dtgsja(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, ref ncycle : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtgsja
 */
inline proc LAPACKE_dtgsja(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, ref ncycle : c_int) : c_int{
  return LAPACKE_dtgsja(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgsja

Original Fortran LAPACK documentation for CTGSJA::

 CTGSJA computes the generalized singular value decomposition (GSVD)
 of two complex upper triangular (or trapezoidal) matrices A and B.

 On entry, it is assumed that matrices A and B have the following
 forms, which may be obtained by the preprocessing subroutine CGGSVP
 from a general M-by-N matrix A and P-by-N matrix B:

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 B = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal.

 On exit,

 U**H *A*Q = D1*( 0 R ), V**H *B*Q = D2*( 0 R ),

 where U, V and Q are unitary matrices.
 R is a nonsingular upper triangular matrix, and D1
 and D2 are ``diagonal'' matrices, which are of the following
 structures:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 ) K
 L ( 0 0 R22 ) L

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where
 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The computation of the unitary transformation matrices U, V or Q
 is optional. These matrices may either be formed explicitly, or they
 may be postmultiplied into input matrices U1, V1, or Q1.

 */
extern proc LAPACKE_ctgsja(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, ref ncycle : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctgsja
 */
inline proc LAPACKE_ctgsja(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, ref ncycle : c_int) : c_int{
  return LAPACKE_ctgsja(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgsja

Original Fortran LAPACK documentation for ZTGSJA::

 ZTGSJA computes the generalized singular value decomposition (GSVD)
 of two complex upper triangular (or trapezoidal) matrices A and B.

 On entry, it is assumed that matrices A and B have the following
 forms, which may be obtained by the preprocessing subroutine ZGGSVP
 from a general M-by-N matrix A and P-by-N matrix B:

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 B = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal.

 On exit,

 U**H *A*Q = D1*( 0 R ), V**H *B*Q = D2*( 0 R ),

 where U, V and Q are unitary matrices.
 R is a nonsingular upper triangular matrix, and D1
 and D2 are ``diagonal'' matrices, which are of the following
 structures:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 ) K
 L ( 0 0 R22 ) L

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where
 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The computation of the unitary transformation matrices U, V or Q
 is optional. These matrices may either be formed explicitly, or they
 may be postmultiplied into input matrices U1, V1, or Q1.

 */
extern proc LAPACKE_ztgsja(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, ref ncycle : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztgsja
 */
inline proc LAPACKE_ztgsja(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, ref ncycle : c_int) : c_int{
  return LAPACKE_ztgsja(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stgsna

Original Fortran LAPACK documentation for STGSNA::

 STGSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or eigenvectors of a matrix pair (A, B) in
 generalized real Schur canonical form (or of any matrix pair
 (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
 Z**T denotes the transpose of Z.

 (A, B) must be in generalized real Schur form (as returned by SGGES),
 i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
 blocks. B is upper triangular.

 */
extern proc LAPACKE_stgsna(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stgsna
 */
inline proc LAPACKE_stgsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_stgsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgsna

Original Fortran LAPACK documentation for DTGSNA::

 DTGSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or eigenvectors of a matrix pair (A, B) in
 generalized real Schur canonical form (or of any matrix pair
 (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
 Z**T denotes the transpose of Z.

 (A, B) must be in generalized real Schur form (as returned by DGGES),
 i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
 blocks. B is upper triangular.

 */
extern proc LAPACKE_dtgsna(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtgsna
 */
inline proc LAPACKE_dtgsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_dtgsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgsna

Original Fortran LAPACK documentation for CTGSNA::

 CTGSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or eigenvectors of a matrix pair (A, B).

 (A, B) must be in generalized Schur canonical form, that is, A and
 B are both upper triangular.

 */
extern proc LAPACKE_ctgsna(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctgsna
 */
inline proc LAPACKE_ctgsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_ctgsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgsna

Original Fortran LAPACK documentation for ZTGSNA::

 ZTGSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or eigenvectors of a matrix pair (A, B).

 (A, B) must be in generalized Schur canonical form, that is, A and
 B are both upper triangular.

 */
extern proc LAPACKE_ztgsna(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztgsna
 */
inline proc LAPACKE_ztgsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_ztgsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stgsyl

Original Fortran LAPACK documentation for STGSYL::

 STGSYL solves the generalized Sylvester equation:

 A * R - L * B = scale * C (1)
 D * R - L * E = scale * F

 where R and L are unknown m-by-n matrices, (A, D), (B, E) and
 (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
 respectively, with real entries. (A, D) and (B, E) must be in
 generalized (real) Schur canonical form, i.e. A, B are upper quasi
 triangular and D, E are upper triangular.

 The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
 scaling factor chosen to avoid overflow.

 In matrix notation (1) is equivalent to solve Zx = scale b, where
 Z is defined as

 Z = [ kron(In, A) -kron(B**T, Im) ] (2)
 [ kron(In, D) -kron(E**T, Im) ].

 Here Ik is the identity matrix of size k and X**T is the transpose of
 X. kron(X, Y) is the Kronecker product between the matrices X and Y.

 If TRANS = 'T', STGSYL solves the transposed system Z**T*y = scale*b,
 which is equivalent to solve for R and L in

 A**T * R + D**T * L = scale * C (3)
 R * B**T + L * E**T = scale * -F

 This case (TRANS = 'T') is used to compute an one-norm-based estimate
 of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
 and (B,E), using SLACON.

 If IJOB >= 1, STGSYL computes a Frobenius norm-based estimate
 of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
 reciprocal of the smallest singular value of Z. See [1-2] for more
 information.

 This is a level 3 BLAS algorithm.

 */
extern proc LAPACKE_stgsyl(matrix_order : lapack_memory_order, trans : c_char, ijob : c_int, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, ldc : c_int, d : [] c_float, ldd : c_int, e : [] c_float, lde : c_int, f : [] c_float, ldf : c_int, ref scale : c_float, ref dif : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stgsyl
 */
inline proc LAPACKE_stgsyl(matrix_order : lapack_memory_order, trans : string, ijob : c_int, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, ldc : c_int, d : [] c_float, ldd : c_int, e : [] c_float, lde : c_int, f : [] c_float, ldf : c_int, ref scale : c_float, ref dif : c_float) : c_int{
  return LAPACKE_stgsyl(matrix_order, ascii(trans) : c_char, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgsyl

Original Fortran LAPACK documentation for DTGSYL::

 DTGSYL solves the generalized Sylvester equation:

 A * R - L * B = scale * C (1)
 D * R - L * E = scale * F

 where R and L are unknown m-by-n matrices, (A, D), (B, E) and
 (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
 respectively, with real entries. (A, D) and (B, E) must be in
 generalized (real) Schur canonical form, i.e. A, B are upper quasi
 triangular and D, E are upper triangular.

 The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
 scaling factor chosen to avoid overflow.

 In matrix notation (1) is equivalent to solve Zx = scale b, where
 Z is defined as

 Z = [ kron(In, A) -kron(B**T, Im) ] (2)
 [ kron(In, D) -kron(E**T, Im) ].

 Here Ik is the identity matrix of size k and X**T is the transpose of
 X. kron(X, Y) is the Kronecker product between the matrices X and Y.

 If TRANS = 'T', DTGSYL solves the transposed system Z**T*y = scale*b,
 which is equivalent to solve for R and L in

 A**T * R + D**T * L = scale * C (3)
 R * B**T + L * E**T = scale * -F

 This case (TRANS = 'T') is used to compute an one-norm-based estimate
 of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
 and (B,E), using DLACON.

 If IJOB >= 1, DTGSYL computes a Frobenius norm-based estimate
 of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
 reciprocal of the smallest singular value of Z. See [1-2] for more
 information.

 This is a level 3 BLAS algorithm.

 */
extern proc LAPACKE_dtgsyl(matrix_order : lapack_memory_order, trans : c_char, ijob : c_int, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, ldc : c_int, d : [] c_double, ldd : c_int, e : [] c_double, lde : c_int, f : [] c_double, ldf : c_int, ref scale : c_double, ref dif : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtgsyl
 */
inline proc LAPACKE_dtgsyl(matrix_order : lapack_memory_order, trans : string, ijob : c_int, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, ldc : c_int, d : [] c_double, ldd : c_int, e : [] c_double, lde : c_int, f : [] c_double, ldf : c_int, ref scale : c_double, ref dif : c_double) : c_int{
  return LAPACKE_dtgsyl(matrix_order, ascii(trans) : c_char, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgsyl

Original Fortran LAPACK documentation for CTGSYL::

 CTGSYL solves the generalized Sylvester equation:

 A * R - L * B = scale * C (1)
 D * R - L * E = scale * F

 where R and L are unknown m-by-n matrices, (A, D), (B, E) and
 (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
 respectively, with complex entries. A, B, D and E are upper
 triangular (i.e., (A,D) and (B,E) in generalized Schur form).

 The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
 is an output scaling factor chosen to avoid overflow.

 In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
 is defined as

 Z = [ kron(In, A) -kron(B**H, Im) ] (2)
 [ kron(In, D) -kron(E**H, Im) ],

 Here Ix is the identity matrix of size x and X**H is the conjugate
 transpose of X. Kron(X, Y) is the Kronecker product between the
 matrices X and Y.

 If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
 is solved for, which is equivalent to solve for R and L in

 A**H * R + D**H * L = scale * C (3)
 R * B**H + L * E**H = scale * -F

 This case (TRANS = 'C') is used to compute an one-norm-based estimate
 of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
 and (B,E), using CLACON.

 If IJOB >= 1, CTGSYL computes a Frobenius norm-based estimate of
 Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
 reciprocal of the smallest singular value of Z.

 This is a level-3 BLAS algorithm.

 */
extern proc LAPACKE_ctgsyl(matrix_order : lapack_memory_order, trans : c_char, ijob : c_int, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), ldc : c_int, d : [] complex(64), ldd : c_int, e : [] complex(64), lde : c_int, f : [] complex(64), ldf : c_int, ref scale : c_float, ref dif : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctgsyl
 */
inline proc LAPACKE_ctgsyl(matrix_order : lapack_memory_order, trans : string, ijob : c_int, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), ldc : c_int, d : [] complex(64), ldd : c_int, e : [] complex(64), lde : c_int, f : [] complex(64), ldf : c_int, ref scale : c_float, ref dif : c_float) : c_int{
  return LAPACKE_ctgsyl(matrix_order, ascii(trans) : c_char, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgsyl

Original Fortran LAPACK documentation for ZTGSYL::

 ZTGSYL solves the generalized Sylvester equation:

 A * R - L * B = scale * C (1)
 D * R - L * E = scale * F

 where R and L are unknown m-by-n matrices, (A, D), (B, E) and
 (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
 respectively, with complex entries. A, B, D and E are upper
 triangular (i.e., (A,D) and (B,E) in generalized Schur form).

 The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
 is an output scaling factor chosen to avoid overflow.

 In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
 is defined as

 Z = [ kron(In, A) -kron(B**H, Im) ] (2)
 [ kron(In, D) -kron(E**H, Im) ],

 Here Ix is the identity matrix of size x and X**H is the conjugate
 transpose of X. Kron(X, Y) is the Kronecker product between the
 matrices X and Y.

 If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
 is solved for, which is equivalent to solve for R and L in

 A**H * R + D**H * L = scale * C (3)
 R * B**H + L * E**H = scale * -F

 This case (TRANS = 'C') is used to compute an one-norm-based estimate
 of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
 and (B,E), using ZLACON.

 If IJOB >= 1, ZTGSYL computes a Frobenius norm-based estimate of
 Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
 reciprocal of the smallest singular value of Z.

 This is a level-3 BLAS algorithm.

 */
extern proc LAPACKE_ztgsyl(matrix_order : lapack_memory_order, trans : c_char, ijob : c_int, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), ldc : c_int, d : [] complex(128), ldd : c_int, e : [] complex(128), lde : c_int, f : [] complex(128), ldf : c_int, ref scale : c_double, ref dif : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztgsyl
 */
inline proc LAPACKE_ztgsyl(matrix_order : lapack_memory_order, trans : string, ijob : c_int, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), ldc : c_int, d : [] complex(128), ldd : c_int, e : [] complex(128), lde : c_int, f : [] complex(128), ldf : c_int, ref scale : c_double, ref dif : c_double) : c_int{
  return LAPACKE_ztgsyl(matrix_order, ascii(trans) : c_char, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stpcon

Original Fortran LAPACK documentation for STPCON::

 STPCON estimates the reciprocal of the condition number of a packed
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_stpcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, ap : [] c_float, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stpcon
 */
inline proc LAPACKE_stpcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] c_float, ref rcond : c_float) : c_int{
  return LAPACKE_stpcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpcon

Original Fortran LAPACK documentation for DTPCON::

 DTPCON estimates the reciprocal of the condition number of a packed
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_dtpcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, ap : [] c_double, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtpcon
 */
inline proc LAPACKE_dtpcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] c_double, ref rcond : c_double) : c_int{
  return LAPACKE_dtpcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpcon

Original Fortran LAPACK documentation for CTPCON::

 CTPCON estimates the reciprocal of the condition number of a packed
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_ctpcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, ap : [] complex(64), ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctpcon
 */
inline proc LAPACKE_ctpcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] complex(64), ref rcond : c_float) : c_int{
  return LAPACKE_ctpcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpcon

Original Fortran LAPACK documentation for ZTPCON::

 ZTPCON estimates the reciprocal of the condition number of a packed
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_ztpcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, ap : [] complex(128), ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztpcon
 */
inline proc LAPACKE_ztpcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] complex(128), ref rcond : c_double) : c_int{
  return LAPACKE_ztpcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stprfs

Original Fortran LAPACK documentation for STPRFS::

 STPRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular packed
 coefficient matrix.

 The solution matrix X must be computed by STPTRS or some other
 means before entering this routine. STPRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_stprfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stprfs
 */
inline proc LAPACKE_stprfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_stprfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtprfs

Original Fortran LAPACK documentation for DTPRFS::

 DTPRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular packed
 coefficient matrix.

 The solution matrix X must be computed by DTPTRS or some other
 means before entering this routine. DTPRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_dtprfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtprfs
 */
inline proc LAPACKE_dtprfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dtprfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctprfs

Original Fortran LAPACK documentation for CTPRFS::

 CTPRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular packed
 coefficient matrix.

 The solution matrix X must be computed by CTPTRS or some other
 means before entering this routine. CTPRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_ctprfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctprfs
 */
inline proc LAPACKE_ctprfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_ctprfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztprfs

Original Fortran LAPACK documentation for ZTPRFS::

 ZTPRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular packed
 coefficient matrix.

 The solution matrix X must be computed by ZTPTRS or some other
 means before entering this routine. ZTPRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_ztprfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztprfs
 */
inline proc LAPACKE_ztprfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_ztprfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stptri

Original Fortran LAPACK documentation for STPTRI::

 STPTRI computes the inverse of a real upper or lower triangular
 matrix A stored in packed format.

 */
extern proc LAPACKE_stptri(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stptri
 */
inline proc LAPACKE_stptri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] c_float) : c_int{
  return LAPACKE_stptri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtptri

Original Fortran LAPACK documentation for DTPTRI::

 DTPTRI computes the inverse of a real upper or lower triangular
 matrix A stored in packed format.

 */
extern proc LAPACKE_dtptri(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtptri
 */
inline proc LAPACKE_dtptri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] c_double) : c_int{
  return LAPACKE_dtptri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctptri

Original Fortran LAPACK documentation for CTPTRI::

 CTPTRI computes the inverse of a complex upper or lower triangular
 matrix A stored in packed format.

 */
extern proc LAPACKE_ctptri(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctptri
 */
inline proc LAPACKE_ctptri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] complex(64)) : c_int{
  return LAPACKE_ctptri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztptri

Original Fortran LAPACK documentation for ZTPTRI::

 ZTPTRI computes the inverse of a complex upper or lower triangular
 matrix A stored in packed format.

 */
extern proc LAPACKE_ztptri(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztptri
 */
inline proc LAPACKE_ztptri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] complex(128)) : c_int{
  return LAPACKE_ztptri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stptrs

Original Fortran LAPACK documentation for STPTRS::

 STPTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N stored in packed format,
 and B is an N-by-NRHS matrix. A check is made to verify that A is
 nonsingular.

 */
extern proc LAPACKE_stptrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stptrs
 */
inline proc LAPACKE_stptrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_stptrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtptrs

Original Fortran LAPACK documentation for DTPTRS::

 DTPTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N stored in packed format,
 and B is an N-by-NRHS matrix. A check is made to verify that A is
 nonsingular.

 */
extern proc LAPACKE_dtptrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtptrs
 */
inline proc LAPACKE_dtptrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtptrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctptrs

Original Fortran LAPACK documentation for CTPTRS::

 CTPTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular matrix of order N stored in packed format,
 and B is an N-by-NRHS matrix. A check is made to verify that A is
 nonsingular.

 */
extern proc LAPACKE_ctptrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctptrs
 */
inline proc LAPACKE_ctptrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctptrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztptrs

Original Fortran LAPACK documentation for ZTPTRS::

 ZTPTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular matrix of order N stored in packed format,
 and B is an N-by-NRHS matrix. A check is made to verify that A is
 nonsingular.

 */
extern proc LAPACKE_ztptrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztptrs
 */
inline proc LAPACKE_ztptrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztptrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stpttf

Original Fortran LAPACK documentation for STPTTF::

 STPTTF copies a triangular matrix A from standard packed format (TP)
 to rectangular full packed format (TF).

 */
extern proc LAPACKE_stpttf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, ap : [] c_float, arf : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stpttf
 */
inline proc LAPACKE_stpttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] c_float, arf : [] c_float) : c_int{
  return LAPACKE_stpttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpttf

Original Fortran LAPACK documentation for DTPTTF::

 DTPTTF copies a triangular matrix A from standard packed format (TP)
 to rectangular full packed format (TF).

 */
extern proc LAPACKE_dtpttf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, ap : [] c_double, arf : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtpttf
 */
inline proc LAPACKE_dtpttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] c_double, arf : [] c_double) : c_int{
  return LAPACKE_dtpttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpttf

Original Fortran LAPACK documentation for CTPTTF::

 CTPTTF copies a triangular matrix A from standard packed format (TP)
 to rectangular full packed format (TF).

 */
extern proc LAPACKE_ctpttf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, ap : [] complex(64), arf : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctpttf
 */
inline proc LAPACKE_ctpttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] complex(64), arf : [] complex(64)) : c_int{
  return LAPACKE_ctpttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpttf

Original Fortran LAPACK documentation for ZTPTTF::

 ZTPTTF copies a triangular matrix A from standard packed format (TP)
 to rectangular full packed format (TF).

 */
extern proc LAPACKE_ztpttf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, ap : [] complex(128), arf : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztpttf
 */
inline proc LAPACKE_ztpttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] complex(128), arf : [] complex(128)) : c_int{
  return LAPACKE_ztpttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stpttr

Original Fortran LAPACK documentation for STPTTR::

 STPTTR copies a triangular matrix A from standard packed format (TP)
 to standard full format (TR).

 */
extern proc LAPACKE_stpttr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stpttr
 */
inline proc LAPACKE_stpttr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_stpttr(matrix_order, ascii(uplo) : c_char, n, ap, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpttr

Original Fortran LAPACK documentation for DTPTTR::

 DTPTTR copies a triangular matrix A from standard packed format (TP)
 to standard full format (TR).

 */
extern proc LAPACKE_dtpttr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtpttr
 */
inline proc LAPACKE_dtpttr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dtpttr(matrix_order, ascii(uplo) : c_char, n, ap, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpttr

Original Fortran LAPACK documentation for CTPTTR::

 CTPTTR copies a triangular matrix A from standard packed format (TP)
 to standard full format (TR).

 */
extern proc LAPACKE_ctpttr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctpttr
 */
inline proc LAPACKE_ctpttr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_ctpttr(matrix_order, ascii(uplo) : c_char, n, ap, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpttr

Original Fortran LAPACK documentation for ZTPTTR::

 ZTPTTR copies a triangular matrix A from standard packed format (TP)
 to standard full format (TR).

 */
extern proc LAPACKE_ztpttr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztpttr
 */
inline proc LAPACKE_ztpttr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_ztpttr(matrix_order, ascii(uplo) : c_char, n, ap, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strcon

Original Fortran LAPACK documentation for STRCON::

 STRCON estimates the reciprocal of the condition number of a
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_strcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] c_float, lda : c_int, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strcon
 */
inline proc LAPACKE_strcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, a : [] c_float, lda : c_int, ref rcond : c_float) : c_int{
  return LAPACKE_strcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrcon

Original Fortran LAPACK documentation for DTRCON::

 DTRCON estimates the reciprocal of the condition number of a
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_dtrcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] c_double, lda : c_int, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrcon
 */
inline proc LAPACKE_dtrcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, a : [] c_double, lda : c_int, ref rcond : c_double) : c_int{
  return LAPACKE_dtrcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrcon

Original Fortran LAPACK documentation for CTRCON::

 CTRCON estimates the reciprocal of the condition number of a
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_ctrcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] complex(64), lda : c_int, ref rcond : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrcon
 */
inline proc LAPACKE_ctrcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, a : [] complex(64), lda : c_int, ref rcond : c_float) : c_int{
  return LAPACKE_ctrcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrcon

Original Fortran LAPACK documentation for ZTRCON::

 ZTRCON estimates the reciprocal of the condition number of a
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACKE_ztrcon(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] complex(128), lda : c_int, ref rcond : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrcon
 */
inline proc LAPACKE_ztrcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, a : [] complex(128), lda : c_int, ref rcond : c_double) : c_int{
  return LAPACKE_ztrcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda, rcond);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strevc

Original Fortran LAPACK documentation for STREVC::

 STREVC computes some or all of the right and/or left eigenvectors of
 a real upper quasi-triangular matrix T.
 Matrices of this type are produced by the Schur factorization of
 a real general matrix: A = Q*T*Q**T, as computed by SHSEQR.
 
 The right eigenvector x and the left eigenvector y of T corresponding
 to an eigenvalue w are defined by:
 
 T*x = w*x, (y**T)*T = w*(y**T)
 
 where y**T denotes the transpose of y.
 The eigenvalues are not input to this routine, but are read directly
 from the diagonal blocks of T.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
 input matrix. If Q is the orthogonal factor that reduces a matrix
 A to Schur form T, then Q*X and Q*Y are the matrices of right and
 left eigenvectors of A.

 */
extern proc LAPACKE_strevc(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strevc
 */
inline proc LAPACKE_strevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_strevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrevc

Original Fortran LAPACK documentation for DTREVC::

 DTREVC computes some or all of the right and/or left eigenvectors of
 a real upper quasi-triangular matrix T.
 Matrices of this type are produced by the Schur factorization of
 a real general matrix: A = Q*T*Q**T, as computed by DHSEQR.
 
 The right eigenvector x and the left eigenvector y of T corresponding
 to an eigenvalue w are defined by:
 
 T*x = w*x, (y**T)*T = w*(y**T)
 
 where y**T denotes the transpose of y.
 The eigenvalues are not input to this routine, but are read directly
 from the diagonal blocks of T.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
 input matrix. If Q is the orthogonal factor that reduces a matrix
 A to Schur form T, then Q*X and Q*Y are the matrices of right and
 left eigenvectors of A.

 */
extern proc LAPACKE_dtrevc(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrevc
 */
inline proc LAPACKE_dtrevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_dtrevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrevc

Original Fortran LAPACK documentation for CTREVC::

 CTREVC computes some or all of the right and/or left eigenvectors of
 a complex upper triangular matrix T.
 Matrices of this type are produced by the Schur factorization of
 a complex general matrix: A = Q*T*Q**H, as computed by CHSEQR.
 
 The right eigenvector x and the left eigenvector y of T corresponding
 to an eigenvalue w are defined by:
 
 T*x = w*x, (y**H)*T = w*(y**H)
 
 where y**H denotes the conjugate transpose of the vector y.
 The eigenvalues are not input to this routine, but are read directly
 from the diagonal of T.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
 input matrix. If Q is the unitary factor that reduces a matrix A to
 Schur form T, then Q*X and Q*Y are the matrices of right and left
 eigenvectors of A.

 */
extern proc LAPACKE_ctrevc(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrevc
 */
inline proc LAPACKE_ctrevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_ctrevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrevc

Original Fortran LAPACK documentation for ZTREVC::

 ZTREVC computes some or all of the right and/or left eigenvectors of
 a complex upper triangular matrix T.
 Matrices of this type are produced by the Schur factorization of
 a complex general matrix: A = Q*T*Q**H, as computed by ZHSEQR.
 
 The right eigenvector x and the left eigenvector y of T corresponding
 to an eigenvalue w are defined by:
 
 T*x = w*x, (y**H)*T = w*(y**H)
 
 where y**H denotes the conjugate transpose of the vector y.
 The eigenvalues are not input to this routine, but are read directly
 from the diagonal of T.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
 input matrix. If Q is the unitary factor that reduces a matrix A to
 Schur form T, then Q*X and Q*Y are the matrices of right and left
 eigenvectors of A.

 */
extern proc LAPACKE_ztrevc(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrevc
 */
inline proc LAPACKE_ztrevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_ztrevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strexc

Original Fortran LAPACK documentation for STREXC::

 STREXC reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
 moved to row ILST.

 The real Schur form T is reordered by an orthogonal similarity
 transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
 is updated by postmultiplying it with Z.

 T must be in Schur canonical form (as returned by SHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACKE_strexc(matrix_order : lapack_memory_order, compq : c_char, n : c_int, t : [] c_float, ldt : c_int, q : [] c_float, ldq : c_int, ref ifst : c_int, ref ilst : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strexc
 */
inline proc LAPACKE_strexc(matrix_order : lapack_memory_order, compq : string, n : c_int, t : [] c_float, ldt : c_int, q : [] c_float, ldq : c_int, ref ifst : c_int, ref ilst : c_int) : c_int{
  return LAPACKE_strexc(matrix_order, ascii(compq) : c_char, n, t, ldt, q, ldq, ifst, ilst);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrexc

Original Fortran LAPACK documentation for DTREXC::

 DTREXC reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
 moved to row ILST.

 The real Schur form T is reordered by an orthogonal similarity
 transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
 is updated by postmultiplying it with Z.

 T must be in Schur canonical form (as returned by DHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACKE_dtrexc(matrix_order : lapack_memory_order, compq : c_char, n : c_int, t : [] c_double, ldt : c_int, q : [] c_double, ldq : c_int, ref ifst : c_int, ref ilst : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrexc
 */
inline proc LAPACKE_dtrexc(matrix_order : lapack_memory_order, compq : string, n : c_int, t : [] c_double, ldt : c_int, q : [] c_double, ldq : c_int, ref ifst : c_int, ref ilst : c_int) : c_int{
  return LAPACKE_dtrexc(matrix_order, ascii(compq) : c_char, n, t, ldt, q, ldq, ifst, ilst);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrexc

Original Fortran LAPACK documentation for CTREXC::

 CTREXC reorders the Schur factorization of a complex matrix
 A = Q*T*Q**H, so that the diagonal element of T with row index IFST
 is moved to row ILST.

 The Schur form T is reordered by a unitary similarity transformation
 Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
 postmultplying it with Z.

 */
extern proc LAPACKE_ctrexc(matrix_order : lapack_memory_order, compq : c_char, n : c_int, t : [] complex(64), ldt : c_int, q : [] complex(64), ldq : c_int, ifst : c_int, ilst : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrexc
 */
inline proc LAPACKE_ctrexc(matrix_order : lapack_memory_order, compq : string, n : c_int, t : [] complex(64), ldt : c_int, q : [] complex(64), ldq : c_int, ifst : c_int, ilst : c_int) : c_int{
  return LAPACKE_ctrexc(matrix_order, ascii(compq) : c_char, n, t, ldt, q, ldq, ifst, ilst);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrexc

Original Fortran LAPACK documentation for ZTREXC::

 ZTREXC reorders the Schur factorization of a complex matrix
 A = Q*T*Q**H, so that the diagonal element of T with row index IFST
 is moved to row ILST.

 The Schur form T is reordered by a unitary similarity transformation
 Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
 postmultplying it with Z.

 */
extern proc LAPACKE_ztrexc(matrix_order : lapack_memory_order, compq : c_char, n : c_int, t : [] complex(128), ldt : c_int, q : [] complex(128), ldq : c_int, ifst : c_int, ilst : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrexc
 */
inline proc LAPACKE_ztrexc(matrix_order : lapack_memory_order, compq : string, n : c_int, t : [] complex(128), ldt : c_int, q : [] complex(128), ldq : c_int, ifst : c_int, ilst : c_int) : c_int{
  return LAPACKE_ztrexc(matrix_order, ascii(compq) : c_char, n, t, ldt, q, ldq, ifst, ilst);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strrfs

Original Fortran LAPACK documentation for STRRFS::

 STRRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular
 coefficient matrix.

 The solution matrix X must be computed by STRTRS or some other
 means before entering this routine. STRRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_strrfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strrfs
 */
inline proc LAPACKE_strrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_strrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrrfs

Original Fortran LAPACK documentation for DTRRFS::

 DTRRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular
 coefficient matrix.

 The solution matrix X must be computed by DTRTRS or some other
 means before entering this routine. DTRRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_dtrrfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrrfs
 */
inline proc LAPACKE_dtrrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_dtrrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrrfs

Original Fortran LAPACK documentation for CTRRFS::

 CTRRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular
 coefficient matrix.

 The solution matrix X must be computed by CTRTRS or some other
 means before entering this routine. CTRRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_ctrrfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrrfs
 */
inline proc LAPACKE_ctrrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float) : c_int{
  return LAPACKE_ctrrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrrfs

Original Fortran LAPACK documentation for ZTRRFS::

 ZTRRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular
 coefficient matrix.

 The solution matrix X must be computed by ZTRTRS or some other
 means before entering this routine. ZTRRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACKE_ztrrfs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrrfs
 */
inline proc LAPACKE_ztrrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double) : c_int{
  return LAPACKE_ztrrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strsen

Original Fortran LAPACK documentation for STRSEN::

 STRSEN reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
 the leading diagonal blocks of the upper quasi-triangular matrix T,
 and the leading columns of Q form an orthonormal basis of the
 corresponding right invariant subspace.

 Optionally the routine computes the reciprocal condition numbers of
 the cluster of eigenvalues and/or the invariant subspace.

 T must be in Schur canonical form (as returned by SHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACKE_strsen(matrix_order : lapack_memory_order, job : c_char, compq : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, q : [] c_float, ldq : c_int, wr : [] c_float, wi : [] c_float, ref m : c_int, ref s : c_float, ref sep : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strsen
 */
inline proc LAPACKE_strsen(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, q : [] c_float, ldq : c_int, wr : [] c_float, wi : [] c_float, ref m : c_int, ref s : c_float, ref sep : c_float) : c_int{
  return LAPACKE_strsen(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrsen

Original Fortran LAPACK documentation for DTRSEN::

 DTRSEN reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
 the leading diagonal blocks of the upper quasi-triangular matrix T,
 and the leading columns of Q form an orthonormal basis of the
 corresponding right invariant subspace.

 Optionally the routine computes the reciprocal condition numbers of
 the cluster of eigenvalues and/or the invariant subspace.

 T must be in Schur canonical form (as returned by DHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACKE_dtrsen(matrix_order : lapack_memory_order, job : c_char, compq : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, q : [] c_double, ldq : c_int, wr : [] c_double, wi : [] c_double, ref m : c_int, ref s : c_double, ref sep : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrsen
 */
inline proc LAPACKE_dtrsen(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, q : [] c_double, ldq : c_int, wr : [] c_double, wi : [] c_double, ref m : c_int, ref s : c_double, ref sep : c_double) : c_int{
  return LAPACKE_dtrsen(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrsen

Original Fortran LAPACK documentation for CTRSEN::

 CTRSEN reorders the Schur factorization of a complex matrix
 A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
 the leading positions on the diagonal of the upper triangular matrix
 T, and the leading columns of Q form an orthonormal basis of the
 corresponding right invariant subspace.

 Optionally the routine computes the reciprocal condition numbers of
 the cluster of eigenvalues and/or the invariant subspace.

 */
extern proc LAPACKE_ctrsen(matrix_order : lapack_memory_order, job : c_char, compq : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, q : [] complex(64), ldq : c_int, w : [] complex(64), ref m : c_int, ref s : c_float, ref sep : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrsen
 */
inline proc LAPACKE_ctrsen(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, q : [] complex(64), ldq : c_int, w : [] complex(64), ref m : c_int, ref s : c_float, ref sep : c_float) : c_int{
  return LAPACKE_ctrsen(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, n, t, ldt, q, ldq, w, m, s, sep);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrsen

Original Fortran LAPACK documentation for ZTRSEN::

 ZTRSEN reorders the Schur factorization of a complex matrix
 A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
 the leading positions on the diagonal of the upper triangular matrix
 T, and the leading columns of Q form an orthonormal basis of the
 corresponding right invariant subspace.

 Optionally the routine computes the reciprocal condition numbers of
 the cluster of eigenvalues and/or the invariant subspace.

 */
extern proc LAPACKE_ztrsen(matrix_order : lapack_memory_order, job : c_char, compq : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, q : [] complex(128), ldq : c_int, w : [] complex(128), ref m : c_int, ref s : c_double, ref sep : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrsen
 */
inline proc LAPACKE_ztrsen(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, q : [] complex(128), ldq : c_int, w : [] complex(128), ref m : c_int, ref s : c_double, ref sep : c_double) : c_int{
  return LAPACKE_ztrsen(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, n, t, ldt, q, ldq, w, m, s, sep);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strsna

Original Fortran LAPACK documentation for STRSNA::

 STRSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or right eigenvectors of a real upper
 quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
 orthogonal).

 T must be in Schur canonical form (as returned by SHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACKE_strsna(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strsna
 */
inline proc LAPACKE_strsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_strsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrsna

Original Fortran LAPACK documentation for DTRSNA::

 DTRSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or right eigenvectors of a real upper
 quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
 orthogonal).

 T must be in Schur canonical form (as returned by DHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACKE_dtrsna(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrsna
 */
inline proc LAPACKE_dtrsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_dtrsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrsna

Original Fortran LAPACK documentation for CTRSNA::

 CTRSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or right eigenvectors of a complex upper triangular
 matrix T (or of any matrix Q*T*Q**H with Q unitary).

 */
extern proc LAPACKE_ctrsna(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrsna
 */
inline proc LAPACKE_ctrsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_ctrsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrsna

Original Fortran LAPACK documentation for ZTRSNA::

 ZTRSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or right eigenvectors of a complex upper triangular
 matrix T (or of any matrix Q*T*Q**H with Q unitary).

 */
extern proc LAPACKE_ztrsna(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrsna
 */
inline proc LAPACKE_ztrsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int) : c_int{
  return LAPACKE_ztrsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strsyl

Original Fortran LAPACK documentation for STRSYL::

 STRSYL solves the real Sylvester matrix equation:

 op(A)*X + X*op(B) = scale*C or
 op(A)*X - X*op(B) = scale*C,

 where op(A) = A or A**T, and A and B are both upper quasi-
 triangular. A is M-by-M and B is N-by-N; the right hand side C and
 the solution X are M-by-N; and scale is an output scale factor, set
 <= 1 to avoid overflow in X.

 A and B must be in Schur canonical form (as returned by SHSEQR), that
 is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
 each 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACKE_strsyl(matrix_order : lapack_memory_order, trana : c_char, tranb : c_char, isgn : c_int, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, ldc : c_int, ref scale : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strsyl
 */
inline proc LAPACKE_strsyl(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, ldc : c_int, ref scale : c_float) : c_int{
  return LAPACKE_strsyl(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrsyl

Original Fortran LAPACK documentation for DTRSYL::

 DTRSYL solves the real Sylvester matrix equation:

 op(A)*X + X*op(B) = scale*C or
 op(A)*X - X*op(B) = scale*C,

 where op(A) = A or A**T, and A and B are both upper quasi-
 triangular. A is M-by-M and B is N-by-N; the right hand side C and
 the solution X are M-by-N; and scale is an output scale factor, set
 <= 1 to avoid overflow in X.

 A and B must be in Schur canonical form (as returned by DHSEQR), that
 is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
 each 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACKE_dtrsyl(matrix_order : lapack_memory_order, trana : c_char, tranb : c_char, isgn : c_int, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, ldc : c_int, ref scale : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrsyl
 */
inline proc LAPACKE_dtrsyl(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, ldc : c_int, ref scale : c_double) : c_int{
  return LAPACKE_dtrsyl(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrsyl

Original Fortran LAPACK documentation for CTRSYL::

 CTRSYL solves the complex Sylvester matrix equation:

 op(A)*X + X*op(B) = scale*C or
 op(A)*X - X*op(B) = scale*C,

 where op(A) = A or A**H, and A and B are both upper triangular. A is
 M-by-M and B is N-by-N; the right hand side C and the solution X are
 M-by-N; and scale is an output scale factor, set <= 1 to avoid
 overflow in X.

 */
extern proc LAPACKE_ctrsyl(matrix_order : lapack_memory_order, trana : c_char, tranb : c_char, isgn : c_int, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), ldc : c_int, ref scale : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrsyl
 */
inline proc LAPACKE_ctrsyl(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), ldc : c_int, ref scale : c_float) : c_int{
  return LAPACKE_ctrsyl(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrsyl

Original Fortran LAPACK documentation for ZTRSYL::

 ZTRSYL solves the complex Sylvester matrix equation:

 op(A)*X + X*op(B) = scale*C or
 op(A)*X - X*op(B) = scale*C,

 where op(A) = A or A**H, and A and B are both upper triangular. A is
 M-by-M and B is N-by-N; the right hand side C and the solution X are
 M-by-N; and scale is an output scale factor, set <= 1 to avoid
 overflow in X.

 */
extern proc LAPACKE_ztrsyl(matrix_order : lapack_memory_order, trana : c_char, tranb : c_char, isgn : c_int, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), ldc : c_int, ref scale : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrsyl
 */
inline proc LAPACKE_ztrsyl(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), ldc : c_int, ref scale : c_double) : c_int{
  return LAPACKE_ztrsyl(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strtri

Original Fortran LAPACK documentation for STRTRI::

 STRTRI computes the inverse of a real upper or lower triangular
 matrix A.

 This is the Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_strtri(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strtri
 */
inline proc LAPACKE_strtri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_strtri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrtri

Original Fortran LAPACK documentation for DTRTRI::

 DTRTRI computes the inverse of a real upper or lower triangular
 matrix A.

 This is the Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_dtrtri(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrtri
 */
inline proc LAPACKE_dtrtri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dtrtri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrtri

Original Fortran LAPACK documentation for CTRTRI::

 CTRTRI computes the inverse of a complex upper or lower triangular
 matrix A.

 This is the Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_ctrtri(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrtri
 */
inline proc LAPACKE_ctrtri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_ctrtri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrtri

Original Fortran LAPACK documentation for ZTRTRI::

 ZTRTRI computes the inverse of a complex upper or lower triangular
 matrix A.

 This is the Level 3 BLAS version of the algorithm.

 */
extern proc LAPACKE_ztrtri(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrtri
 */
inline proc LAPACKE_ztrtri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_ztrtri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strtrs

Original Fortran LAPACK documentation for STRTRS::

 STRTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N, and B is an N-by-NRHS
 matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACKE_strtrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strtrs
 */
inline proc LAPACKE_strtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_strtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrtrs

Original Fortran LAPACK documentation for DTRTRS::

 DTRTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N, and B is an N-by-NRHS
 matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACKE_dtrtrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrtrs
 */
inline proc LAPACKE_dtrtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtrtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrtrs

Original Fortran LAPACK documentation for CTRTRS::

 CTRTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular matrix of order N, and B is an N-by-NRHS
 matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACKE_ctrtrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrtrs
 */
inline proc LAPACKE_ctrtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctrtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrtrs

Original Fortran LAPACK documentation for ZTRTRS::

 ZTRTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular matrix of order N, and B is an N-by-NRHS
 matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACKE_ztrtrs(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrtrs
 */
inline proc LAPACKE_ztrtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztrtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strttf

Original Fortran LAPACK documentation for STRTTF::

 STRTTF copies a triangular matrix A from standard full format (TR)
 to rectangular full packed format (TF) .

 */
extern proc LAPACKE_strttf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, arf : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strttf
 */
inline proc LAPACKE_strttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, arf : [] c_float) : c_int{
  return LAPACKE_strttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a, lda, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrttf

Original Fortran LAPACK documentation for DTRTTF::

 DTRTTF copies a triangular matrix A from standard full format (TR)
 to rectangular full packed format (TF) .

 */
extern proc LAPACKE_dtrttf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, arf : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrttf
 */
inline proc LAPACKE_dtrttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, arf : [] c_double) : c_int{
  return LAPACKE_dtrttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a, lda, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrttf

Original Fortran LAPACK documentation for CTRTTF::

 CTRTTF copies a triangular matrix A from standard full format (TR)
 to rectangular full packed format (TF) .

 */
extern proc LAPACKE_ctrttf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, arf : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrttf
 */
inline proc LAPACKE_ctrttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, arf : [] complex(64)) : c_int{
  return LAPACKE_ctrttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a, lda, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrttf

Original Fortran LAPACK documentation for ZTRTTF::

 ZTRTTF copies a triangular matrix A from standard full format (TR)
 to rectangular full packed format (TF) .

 */
extern proc LAPACKE_ztrttf(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, arf : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrttf
 */
inline proc LAPACKE_ztrttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, arf : [] complex(128)) : c_int{
  return LAPACKE_ztrttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a, lda, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strttp

Original Fortran LAPACK documentation for STRTTP::

 STRTTP copies a triangular matrix A from full format (TR) to standard
 packed format (TP).

 */
extern proc LAPACKE_strttp(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strttp
 */
inline proc LAPACKE_strttp(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ap : [] c_float) : c_int{
  return LAPACKE_strttp(matrix_order, ascii(uplo) : c_char, n, a, lda, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrttp

Original Fortran LAPACK documentation for DTRTTP::

 DTRTTP copies a triangular matrix A from full format (TR) to standard
 packed format (TP).

 */
extern proc LAPACKE_dtrttp(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrttp
 */
inline proc LAPACKE_dtrttp(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ap : [] c_double) : c_int{
  return LAPACKE_dtrttp(matrix_order, ascii(uplo) : c_char, n, a, lda, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrttp

Original Fortran LAPACK documentation for CTRTTP::

 CTRTTP copies a triangular matrix A from full format (TR) to standard
 packed format (TP).

 */
extern proc LAPACKE_ctrttp(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrttp
 */
inline proc LAPACKE_ctrttp(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ap : [] complex(64)) : c_int{
  return LAPACKE_ctrttp(matrix_order, ascii(uplo) : c_char, n, a, lda, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrttp

Original Fortran LAPACK documentation for ZTRTTP::

 ZTRTTP copies a triangular matrix A from full format (TR) to standard
 packed format (TP).

 */
extern proc LAPACKE_ztrttp(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrttp
 */
inline proc LAPACKE_ztrttp(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ap : [] complex(128)) : c_int{
  return LAPACKE_ztrttp(matrix_order, ascii(uplo) : c_char, n, a, lda, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stzrzf

Original Fortran LAPACK documentation for STZRZF::

 STZRZF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
 to upper triangular form by means of orthogonal transformations.

 The upper trapezoidal matrix A is factored as

 A = ( R 0 ) * Z,

 where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
 triangular matrix.

 */
extern proc LAPACKE_stzrzf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dtzrzf

Original Fortran LAPACK documentation for DTZRZF::

 DTZRZF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
 to upper triangular form by means of orthogonal transformations.

 The upper trapezoidal matrix A is factored as

 A = ( R 0 ) * Z,

 where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
 triangular matrix.

 */
extern proc LAPACKE_dtzrzf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctzrzf

Original Fortran LAPACK documentation for CTZRZF::

 CTZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
 to upper triangular form by means of unitary transformations.

 The upper trapezoidal matrix A is factored as

 A = ( R 0 ) * Z,

 where Z is an N-by-N unitary matrix and R is an M-by-M upper
 triangular matrix.

 */
extern proc LAPACKE_ctzrzf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztzrzf

Original Fortran LAPACK documentation for ZTZRZF::

 ZTZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
 to upper triangular form by means of unitary transformations.

 The upper trapezoidal matrix A is factored as

 A = ( R 0 ) * Z,

 where Z is an N-by-N unitary matrix and R is an M-by-M upper
 triangular matrix.

 */
extern proc LAPACKE_ztzrzf(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungbr

Original Fortran LAPACK documentation for CUNGBR::

 CUNGBR generates one of the complex unitary matrices Q or P**H
 determined by CGEBRD when reducing a complex matrix A to bidiagonal
 form: A = Q * B * P**H. Q and P**H are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
 is of order N:
 if k < n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m
 rows of P**H, where n >= m >= k;
 if k >= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as
 an N-by-N matrix.

 */
extern proc LAPACKE_cungbr(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cungbr
 */
inline proc LAPACKE_cungbr(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int{
  return LAPACKE_cungbr(matrix_order, ascii(vect) : c_char, m, n, k, a, lda, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zungbr

Original Fortran LAPACK documentation for ZUNGBR::

 ZUNGBR generates one of the complex unitary matrices Q or P**H
 determined by ZGEBRD when reducing a complex matrix A to bidiagonal
 form: A = Q * B * P**H. Q and P**H are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and ZUNGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and ZUNGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
 is of order N:
 if k < n, P**H = G(k) . . . G(2) G(1) and ZUNGBR returns the first m
 rows of P**H, where n >= m >= k;
 if k >= n, P**H = G(n-1) . . . G(2) G(1) and ZUNGBR returns P**H as
 an N-by-N matrix.

 */
extern proc LAPACKE_zungbr(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zungbr
 */
inline proc LAPACKE_zungbr(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int{
  return LAPACKE_zungbr(matrix_order, ascii(vect) : c_char, m, n, k, a, lda, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunghr

Original Fortran LAPACK documentation for CUNGHR::

 CUNGHR generates a complex unitary matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 CGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACKE_cunghr(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zunghr

Original Fortran LAPACK documentation for ZUNGHR::

 ZUNGHR generates a complex unitary matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 ZGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACKE_zunghr(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cunglq

Original Fortran LAPACK documentation for CUNGLQ::

 CUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by CGELQF.

 */
extern proc LAPACKE_cunglq(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zunglq

Original Fortran LAPACK documentation for ZUNGLQ::

 ZUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by ZGELQF.

 */
extern proc LAPACKE_zunglq(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungql

Original Fortran LAPACK documentation for CUNGQL::

 CUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by CGEQLF.

 */
extern proc LAPACKE_cungql(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zungql

Original Fortran LAPACK documentation for ZUNGQL::

 ZUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by ZGEQLF.

 */
extern proc LAPACKE_zungql(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungqr

Original Fortran LAPACK documentation for CUNGQR::

 CUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by CGEQRF.

 */
extern proc LAPACKE_cungqr(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zungqr

Original Fortran LAPACK documentation for ZUNGQR::

 ZUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by ZGEQRF.

 */
extern proc LAPACKE_zungqr(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungrq

Original Fortran LAPACK documentation for CUNGRQ::

 CUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by CGERQF.

 */
extern proc LAPACKE_cungrq(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zungrq

Original Fortran LAPACK documentation for ZUNGRQ::

 ZUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by ZGERQF.

 */
extern proc LAPACKE_zungrq(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungtr

Original Fortran LAPACK documentation for CUNGTR::

 CUNGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 CHETRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACKE_cungtr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cungtr
 */
inline proc LAPACKE_cungtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64)) : c_int{
  return LAPACKE_cungtr(matrix_order, ascii(uplo) : c_char, n, a, lda, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zungtr

Original Fortran LAPACK documentation for ZUNGTR::

 ZUNGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 ZHETRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACKE_zungtr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zungtr
 */
inline proc LAPACKE_zungtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128)) : c_int{
  return LAPACKE_zungtr(matrix_order, ascii(uplo) : c_char, n, a, lda, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmbr

Original Fortran LAPACK documentation for CUNMBR::

 If VECT = 'Q', CUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'C': P**H * C C * P**H

 Here Q and P**H are the unitary matrices determined by CGEBRD when
 reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
 and P**H are defined as products of elementary reflectors H(i) and
 G(i) respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the unitary matrix Q or P**H that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

 */
extern proc LAPACKE_cunmbr(matrix_order : lapack_memory_order, vect : c_char, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmbr
 */
inline proc LAPACKE_cunmbr(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cunmbr(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmbr

Original Fortran LAPACK documentation for ZUNMBR::

 If VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 If VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'C': P**H * C C * P**H

 Here Q and P**H are the unitary matrices determined by ZGEBRD when
 reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
 and P**H are defined as products of elementary reflectors H(i) and
 G(i) respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the unitary matrix Q or P**H that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

 */
extern proc LAPACKE_zunmbr(matrix_order : lapack_memory_order, vect : c_char, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmbr
 */
inline proc LAPACKE_zunmbr(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zunmbr(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmhr

Original Fortran LAPACK documentation for CUNMHR::

 CUNMHR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by CGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACKE_cunmhr(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmhr
 */
inline proc LAPACKE_cunmhr(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cunmhr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, ilo, ihi, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmhr

Original Fortran LAPACK documentation for ZUNMHR::

 ZUNMHR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by ZGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACKE_zunmhr(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmhr
 */
inline proc LAPACKE_zunmhr(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zunmhr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, ilo, ihi, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmlq

Original Fortran LAPACK documentation for CUNMLQ::

 CUNMLQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_cunmlq(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmlq
 */
inline proc LAPACKE_cunmlq(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cunmlq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmlq

Original Fortran LAPACK documentation for ZUNMLQ::

 ZUNMLQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_zunmlq(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmlq
 */
inline proc LAPACKE_zunmlq(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zunmlq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmql

Original Fortran LAPACK documentation for CUNMQL::

 CUNMQL overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_cunmql(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmql
 */
inline proc LAPACKE_cunmql(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cunmql(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmql

Original Fortran LAPACK documentation for ZUNMQL::

 ZUNMQL overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by ZGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_zunmql(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmql
 */
inline proc LAPACKE_zunmql(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zunmql(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmqr

Original Fortran LAPACK documentation for CUNMQR::

 CUNMQR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_cunmqr(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmqr
 */
inline proc LAPACKE_cunmqr(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cunmqr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmqr

Original Fortran LAPACK documentation for ZUNMQR::

 ZUNMQR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_zunmqr(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmqr
 */
inline proc LAPACKE_zunmqr(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zunmqr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmrq

Original Fortran LAPACK documentation for CUNMRQ::

 CUNMRQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_cunmrq(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmrq
 */
inline proc LAPACKE_cunmrq(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cunmrq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmrq

Original Fortran LAPACK documentation for ZUNMRQ::

 ZUNMRQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by ZGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_zunmrq(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmrq
 */
inline proc LAPACKE_zunmrq(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zunmrq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmrz

Original Fortran LAPACK documentation for CUNMRZ::

 CUNMRZ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_cunmrz(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmrz
 */
inline proc LAPACKE_cunmrz(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cunmrz(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmrz

Original Fortran LAPACK documentation for ZUNMRZ::

 ZUNMRZ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by ZTZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACKE_zunmrz(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmrz
 */
inline proc LAPACKE_zunmrz(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zunmrz(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmtr

Original Fortran LAPACK documentation for CUNMTR::

 CUNMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by CHETRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACKE_cunmtr(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmtr
 */
inline proc LAPACKE_cunmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cunmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmtr

Original Fortran LAPACK documentation for ZUNMTR::

 ZUNMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by ZHETRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACKE_zunmtr(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmtr
 */
inline proc LAPACKE_zunmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zunmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, a, lda, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cupgtr

Original Fortran LAPACK documentation for CUPGTR::

 CUPGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 CHPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACKE_cupgtr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), tau : [] complex(64), q : [] complex(64), ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cupgtr
 */
inline proc LAPACKE_cupgtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), tau : [] complex(64), q : [] complex(64), ldq : c_int) : c_int{
  return LAPACKE_cupgtr(matrix_order, ascii(uplo) : c_char, n, ap, tau, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zupgtr

Original Fortran LAPACK documentation for ZUPGTR::

 ZUPGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 ZHPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACKE_zupgtr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), tau : [] complex(128), q : [] complex(128), ldq : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zupgtr
 */
inline proc LAPACKE_zupgtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), tau : [] complex(128), q : [] complex(128), ldq : c_int) : c_int{
  return LAPACKE_zupgtr(matrix_order, ascii(uplo) : c_char, n, ap, tau, q, ldq);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cupmtr

Original Fortran LAPACK documentation for CUPMTR::

 CUPMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by CHPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACKE_cupmtr(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, ap : [] complex(64), tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cupmtr
 */
inline proc LAPACKE_cupmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, ap : [] complex(64), tau : [] complex(64), c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cupmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, ap, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zupmtr

Original Fortran LAPACK documentation for ZUPMTR::

 ZUPMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by ZHPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACKE_zupmtr(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, ap : [] complex(128), tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zupmtr
 */
inline proc LAPACKE_zupmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, ap : [] complex(128), tau : [] complex(128), c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zupmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, ap, tau, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sbdsdc_work
 */
extern proc LAPACKE_sbdsdc_work(matrix_order : lapack_memory_order, uplo : c_char, compq : c_char, n : c_int, d : [] c_float, e : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, q : [] c_float, iq : [] c_int, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sbdsdc_work
 */
inline proc LAPACKE_sbdsdc_work(matrix_order : lapack_memory_order, uplo : string, compq : string, n : c_int, d : [] c_float, e : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, q : [] c_float, iq : [] c_int, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sbdsdc_work(matrix_order, ascii(uplo) : c_char, ascii(compq) : c_char, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dbdsdc_work
 */
extern proc LAPACKE_dbdsdc_work(matrix_order : lapack_memory_order, uplo : c_char, compq : c_char, n : c_int, d : [] c_double, e : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, q : [] c_double, iq : [] c_int, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dbdsdc_work
 */
inline proc LAPACKE_dbdsdc_work(matrix_order : lapack_memory_order, uplo : string, compq : string, n : c_int, d : [] c_double, e : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, q : [] c_double, iq : [] c_int, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dbdsdc_work(matrix_order, ascii(uplo) : c_char, ascii(compq) : c_char, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sbdsqr_work
 */
extern proc LAPACKE_sbdsqr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_float, e : [] c_float, vt : [] c_float, ldvt : c_int, u : [] c_float, ldu : c_int, c : [] c_float, ldc : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sbdsqr_work
 */
inline proc LAPACKE_sbdsqr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_float, e : [] c_float, vt : [] c_float, ldvt : c_int, u : [] c_float, ldu : c_int, c : [] c_float, ldc : c_int, work : [] c_float) : c_int{
  return LAPACKE_sbdsqr_work(matrix_order, ascii(uplo) : c_char, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dbdsqr_work
 */
extern proc LAPACKE_dbdsqr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_double, e : [] c_double, vt : [] c_double, ldvt : c_int, u : [] c_double, ldu : c_int, c : [] c_double, ldc : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dbdsqr_work
 */
inline proc LAPACKE_dbdsqr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_double, e : [] c_double, vt : [] c_double, ldvt : c_int, u : [] c_double, ldu : c_int, c : [] c_double, ldc : c_int, work : [] c_double) : c_int{
  return LAPACKE_dbdsqr_work(matrix_order, ascii(uplo) : c_char, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cbdsqr_work
 */
extern proc LAPACKE_cbdsqr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_float, e : [] c_float, vt : [] complex(64), ldvt : c_int, u : [] complex(64), ldu : c_int, c : [] complex(64), ldc : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cbdsqr_work
 */
inline proc LAPACKE_cbdsqr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_float, e : [] c_float, vt : [] complex(64), ldvt : c_int, u : [] complex(64), ldu : c_int, c : [] complex(64), ldc : c_int, work : [] c_float) : c_int{
  return LAPACKE_cbdsqr_work(matrix_order, ascii(uplo) : c_char, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zbdsqr_work
 */
extern proc LAPACKE_zbdsqr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_double, e : [] c_double, vt : [] complex(128), ldvt : c_int, u : [] complex(128), ldu : c_int, c : [] complex(128), ldc : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zbdsqr_work
 */
inline proc LAPACKE_zbdsqr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ncvt : c_int, nru : c_int, ncc : c_int, d : [] c_double, e : [] c_double, vt : [] complex(128), ldvt : c_int, u : [] complex(128), ldu : c_int, c : [] complex(128), ldc : c_int, work : [] c_double) : c_int{
  return LAPACKE_zbdsqr_work(matrix_order, ascii(uplo) : c_char, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sdisna_work
 */
extern proc LAPACKE_sdisna_work(job : c_char, m : c_int, n : c_int, d : [] c_float, sep : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sdisna_work
 */
inline proc LAPACKE_sdisna_work(job : string, m : c_int, n : c_int, d : [] c_float, sep : [] c_float) : c_int{
  return LAPACKE_sdisna_work(ascii(job) : c_char, m, n, d, sep);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ddisna_work
 */
extern proc LAPACKE_ddisna_work(job : c_char, m : c_int, n : c_int, d : [] c_double, sep : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ddisna_work
 */
inline proc LAPACKE_ddisna_work(job : string, m : c_int, n : c_int, d : [] c_double, sep : [] c_double) : c_int{
  return LAPACKE_ddisna_work(ascii(job) : c_char, m, n, d, sep);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbbrd_work
 */
extern proc LAPACKE_sgbbrd_work(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ldq : c_int, pt : [] c_float, ldpt : c_int, c : [] c_float, ldc : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbbrd_work
 */
inline proc LAPACKE_sgbbrd_work(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ldq : c_int, pt : [] c_float, ldpt : c_int, c : [] c_float, ldc : c_int, work : [] c_float) : c_int{
  return LAPACKE_sgbbrd_work(matrix_order, ascii(vect) : c_char, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbbrd_work
 */
extern proc LAPACKE_dgbbrd_work(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ldq : c_int, pt : [] c_double, ldpt : c_int, c : [] c_double, ldc : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbbrd_work
 */
inline proc LAPACKE_dgbbrd_work(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ldq : c_int, pt : [] c_double, ldpt : c_int, c : [] c_double, ldc : c_int, work : [] c_double) : c_int{
  return LAPACKE_dgbbrd_work(matrix_order, ascii(vect) : c_char, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbbrd_work
 */
extern proc LAPACKE_cgbbrd_work(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ldq : c_int, pt : [] complex(64), ldpt : c_int, c : [] complex(64), ldc : c_int, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbbrd_work
 */
inline proc LAPACKE_cgbbrd_work(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ldq : c_int, pt : [] complex(64), ldpt : c_int, c : [] complex(64), ldc : c_int, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgbbrd_work(matrix_order, ascii(vect) : c_char, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbbrd_work
 */
extern proc LAPACKE_zgbbrd_work(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ldq : c_int, pt : [] complex(128), ldpt : c_int, c : [] complex(128), ldc : c_int, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbbrd_work
 */
inline proc LAPACKE_zgbbrd_work(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, ncc : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ldq : c_int, pt : [] complex(128), ldpt : c_int, c : [] complex(128), ldc : c_int, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgbbrd_work(matrix_order, ascii(vect) : c_char, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbcon_work
 */
extern proc LAPACKE_sgbcon_work(matrix_order : lapack_memory_order, norm : c_char, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbcon_work
 */
inline proc LAPACKE_sgbcon_work(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgbcon_work(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbcon_work
 */
extern proc LAPACKE_dgbcon_work(matrix_order : lapack_memory_order, norm : c_char, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbcon_work
 */
inline proc LAPACKE_dgbcon_work(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgbcon_work(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbcon_work
 */
extern proc LAPACKE_cgbcon_work(matrix_order : lapack_memory_order, norm : c_char, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbcon_work
 */
inline proc LAPACKE_cgbcon_work(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgbcon_work(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbcon_work
 */
extern proc LAPACKE_zgbcon_work(matrix_order : lapack_memory_order, norm : c_char, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbcon_work
 */
inline proc LAPACKE_zgbcon_work(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgbcon_work(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbequ_work
 */
extern proc LAPACKE_sgbequ_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbequ_work
 */
extern proc LAPACKE_dgbequ_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbequ_work
 */
extern proc LAPACKE_cgbequ_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbequ_work
 */
extern proc LAPACKE_zgbequ_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbequb_work
 */
extern proc LAPACKE_sgbequb_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbequb_work
 */
extern proc LAPACKE_dgbequb_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbequb_work
 */
extern proc LAPACKE_cgbequb_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbequb_work
 */
extern proc LAPACKE_zgbequb_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbrfs_work
 */
extern proc LAPACKE_sgbrfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbrfs_work
 */
inline proc LAPACKE_sgbrfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgbrfs_work(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbrfs_work
 */
extern proc LAPACKE_dgbrfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbrfs_work
 */
inline proc LAPACKE_dgbrfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgbrfs_work(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbrfs_work
 */
extern proc LAPACKE_cgbrfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbrfs_work
 */
inline proc LAPACKE_cgbrfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgbrfs_work(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbrfs_work
 */
extern proc LAPACKE_zgbrfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbrfs_work
 */
inline proc LAPACKE_zgbrfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgbrfs_work(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbrfsx_work
 */
extern proc LAPACKE_sgbrfsx_work(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbrfsx_work
 */
inline proc LAPACKE_sgbrfsx_work(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgbrfsx_work(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbrfsx_work
 */
extern proc LAPACKE_dgbrfsx_work(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbrfsx_work
 */
inline proc LAPACKE_dgbrfsx_work(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgbrfsx_work(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbrfsx_work
 */
extern proc LAPACKE_cgbrfsx_work(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbrfsx_work
 */
inline proc LAPACKE_cgbrfsx_work(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgbrfsx_work(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbrfsx_work
 */
extern proc LAPACKE_zgbrfsx_work(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbrfsx_work
 */
inline proc LAPACKE_zgbrfsx_work(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgbrfsx_work(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbsv_work
 */
extern proc LAPACKE_sgbsv_work(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbsv_work
 */
extern proc LAPACKE_dgbsv_work(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbsv_work
 */
extern proc LAPACKE_cgbsv_work(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbsv_work
 */
extern proc LAPACKE_zgbsv_work(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbsvx_work
 */
extern proc LAPACKE_sgbsvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbsvx_work
 */
inline proc LAPACKE_sgbsvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgbsvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbsvx_work
 */
extern proc LAPACKE_dgbsvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbsvx_work
 */
inline proc LAPACKE_dgbsvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgbsvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbsvx_work
 */
extern proc LAPACKE_cgbsvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbsvx_work
 */
inline proc LAPACKE_cgbsvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgbsvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbsvx_work
 */
extern proc LAPACKE_zgbsvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbsvx_work
 */
inline proc LAPACKE_zgbsvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgbsvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbsvxx_work
 */
extern proc LAPACKE_sgbsvxx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbsvxx_work
 */
inline proc LAPACKE_sgbsvxx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgbsvxx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbsvxx_work
 */
extern proc LAPACKE_dgbsvxx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbsvxx_work
 */
inline proc LAPACKE_dgbsvxx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgbsvxx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbsvxx_work
 */
extern proc LAPACKE_cgbsvxx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbsvxx_work
 */
inline proc LAPACKE_cgbsvxx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgbsvxx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbsvxx_work
 */
extern proc LAPACKE_zgbsvxx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbsvxx_work
 */
inline proc LAPACKE_zgbsvxx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgbsvxx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbtrf_work
 */
extern proc LAPACKE_sgbtrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbtrf_work
 */
extern proc LAPACKE_dgbtrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbtrf_work
 */
extern proc LAPACKE_cgbtrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbtrf_work
 */
extern proc LAPACKE_zgbtrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgbtrs_work
 */
extern proc LAPACKE_sgbtrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgbtrs_work
 */
inline proc LAPACKE_sgbtrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sgbtrs_work(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgbtrs_work
 */
extern proc LAPACKE_dgbtrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgbtrs_work
 */
inline proc LAPACKE_dgbtrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dgbtrs_work(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgbtrs_work
 */
extern proc LAPACKE_cgbtrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgbtrs_work
 */
inline proc LAPACKE_cgbtrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cgbtrs_work(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgbtrs_work
 */
extern proc LAPACKE_zgbtrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgbtrs_work
 */
inline proc LAPACKE_zgbtrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zgbtrs_work(matrix_order, ascii(trans) : c_char, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgebak_work
 */
extern proc LAPACKE_sgebak_work(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_float, m : c_int, v : [] c_float, ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgebak_work
 */
inline proc LAPACKE_sgebak_work(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_float, m : c_int, v : [] c_float, ldv : c_int) : c_int{
  return LAPACKE_sgebak_work(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, scale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgebak_work
 */
extern proc LAPACKE_dgebak_work(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_double, m : c_int, v : [] c_double, ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgebak_work
 */
inline proc LAPACKE_dgebak_work(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_double, m : c_int, v : [] c_double, ldv : c_int) : c_int{
  return LAPACKE_dgebak_work(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, scale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgebak_work
 */
extern proc LAPACKE_cgebak_work(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_float, m : c_int, v : [] complex(64), ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgebak_work
 */
inline proc LAPACKE_cgebak_work(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_float, m : c_int, v : [] complex(64), ldv : c_int) : c_int{
  return LAPACKE_cgebak_work(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, scale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgebak_work
 */
extern proc LAPACKE_zgebak_work(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_double, m : c_int, v : [] complex(128), ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgebak_work
 */
inline proc LAPACKE_zgebak_work(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, scale : [] c_double, m : c_int, v : [] complex(128), ldv : c_int) : c_int{
  return LAPACKE_zgebak_work(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, scale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgebal_work
 */
extern proc LAPACKE_sgebal_work(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] c_float, lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgebal_work
 */
inline proc LAPACKE_sgebal_work(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] c_float, lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float) : c_int{
  return LAPACKE_sgebal_work(matrix_order, ascii(job) : c_char, n, a, lda, ilo, ihi, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgebal_work
 */
extern proc LAPACKE_dgebal_work(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] c_double, lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgebal_work
 */
inline proc LAPACKE_dgebal_work(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] c_double, lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double) : c_int{
  return LAPACKE_dgebal_work(matrix_order, ascii(job) : c_char, n, a, lda, ilo, ihi, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgebal_work
 */
extern proc LAPACKE_cgebal_work(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] complex(64), lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgebal_work
 */
inline proc LAPACKE_cgebal_work(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] complex(64), lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float) : c_int{
  return LAPACKE_cgebal_work(matrix_order, ascii(job) : c_char, n, a, lda, ilo, ihi, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgebal_work
 */
extern proc LAPACKE_zgebal_work(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] complex(128), lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgebal_work
 */
inline proc LAPACKE_zgebal_work(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] complex(128), lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double) : c_int{
  return LAPACKE_zgebal_work(matrix_order, ascii(job) : c_char, n, a, lda, ilo, ihi, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgebrd_work
 */
extern proc LAPACKE_sgebrd_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, d : [] c_float, e : [] c_float, tauq : [] c_float, taup : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgebrd_work
 */
extern proc LAPACKE_dgebrd_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, d : [] c_double, e : [] c_double, tauq : [] c_double, taup : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgebrd_work
 */
extern proc LAPACKE_cgebrd_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, d : [] c_float, e : [] c_float, tauq : [] complex(64), taup : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgebrd_work
 */
extern proc LAPACKE_zgebrd_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, d : [] c_double, e : [] c_double, tauq : [] complex(128), taup : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgecon_work
 */
extern proc LAPACKE_sgecon_work(matrix_order : lapack_memory_order, norm : c_char, n : c_int, a : [] c_float, lda : c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgecon_work
 */
inline proc LAPACKE_sgecon_work(matrix_order : lapack_memory_order, norm : string, n : c_int, a : [] c_float, lda : c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgecon_work(matrix_order, ascii(norm) : c_char, n, a, lda, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgecon_work
 */
extern proc LAPACKE_dgecon_work(matrix_order : lapack_memory_order, norm : c_char, n : c_int, a : [] c_double, lda : c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgecon_work
 */
inline proc LAPACKE_dgecon_work(matrix_order : lapack_memory_order, norm : string, n : c_int, a : [] c_double, lda : c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgecon_work(matrix_order, ascii(norm) : c_char, n, a, lda, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgecon_work
 */
extern proc LAPACKE_cgecon_work(matrix_order : lapack_memory_order, norm : c_char, n : c_int, a : [] complex(64), lda : c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgecon_work
 */
inline proc LAPACKE_cgecon_work(matrix_order : lapack_memory_order, norm : string, n : c_int, a : [] complex(64), lda : c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgecon_work(matrix_order, ascii(norm) : c_char, n, a, lda, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgecon_work
 */
extern proc LAPACKE_zgecon_work(matrix_order : lapack_memory_order, norm : c_char, n : c_int, a : [] complex(128), lda : c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgecon_work
 */
inline proc LAPACKE_zgecon_work(matrix_order : lapack_memory_order, norm : string, n : c_int, a : [] complex(128), lda : c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgecon_work(matrix_order, ascii(norm) : c_char, n, a, lda, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeequ_work
 */
extern proc LAPACKE_sgeequ_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeequ_work
 */
extern proc LAPACKE_dgeequ_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeequ_work
 */
extern proc LAPACKE_cgeequ_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeequ_work
 */
extern proc LAPACKE_zgeequ_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeequb_work
 */
extern proc LAPACKE_sgeequb_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeequb_work
 */
extern proc LAPACKE_dgeequb_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeequb_work
 */
extern proc LAPACKE_cgeequb_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeequb_work
 */
extern proc LAPACKE_zgeequb_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgees_work
 */
extern proc LAPACKE_sgees_work(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_S_SELECT2, n : c_int, a : [] c_float, lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ldvs : c_int, work : [] c_float, lwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgees_work
 */
inline proc LAPACKE_sgees_work(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_S_SELECT2, n : c_int, a : [] c_float, lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ldvs : c_int, work : [] c_float, lwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_sgees_work(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgees_work
 */
extern proc LAPACKE_dgees_work(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_D_SELECT2, n : c_int, a : [] c_double, lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ldvs : c_int, work : [] c_double, lwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgees_work
 */
inline proc LAPACKE_dgees_work(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_D_SELECT2, n : c_int, a : [] c_double, lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ldvs : c_int, work : [] c_double, lwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_dgees_work(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgees_work
 */
extern proc LAPACKE_cgees_work(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_C_SELECT1, n : c_int, a : [] complex(64), lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ldvs : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgees_work
 */
inline proc LAPACKE_cgees_work(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_C_SELECT1, n : c_int, a : [] complex(64), lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ldvs : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, bwork : [] c_int) : c_int{
  return LAPACKE_cgees_work(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgees_work
 */
extern proc LAPACKE_zgees_work(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_Z_SELECT1, n : c_int, a : [] complex(128), lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ldvs : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgees_work
 */
inline proc LAPACKE_zgees_work(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_Z_SELECT1, n : c_int, a : [] complex(128), lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ldvs : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, bwork : [] c_int) : c_int{
  return LAPACKE_zgees_work(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeesx_work
 */
extern proc LAPACKE_sgeesx_work(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_S_SELECT2, sense : c_char, n : c_int, a : [] c_float, lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ldvs : c_int, ref rconde : c_float, ref rcondv : c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgeesx_work
 */
inline proc LAPACKE_sgeesx_work(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_S_SELECT2, sense : string, n : c_int, a : [] c_float, lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ldvs : c_int, ref rconde : c_float, ref rcondv : c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_sgeesx_work(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeesx_work
 */
extern proc LAPACKE_dgeesx_work(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_D_SELECT2, sense : c_char, n : c_int, a : [] c_double, lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ldvs : c_int, ref rconde : c_double, ref rcondv : c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgeesx_work
 */
inline proc LAPACKE_dgeesx_work(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_D_SELECT2, sense : string, n : c_int, a : [] c_double, lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ldvs : c_int, ref rconde : c_double, ref rcondv : c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_dgeesx_work(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeesx_work
 */
extern proc LAPACKE_cgeesx_work(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_C_SELECT1, sense : c_char, n : c_int, a : [] complex(64), lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ldvs : c_int, ref rconde : c_float, ref rcondv : c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgeesx_work
 */
inline proc LAPACKE_cgeesx_work(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_C_SELECT1, sense : string, n : c_int, a : [] complex(64), lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ldvs : c_int, ref rconde : c_float, ref rcondv : c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, bwork : [] c_int) : c_int{
  return LAPACKE_cgeesx_work(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeesx_work
 */
extern proc LAPACKE_zgeesx_work(matrix_order : lapack_memory_order, jobvs : c_char, sort : c_char, chlapack_select : LAPACK_Z_SELECT1, sense : c_char, n : c_int, a : [] complex(128), lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ldvs : c_int, ref rconde : c_double, ref rcondv : c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgeesx_work
 */
inline proc LAPACKE_zgeesx_work(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_Z_SELECT1, sense : string, n : c_int, a : [] complex(128), lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ldvs : c_int, ref rconde : c_double, ref rcondv : c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, bwork : [] c_int) : c_int{
  return LAPACKE_zgeesx_work(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeev_work
 */
extern proc LAPACKE_sgeev_work(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] c_float, lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgeev_work
 */
inline proc LAPACKE_sgeev_work(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] c_float, lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sgeev_work(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeev_work
 */
extern proc LAPACKE_dgeev_work(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] c_double, lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgeev_work
 */
inline proc LAPACKE_dgeev_work(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] c_double, lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dgeev_work(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeev_work
 */
extern proc LAPACKE_cgeev_work(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] complex(64), lda : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgeev_work
 */
inline proc LAPACKE_cgeev_work(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] complex(64), lda : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_cgeev_work(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeev_work
 */
extern proc LAPACKE_zgeev_work(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] complex(128), lda : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgeev_work
 */
inline proc LAPACKE_zgeev_work(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] complex(128), lda : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_zgeev_work(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeevx_work
 */
extern proc LAPACKE_sgeevx_work(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] c_float, lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgeevx_work
 */
inline proc LAPACKE_sgeevx_work(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] c_float, lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_sgeevx_work(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeevx_work
 */
extern proc LAPACKE_dgeevx_work(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] c_double, lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgeevx_work
 */
inline proc LAPACKE_dgeevx_work(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] c_double, lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_dgeevx_work(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeevx_work
 */
extern proc LAPACKE_cgeevx_work(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] complex(64), lda : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgeevx_work
 */
inline proc LAPACKE_cgeevx_work(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] complex(64), lda : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_cgeevx_work(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeevx_work
 */
extern proc LAPACKE_zgeevx_work(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] complex(128), lda : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgeevx_work
 */
inline proc LAPACKE_zgeevx_work(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] complex(128), lda : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_zgeevx_work(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgehrd_work
 */
extern proc LAPACKE_sgehrd_work(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgehrd_work
 */
extern proc LAPACKE_dgehrd_work(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgehrd_work
 */
extern proc LAPACKE_cgehrd_work(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgehrd_work
 */
extern proc LAPACKE_zgehrd_work(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgejsv_work
 */
extern proc LAPACKE_sgejsv_work(matrix_order : lapack_memory_order, joba : c_char, jobu : c_char, jobv : c_char, jobr : c_char, jobt : c_char, jobp : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, sva : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgejsv_work
 */
inline proc LAPACKE_sgejsv_work(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, jobr : string, jobt : string, jobp : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, sva : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_sgejsv_work(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobr) : c_char, ascii(jobt) : c_char, ascii(jobp) : c_char, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgejsv_work
 */
extern proc LAPACKE_dgejsv_work(matrix_order : lapack_memory_order, joba : c_char, jobu : c_char, jobv : c_char, jobr : c_char, jobt : c_char, jobp : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, sva : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgejsv_work
 */
inline proc LAPACKE_dgejsv_work(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, jobr : string, jobt : string, jobp : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, sva : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_dgejsv_work(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobr) : c_char, ascii(jobt) : c_char, ascii(jobp) : c_char, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelq2_work
 */
extern proc LAPACKE_sgelq2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelq2_work
 */
extern proc LAPACKE_dgelq2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelq2_work
 */
extern proc LAPACKE_cgelq2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelq2_work
 */
extern proc LAPACKE_zgelq2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelqf_work
 */
extern proc LAPACKE_sgelqf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelqf_work
 */
extern proc LAPACKE_dgelqf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelqf_work
 */
extern proc LAPACKE_cgelqf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelqf_work
 */
extern proc LAPACKE_zgelqf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgels_work
 */
extern proc LAPACKE_sgels_work(matrix_order : lapack_memory_order, trans : c_char, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgels_work
 */
inline proc LAPACKE_sgels_work(matrix_order : lapack_memory_order, trans : string, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sgels_work(matrix_order, ascii(trans) : c_char, m, n, nrhs, a, lda, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgels_work
 */
extern proc LAPACKE_dgels_work(matrix_order : lapack_memory_order, trans : c_char, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgels_work
 */
inline proc LAPACKE_dgels_work(matrix_order : lapack_memory_order, trans : string, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dgels_work(matrix_order, ascii(trans) : c_char, m, n, nrhs, a, lda, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgels_work
 */
extern proc LAPACKE_cgels_work(matrix_order : lapack_memory_order, trans : c_char, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgels_work
 */
inline proc LAPACKE_cgels_work(matrix_order : lapack_memory_order, trans : string, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cgels_work(matrix_order, ascii(trans) : c_char, m, n, nrhs, a, lda, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgels_work
 */
extern proc LAPACKE_zgels_work(matrix_order : lapack_memory_order, trans : c_char, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgels_work
 */
inline proc LAPACKE_zgels_work(matrix_order : lapack_memory_order, trans : string, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zgels_work(matrix_order, ascii(trans) : c_char, m, n, nrhs, a, lda, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelsd_work
 */
extern proc LAPACKE_sgelsd_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, s : [] c_float, rcond : c_float, ref rank : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelsd_work
 */
extern proc LAPACKE_dgelsd_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, s : [] c_double, rcond : c_double, ref rank : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelsd_work
 */
extern proc LAPACKE_cgelsd_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, s : [] c_float, rcond : c_float, ref rank : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelsd_work
 */
extern proc LAPACKE_zgelsd_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, s : [] c_double, rcond : c_double, ref rank : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelss_work
 */
extern proc LAPACKE_sgelss_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, s : [] c_float, rcond : c_float, ref rank : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelss_work
 */
extern proc LAPACKE_dgelss_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, s : [] c_double, rcond : c_double, ref rank : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelss_work
 */
extern proc LAPACKE_cgelss_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, s : [] c_float, rcond : c_float, ref rank : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelss_work
 */
extern proc LAPACKE_zgelss_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, s : [] c_double, rcond : c_double, ref rank : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgelsy_work
 */
extern proc LAPACKE_sgelsy_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, jpvt : [] c_int, rcond : c_float, ref rank : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgelsy_work
 */
extern proc LAPACKE_dgelsy_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, jpvt : [] c_int, rcond : c_double, ref rank : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgelsy_work
 */
extern proc LAPACKE_cgelsy_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, jpvt : [] c_int, rcond : c_float, ref rank : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgelsy_work
 */
extern proc LAPACKE_zgelsy_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, jpvt : [] c_int, rcond : c_double, ref rank : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqlf_work
 */
extern proc LAPACKE_sgeqlf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqlf_work
 */
extern proc LAPACKE_dgeqlf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqlf_work
 */
extern proc LAPACKE_cgeqlf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqlf_work
 */
extern proc LAPACKE_zgeqlf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqp3_work
 */
extern proc LAPACKE_sgeqp3_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, jpvt : [] c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqp3_work
 */
extern proc LAPACKE_dgeqp3_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, jpvt : [] c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqp3_work
 */
extern proc LAPACKE_cgeqp3_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, jpvt : [] c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqp3_work
 */
extern proc LAPACKE_zgeqp3_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, jpvt : [] c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqpf_work
 */
extern proc LAPACKE_sgeqpf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, jpvt : [] c_int, tau : [] c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqpf_work
 */
extern proc LAPACKE_dgeqpf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, jpvt : [] c_int, tau : [] c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqpf_work
 */
extern proc LAPACKE_cgeqpf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, jpvt : [] c_int, tau : [] complex(64), work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqpf_work
 */
extern proc LAPACKE_zgeqpf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, jpvt : [] c_int, tau : [] complex(128), work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqr2_work
 */
extern proc LAPACKE_sgeqr2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqr2_work
 */
extern proc LAPACKE_dgeqr2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqr2_work
 */
extern proc LAPACKE_cgeqr2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqr2_work
 */
extern proc LAPACKE_zgeqr2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrf_work
 */
extern proc LAPACKE_sgeqrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrf_work
 */
extern proc LAPACKE_dgeqrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrf_work
 */
extern proc LAPACKE_cgeqrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrf_work
 */
extern proc LAPACKE_zgeqrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrfp_work
 */
extern proc LAPACKE_sgeqrfp_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrfp_work
 */
extern proc LAPACKE_dgeqrfp_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrfp_work
 */
extern proc LAPACKE_cgeqrfp_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrfp_work
 */
extern proc LAPACKE_zgeqrfp_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgerfs_work
 */
extern proc LAPACKE_sgerfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgerfs_work
 */
inline proc LAPACKE_sgerfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgerfs_work(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgerfs_work
 */
extern proc LAPACKE_dgerfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgerfs_work
 */
inline proc LAPACKE_dgerfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgerfs_work(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgerfs_work
 */
extern proc LAPACKE_cgerfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgerfs_work
 */
inline proc LAPACKE_cgerfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgerfs_work(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgerfs_work
 */
extern proc LAPACKE_zgerfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgerfs_work
 */
inline proc LAPACKE_zgerfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgerfs_work(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgerfsx_work
 */
extern proc LAPACKE_sgerfsx_work(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgerfsx_work
 */
inline proc LAPACKE_sgerfsx_work(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgerfsx_work(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgerfsx_work
 */
extern proc LAPACKE_dgerfsx_work(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgerfsx_work
 */
inline proc LAPACKE_dgerfsx_work(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgerfsx_work(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgerfsx_work
 */
extern proc LAPACKE_cgerfsx_work(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgerfsx_work
 */
inline proc LAPACKE_cgerfsx_work(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgerfsx_work(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgerfsx_work
 */
extern proc LAPACKE_zgerfsx_work(matrix_order : lapack_memory_order, trans : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgerfsx_work
 */
inline proc LAPACKE_zgerfsx_work(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgerfsx_work(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgerqf_work
 */
extern proc LAPACKE_sgerqf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgerqf_work
 */
extern proc LAPACKE_dgerqf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgerqf_work
 */
extern proc LAPACKE_cgerqf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgerqf_work
 */
extern proc LAPACKE_zgerqf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesdd_work
 */
extern proc LAPACKE_sgesdd_work(matrix_order : lapack_memory_order, jobz : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesdd_work
 */
inline proc LAPACKE_sgesdd_work(matrix_order : lapack_memory_order, jobz : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_sgesdd_work(matrix_order, ascii(jobz) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesdd_work
 */
extern proc LAPACKE_dgesdd_work(matrix_order : lapack_memory_order, jobz : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesdd_work
 */
inline proc LAPACKE_dgesdd_work(matrix_order : lapack_memory_order, jobz : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_dgesdd_work(matrix_order, ascii(jobz) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesdd_work
 */
extern proc LAPACKE_cgesdd_work(matrix_order : lapack_memory_order, jobz : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, u : [] complex(64), ldu : c_int, vt : [] complex(64), ldvt : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgesdd_work
 */
inline proc LAPACKE_cgesdd_work(matrix_order : lapack_memory_order, jobz : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, u : [] complex(64), ldu : c_int, vt : [] complex(64), ldvt : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_cgesdd_work(matrix_order, ascii(jobz) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesdd_work
 */
extern proc LAPACKE_zgesdd_work(matrix_order : lapack_memory_order, jobz : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, u : [] complex(128), ldu : c_int, vt : [] complex(128), ldvt : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgesdd_work
 */
inline proc LAPACKE_zgesdd_work(matrix_order : lapack_memory_order, jobz : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, u : [] complex(128), ldu : c_int, vt : [] complex(128), ldvt : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_zgesdd_work(matrix_order, ascii(jobz) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesv_work
 */
extern proc LAPACKE_sgesv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesv_work
 */
extern proc LAPACKE_dgesv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesv_work
 */
extern proc LAPACKE_cgesv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesv_work
 */
extern proc LAPACKE_zgesv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dsgesv_work
 */
extern proc LAPACKE_dsgesv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, work : [] c_double, swork : [] c_float, ref chlapack_iter : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zcgesv_work
 */
extern proc LAPACKE_zcgesv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, work : [] complex(128), swork : [] complex(64), rwork : [] c_double, ref chlapack_iter : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesvd_work
 */
extern proc LAPACKE_sgesvd_work(matrix_order : lapack_memory_order, jobu : c_char, jobvt : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesvd_work
 */
inline proc LAPACKE_sgesvd_work(matrix_order : lapack_memory_order, jobu : string, jobvt : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, u : [] c_float, ldu : c_int, vt : [] c_float, ldvt : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sgesvd_work(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesvd_work
 */
extern proc LAPACKE_dgesvd_work(matrix_order : lapack_memory_order, jobu : c_char, jobvt : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesvd_work
 */
inline proc LAPACKE_dgesvd_work(matrix_order : lapack_memory_order, jobu : string, jobvt : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, u : [] c_double, ldu : c_int, vt : [] c_double, ldvt : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dgesvd_work(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesvd_work
 */
extern proc LAPACKE_cgesvd_work(matrix_order : lapack_memory_order, jobu : c_char, jobvt : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, u : [] complex(64), ldu : c_int, vt : [] complex(64), ldvt : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgesvd_work
 */
inline proc LAPACKE_cgesvd_work(matrix_order : lapack_memory_order, jobu : string, jobvt : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, u : [] complex(64), ldu : c_int, vt : [] complex(64), ldvt : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_cgesvd_work(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesvd_work
 */
extern proc LAPACKE_zgesvd_work(matrix_order : lapack_memory_order, jobu : c_char, jobvt : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, u : [] complex(128), ldu : c_int, vt : [] complex(128), ldvt : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgesvd_work
 */
inline proc LAPACKE_zgesvd_work(matrix_order : lapack_memory_order, jobu : string, jobvt : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, u : [] complex(128), ldu : c_int, vt : [] complex(128), ldvt : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_zgesvd_work(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesvj_work
 */
extern proc LAPACKE_sgesvj_work(matrix_order : lapack_memory_order, joba : c_char, jobu : c_char, jobv : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, sva : [] c_float, mv : c_int, v : [] c_float, ldv : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesvj_work
 */
inline proc LAPACKE_sgesvj_work(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, sva : [] c_float, mv : c_int, v : [] c_float, ldv : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sgesvj_work(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, m, n, a, lda, sva, mv, v, ldv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesvj_work
 */
extern proc LAPACKE_dgesvj_work(matrix_order : lapack_memory_order, joba : c_char, jobu : c_char, jobv : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, sva : [] c_double, mv : c_int, v : [] c_double, ldv : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesvj_work
 */
inline proc LAPACKE_dgesvj_work(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, sva : [] c_double, mv : c_int, v : [] c_double, ldv : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dgesvj_work(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, m, n, a, lda, sva, mv, v, ldv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesvx_work
 */
extern proc LAPACKE_sgesvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesvx_work
 */
inline proc LAPACKE_sgesvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgesvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesvx_work
 */
extern proc LAPACKE_dgesvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesvx_work
 */
inline proc LAPACKE_dgesvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgesvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesvx_work
 */
extern proc LAPACKE_cgesvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgesvx_work
 */
inline proc LAPACKE_cgesvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgesvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesvx_work
 */
extern proc LAPACKE_zgesvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgesvx_work
 */
inline proc LAPACKE_zgesvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgesvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgesvxx_work
 */
extern proc LAPACKE_sgesvxx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgesvxx_work
 */
inline proc LAPACKE_sgesvxx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgesvxx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgesvxx_work
 */
extern proc LAPACKE_dgesvxx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgesvxx_work
 */
inline proc LAPACKE_dgesvxx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgesvxx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgesvxx_work
 */
extern proc LAPACKE_cgesvxx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgesvxx_work
 */
inline proc LAPACKE_cgesvxx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgesvxx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgesvxx_work
 */
extern proc LAPACKE_zgesvxx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgesvxx_work
 */
inline proc LAPACKE_zgesvxx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgesvxx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgetf2_work
 */
extern proc LAPACKE_sgetf2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgetf2_work
 */
extern proc LAPACKE_dgetf2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgetf2_work
 */
extern proc LAPACKE_cgetf2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgetf2_work
 */
extern proc LAPACKE_zgetf2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgetrf_work
 */
extern proc LAPACKE_sgetrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgetrf_work
 */
extern proc LAPACKE_dgetrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgetrf_work
 */
extern proc LAPACKE_cgetrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgetrf_work
 */
extern proc LAPACKE_zgetrf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgetri_work
 */
extern proc LAPACKE_sgetri_work(matrix_order : lapack_memory_order, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgetri_work
 */
extern proc LAPACKE_dgetri_work(matrix_order : lapack_memory_order, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgetri_work
 */
extern proc LAPACKE_cgetri_work(matrix_order : lapack_memory_order, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgetri_work
 */
extern proc LAPACKE_zgetri_work(matrix_order : lapack_memory_order, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgetrs_work
 */
extern proc LAPACKE_sgetrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgetrs_work
 */
inline proc LAPACKE_sgetrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sgetrs_work(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgetrs_work
 */
extern proc LAPACKE_dgetrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgetrs_work
 */
inline proc LAPACKE_dgetrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dgetrs_work(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgetrs_work
 */
extern proc LAPACKE_cgetrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgetrs_work
 */
inline proc LAPACKE_cgetrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cgetrs_work(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgetrs_work
 */
extern proc LAPACKE_zgetrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgetrs_work
 */
inline proc LAPACKE_zgetrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zgetrs_work(matrix_order, ascii(trans) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggbak_work
 */
extern proc LAPACKE_sggbak_work(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, m : c_int, v : [] c_float, ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggbak_work
 */
inline proc LAPACKE_sggbak_work(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, m : c_int, v : [] c_float, ldv : c_int) : c_int{
  return LAPACKE_sggbak_work(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, lscale, rscale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggbak_work
 */
extern proc LAPACKE_dggbak_work(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, m : c_int, v : [] c_double, ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggbak_work
 */
inline proc LAPACKE_dggbak_work(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, m : c_int, v : [] c_double, ldv : c_int) : c_int{
  return LAPACKE_dggbak_work(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, lscale, rscale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggbak_work
 */
extern proc LAPACKE_cggbak_work(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, m : c_int, v : [] complex(64), ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggbak_work
 */
inline proc LAPACKE_cggbak_work(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, m : c_int, v : [] complex(64), ldv : c_int) : c_int{
  return LAPACKE_cggbak_work(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, lscale, rscale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggbak_work
 */
extern proc LAPACKE_zggbak_work(matrix_order : lapack_memory_order, job : c_char, side : c_char, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, m : c_int, v : [] complex(128), ldv : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggbak_work
 */
inline proc LAPACKE_zggbak_work(matrix_order : lapack_memory_order, job : string, side : string, n : c_int, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, m : c_int, v : [] complex(128), ldv : c_int) : c_int{
  return LAPACKE_zggbak_work(matrix_order, ascii(job) : c_char, ascii(side) : c_char, n, ilo, ihi, lscale, rscale, m, v, ldv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggbal_work
 */
extern proc LAPACKE_sggbal_work(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggbal_work
 */
inline proc LAPACKE_sggbal_work(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, work : [] c_float) : c_int{
  return LAPACKE_sggbal_work(matrix_order, ascii(job) : c_char, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggbal_work
 */
extern proc LAPACKE_dggbal_work(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggbal_work
 */
inline proc LAPACKE_dggbal_work(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, work : [] c_double) : c_int{
  return LAPACKE_dggbal_work(matrix_order, ascii(job) : c_char, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggbal_work
 */
extern proc LAPACKE_cggbal_work(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggbal_work
 */
inline proc LAPACKE_cggbal_work(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, work : [] c_float) : c_int{
  return LAPACKE_cggbal_work(matrix_order, ascii(job) : c_char, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggbal_work
 */
extern proc LAPACKE_zggbal_work(matrix_order : lapack_memory_order, job : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggbal_work
 */
inline proc LAPACKE_zggbal_work(matrix_order : lapack_memory_order, job : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, work : [] c_double) : c_int{
  return LAPACKE_zggbal_work(matrix_order, ascii(job) : c_char, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgges_work
 */
extern proc LAPACKE_sgges_work(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_S_SELECT3, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ldvsl : c_int, vsr : [] c_float, ldvsr : c_int, work : [] c_float, lwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgges_work
 */
inline proc LAPACKE_sgges_work(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_S_SELECT3, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ldvsl : c_int, vsr : [] c_float, ldvsr : c_int, work : [] c_float, lwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_sgges_work(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgges_work
 */
extern proc LAPACKE_dgges_work(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_D_SELECT3, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ldvsl : c_int, vsr : [] c_double, ldvsr : c_int, work : [] c_double, lwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgges_work
 */
inline proc LAPACKE_dgges_work(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_D_SELECT3, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ldvsl : c_int, vsr : [] c_double, ldvsr : c_int, work : [] c_double, lwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_dgges_work(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgges_work
 */
extern proc LAPACKE_cgges_work(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_C_SELECT2, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ldvsl : c_int, vsr : [] complex(64), ldvsr : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgges_work
 */
inline proc LAPACKE_cgges_work(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_C_SELECT2, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ldvsl : c_int, vsr : [] complex(64), ldvsr : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, bwork : [] c_int) : c_int{
  return LAPACKE_cgges_work(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgges_work
 */
extern proc LAPACKE_zgges_work(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_Z_SELECT2, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ldvsl : c_int, vsr : [] complex(128), ldvsr : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgges_work
 */
inline proc LAPACKE_zgges_work(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_Z_SELECT2, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ldvsl : c_int, vsr : [] complex(128), ldvsr : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, bwork : [] c_int) : c_int{
  return LAPACKE_zgges_work(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggesx_work
 */
extern proc LAPACKE_sggesx_work(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_S_SELECT3, sense : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ldvsl : c_int, vsr : [] c_float, ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggesx_work
 */
inline proc LAPACKE_sggesx_work(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_S_SELECT3, sense : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ldvsl : c_int, vsr : [] c_float, ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_sggesx_work(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggesx_work
 */
extern proc LAPACKE_dggesx_work(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_D_SELECT3, sense : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ldvsl : c_int, vsr : [] c_double, ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggesx_work
 */
inline proc LAPACKE_dggesx_work(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_D_SELECT3, sense : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ldvsl : c_int, vsr : [] c_double, ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_dggesx_work(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggesx_work
 */
extern proc LAPACKE_cggesx_work(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_C_SELECT2, sense : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ldvsl : c_int, vsr : [] complex(64), ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggesx_work
 */
inline proc LAPACKE_cggesx_work(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_C_SELECT2, sense : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ldvsl : c_int, vsr : [] complex(64), ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_cggesx_work(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggesx_work
 */
extern proc LAPACKE_zggesx_work(matrix_order : lapack_memory_order, jobvsl : c_char, jobvsr : c_char, sort : c_char, selctg : LAPACK_Z_SELECT2, sense : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ldvsl : c_int, vsr : [] complex(128), ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggesx_work
 */
inline proc LAPACKE_zggesx_work(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_Z_SELECT2, sense : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ldvsl : c_int, vsr : [] complex(128), ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int, liwork : c_int, bwork : [] c_int) : c_int{
  return LAPACKE_zggesx_work(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggev_work
 */
extern proc LAPACKE_sggev_work(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggev_work
 */
inline proc LAPACKE_sggev_work(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sggev_work(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggev_work
 */
extern proc LAPACKE_dggev_work(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggev_work
 */
inline proc LAPACKE_dggev_work(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dggev_work(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggev_work
 */
extern proc LAPACKE_cggev_work(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggev_work
 */
inline proc LAPACKE_cggev_work(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_cggev_work(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggev_work
 */
extern proc LAPACKE_zggev_work(matrix_order : lapack_memory_order, jobvl : c_char, jobvr : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggev_work
 */
inline proc LAPACKE_zggev_work(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_zggev_work(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggevx_work
 */
extern proc LAPACKE_sggevx_work(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggevx_work
 */
inline proc LAPACKE_sggevx_work(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, bwork : [] c_int) : c_int{
  return LAPACKE_sggevx_work(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggevx_work
 */
extern proc LAPACKE_dggevx_work(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggevx_work
 */
inline proc LAPACKE_dggevx_work(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, bwork : [] c_int) : c_int{
  return LAPACKE_dggevx_work(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggevx_work
 */
extern proc LAPACKE_cggevx_work(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggevx_work
 */
inline proc LAPACKE_cggevx_work(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int, bwork : [] c_int) : c_int{
  return LAPACKE_cggevx_work(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggevx_work
 */
extern proc LAPACKE_zggevx_work(matrix_order : lapack_memory_order, balanc : c_char, jobvl : c_char, jobvr : c_char, sense : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int, bwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggevx_work
 */
inline proc LAPACKE_zggevx_work(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int, bwork : [] c_int) : c_int{
  return LAPACKE_zggevx_work(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggglm_work
 */
extern proc LAPACKE_sggglm_work(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, d : [] c_float, x : [] c_float, y : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dggglm_work
 */
extern proc LAPACKE_dggglm_work(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, d : [] c_double, x : [] c_double, y : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cggglm_work
 */
extern proc LAPACKE_cggglm_work(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, d : [] complex(64), x : [] complex(64), y : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zggglm_work
 */
extern proc LAPACKE_zggglm_work(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, d : [] complex(128), x : [] complex(128), y : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgghrd_work
 */
extern proc LAPACKE_sgghrd_work(matrix_order : lapack_memory_order, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgghrd_work
 */
inline proc LAPACKE_sgghrd_work(matrix_order : lapack_memory_order, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int) : c_int{
  return LAPACKE_sgghrd_work(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgghrd_work
 */
extern proc LAPACKE_dgghrd_work(matrix_order : lapack_memory_order, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgghrd_work
 */
inline proc LAPACKE_dgghrd_work(matrix_order : lapack_memory_order, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int) : c_int{
  return LAPACKE_dgghrd_work(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgghrd_work
 */
extern proc LAPACKE_cgghrd_work(matrix_order : lapack_memory_order, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgghrd_work
 */
inline proc LAPACKE_cgghrd_work(matrix_order : lapack_memory_order, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int) : c_int{
  return LAPACKE_cgghrd_work(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgghrd_work
 */
extern proc LAPACKE_zgghrd_work(matrix_order : lapack_memory_order, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgghrd_work
 */
inline proc LAPACKE_zgghrd_work(matrix_order : lapack_memory_order, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int) : c_int{
  return LAPACKE_zgghrd_work(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgglse_work
 */
extern proc LAPACKE_sgglse_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, p : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, d : [] c_float, x : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgglse_work
 */
extern proc LAPACKE_dgglse_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, p : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, d : [] c_double, x : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgglse_work
 */
extern proc LAPACKE_cgglse_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, p : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), d : [] complex(64), x : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgglse_work
 */
extern proc LAPACKE_zgglse_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, p : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), d : [] complex(128), x : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sggqrf_work
 */
extern proc LAPACKE_sggqrf_work(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] c_float, lda : c_int, taua : [] c_float, b : [] c_float, ldb : c_int, taub : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dggqrf_work
 */
extern proc LAPACKE_dggqrf_work(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] c_double, lda : c_int, taua : [] c_double, b : [] c_double, ldb : c_int, taub : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cggqrf_work
 */
extern proc LAPACKE_cggqrf_work(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] complex(64), lda : c_int, taua : [] complex(64), b : [] complex(64), ldb : c_int, taub : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zggqrf_work
 */
extern proc LAPACKE_zggqrf_work(matrix_order : lapack_memory_order, n : c_int, m : c_int, p : c_int, a : [] complex(128), lda : c_int, taua : [] complex(128), b : [] complex(128), ldb : c_int, taub : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sggrqf_work
 */
extern proc LAPACKE_sggrqf_work(matrix_order : lapack_memory_order, m : c_int, p : c_int, n : c_int, a : [] c_float, lda : c_int, taua : [] c_float, b : [] c_float, ldb : c_int, taub : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dggrqf_work
 */
extern proc LAPACKE_dggrqf_work(matrix_order : lapack_memory_order, m : c_int, p : c_int, n : c_int, a : [] c_double, lda : c_int, taua : [] c_double, b : [] c_double, ldb : c_int, taub : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cggrqf_work
 */
extern proc LAPACKE_cggrqf_work(matrix_order : lapack_memory_order, m : c_int, p : c_int, n : c_int, a : [] complex(64), lda : c_int, taua : [] complex(64), b : [] complex(64), ldb : c_int, taub : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zggrqf_work
 */
extern proc LAPACKE_zggrqf_work(matrix_order : lapack_memory_order, m : c_int, p : c_int, n : c_int, a : [] complex(128), lda : c_int, taua : [] complex(128), b : [] complex(128), ldb : c_int, taub : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sggsvd_work
 */
extern proc LAPACKE_sggsvd_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggsvd_work
 */
inline proc LAPACKE_sggsvd_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sggsvd_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggsvd_work
 */
extern proc LAPACKE_dggsvd_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggsvd_work
 */
inline proc LAPACKE_dggsvd_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dggsvd_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggsvd_work
 */
extern proc LAPACKE_cggsvd_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggsvd_work
 */
inline proc LAPACKE_cggsvd_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_cggsvd_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggsvd_work
 */
extern proc LAPACKE_zggsvd_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggsvd_work
 */
inline proc LAPACKE_zggsvd_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, n : c_int, p : c_int, ref k : c_int, ref l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_zggsvd_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sggsvp_work
 */
extern proc LAPACKE_sggsvp_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, iwork : [] c_int, tau : [] c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sggsvp_work
 */
inline proc LAPACKE_sggsvp_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, iwork : [] c_int, tau : [] c_float, work : [] c_float) : c_int{
  return LAPACKE_sggsvp_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dggsvp_work
 */
extern proc LAPACKE_dggsvp_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, iwork : [] c_int, tau : [] c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dggsvp_work
 */
inline proc LAPACKE_dggsvp_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, iwork : [] c_int, tau : [] c_double, work : [] c_double) : c_int{
  return LAPACKE_dggsvp_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cggsvp_work
 */
extern proc LAPACKE_cggsvp_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, iwork : [] c_int, rwork : [] c_float, tau : [] complex(64), work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cggsvp_work
 */
inline proc LAPACKE_cggsvp_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, iwork : [] c_int, rwork : [] c_float, tau : [] complex(64), work : [] complex(64)) : c_int{
  return LAPACKE_cggsvp_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zggsvp_work
 */
extern proc LAPACKE_zggsvp_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, iwork : [] c_int, rwork : [] c_double, tau : [] complex(128), work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zggsvp_work
 */
inline proc LAPACKE_zggsvp_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, iwork : [] c_int, rwork : [] c_double, tau : [] complex(128), work : [] complex(128)) : c_int{
  return LAPACKE_zggsvp_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgtcon_work
 */
extern proc LAPACKE_sgtcon_work(norm : c_char, n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgtcon_work
 */
inline proc LAPACKE_sgtcon_work(norm : string, n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgtcon_work(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgtcon_work
 */
extern proc LAPACKE_dgtcon_work(norm : c_char, n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgtcon_work
 */
inline proc LAPACKE_dgtcon_work(norm : string, n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgtcon_work(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgtcon_work
 */
extern proc LAPACKE_cgtcon_work(norm : c_char, n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgtcon_work
 */
inline proc LAPACKE_cgtcon_work(norm : string, n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int{
  return LAPACKE_cgtcon_work(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgtcon_work
 */
extern proc LAPACKE_zgtcon_work(norm : c_char, n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgtcon_work
 */
inline proc LAPACKE_zgtcon_work(norm : string, n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int{
  return LAPACKE_zgtcon_work(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgtrfs_work
 */
extern proc LAPACKE_sgtrfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgtrfs_work
 */
inline proc LAPACKE_sgtrfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgtrfs_work(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgtrfs_work
 */
extern proc LAPACKE_dgtrfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgtrfs_work
 */
inline proc LAPACKE_dgtrfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgtrfs_work(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgtrfs_work
 */
extern proc LAPACKE_cgtrfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgtrfs_work
 */
inline proc LAPACKE_cgtrfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgtrfs_work(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgtrfs_work
 */
extern proc LAPACKE_zgtrfs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgtrfs_work
 */
inline proc LAPACKE_zgtrfs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgtrfs_work(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgtsv_work
 */
extern proc LAPACKE_sgtsv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgtsv_work
 */
extern proc LAPACKE_dgtsv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgtsv_work
 */
extern proc LAPACKE_cgtsv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgtsv_work
 */
extern proc LAPACKE_zgtsv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgtsvx_work
 */
extern proc LAPACKE_sgtsvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgtsvx_work
 */
inline proc LAPACKE_sgtsvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sgtsvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgtsvx_work
 */
extern proc LAPACKE_dgtsvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgtsvx_work
 */
inline proc LAPACKE_dgtsvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dgtsvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgtsvx_work
 */
extern proc LAPACKE_cgtsvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgtsvx_work
 */
inline proc LAPACKE_cgtsvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cgtsvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgtsvx_work
 */
extern proc LAPACKE_zgtsvx_work(matrix_order : lapack_memory_order, fact : c_char, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgtsvx_work
 */
inline proc LAPACKE_zgtsvx_work(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zgtsvx_work(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgttrf_work
 */
extern proc LAPACKE_sgttrf_work(n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgttrf_work
 */
extern proc LAPACKE_dgttrf_work(n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgttrf_work
 */
extern proc LAPACKE_cgttrf_work(n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgttrf_work
 */
extern proc LAPACKE_zgttrf_work(n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgttrs_work
 */
extern proc LAPACKE_sgttrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgttrs_work
 */
inline proc LAPACKE_sgttrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sgttrs_work(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgttrs_work
 */
extern proc LAPACKE_dgttrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgttrs_work
 */
inline proc LAPACKE_dgttrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dgttrs_work(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgttrs_work
 */
extern proc LAPACKE_cgttrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgttrs_work
 */
inline proc LAPACKE_cgttrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cgttrs_work(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgttrs_work
 */
extern proc LAPACKE_zgttrs_work(matrix_order : lapack_memory_order, trans : c_char, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgttrs_work
 */
inline proc LAPACKE_zgttrs_work(matrix_order : lapack_memory_order, trans : string, n : c_int, nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zgttrs_work(matrix_order, ascii(trans) : c_char, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbev_work
 */
extern proc LAPACKE_chbev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbev_work
 */
inline proc LAPACKE_chbev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_chbev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbev_work
 */
extern proc LAPACKE_zhbev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbev_work
 */
inline proc LAPACKE_zhbev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zhbev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbevd_work
 */
extern proc LAPACKE_chbevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbevd_work
 */
inline proc LAPACKE_chbevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_chbevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbevd_work
 */
extern proc LAPACKE_zhbevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbevd_work
 */
inline proc LAPACKE_zhbevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zhbevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbevx_work
 */
extern proc LAPACKE_chbevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, q : [] complex(64), ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbevx_work
 */
inline proc LAPACKE_chbevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, q : [] complex(64), ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chbevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbevx_work
 */
extern proc LAPACKE_zhbevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, q : [] complex(128), ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbevx_work
 */
inline proc LAPACKE_zhbevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, q : [] complex(128), ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhbevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbgst_work
 */
extern proc LAPACKE_chbgst_work(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, x : [] complex(64), ldx : c_int, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbgst_work
 */
inline proc LAPACKE_chbgst_work(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, x : [] complex(64), ldx : c_int, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_chbgst_work(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbgst_work
 */
extern proc LAPACKE_zhbgst_work(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, x : [] complex(128), ldx : c_int, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbgst_work
 */
inline proc LAPACKE_zhbgst_work(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, x : [] complex(128), ldx : c_int, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zhbgst_work(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbgv_work
 */
extern proc LAPACKE_chbgv_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbgv_work
 */
inline proc LAPACKE_chbgv_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_chbgv_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbgv_work
 */
extern proc LAPACKE_zhbgv_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbgv_work
 */
inline proc LAPACKE_zhbgv_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zhbgv_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbgvd_work
 */
extern proc LAPACKE_chbgvd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbgvd_work
 */
inline proc LAPACKE_chbgvd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_chbgvd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbgvd_work
 */
extern proc LAPACKE_zhbgvd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbgvd_work
 */
inline proc LAPACKE_zhbgvd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zhbgvd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbgvx_work
 */
extern proc LAPACKE_chbgvx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, q : [] complex(64), ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbgvx_work
 */
inline proc LAPACKE_chbgvx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), ldab : c_int, bb : [] complex(64), ldbb : c_int, q : [] complex(64), ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chbgvx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbgvx_work
 */
extern proc LAPACKE_zhbgvx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, q : [] complex(128), ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbgvx_work
 */
inline proc LAPACKE_zhbgvx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), ldab : c_int, bb : [] complex(128), ldbb : c_int, q : [] complex(128), ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhbgvx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chbtrd_work
 */
extern proc LAPACKE_chbtrd_work(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ldq : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chbtrd_work
 */
inline proc LAPACKE_chbtrd_work(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ldq : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_chbtrd_work(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, d, e, q, ldq, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhbtrd_work
 */
extern proc LAPACKE_zhbtrd_work(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ldq : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhbtrd_work
 */
inline proc LAPACKE_zhbtrd_work(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ldq : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zhbtrd_work(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, d, e, q, ldq, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_checon_work
 */
extern proc LAPACKE_checon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_checon_work
 */
inline proc LAPACKE_checon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int{
  return LAPACKE_checon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhecon_work
 */
extern proc LAPACKE_zhecon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhecon_work
 */
inline proc LAPACKE_zhecon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int{
  return LAPACKE_zhecon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheequb_work
 */
extern proc LAPACKE_cheequb_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheequb_work
 */
inline proc LAPACKE_cheequb_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, work : [] complex(64)) : c_int{
  return LAPACKE_cheequb_work(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheequb_work
 */
extern proc LAPACKE_zheequb_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheequb_work
 */
inline proc LAPACKE_zheequb_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, work : [] complex(128)) : c_int{
  return LAPACKE_zheequb_work(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheev_work
 */
extern proc LAPACKE_cheev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, w : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheev_work
 */
inline proc LAPACKE_cheev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, w : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_cheev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheev_work
 */
extern proc LAPACKE_zheev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, w : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheev_work
 */
inline proc LAPACKE_zheev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, w : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_zheev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheevd_work
 */
extern proc LAPACKE_cheevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, w : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheevd_work
 */
inline proc LAPACKE_cheevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, w : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_cheevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheevd_work
 */
extern proc LAPACKE_zheevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, w : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheevd_work
 */
inline proc LAPACKE_zheevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, w : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zheevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheevr_work
 */
extern proc LAPACKE_cheevr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, isuppz : [] c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheevr_work
 */
inline proc LAPACKE_cheevr_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, isuppz : [] c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_cheevr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheevr_work
 */
extern proc LAPACKE_zheevr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, isuppz : [] c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheevr_work
 */
inline proc LAPACKE_zheevr_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, isuppz : [] c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zheevr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheevx_work
 */
extern proc LAPACKE_cheevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheevx_work
 */
inline proc LAPACKE_cheevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_cheevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheevx_work
 */
extern proc LAPACKE_zheevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheevx_work
 */
inline proc LAPACKE_zheevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zheevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chegst_work
 */
extern proc LAPACKE_chegst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chegst_work
 */
inline proc LAPACKE_chegst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chegst_work(matrix_order, itype, ascii(uplo) : c_char, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhegst_work
 */
extern proc LAPACKE_zhegst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhegst_work
 */
inline proc LAPACKE_zhegst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhegst_work(matrix_order, itype, ascii(uplo) : c_char, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chegv_work
 */
extern proc LAPACKE_chegv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, w : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chegv_work
 */
inline proc LAPACKE_chegv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, w : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_chegv_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhegv_work
 */
extern proc LAPACKE_zhegv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, w : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhegv_work
 */
inline proc LAPACKE_zhegv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, w : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_zhegv_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chegvd_work
 */
extern proc LAPACKE_chegvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, w : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chegvd_work
 */
inline proc LAPACKE_chegvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, w : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_chegvd_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhegvd_work
 */
extern proc LAPACKE_zhegvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, w : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhegvd_work
 */
inline proc LAPACKE_zhegvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, w : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zhegvd_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chegvx_work
 */
extern proc LAPACKE_chegvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chegvx_work
 */
inline proc LAPACKE_chegvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chegvx_work(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhegvx_work
 */
extern proc LAPACKE_zhegvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhegvx_work
 */
inline proc LAPACKE_zhegvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhegvx_work(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cherfs_work
 */
extern proc LAPACKE_cherfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cherfs_work
 */
inline proc LAPACKE_cherfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cherfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zherfs_work
 */
extern proc LAPACKE_zherfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zherfs_work
 */
inline proc LAPACKE_zherfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zherfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cherfsx_work
 */
extern proc LAPACKE_cherfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cherfsx_work
 */
inline proc LAPACKE_cherfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cherfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zherfsx_work
 */
extern proc LAPACKE_zherfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zherfsx_work
 */
inline proc LAPACKE_zherfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zherfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chesv_work
 */
extern proc LAPACKE_chesv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chesv_work
 */
inline proc LAPACKE_chesv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_chesv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhesv_work
 */
extern proc LAPACKE_zhesv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhesv_work
 */
inline proc LAPACKE_zhesv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zhesv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chesvx_work
 */
extern proc LAPACKE_chesvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chesvx_work
 */
inline proc LAPACKE_chesvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_chesvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhesvx_work
 */
extern proc LAPACKE_zhesvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhesvx_work
 */
inline proc LAPACKE_zhesvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_zhesvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chesvxx_work
 */
extern proc LAPACKE_chesvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chesvxx_work
 */
inline proc LAPACKE_chesvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_chesvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhesvxx_work
 */
extern proc LAPACKE_zhesvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhesvxx_work
 */
inline proc LAPACKE_zhesvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zhesvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetrd_work
 */
extern proc LAPACKE_chetrd_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, d : [] c_float, e : [] c_float, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetrd_work
 */
inline proc LAPACKE_chetrd_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, d : [] c_float, e : [] c_float, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_chetrd_work(matrix_order, ascii(uplo) : c_char, n, a, lda, d, e, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetrd_work
 */
extern proc LAPACKE_zhetrd_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, d : [] c_double, e : [] c_double, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetrd_work
 */
inline proc LAPACKE_zhetrd_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, d : [] c_double, e : [] c_double, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zhetrd_work(matrix_order, ascii(uplo) : c_char, n, a, lda, d, e, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetrf_work
 */
extern proc LAPACKE_chetrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetrf_work
 */
inline proc LAPACKE_chetrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_chetrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetrf_work
 */
extern proc LAPACKE_zhetrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetrf_work
 */
inline proc LAPACKE_zhetrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zhetrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetri_work
 */
extern proc LAPACKE_chetri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetri_work
 */
inline proc LAPACKE_chetri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64)) : c_int{
  return LAPACKE_chetri_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetri_work
 */
extern proc LAPACKE_zhetri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetri_work
 */
inline proc LAPACKE_zhetri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zhetri_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetrs_work
 */
extern proc LAPACKE_chetrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetrs_work
 */
inline proc LAPACKE_chetrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chetrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetrs_work
 */
extern proc LAPACKE_zhetrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetrs_work
 */
inline proc LAPACKE_zhetrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhetrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chfrk_work
 */
extern proc LAPACKE_chfrk_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, trans : c_char, n : c_int, k : c_int, alpha : c_float, a : [] complex(64), lda : c_int, beta : c_float, c : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chfrk_work
 */
inline proc LAPACKE_chfrk_work(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, n : c_int, k : c_int, alpha : c_float, a : [] complex(64), lda : c_int, beta : c_float, c : [] complex(64)) : c_int{
  return LAPACKE_chfrk_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, n, k, alpha, a, lda, beta, c);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhfrk_work
 */
extern proc LAPACKE_zhfrk_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, trans : c_char, n : c_int, k : c_int, alpha : c_double, a : [] complex(128), lda : c_int, beta : c_double, c : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhfrk_work
 */
inline proc LAPACKE_zhfrk_work(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, n : c_int, k : c_int, alpha : c_double, a : [] complex(128), lda : c_int, beta : c_double, c : [] complex(128)) : c_int{
  return LAPACKE_zhfrk_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, n, k, alpha, a, lda, beta, c);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_shgeqz_work
 */
extern proc LAPACKE_shgeqz_work(matrix_order : lapack_memory_order, job : c_char, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] c_float, ldh : c_int, t : [] c_float, ldt : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_shgeqz_work
 */
inline proc LAPACKE_shgeqz_work(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] c_float, ldh : c_int, t : [] c_float, ldt : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_shgeqz_work(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dhgeqz_work
 */
extern proc LAPACKE_dhgeqz_work(matrix_order : lapack_memory_order, job : c_char, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] c_double, ldh : c_int, t : [] c_double, ldt : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dhgeqz_work
 */
inline proc LAPACKE_dhgeqz_work(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] c_double, ldh : c_int, t : [] c_double, ldt : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dhgeqz_work(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chgeqz_work
 */
extern proc LAPACKE_chgeqz_work(matrix_order : lapack_memory_order, job : c_char, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(64), ldh : c_int, t : [] complex(64), ldt : c_int, alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chgeqz_work
 */
inline proc LAPACKE_chgeqz_work(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(64), ldh : c_int, t : [] complex(64), ldt : c_int, alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_chgeqz_work(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhgeqz_work
 */
extern proc LAPACKE_zhgeqz_work(matrix_order : lapack_memory_order, job : c_char, compq : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(128), ldh : c_int, t : [] complex(128), ldt : c_int, alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhgeqz_work
 */
inline proc LAPACKE_zhgeqz_work(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(128), ldh : c_int, t : [] complex(128), ldt : c_int, alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_zhgeqz_work(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpcon_work
 */
extern proc LAPACKE_chpcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpcon_work
 */
inline proc LAPACKE_chpcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int{
  return LAPACKE_chpcon_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpcon_work
 */
extern proc LAPACKE_zhpcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpcon_work
 */
inline proc LAPACKE_zhpcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int{
  return LAPACKE_zhpcon_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpev_work
 */
extern proc LAPACKE_chpev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpev_work
 */
inline proc LAPACKE_chpev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_chpev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpev_work
 */
extern proc LAPACKE_zhpev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpev_work
 */
inline proc LAPACKE_zhpev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zhpev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpevd_work
 */
extern proc LAPACKE_chpevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpevd_work
 */
inline proc LAPACKE_chpevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_chpevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpevd_work
 */
extern proc LAPACKE_zhpevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpevd_work
 */
inline proc LAPACKE_zhpevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zhpevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpevx_work
 */
extern proc LAPACKE_chpevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpevx_work
 */
inline proc LAPACKE_chpevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chpevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpevx_work
 */
extern proc LAPACKE_zhpevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpevx_work
 */
inline proc LAPACKE_zhpevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhpevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpgst_work
 */
extern proc LAPACKE_chpgst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, ap : [] complex(64), bp : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpgst_work
 */
inline proc LAPACKE_chpgst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64)) : c_int{
  return LAPACKE_chpgst_work(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpgst_work
 */
extern proc LAPACKE_zhpgst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, ap : [] complex(128), bp : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpgst_work
 */
inline proc LAPACKE_zhpgst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128)) : c_int{
  return LAPACKE_zhpgst_work(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpgv_work
 */
extern proc LAPACKE_chpgv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpgv_work
 */
inline proc LAPACKE_chpgv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_chpgv_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpgv_work
 */
extern proc LAPACKE_zhpgv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpgv_work
 */
inline proc LAPACKE_zhpgv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zhpgv_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpgvd_work
 */
extern proc LAPACKE_chpgvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpgvd_work
 */
inline proc LAPACKE_chpgvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_chpgvd_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpgvd_work
 */
extern proc LAPACKE_zhpgvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpgvd_work
 */
inline proc LAPACKE_zhpgvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zhpgvd_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpgvx_work
 */
extern proc LAPACKE_chpgvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] complex(64), bp : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpgvx_work
 */
inline proc LAPACKE_chpgvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_chpgvx_work(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpgvx_work
 */
extern proc LAPACKE_zhpgvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] complex(128), bp : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpgvx_work
 */
inline proc LAPACKE_zhpgvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_zhpgvx_work(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chprfs_work
 */
extern proc LAPACKE_chprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chprfs_work
 */
inline proc LAPACKE_chprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_chprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhprfs_work
 */
extern proc LAPACKE_zhprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhprfs_work
 */
inline proc LAPACKE_zhprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zhprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpsv_work
 */
extern proc LAPACKE_chpsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpsv_work
 */
inline proc LAPACKE_chpsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chpsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpsv_work
 */
extern proc LAPACKE_zhpsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpsv_work
 */
inline proc LAPACKE_zhpsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhpsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chpsvx_work
 */
extern proc LAPACKE_chpsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chpsvx_work
 */
inline proc LAPACKE_chpsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_chpsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhpsvx_work
 */
extern proc LAPACKE_zhpsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhpsvx_work
 */
inline proc LAPACKE_zhpsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zhpsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chptrd_work
 */
extern proc LAPACKE_chptrd_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), d : [] c_float, e : [] c_float, tau : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chptrd_work
 */
inline proc LAPACKE_chptrd_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), d : [] c_float, e : [] c_float, tau : [] complex(64)) : c_int{
  return LAPACKE_chptrd_work(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhptrd_work
 */
extern proc LAPACKE_zhptrd_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), d : [] c_double, e : [] c_double, tau : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhptrd_work
 */
inline proc LAPACKE_zhptrd_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), d : [] c_double, e : [] c_double, tau : [] complex(128)) : c_int{
  return LAPACKE_zhptrd_work(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chptrf_work
 */
extern proc LAPACKE_chptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chptrf_work
 */
inline proc LAPACKE_chptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int{
  return LAPACKE_chptrf_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhptrf_work
 */
extern proc LAPACKE_zhptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhptrf_work
 */
inline proc LAPACKE_zhptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int{
  return LAPACKE_zhptrf_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chptri_work
 */
extern proc LAPACKE_chptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chptri_work
 */
inline proc LAPACKE_chptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, work : [] complex(64)) : c_int{
  return LAPACKE_chptri_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhptri_work
 */
extern proc LAPACKE_zhptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhptri_work
 */
inline proc LAPACKE_zhptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zhptri_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chptrs_work
 */
extern proc LAPACKE_chptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chptrs_work
 */
inline proc LAPACKE_chptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhptrs_work
 */
extern proc LAPACKE_zhptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhptrs_work
 */
inline proc LAPACKE_zhptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_shsein_work
 */
extern proc LAPACKE_shsein_work(matrix_order : lapack_memory_order, job : c_char, eigsrc : c_char, initv : c_char, chlapack_select : [] c_int, n : c_int, h : [] c_float, ldh : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_float, ifaill : [] c_int, ifailr : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_shsein_work
 */
inline proc LAPACKE_shsein_work(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, n : c_int, h : [] c_float, ldh : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_float, ifaill : [] c_int, ifailr : [] c_int) : c_int{
  return LAPACKE_shsein_work(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dhsein_work
 */
extern proc LAPACKE_dhsein_work(matrix_order : lapack_memory_order, job : c_char, eigsrc : c_char, initv : c_char, chlapack_select : [] c_int, n : c_int, h : [] c_double, ldh : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_double, ifaill : [] c_int, ifailr : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dhsein_work
 */
inline proc LAPACKE_dhsein_work(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, n : c_int, h : [] c_double, ldh : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_double, ifaill : [] c_int, ifailr : [] c_int) : c_int{
  return LAPACKE_dhsein_work(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chsein_work
 */
extern proc LAPACKE_chsein_work(matrix_order : lapack_memory_order, job : c_char, eigsrc : c_char, initv : c_char, chlapack_select : [] c_int, n : c_int, h : [] complex(64), ldh : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(64), rwork : [] c_float, ifaill : [] c_int, ifailr : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chsein_work
 */
inline proc LAPACKE_chsein_work(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, n : c_int, h : [] complex(64), ldh : c_int, w : [] complex(64), vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(64), rwork : [] c_float, ifaill : [] c_int, ifailr : [] c_int) : c_int{
  return LAPACKE_chsein_work(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhsein_work
 */
extern proc LAPACKE_zhsein_work(matrix_order : lapack_memory_order, job : c_char, eigsrc : c_char, initv : c_char, chlapack_select : [] c_int, n : c_int, h : [] complex(128), ldh : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(128), rwork : [] c_double, ifaill : [] c_int, ifailr : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhsein_work
 */
inline proc LAPACKE_zhsein_work(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, n : c_int, h : [] complex(128), ldh : c_int, w : [] complex(128), vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(128), rwork : [] c_double, ifaill : [] c_int, ifailr : [] c_int) : c_int{
  return LAPACKE_zhsein_work(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_shseqr_work
 */
extern proc LAPACKE_shseqr_work(matrix_order : lapack_memory_order, job : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] c_float, ldh : c_int, wr : [] c_float, wi : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_shseqr_work
 */
inline proc LAPACKE_shseqr_work(matrix_order : lapack_memory_order, job : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] c_float, ldh : c_int, wr : [] c_float, wi : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_shseqr_work(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dhseqr_work
 */
extern proc LAPACKE_dhseqr_work(matrix_order : lapack_memory_order, job : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] c_double, ldh : c_int, wr : [] c_double, wi : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dhseqr_work
 */
inline proc LAPACKE_dhseqr_work(matrix_order : lapack_memory_order, job : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] c_double, ldh : c_int, wr : [] c_double, wi : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dhseqr_work(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chseqr_work
 */
extern proc LAPACKE_chseqr_work(matrix_order : lapack_memory_order, job : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(64), ldh : c_int, w : [] complex(64), z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chseqr_work
 */
inline proc LAPACKE_chseqr_work(matrix_order : lapack_memory_order, job : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(64), ldh : c_int, w : [] complex(64), z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_chseqr_work(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhseqr_work
 */
extern proc LAPACKE_zhseqr_work(matrix_order : lapack_memory_order, job : c_char, compz : c_char, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(128), ldh : c_int, w : [] complex(128), z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhseqr_work
 */
inline proc LAPACKE_zhseqr_work(matrix_order : lapack_memory_order, job : string, compz : string, n : c_int, ilo : c_int, ihi : c_int, h : [] complex(128), ldh : c_int, w : [] complex(128), z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zhseqr_work(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clacgv_work
 */
extern proc LAPACKE_clacgv_work(n : c_int, x : [] complex(64), incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlacgv_work
 */
extern proc LAPACKE_zlacgv_work(n : c_int, x : [] complex(128), incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slacn2_work
 */
extern proc LAPACKE_slacn2_work(n : c_int, v : [] c_float, x : [] c_float, isgn : [] c_int, ref est : c_float, ref kase : c_int, isave : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlacn2_work
 */
extern proc LAPACKE_dlacn2_work(n : c_int, v : [] c_double, x : [] c_double, isgn : [] c_int, ref est : c_double, ref kase : c_int, isave : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clacn2_work
 */
extern proc LAPACKE_clacn2_work(n : c_int, v : [] complex(64), x : [] complex(64), ref est : c_float, ref kase : c_int, isave : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlacn2_work
 */
extern proc LAPACKE_zlacn2_work(n : c_int, v : [] complex(128), x : [] complex(128), ref est : c_double, ref kase : c_int, isave : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slacpy_work
 */
extern proc LAPACKE_slacpy_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slacpy_work
 */
inline proc LAPACKE_slacpy_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_slacpy_work(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlacpy_work
 */
extern proc LAPACKE_dlacpy_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlacpy_work
 */
inline proc LAPACKE_dlacpy_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dlacpy_work(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clacpy_work
 */
extern proc LAPACKE_clacpy_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clacpy_work
 */
inline proc LAPACKE_clacpy_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_clacpy_work(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlacpy_work
 */
extern proc LAPACKE_zlacpy_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlacpy_work
 */
inline proc LAPACKE_zlacpy_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zlacpy_work(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clacp2_work
 */
extern proc LAPACKE_clacp2_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clacp2_work
 */
inline proc LAPACKE_clacp2_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_clacp2_work(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlacp2_work
 */
extern proc LAPACKE_zlacp2_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlacp2_work
 */
inline proc LAPACKE_zlacp2_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zlacp2_work(matrix_order, ascii(uplo) : c_char, m, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlag2c_work
 */
extern proc LAPACKE_zlag2c_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, sa : [] complex(64), ldsa : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slag2d_work
 */
extern proc LAPACKE_slag2d_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, sa : [] c_float, ldsa : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlag2s_work
 */
extern proc LAPACKE_dlag2s_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, sa : [] c_float, ldsa : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clag2z_work
 */
extern proc LAPACKE_clag2z_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, sa : [] complex(64), ldsa : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slagge_work
 */
extern proc LAPACKE_slagge_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, d : [] c_float, a : [] c_float, lda : c_int, iseed : [] c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlagge_work
 */
extern proc LAPACKE_dlagge_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, d : [] c_double, a : [] c_double, lda : c_int, iseed : [] c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clagge_work
 */
extern proc LAPACKE_clagge_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, d : [] c_float, a : [] complex(64), lda : c_int, iseed : [] c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlagge_work
 */
extern proc LAPACKE_zlagge_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, d : [] c_double, a : [] complex(128), lda : c_int, iseed : [] c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_claghe_work
 */
extern proc LAPACKE_claghe_work(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_float, a : [] complex(64), lda : c_int, iseed : [] c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlaghe_work
 */
extern proc LAPACKE_zlaghe_work(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_double, a : [] complex(128), lda : c_int, iseed : [] c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slagsy_work
 */
extern proc LAPACKE_slagsy_work(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_float, a : [] c_float, lda : c_int, iseed : [] c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlagsy_work
 */
extern proc LAPACKE_dlagsy_work(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_double, a : [] c_double, lda : c_int, iseed : [] c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clagsy_work
 */
extern proc LAPACKE_clagsy_work(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_float, a : [] complex(64), lda : c_int, iseed : [] c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlagsy_work
 */
extern proc LAPACKE_zlagsy_work(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_double, a : [] complex(128), lda : c_int, iseed : [] c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slapmr_work
 */
extern proc LAPACKE_slapmr_work(matrix_order : lapack_memory_order, forwrd : c_int, m : c_int, n : c_int, x : [] c_float, ldx : c_int, k : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlapmr_work
 */
extern proc LAPACKE_dlapmr_work(matrix_order : lapack_memory_order, forwrd : c_int, m : c_int, n : c_int, x : [] c_double, ldx : c_int, k : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clapmr_work
 */
extern proc LAPACKE_clapmr_work(matrix_order : lapack_memory_order, forwrd : c_int, m : c_int, n : c_int, x : [] complex(64), ldx : c_int, k : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlapmr_work
 */
extern proc LAPACKE_zlapmr_work(matrix_order : lapack_memory_order, forwrd : c_int, m : c_int, n : c_int, x : [] complex(128), ldx : c_int, k : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slartgp_work
 */
extern proc LAPACKE_slartgp_work(f : c_float, g : c_float, ref cs : c_float, ref sn : c_float, ref r : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlartgp_work
 */
extern proc LAPACKE_dlartgp_work(f : c_double, g : c_double, ref cs : c_double, ref sn : c_double, ref r : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slartgs_work
 */
extern proc LAPACKE_slartgs_work(x : c_float, y : c_float, sigma : c_float, ref cs : c_float, ref sn : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlartgs_work
 */
extern proc LAPACKE_dlartgs_work(x : c_double, y : c_double, sigma : c_double, ref cs : c_double, ref sn : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slapy2_work
 */
extern proc LAPACKE_slapy2_work(x : c_float, y : c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlapy2_work
 */
extern proc LAPACKE_dlapy2_work(x : c_double, y : c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACKE_slapy3_work
 */
extern proc LAPACKE_slapy3_work(x : c_float, y : c_float, z : c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlapy3_work
 */
extern proc LAPACKE_dlapy3_work(x : c_double, y : c_double, z : c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACKE_slamch_work
 */
extern proc LAPACKE_slamch_work(cmach : c_char) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slamch_work
 */
inline proc LAPACKE_slamch_work(cmach : string) : c_float{
  return LAPACKE_slamch_work(ascii(cmach) : c_char);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlamch_work
 */
extern proc LAPACKE_dlamch_work(cmach : c_char) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlamch_work
 */
inline proc LAPACKE_dlamch_work(cmach : string) : c_double{
  return LAPACKE_dlamch_work(ascii(cmach) : c_char);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slange_work
 */
extern proc LAPACKE_slange_work(matrix_order : lapack_memory_order, norm : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slange_work
 */
inline proc LAPACKE_slange_work(matrix_order : lapack_memory_order, norm : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, work : [] c_float) : c_float{
  return LAPACKE_slange_work(matrix_order, ascii(norm) : c_char, m, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlange_work
 */
extern proc LAPACKE_dlange_work(matrix_order : lapack_memory_order, norm : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlange_work
 */
inline proc LAPACKE_dlange_work(matrix_order : lapack_memory_order, norm : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, work : [] c_double) : c_double{
  return LAPACKE_dlange_work(matrix_order, ascii(norm) : c_char, m, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clange_work
 */
extern proc LAPACKE_clange_work(matrix_order : lapack_memory_order, norm : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clange_work
 */
inline proc LAPACKE_clange_work(matrix_order : lapack_memory_order, norm : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, work : [] c_float) : c_float{
  return LAPACKE_clange_work(matrix_order, ascii(norm) : c_char, m, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlange_work
 */
extern proc LAPACKE_zlange_work(matrix_order : lapack_memory_order, norm : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlange_work
 */
inline proc LAPACKE_zlange_work(matrix_order : lapack_memory_order, norm : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, work : [] c_double) : c_double{
  return LAPACKE_zlange_work(matrix_order, ascii(norm) : c_char, m, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clanhe_work
 */
extern proc LAPACKE_clanhe_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clanhe_work
 */
inline proc LAPACKE_clanhe_work(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, work : [] c_float) : c_float{
  return LAPACKE_clanhe_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlanhe_work
 */
extern proc LAPACKE_zlanhe_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlanhe_work
 */
inline proc LAPACKE_zlanhe_work(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, work : [] c_double) : c_double{
  return LAPACKE_zlanhe_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slansy_work
 */
extern proc LAPACKE_slansy_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slansy_work
 */
inline proc LAPACKE_slansy_work(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, work : [] c_float) : c_float{
  return LAPACKE_slansy_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlansy_work
 */
extern proc LAPACKE_dlansy_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlansy_work
 */
inline proc LAPACKE_dlansy_work(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, work : [] c_double) : c_double{
  return LAPACKE_dlansy_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clansy_work
 */
extern proc LAPACKE_clansy_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clansy_work
 */
inline proc LAPACKE_clansy_work(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, work : [] c_float) : c_float{
  return LAPACKE_clansy_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlansy_work
 */
extern proc LAPACKE_zlansy_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlansy_work
 */
inline proc LAPACKE_zlansy_work(matrix_order : lapack_memory_order, norm : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, work : [] c_double) : c_double{
  return LAPACKE_zlansy_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slantr_work
 */
extern proc LAPACKE_slantr_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slantr_work
 */
inline proc LAPACKE_slantr_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, work : [] c_float) : c_float{
  return LAPACKE_slantr_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, m, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlantr_work
 */
extern proc LAPACKE_dlantr_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlantr_work
 */
inline proc LAPACKE_dlantr_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, work : [] c_double) : c_double{
  return LAPACKE_dlantr_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, m, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clantr_work
 */
extern proc LAPACKE_clantr_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clantr_work
 */
inline proc LAPACKE_clantr_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, work : [] c_float) : c_float{
  return LAPACKE_clantr_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, m, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlantr_work
 */
extern proc LAPACKE_zlantr_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlantr_work
 */
inline proc LAPACKE_zlantr_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, work : [] c_double) : c_double{
  return LAPACKE_zlantr_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, m, n, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slarfb_work
 */
extern proc LAPACKE_slarfb_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, c : [] c_float, ldc : c_int, work : [] c_float, ldwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slarfb_work
 */
inline proc LAPACKE_slarfb_work(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, c : [] c_float, ldc : c_int, work : [] c_float, ldwork : c_int) : c_int{
  return LAPACKE_slarfb_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarfb_work
 */
extern proc LAPACKE_dlarfb_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, c : [] c_double, ldc : c_int, work : [] c_double, ldwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlarfb_work
 */
inline proc LAPACKE_dlarfb_work(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, c : [] c_double, ldc : c_int, work : [] c_double, ldwork : c_int) : c_int{
  return LAPACKE_dlarfb_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clarfb_work
 */
extern proc LAPACKE_clarfb_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, c : [] complex(64), ldc : c_int, work : [] complex(64), ldwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clarfb_work
 */
inline proc LAPACKE_clarfb_work(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, c : [] complex(64), ldc : c_int, work : [] complex(64), ldwork : c_int) : c_int{
  return LAPACKE_clarfb_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarfb_work
 */
extern proc LAPACKE_zlarfb_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, c : [] complex(128), ldc : c_int, work : [] complex(128), ldwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlarfb_work
 */
inline proc LAPACKE_zlarfb_work(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, c : [] complex(128), ldc : c_int, work : [] complex(128), ldwork : c_int) : c_int{
  return LAPACKE_zlarfb_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slarfg_work
 */
extern proc LAPACKE_slarfg_work(n : c_int, ref alpha : c_float, x : [] c_float, incx : c_int, ref tau : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarfg_work
 */
extern proc LAPACKE_dlarfg_work(n : c_int, ref alpha : c_double, x : [] c_double, incx : c_int, ref tau : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clarfg_work
 */
extern proc LAPACKE_clarfg_work(n : c_int, ref alpha : complex(64), x : [] complex(64), incx : c_int, ref tau : complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarfg_work
 */
extern proc LAPACKE_zlarfg_work(n : c_int, ref alpha : complex(128), x : [] complex(128), incx : c_int, ref tau : complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slarft_work
 */
extern proc LAPACKE_slarft_work(matrix_order : lapack_memory_order, direct : c_char, storev : c_char, n : c_int, k : c_int, v : [] c_float, ldv : c_int, tau : [] c_float, t : [] c_float, ldt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slarft_work
 */
inline proc LAPACKE_slarft_work(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] c_float, ldv : c_int, tau : [] c_float, t : [] c_float, ldt : c_int) : c_int{
  return LAPACKE_slarft_work(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, ldv, tau, t, ldt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarft_work
 */
extern proc LAPACKE_dlarft_work(matrix_order : lapack_memory_order, direct : c_char, storev : c_char, n : c_int, k : c_int, v : [] c_double, ldv : c_int, tau : [] c_double, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlarft_work
 */
inline proc LAPACKE_dlarft_work(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] c_double, ldv : c_int, tau : [] c_double, t : [] c_double, ldt : c_int) : c_int{
  return LAPACKE_dlarft_work(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, ldv, tau, t, ldt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clarft_work
 */
extern proc LAPACKE_clarft_work(matrix_order : lapack_memory_order, direct : c_char, storev : c_char, n : c_int, k : c_int, v : [] complex(64), ldv : c_int, tau : [] complex(64), t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clarft_work
 */
inline proc LAPACKE_clarft_work(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] complex(64), ldv : c_int, tau : [] complex(64), t : [] complex(64), ldt : c_int) : c_int{
  return LAPACKE_clarft_work(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, ldv, tau, t, ldt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarft_work
 */
extern proc LAPACKE_zlarft_work(matrix_order : lapack_memory_order, direct : c_char, storev : c_char, n : c_int, k : c_int, v : [] complex(128), ldv : c_int, tau : [] complex(128), t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlarft_work
 */
inline proc LAPACKE_zlarft_work(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] complex(128), ldv : c_int, tau : [] complex(128), t : [] complex(128), ldt : c_int) : c_int{
  return LAPACKE_zlarft_work(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, ldv, tau, t, ldt);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slarfx_work
 */
extern proc LAPACKE_slarfx_work(matrix_order : lapack_memory_order, side : c_char, m : c_int, n : c_int, v : [] c_float, tau : c_float, c : [] c_float, ldc : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slarfx_work
 */
inline proc LAPACKE_slarfx_work(matrix_order : lapack_memory_order, side : string, m : c_int, n : c_int, v : [] c_float, tau : c_float, c : [] c_float, ldc : c_int, work : [] c_float) : c_int{
  return LAPACKE_slarfx_work(matrix_order, ascii(side) : c_char, m, n, v, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarfx_work
 */
extern proc LAPACKE_dlarfx_work(matrix_order : lapack_memory_order, side : c_char, m : c_int, n : c_int, v : [] c_double, tau : c_double, c : [] c_double, ldc : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlarfx_work
 */
inline proc LAPACKE_dlarfx_work(matrix_order : lapack_memory_order, side : string, m : c_int, n : c_int, v : [] c_double, tau : c_double, c : [] c_double, ldc : c_int, work : [] c_double) : c_int{
  return LAPACKE_dlarfx_work(matrix_order, ascii(side) : c_char, m, n, v, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clarfx_work
 */
extern proc LAPACKE_clarfx_work(matrix_order : lapack_memory_order, side : c_char, m : c_int, n : c_int, v : [] complex(64), tau : complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clarfx_work
 */
inline proc LAPACKE_clarfx_work(matrix_order : lapack_memory_order, side : string, m : c_int, n : c_int, v : [] complex(64), tau : complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_clarfx_work(matrix_order, ascii(side) : c_char, m, n, v, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarfx_work
 */
extern proc LAPACKE_zlarfx_work(matrix_order : lapack_memory_order, side : c_char, m : c_int, n : c_int, v : [] complex(128), tau : complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlarfx_work
 */
inline proc LAPACKE_zlarfx_work(matrix_order : lapack_memory_order, side : string, m : c_int, n : c_int, v : [] complex(128), tau : complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zlarfx_work(matrix_order, ascii(side) : c_char, m, n, v, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slarnv_work
 */
extern proc LAPACKE_slarnv_work(idist : c_int, iseed : [] c_int, n : c_int, x : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlarnv_work
 */
extern proc LAPACKE_dlarnv_work(idist : c_int, iseed : [] c_int, n : c_int, x : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clarnv_work
 */
extern proc LAPACKE_clarnv_work(idist : c_int, iseed : [] c_int, n : c_int, x : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlarnv_work
 */
extern proc LAPACKE_zlarnv_work(idist : c_int, iseed : [] c_int, n : c_int, x : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slaset_work
 */
extern proc LAPACKE_slaset_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, alpha : c_float, beta : c_float, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slaset_work
 */
inline proc LAPACKE_slaset_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, alpha : c_float, beta : c_float, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_slaset_work(matrix_order, ascii(uplo) : c_char, m, n, alpha, beta, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlaset_work
 */
extern proc LAPACKE_dlaset_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, alpha : c_double, beta : c_double, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlaset_work
 */
inline proc LAPACKE_dlaset_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, alpha : c_double, beta : c_double, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dlaset_work(matrix_order, ascii(uplo) : c_char, m, n, alpha, beta, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_claset_work
 */
extern proc LAPACKE_claset_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, alpha : complex(64), beta : complex(64), a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_claset_work
 */
inline proc LAPACKE_claset_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, alpha : complex(64), beta : complex(64), a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_claset_work(matrix_order, ascii(uplo) : c_char, m, n, alpha, beta, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlaset_work
 */
extern proc LAPACKE_zlaset_work(matrix_order : lapack_memory_order, uplo : c_char, m : c_int, n : c_int, alpha : complex(128), beta : complex(128), a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlaset_work
 */
inline proc LAPACKE_zlaset_work(matrix_order : lapack_memory_order, uplo : string, m : c_int, n : c_int, alpha : complex(128), beta : complex(128), a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zlaset_work(matrix_order, ascii(uplo) : c_char, m, n, alpha, beta, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slasrt_work
 */
extern proc LAPACKE_slasrt_work(id : c_char, n : c_int, d : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slasrt_work
 */
inline proc LAPACKE_slasrt_work(id : string, n : c_int, d : [] c_float) : c_int{
  return LAPACKE_slasrt_work(ascii(id) : c_char, n, d);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlasrt_work
 */
extern proc LAPACKE_dlasrt_work(id : c_char, n : c_int, d : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlasrt_work
 */
inline proc LAPACKE_dlasrt_work(id : string, n : c_int, d : [] c_double) : c_int{
  return LAPACKE_dlasrt_work(ascii(id) : c_char, n, d);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slaswp_work
 */
extern proc LAPACKE_slaswp_work(matrix_order : lapack_memory_order, n : c_int, a : [] c_float, lda : c_int, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlaswp_work
 */
extern proc LAPACKE_dlaswp_work(matrix_order : lapack_memory_order, n : c_int, a : [] c_double, lda : c_int, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_claswp_work
 */
extern proc LAPACKE_claswp_work(matrix_order : lapack_memory_order, n : c_int, a : [] complex(64), lda : c_int, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlaswp_work
 */
extern proc LAPACKE_zlaswp_work(matrix_order : lapack_memory_order, n : c_int, a : [] complex(128), lda : c_int, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slatms_work
 */
extern proc LAPACKE_slatms_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : c_char, iseed : [] c_int, sym : c_char, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : c_char, a : [] c_float, lda : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slatms_work
 */
inline proc LAPACKE_slatms_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : string, iseed : [] c_int, sym : string, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : string, a : [] c_float, lda : c_int, work : [] c_float) : c_int{
  return LAPACKE_slatms_work(matrix_order, m, n, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlatms_work
 */
extern proc LAPACKE_dlatms_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : c_char, iseed : [] c_int, sym : c_char, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : c_char, a : [] c_double, lda : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlatms_work
 */
inline proc LAPACKE_dlatms_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : string, iseed : [] c_int, sym : string, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : string, a : [] c_double, lda : c_int, work : [] c_double) : c_int{
  return LAPACKE_dlatms_work(matrix_order, m, n, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clatms_work
 */
extern proc LAPACKE_clatms_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : c_char, iseed : [] c_int, sym : c_char, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : c_char, a : [] complex(64), lda : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clatms_work
 */
inline proc LAPACKE_clatms_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : string, iseed : [] c_int, sym : string, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : string, a : [] complex(64), lda : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_clatms_work(matrix_order, m, n, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlatms_work
 */
extern proc LAPACKE_zlatms_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : c_char, iseed : [] c_int, sym : c_char, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : c_char, a : [] complex(128), lda : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlatms_work
 */
inline proc LAPACKE_zlatms_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, dist : string, iseed : [] c_int, sym : string, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : string, a : [] complex(128), lda : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zlatms_work(matrix_order, m, n, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, lda, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_slauum_work
 */
extern proc LAPACKE_slauum_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_slauum_work
 */
inline proc LAPACKE_slauum_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_slauum_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dlauum_work
 */
extern proc LAPACKE_dlauum_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dlauum_work
 */
inline proc LAPACKE_dlauum_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dlauum_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_clauum_work
 */
extern proc LAPACKE_clauum_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_clauum_work
 */
inline proc LAPACKE_clauum_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_clauum_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zlauum_work
 */
extern proc LAPACKE_zlauum_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zlauum_work
 */
inline proc LAPACKE_zlauum_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zlauum_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sopgtr_work
 */
extern proc LAPACKE_sopgtr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, tau : [] c_float, q : [] c_float, ldq : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sopgtr_work
 */
inline proc LAPACKE_sopgtr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, tau : [] c_float, q : [] c_float, ldq : c_int, work : [] c_float) : c_int{
  return LAPACKE_sopgtr_work(matrix_order, ascii(uplo) : c_char, n, ap, tau, q, ldq, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dopgtr_work
 */
extern proc LAPACKE_dopgtr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, tau : [] c_double, q : [] c_double, ldq : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dopgtr_work
 */
inline proc LAPACKE_dopgtr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, tau : [] c_double, q : [] c_double, ldq : c_int, work : [] c_double) : c_int{
  return LAPACKE_dopgtr_work(matrix_order, ascii(uplo) : c_char, n, ap, tau, q, ldq, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sopmtr_work
 */
extern proc LAPACKE_sopmtr_work(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, ap : [] c_float, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sopmtr_work
 */
inline proc LAPACKE_sopmtr_work(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, ap : [] c_float, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float) : c_int{
  return LAPACKE_sopmtr_work(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, ap, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dopmtr_work
 */
extern proc LAPACKE_dopmtr_work(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, ap : [] c_double, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dopmtr_work
 */
inline proc LAPACKE_dopmtr_work(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, ap : [] c_double, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double) : c_int{
  return LAPACKE_dopmtr_work(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, ap, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgbr_work
 */
extern proc LAPACKE_sorgbr_work(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sorgbr_work
 */
inline proc LAPACKE_sorgbr_work(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sorgbr_work(matrix_order, ascii(vect) : c_char, m, n, k, a, lda, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgbr_work
 */
extern proc LAPACKE_dorgbr_work(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dorgbr_work
 */
inline proc LAPACKE_dorgbr_work(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dorgbr_work(matrix_order, ascii(vect) : c_char, m, n, k, a, lda, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sorghr_work
 */
extern proc LAPACKE_sorghr_work(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorghr_work
 */
extern proc LAPACKE_dorghr_work(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorglq_work
 */
extern proc LAPACKE_sorglq_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorglq_work
 */
extern proc LAPACKE_dorglq_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgql_work
 */
extern proc LAPACKE_sorgql_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgql_work
 */
extern proc LAPACKE_dorgql_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgqr_work
 */
extern proc LAPACKE_sorgqr_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgqr_work
 */
extern proc LAPACKE_dorgqr_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgrq_work
 */
extern proc LAPACKE_sorgrq_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgrq_work
 */
extern proc LAPACKE_dorgrq_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sorgtr_work
 */
extern proc LAPACKE_sorgtr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sorgtr_work
 */
inline proc LAPACKE_sorgtr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sorgtr_work(matrix_order, ascii(uplo) : c_char, n, a, lda, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dorgtr_work
 */
extern proc LAPACKE_dorgtr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dorgtr_work
 */
inline proc LAPACKE_dorgtr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dorgtr_work(matrix_order, ascii(uplo) : c_char, n, a, lda, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormbr_work
 */
extern proc LAPACKE_sormbr_work(matrix_order : lapack_memory_order, vect : c_char, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormbr_work
 */
inline proc LAPACKE_sormbr_work(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sormbr_work(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormbr_work
 */
extern proc LAPACKE_dormbr_work(matrix_order : lapack_memory_order, vect : c_char, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormbr_work
 */
inline proc LAPACKE_dormbr_work(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dormbr_work(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormhr_work
 */
extern proc LAPACKE_sormhr_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormhr_work
 */
inline proc LAPACKE_sormhr_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sormhr_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormhr_work
 */
extern proc LAPACKE_dormhr_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormhr_work
 */
inline proc LAPACKE_dormhr_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dormhr_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormlq_work
 */
extern proc LAPACKE_sormlq_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormlq_work
 */
inline proc LAPACKE_sormlq_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sormlq_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormlq_work
 */
extern proc LAPACKE_dormlq_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormlq_work
 */
inline proc LAPACKE_dormlq_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dormlq_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormql_work
 */
extern proc LAPACKE_sormql_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormql_work
 */
inline proc LAPACKE_sormql_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sormql_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormql_work
 */
extern proc LAPACKE_dormql_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormql_work
 */
inline proc LAPACKE_dormql_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dormql_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormqr_work
 */
extern proc LAPACKE_sormqr_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormqr_work
 */
inline proc LAPACKE_sormqr_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sormqr_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormqr_work
 */
extern proc LAPACKE_dormqr_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormqr_work
 */
inline proc LAPACKE_dormqr_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dormqr_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormrq_work
 */
extern proc LAPACKE_sormrq_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormrq_work
 */
inline proc LAPACKE_sormrq_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sormrq_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormrq_work
 */
extern proc LAPACKE_dormrq_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormrq_work
 */
inline proc LAPACKE_dormrq_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dormrq_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormrz_work
 */
extern proc LAPACKE_sormrz_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormrz_work
 */
inline proc LAPACKE_sormrz_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sormrz_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormrz_work
 */
extern proc LAPACKE_dormrz_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormrz_work
 */
inline proc LAPACKE_dormrz_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dormrz_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sormtr_work
 */
extern proc LAPACKE_sormtr_work(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sormtr_work
 */
inline proc LAPACKE_sormtr_work(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, c : [] c_float, ldc : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sormtr_work(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dormtr_work
 */
extern proc LAPACKE_dormtr_work(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dormtr_work
 */
inline proc LAPACKE_dormtr_work(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, c : [] c_double, ldc : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dormtr_work(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbcon_work
 */
extern proc LAPACKE_spbcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbcon_work
 */
inline proc LAPACKE_spbcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_spbcon_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbcon_work
 */
extern proc LAPACKE_dpbcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbcon_work
 */
inline proc LAPACKE_dpbcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dpbcon_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbcon_work
 */
extern proc LAPACKE_cpbcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbcon_work
 */
inline proc LAPACKE_cpbcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cpbcon_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbcon_work
 */
extern proc LAPACKE_zpbcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbcon_work
 */
inline proc LAPACKE_zpbcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zpbcon_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbequ_work
 */
extern proc LAPACKE_spbequ_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbequ_work
 */
inline proc LAPACKE_spbequ_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_spbequ_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbequ_work
 */
extern proc LAPACKE_dpbequ_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbequ_work
 */
inline proc LAPACKE_dpbequ_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_dpbequ_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbequ_work
 */
extern proc LAPACKE_cpbequ_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbequ_work
 */
inline proc LAPACKE_cpbequ_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_cpbequ_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbequ_work
 */
extern proc LAPACKE_zpbequ_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbequ_work
 */
inline proc LAPACKE_zpbequ_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_zpbequ_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbrfs_work
 */
extern proc LAPACKE_spbrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbrfs_work
 */
inline proc LAPACKE_spbrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_spbrfs_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbrfs_work
 */
extern proc LAPACKE_dpbrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbrfs_work
 */
inline proc LAPACKE_dpbrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dpbrfs_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbrfs_work
 */
extern proc LAPACKE_cpbrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbrfs_work
 */
inline proc LAPACKE_cpbrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cpbrfs_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbrfs_work
 */
extern proc LAPACKE_zpbrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbrfs_work
 */
inline proc LAPACKE_zpbrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zpbrfs_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbstf_work
 */
extern proc LAPACKE_spbstf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kb : c_int, bb : [] c_float, ldbb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbstf_work
 */
inline proc LAPACKE_spbstf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] c_float, ldbb : c_int) : c_int{
  return LAPACKE_spbstf_work(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbstf_work
 */
extern proc LAPACKE_dpbstf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kb : c_int, bb : [] c_double, ldbb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbstf_work
 */
inline proc LAPACKE_dpbstf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] c_double, ldbb : c_int) : c_int{
  return LAPACKE_dpbstf_work(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbstf_work
 */
extern proc LAPACKE_cpbstf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kb : c_int, bb : [] complex(64), ldbb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbstf_work
 */
inline proc LAPACKE_cpbstf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] complex(64), ldbb : c_int) : c_int{
  return LAPACKE_cpbstf_work(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbstf_work
 */
extern proc LAPACKE_zpbstf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kb : c_int, bb : [] complex(128), ldbb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbstf_work
 */
inline proc LAPACKE_zpbstf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] complex(128), ldbb : c_int) : c_int{
  return LAPACKE_zpbstf_work(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbsv_work
 */
extern proc LAPACKE_spbsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbsv_work
 */
inline proc LAPACKE_spbsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spbsv_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbsv_work
 */
extern proc LAPACKE_dpbsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbsv_work
 */
inline proc LAPACKE_dpbsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpbsv_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbsv_work
 */
extern proc LAPACKE_cpbsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbsv_work
 */
inline proc LAPACKE_cpbsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpbsv_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbsv_work
 */
extern proc LAPACKE_zpbsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbsv_work
 */
inline proc LAPACKE_zpbsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpbsv_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbsvx_work
 */
extern proc LAPACKE_spbsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbsvx_work
 */
inline proc LAPACKE_spbsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, afb : [] c_float, ldafb : c_int, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_spbsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbsvx_work
 */
extern proc LAPACKE_dpbsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbsvx_work
 */
inline proc LAPACKE_dpbsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, afb : [] c_double, ldafb : c_int, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dpbsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbsvx_work
 */
extern proc LAPACKE_cpbsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbsvx_work
 */
inline proc LAPACKE_cpbsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, afb : [] complex(64), ldafb : c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cpbsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbsvx_work
 */
extern proc LAPACKE_zpbsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbsvx_work
 */
inline proc LAPACKE_zpbsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, afb : [] complex(128), ldafb : c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zpbsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, afb, ldafb, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbtrf_work
 */
extern proc LAPACKE_spbtrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbtrf_work
 */
inline proc LAPACKE_spbtrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int) : c_int{
  return LAPACKE_spbtrf_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbtrf_work
 */
extern proc LAPACKE_dpbtrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbtrf_work
 */
inline proc LAPACKE_dpbtrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int) : c_int{
  return LAPACKE_dpbtrf_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbtrf_work
 */
extern proc LAPACKE_cpbtrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbtrf_work
 */
inline proc LAPACKE_cpbtrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int) : c_int{
  return LAPACKE_cpbtrf_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbtrf_work
 */
extern proc LAPACKE_zpbtrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbtrf_work
 */
inline proc LAPACKE_zpbtrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int) : c_int{
  return LAPACKE_zpbtrf_work(matrix_order, ascii(uplo) : c_char, n, kd, ab, ldab);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spbtrs_work
 */
extern proc LAPACKE_spbtrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spbtrs_work
 */
inline proc LAPACKE_spbtrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spbtrs_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpbtrs_work
 */
extern proc LAPACKE_dpbtrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpbtrs_work
 */
inline proc LAPACKE_dpbtrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpbtrs_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpbtrs_work
 */
extern proc LAPACKE_cpbtrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpbtrs_work
 */
inline proc LAPACKE_cpbtrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpbtrs_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpbtrs_work
 */
extern proc LAPACKE_zpbtrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpbtrs_work
 */
inline proc LAPACKE_zpbtrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpbtrs_work(matrix_order, ascii(uplo) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spftrf_work
 */
extern proc LAPACKE_spftrf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spftrf_work
 */
inline proc LAPACKE_spftrf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_float) : c_int{
  return LAPACKE_spftrf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpftrf_work
 */
extern proc LAPACKE_dpftrf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpftrf_work
 */
inline proc LAPACKE_dpftrf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_double) : c_int{
  return LAPACKE_dpftrf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpftrf_work
 */
extern proc LAPACKE_cpftrf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpftrf_work
 */
inline proc LAPACKE_cpftrf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(64)) : c_int{
  return LAPACKE_cpftrf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpftrf_work
 */
extern proc LAPACKE_zpftrf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpftrf_work
 */
inline proc LAPACKE_zpftrf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(128)) : c_int{
  return LAPACKE_zpftrf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spftri_work
 */
extern proc LAPACKE_spftri_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spftri_work
 */
inline proc LAPACKE_spftri_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_float) : c_int{
  return LAPACKE_spftri_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpftri_work
 */
extern proc LAPACKE_dpftri_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpftri_work
 */
inline proc LAPACKE_dpftri_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_double) : c_int{
  return LAPACKE_dpftri_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpftri_work
 */
extern proc LAPACKE_cpftri_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpftri_work
 */
inline proc LAPACKE_cpftri_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(64)) : c_int{
  return LAPACKE_cpftri_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpftri_work
 */
extern proc LAPACKE_zpftri_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpftri_work
 */
inline proc LAPACKE_zpftri_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(128)) : c_int{
  return LAPACKE_zpftri_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spftrs_work
 */
extern proc LAPACKE_spftrs_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spftrs_work
 */
inline proc LAPACKE_spftrs_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spftrs_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, nrhs, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpftrs_work
 */
extern proc LAPACKE_dpftrs_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpftrs_work
 */
inline proc LAPACKE_dpftrs_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpftrs_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, nrhs, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpftrs_work
 */
extern proc LAPACKE_cpftrs_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpftrs_work
 */
inline proc LAPACKE_cpftrs_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpftrs_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, nrhs, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpftrs_work
 */
extern proc LAPACKE_zpftrs_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpftrs_work
 */
inline proc LAPACKE_zpftrs_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpftrs_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, nrhs, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spocon_work
 */
extern proc LAPACKE_spocon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spocon_work
 */
inline proc LAPACKE_spocon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_spocon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpocon_work
 */
extern proc LAPACKE_dpocon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpocon_work
 */
inline proc LAPACKE_dpocon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dpocon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpocon_work
 */
extern proc LAPACKE_cpocon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpocon_work
 */
inline proc LAPACKE_cpocon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cpocon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpocon_work
 */
extern proc LAPACKE_zpocon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpocon_work
 */
inline proc LAPACKE_zpocon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zpocon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spoequ_work
 */
extern proc LAPACKE_spoequ_work(matrix_order : lapack_memory_order, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dpoequ_work
 */
extern proc LAPACKE_dpoequ_work(matrix_order : lapack_memory_order, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cpoequ_work
 */
extern proc LAPACKE_cpoequ_work(matrix_order : lapack_memory_order, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zpoequ_work
 */
extern proc LAPACKE_zpoequ_work(matrix_order : lapack_memory_order, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_spoequb_work
 */
extern proc LAPACKE_spoequb_work(matrix_order : lapack_memory_order, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dpoequb_work
 */
extern proc LAPACKE_dpoequb_work(matrix_order : lapack_memory_order, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cpoequb_work
 */
extern proc LAPACKE_cpoequb_work(matrix_order : lapack_memory_order, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zpoequb_work
 */
extern proc LAPACKE_zpoequb_work(matrix_order : lapack_memory_order, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sporfs_work
 */
extern proc LAPACKE_sporfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sporfs_work
 */
inline proc LAPACKE_sporfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sporfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dporfs_work
 */
extern proc LAPACKE_dporfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dporfs_work
 */
inline proc LAPACKE_dporfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dporfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cporfs_work
 */
extern proc LAPACKE_cporfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cporfs_work
 */
inline proc LAPACKE_cporfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cporfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zporfs_work
 */
extern proc LAPACKE_zporfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zporfs_work
 */
inline proc LAPACKE_zporfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zporfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sporfsx_work
 */
extern proc LAPACKE_sporfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sporfsx_work
 */
inline proc LAPACKE_sporfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sporfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dporfsx_work
 */
extern proc LAPACKE_dporfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dporfsx_work
 */
inline proc LAPACKE_dporfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dporfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cporfsx_work
 */
extern proc LAPACKE_cporfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cporfsx_work
 */
inline proc LAPACKE_cporfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cporfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zporfsx_work
 */
extern proc LAPACKE_zporfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zporfsx_work
 */
inline proc LAPACKE_zporfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zporfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sposv_work
 */
extern proc LAPACKE_sposv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sposv_work
 */
inline proc LAPACKE_sposv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sposv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dposv_work
 */
extern proc LAPACKE_dposv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dposv_work
 */
inline proc LAPACKE_dposv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dposv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cposv_work
 */
extern proc LAPACKE_cposv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cposv_work
 */
inline proc LAPACKE_cposv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cposv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zposv_work
 */
extern proc LAPACKE_zposv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zposv_work
 */
inline proc LAPACKE_zposv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zposv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsposv_work
 */
extern proc LAPACKE_dsposv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, work : [] c_double, swork : [] c_float, ref chlapack_iter : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsposv_work
 */
inline proc LAPACKE_dsposv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, work : [] c_double, swork : [] c_float, ref chlapack_iter : c_int) : c_int{
  return LAPACKE_dsposv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, chlapack_iter);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zcposv_work
 */
extern proc LAPACKE_zcposv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, work : [] complex(128), swork : [] complex(64), rwork : [] c_double, ref chlapack_iter : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zcposv_work
 */
inline proc LAPACKE_zcposv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, work : [] complex(128), swork : [] complex(64), rwork : [] c_double, ref chlapack_iter : c_int) : c_int{
  return LAPACKE_zcposv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, rwork, chlapack_iter);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sposvx_work
 */
extern proc LAPACKE_sposvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sposvx_work
 */
inline proc LAPACKE_sposvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sposvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dposvx_work
 */
extern proc LAPACKE_dposvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dposvx_work
 */
inline proc LAPACKE_dposvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dposvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cposvx_work
 */
extern proc LAPACKE_cposvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cposvx_work
 */
inline proc LAPACKE_cposvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cposvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zposvx_work
 */
extern proc LAPACKE_zposvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zposvx_work
 */
inline proc LAPACKE_zposvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zposvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sposvxx_work
 */
extern proc LAPACKE_sposvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sposvxx_work
 */
inline proc LAPACKE_sposvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sposvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dposvxx_work
 */
extern proc LAPACKE_dposvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dposvxx_work
 */
inline proc LAPACKE_dposvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dposvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cposvxx_work
 */
extern proc LAPACKE_cposvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cposvxx_work
 */
inline proc LAPACKE_cposvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cposvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zposvxx_work
 */
extern proc LAPACKE_zposvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zposvxx_work
 */
inline proc LAPACKE_zposvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zposvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spotrf_work
 */
extern proc LAPACKE_spotrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spotrf_work
 */
inline proc LAPACKE_spotrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_spotrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpotrf_work
 */
extern proc LAPACKE_dpotrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpotrf_work
 */
inline proc LAPACKE_dpotrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dpotrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpotrf_work
 */
extern proc LAPACKE_cpotrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpotrf_work
 */
inline proc LAPACKE_cpotrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_cpotrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpotrf_work
 */
extern proc LAPACKE_zpotrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpotrf_work
 */
inline proc LAPACKE_zpotrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zpotrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spotri_work
 */
extern proc LAPACKE_spotri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spotri_work
 */
inline proc LAPACKE_spotri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_spotri_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpotri_work
 */
extern proc LAPACKE_dpotri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpotri_work
 */
inline proc LAPACKE_dpotri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dpotri_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpotri_work
 */
extern proc LAPACKE_cpotri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpotri_work
 */
inline proc LAPACKE_cpotri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_cpotri_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpotri_work
 */
extern proc LAPACKE_zpotri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpotri_work
 */
inline proc LAPACKE_zpotri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zpotri_work(matrix_order, ascii(uplo) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spotrs_work
 */
extern proc LAPACKE_spotrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spotrs_work
 */
inline proc LAPACKE_spotrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spotrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpotrs_work
 */
extern proc LAPACKE_dpotrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpotrs_work
 */
inline proc LAPACKE_dpotrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpotrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpotrs_work
 */
extern proc LAPACKE_cpotrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpotrs_work
 */
inline proc LAPACKE_cpotrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpotrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpotrs_work
 */
extern proc LAPACKE_zpotrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpotrs_work
 */
inline proc LAPACKE_zpotrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpotrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sppcon_work
 */
extern proc LAPACKE_sppcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sppcon_work
 */
inline proc LAPACKE_sppcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sppcon_work(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dppcon_work
 */
extern proc LAPACKE_dppcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dppcon_work
 */
inline proc LAPACKE_dppcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dppcon_work(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cppcon_work
 */
extern proc LAPACKE_cppcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cppcon_work
 */
inline proc LAPACKE_cppcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cppcon_work(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zppcon_work
 */
extern proc LAPACKE_zppcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zppcon_work
 */
inline proc LAPACKE_zppcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zppcon_work(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sppequ_work
 */
extern proc LAPACKE_sppequ_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sppequ_work
 */
inline proc LAPACKE_sppequ_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_sppequ_work(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dppequ_work
 */
extern proc LAPACKE_dppequ_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dppequ_work
 */
inline proc LAPACKE_dppequ_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_dppequ_work(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cppequ_work
 */
extern proc LAPACKE_cppequ_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cppequ_work
 */
inline proc LAPACKE_cppequ_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float) : c_int{
  return LAPACKE_cppequ_work(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zppequ_work
 */
extern proc LAPACKE_zppequ_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zppequ_work
 */
inline proc LAPACKE_zppequ_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double) : c_int{
  return LAPACKE_zppequ_work(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spprfs_work
 */
extern proc LAPACKE_spprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spprfs_work
 */
inline proc LAPACKE_spprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_spprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpprfs_work
 */
extern proc LAPACKE_dpprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpprfs_work
 */
inline proc LAPACKE_dpprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dpprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpprfs_work
 */
extern proc LAPACKE_cpprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpprfs_work
 */
inline proc LAPACKE_cpprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cpprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpprfs_work
 */
extern proc LAPACKE_zpprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpprfs_work
 */
inline proc LAPACKE_zpprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zpprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sppsv_work
 */
extern proc LAPACKE_sppsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sppsv_work
 */
inline proc LAPACKE_sppsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sppsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dppsv_work
 */
extern proc LAPACKE_dppsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dppsv_work
 */
inline proc LAPACKE_dppsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dppsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cppsv_work
 */
extern proc LAPACKE_cppsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cppsv_work
 */
inline proc LAPACKE_cppsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cppsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zppsv_work
 */
extern proc LAPACKE_zppsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zppsv_work
 */
inline proc LAPACKE_zppsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zppsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sppsvx_work
 */
extern proc LAPACKE_sppsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sppsvx_work
 */
inline proc LAPACKE_sppsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sppsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dppsvx_work
 */
extern proc LAPACKE_dppsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dppsvx_work
 */
inline proc LAPACKE_dppsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dppsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cppsvx_work
 */
extern proc LAPACKE_cppsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cppsvx_work
 */
inline proc LAPACKE_cppsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cppsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zppsvx_work
 */
extern proc LAPACKE_zppsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zppsvx_work
 */
inline proc LAPACKE_zppsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zppsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spptrf_work
 */
extern proc LAPACKE_spptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spptrf_work
 */
inline proc LAPACKE_spptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float) : c_int{
  return LAPACKE_spptrf_work(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpptrf_work
 */
extern proc LAPACKE_dpptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpptrf_work
 */
inline proc LAPACKE_dpptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double) : c_int{
  return LAPACKE_dpptrf_work(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpptrf_work
 */
extern proc LAPACKE_cpptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpptrf_work
 */
inline proc LAPACKE_cpptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64)) : c_int{
  return LAPACKE_cpptrf_work(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpptrf_work
 */
extern proc LAPACKE_zpptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpptrf_work
 */
inline proc LAPACKE_zpptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128)) : c_int{
  return LAPACKE_zpptrf_work(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spptri_work
 */
extern proc LAPACKE_spptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spptri_work
 */
inline proc LAPACKE_spptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float) : c_int{
  return LAPACKE_spptri_work(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpptri_work
 */
extern proc LAPACKE_dpptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpptri_work
 */
inline proc LAPACKE_dpptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double) : c_int{
  return LAPACKE_dpptri_work(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpptri_work
 */
extern proc LAPACKE_cpptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpptri_work
 */
inline proc LAPACKE_cpptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64)) : c_int{
  return LAPACKE_cpptri_work(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpptri_work
 */
extern proc LAPACKE_zpptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpptri_work
 */
inline proc LAPACKE_zpptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128)) : c_int{
  return LAPACKE_zpptri_work(matrix_order, ascii(uplo) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spptrs_work
 */
extern proc LAPACKE_spptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spptrs_work
 */
inline proc LAPACKE_spptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_spptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpptrs_work
 */
extern proc LAPACKE_dpptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpptrs_work
 */
inline proc LAPACKE_dpptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dpptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpptrs_work
 */
extern proc LAPACKE_cpptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpptrs_work
 */
inline proc LAPACKE_cpptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpptrs_work
 */
extern proc LAPACKE_zpptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpptrs_work
 */
inline proc LAPACKE_zpptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spstrf_work
 */
extern proc LAPACKE_spstrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spstrf_work
 */
inline proc LAPACKE_spstrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_float, work : [] c_float) : c_int{
  return LAPACKE_spstrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, piv, rank, tol, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpstrf_work
 */
extern proc LAPACKE_dpstrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpstrf_work
 */
inline proc LAPACKE_dpstrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_double, work : [] c_double) : c_int{
  return LAPACKE_dpstrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, piv, rank, tol, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpstrf_work
 */
extern proc LAPACKE_cpstrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpstrf_work
 */
inline proc LAPACKE_cpstrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_float, work : [] c_float) : c_int{
  return LAPACKE_cpstrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, piv, rank, tol, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpstrf_work
 */
extern proc LAPACKE_zpstrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpstrf_work
 */
inline proc LAPACKE_zpstrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, piv : [] c_int, ref rank : c_int, tol : c_double, work : [] c_double) : c_int{
  return LAPACKE_zpstrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, piv, rank, tol, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sptcon_work
 */
extern proc LAPACKE_sptcon_work(n : c_int, d : [] c_float, e : [] c_float, anorm : c_float, ref rcond : c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dptcon_work
 */
extern proc LAPACKE_dptcon_work(n : c_int, d : [] c_double, e : [] c_double, anorm : c_double, ref rcond : c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cptcon_work
 */
extern proc LAPACKE_cptcon_work(n : c_int, d : [] c_float, e : [] complex(64), anorm : c_float, ref rcond : c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zptcon_work
 */
extern proc LAPACKE_zptcon_work(n : c_int, d : [] c_double, e : [] complex(128), anorm : c_double, ref rcond : c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_spteqr_work
 */
extern proc LAPACKE_spteqr_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_spteqr_work
 */
inline proc LAPACKE_spteqr_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int{
  return LAPACKE_spteqr_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dpteqr_work
 */
extern proc LAPACKE_dpteqr_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dpteqr_work
 */
inline proc LAPACKE_dpteqr_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int{
  return LAPACKE_dpteqr_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cpteqr_work
 */
extern proc LAPACKE_cpteqr_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpteqr_work
 */
inline proc LAPACKE_cpteqr_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int, work : [] c_float) : c_int{
  return LAPACKE_cpteqr_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpteqr_work
 */
extern proc LAPACKE_zpteqr_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpteqr_work
 */
inline proc LAPACKE_zpteqr_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int, work : [] c_double) : c_int{
  return LAPACKE_zpteqr_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sptrfs_work
 */
extern proc LAPACKE_sptrfs_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dptrfs_work
 */
extern proc LAPACKE_dptrfs_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cptrfs_work
 */
extern proc LAPACKE_cptrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cptrfs_work
 */
inline proc LAPACKE_cptrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cptrfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zptrfs_work
 */
extern proc LAPACKE_zptrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zptrfs_work
 */
inline proc LAPACKE_zptrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zptrfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sptsv_work
 */
extern proc LAPACKE_sptsv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dptsv_work
 */
extern proc LAPACKE_dptsv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cptsv_work
 */
extern proc LAPACKE_cptsv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zptsv_work
 */
extern proc LAPACKE_zptsv_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sptsvx_work
 */
extern proc LAPACKE_sptsvx_work(matrix_order : lapack_memory_order, fact : c_char, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sptsvx_work
 */
inline proc LAPACKE_sptsvx_work(matrix_order : lapack_memory_order, fact : string, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float) : c_int{
  return LAPACKE_sptsvx_work(matrix_order, ascii(fact) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dptsvx_work
 */
extern proc LAPACKE_dptsvx_work(matrix_order : lapack_memory_order, fact : c_char, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dptsvx_work
 */
inline proc LAPACKE_dptsvx_work(matrix_order : lapack_memory_order, fact : string, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double) : c_int{
  return LAPACKE_dptsvx_work(matrix_order, ascii(fact) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cptsvx_work
 */
extern proc LAPACKE_cptsvx_work(matrix_order : lapack_memory_order, fact : c_char, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cptsvx_work
 */
inline proc LAPACKE_cptsvx_work(matrix_order : lapack_memory_order, fact : string, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cptsvx_work(matrix_order, ascii(fact) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zptsvx_work
 */
extern proc LAPACKE_zptsvx_work(matrix_order : lapack_memory_order, fact : c_char, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zptsvx_work
 */
inline proc LAPACKE_zptsvx_work(matrix_order : lapack_memory_order, fact : string, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zptsvx_work(matrix_order, ascii(fact) : c_char, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_spttrf_work
 */
extern proc LAPACKE_spttrf_work(n : c_int, d : [] c_float, e : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dpttrf_work
 */
extern proc LAPACKE_dpttrf_work(n : c_int, d : [] c_double, e : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cpttrf_work
 */
extern proc LAPACKE_cpttrf_work(n : c_int, d : [] c_float, e : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zpttrf_work
 */
extern proc LAPACKE_zpttrf_work(n : c_int, d : [] c_double, e : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_spttrs_work
 */
extern proc LAPACKE_spttrs_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_float, e : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dpttrs_work
 */
extern proc LAPACKE_dpttrs_work(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, d : [] c_double, e : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cpttrs_work
 */
extern proc LAPACKE_cpttrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cpttrs_work
 */
inline proc LAPACKE_cpttrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cpttrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, d, e, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zpttrs_work
 */
extern proc LAPACKE_zpttrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zpttrs_work
 */
inline proc LAPACKE_zpttrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zpttrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, d, e, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbev_work
 */
extern proc LAPACKE_ssbev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbev_work
 */
inline proc LAPACKE_ssbev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int{
  return LAPACKE_ssbev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbev_work
 */
extern proc LAPACKE_dsbev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbev_work
 */
inline proc LAPACKE_dsbev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int{
  return LAPACKE_dsbev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbevd_work
 */
extern proc LAPACKE_ssbevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbevd_work
 */
inline proc LAPACKE_ssbevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_ssbevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbevd_work
 */
extern proc LAPACKE_dsbevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbevd_work
 */
inline proc LAPACKE_dsbevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dsbevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbevx_work
 */
extern proc LAPACKE_ssbevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, q : [] c_float, ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbevx_work
 */
inline proc LAPACKE_ssbevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, q : [] c_float, ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_ssbevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbevx_work
 */
extern proc LAPACKE_dsbevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, q : [] c_double, ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbevx_work
 */
inline proc LAPACKE_dsbevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, q : [] c_double, ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dsbevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbgst_work
 */
extern proc LAPACKE_ssbgst_work(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, x : [] c_float, ldx : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbgst_work
 */
inline proc LAPACKE_ssbgst_work(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, x : [] c_float, ldx : c_int, work : [] c_float) : c_int{
  return LAPACKE_ssbgst_work(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbgst_work
 */
extern proc LAPACKE_dsbgst_work(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, x : [] c_double, ldx : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbgst_work
 */
inline proc LAPACKE_dsbgst_work(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, x : [] c_double, ldx : c_int, work : [] c_double) : c_int{
  return LAPACKE_dsbgst_work(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbgv_work
 */
extern proc LAPACKE_ssbgv_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbgv_work
 */
inline proc LAPACKE_ssbgv_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int{
  return LAPACKE_ssbgv_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbgv_work
 */
extern proc LAPACKE_dsbgv_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbgv_work
 */
inline proc LAPACKE_dsbgv_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int{
  return LAPACKE_dsbgv_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbgvd_work
 */
extern proc LAPACKE_ssbgvd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbgvd_work
 */
inline proc LAPACKE_ssbgvd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_ssbgvd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbgvd_work
 */
extern proc LAPACKE_dsbgvd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbgvd_work
 */
inline proc LAPACKE_dsbgvd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dsbgvd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbgvx_work
 */
extern proc LAPACKE_ssbgvx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, q : [] c_float, ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbgvx_work
 */
inline proc LAPACKE_ssbgvx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, ldab : c_int, bb : [] c_float, ldbb : c_int, q : [] c_float, ldq : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_ssbgvx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbgvx_work
 */
extern proc LAPACKE_dsbgvx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, q : [] c_double, ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbgvx_work
 */
inline proc LAPACKE_dsbgvx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, ldab : c_int, bb : [] c_double, ldbb : c_int, q : [] c_double, ldq : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dsbgvx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssbtrd_work
 */
extern proc LAPACKE_ssbtrd_work(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ldq : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssbtrd_work
 */
inline proc LAPACKE_ssbtrd_work(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ldq : c_int, work : [] c_float) : c_int{
  return LAPACKE_ssbtrd_work(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, d, e, q, ldq, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsbtrd_work
 */
extern proc LAPACKE_dsbtrd_work(matrix_order : lapack_memory_order, vect : c_char, uplo : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ldq : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsbtrd_work
 */
inline proc LAPACKE_dsbtrd_work(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ldq : c_int, work : [] c_double) : c_int{
  return LAPACKE_dsbtrd_work(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, ldab, d, e, q, ldq, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssfrk_work
 */
extern proc LAPACKE_ssfrk_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, trans : c_char, n : c_int, k : c_int, alpha : c_float, a : [] c_float, lda : c_int, beta : c_float, c : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssfrk_work
 */
inline proc LAPACKE_ssfrk_work(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, n : c_int, k : c_int, alpha : c_float, a : [] c_float, lda : c_int, beta : c_float, c : [] c_float) : c_int{
  return LAPACKE_ssfrk_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, n, k, alpha, a, lda, beta, c);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsfrk_work
 */
extern proc LAPACKE_dsfrk_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, trans : c_char, n : c_int, k : c_int, alpha : c_double, a : [] c_double, lda : c_int, beta : c_double, c : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsfrk_work
 */
inline proc LAPACKE_dsfrk_work(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, n : c_int, k : c_int, alpha : c_double, a : [] c_double, lda : c_int, beta : c_double, c : [] c_double) : c_int{
  return LAPACKE_dsfrk_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, n, k, alpha, a, lda, beta, c);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspcon_work
 */
extern proc LAPACKE_sspcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspcon_work
 */
inline proc LAPACKE_sspcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sspcon_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspcon_work
 */
extern proc LAPACKE_dspcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspcon_work
 */
inline proc LAPACKE_dspcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dspcon_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cspcon_work
 */
extern proc LAPACKE_cspcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cspcon_work
 */
inline proc LAPACKE_cspcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int{
  return LAPACKE_cspcon_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zspcon_work
 */
extern proc LAPACKE_zspcon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zspcon_work
 */
inline proc LAPACKE_zspcon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int{
  return LAPACKE_zspcon_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspev_work
 */
extern proc LAPACKE_sspev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspev_work
 */
inline proc LAPACKE_sspev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int{
  return LAPACKE_sspev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspev_work
 */
extern proc LAPACKE_dspev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspev_work
 */
inline proc LAPACKE_dspev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int{
  return LAPACKE_dspev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspevd_work
 */
extern proc LAPACKE_sspevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspevd_work
 */
inline proc LAPACKE_sspevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_sspevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspevd_work
 */
extern proc LAPACKE_dspevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspevd_work
 */
inline proc LAPACKE_dspevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dspevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspevx_work
 */
extern proc LAPACKE_sspevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspevx_work
 */
inline proc LAPACKE_sspevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_sspevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspevx_work
 */
extern proc LAPACKE_dspevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspevx_work
 */
inline proc LAPACKE_dspevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dspevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspgst_work
 */
extern proc LAPACKE_sspgst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, ap : [] c_float, bp : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspgst_work
 */
inline proc LAPACKE_sspgst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float) : c_int{
  return LAPACKE_sspgst_work(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspgst_work
 */
extern proc LAPACKE_dspgst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, ap : [] c_double, bp : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspgst_work
 */
inline proc LAPACKE_dspgst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double) : c_int{
  return LAPACKE_dspgst_work(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspgv_work
 */
extern proc LAPACKE_sspgv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspgv_work
 */
inline proc LAPACKE_sspgv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int{
  return LAPACKE_sspgv_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspgv_work
 */
extern proc LAPACKE_dspgv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspgv_work
 */
inline proc LAPACKE_dspgv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int{
  return LAPACKE_dspgv_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspgvd_work
 */
extern proc LAPACKE_sspgvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspgvd_work
 */
inline proc LAPACKE_sspgvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_sspgvd_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspgvd_work
 */
extern proc LAPACKE_dspgvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspgvd_work
 */
inline proc LAPACKE_dspgvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dspgvd_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspgvx_work
 */
extern proc LAPACKE_sspgvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] c_float, bp : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspgvx_work
 */
inline proc LAPACKE_sspgvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_sspgvx_work(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspgvx_work
 */
extern proc LAPACKE_dspgvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, ap : [] c_double, bp : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspgvx_work
 */
inline proc LAPACKE_dspgvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dspgvx_work(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssprfs_work
 */
extern proc LAPACKE_ssprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssprfs_work
 */
inline proc LAPACKE_ssprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_ssprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsprfs_work
 */
extern proc LAPACKE_dsprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsprfs_work
 */
inline proc LAPACKE_dsprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dsprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csprfs_work
 */
extern proc LAPACKE_csprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csprfs_work
 */
inline proc LAPACKE_csprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_csprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsprfs_work
 */
extern proc LAPACKE_zsprfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsprfs_work
 */
inline proc LAPACKE_zsprfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zsprfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspsv_work
 */
extern proc LAPACKE_sspsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspsv_work
 */
inline proc LAPACKE_sspsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_sspsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspsv_work
 */
extern proc LAPACKE_dspsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspsv_work
 */
inline proc LAPACKE_dspsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dspsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cspsv_work
 */
extern proc LAPACKE_cspsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cspsv_work
 */
inline proc LAPACKE_cspsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_cspsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zspsv_work
 */
extern proc LAPACKE_zspsv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zspsv_work
 */
inline proc LAPACKE_zspsv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zspsv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sspsvx_work
 */
extern proc LAPACKE_sspsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sspsvx_work
 */
inline proc LAPACKE_sspsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sspsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dspsvx_work
 */
extern proc LAPACKE_dspsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dspsvx_work
 */
inline proc LAPACKE_dspsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dspsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cspsvx_work
 */
extern proc LAPACKE_cspsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cspsvx_work
 */
inline proc LAPACKE_cspsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_cspsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zspsvx_work
 */
extern proc LAPACKE_zspsvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zspsvx_work
 */
inline proc LAPACKE_zspsvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zspsvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssptrd_work
 */
extern proc LAPACKE_ssptrd_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, d : [] c_float, e : [] c_float, tau : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssptrd_work
 */
inline proc LAPACKE_ssptrd_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, d : [] c_float, e : [] c_float, tau : [] c_float) : c_int{
  return LAPACKE_ssptrd_work(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsptrd_work
 */
extern proc LAPACKE_dsptrd_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, d : [] c_double, e : [] c_double, tau : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsptrd_work
 */
inline proc LAPACKE_dsptrd_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, d : [] c_double, e : [] c_double, tau : [] c_double) : c_int{
  return LAPACKE_dsptrd_work(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssptrf_work
 */
extern proc LAPACKE_ssptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssptrf_work
 */
inline proc LAPACKE_ssptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int) : c_int{
  return LAPACKE_ssptrf_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsptrf_work
 */
extern proc LAPACKE_dsptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsptrf_work
 */
inline proc LAPACKE_dsptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int) : c_int{
  return LAPACKE_dsptrf_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csptrf_work
 */
extern proc LAPACKE_csptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csptrf_work
 */
inline proc LAPACKE_csptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int) : c_int{
  return LAPACKE_csptrf_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsptrf_work
 */
extern proc LAPACKE_zsptrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsptrf_work
 */
inline proc LAPACKE_zsptrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int) : c_int{
  return LAPACKE_zsptrf_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssptri_work
 */
extern proc LAPACKE_ssptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, ipiv : [] c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssptri_work
 */
inline proc LAPACKE_ssptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int, work : [] c_float) : c_int{
  return LAPACKE_ssptri_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsptri_work
 */
extern proc LAPACKE_dsptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, ipiv : [] c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsptri_work
 */
inline proc LAPACKE_dsptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int, work : [] c_double) : c_int{
  return LAPACKE_dsptri_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csptri_work
 */
extern proc LAPACKE_csptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), ipiv : [] c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csptri_work
 */
inline proc LAPACKE_csptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, work : [] complex(64)) : c_int{
  return LAPACKE_csptri_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsptri_work
 */
extern proc LAPACKE_zsptri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), ipiv : [] c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsptri_work
 */
inline proc LAPACKE_zsptri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zsptri_work(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssptrs_work
 */
extern proc LAPACKE_ssptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssptrs_work
 */
inline proc LAPACKE_ssptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_ssptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsptrs_work
 */
extern proc LAPACKE_dsptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsptrs_work
 */
inline proc LAPACKE_dsptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dsptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csptrs_work
 */
extern proc LAPACKE_csptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csptrs_work
 */
inline proc LAPACKE_csptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_csptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsptrs_work
 */
extern proc LAPACKE_zsptrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsptrs_work
 */
inline proc LAPACKE_zsptrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zsptrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, ap, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstebz_work
 */
extern proc LAPACKE_sstebz_work(range : c_char, order : c_char, n : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, d : [] c_float, e : [] c_float, ref m : c_int, ref nsplit : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstebz_work
 */
inline proc LAPACKE_sstebz_work(range : string, order : string, n : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, d : [] c_float, e : [] c_float, ref m : c_int, ref nsplit : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_sstebz_work(ascii(range) : c_char, ascii(order) : c_char, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstebz_work
 */
extern proc LAPACKE_dstebz_work(range : c_char, order : c_char, n : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, d : [] c_double, e : [] c_double, ref m : c_int, ref nsplit : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstebz_work
 */
inline proc LAPACKE_dstebz_work(range : string, order : string, n : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, d : [] c_double, e : [] c_double, ref m : c_int, ref nsplit : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dstebz_work(ascii(range) : c_char, ascii(order) : c_char, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstedc_work
 */
extern proc LAPACKE_sstedc_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstedc_work
 */
inline proc LAPACKE_sstedc_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_sstedc_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstedc_work
 */
extern proc LAPACKE_dstedc_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstedc_work
 */
inline proc LAPACKE_dstedc_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dstedc_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cstedc_work
 */
extern proc LAPACKE_cstedc_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cstedc_work
 */
inline proc LAPACKE_cstedc_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_cstedc_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zstedc_work
 */
extern proc LAPACKE_zstedc_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zstedc_work
 */
inline proc LAPACKE_zstedc_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zstedc_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstegr_work
 */
extern proc LAPACKE_sstegr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstegr_work
 */
inline proc LAPACKE_sstegr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_sstegr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstegr_work
 */
extern proc LAPACKE_dstegr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstegr_work
 */
inline proc LAPACKE_dstegr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dstegr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cstegr_work
 */
extern proc LAPACKE_cstegr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, isuppz : [] c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cstegr_work
 */
inline proc LAPACKE_cstegr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, isuppz : [] c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_cstegr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zstegr_work
 */
extern proc LAPACKE_zstegr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, isuppz : [] c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zstegr_work
 */
inline proc LAPACKE_zstegr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, isuppz : [] c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zstegr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstein_work
 */
extern proc LAPACKE_sstein_work(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] c_float, m : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifailv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dstein_work
 */
extern proc LAPACKE_dstein_work(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] c_double, m : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifailv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cstein_work
 */
extern proc LAPACKE_cstein_work(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] c_float, m : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, z : [] complex(64), ldz : c_int, work : [] c_float, iwork : [] c_int, ifailv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zstein_work
 */
extern proc LAPACKE_zstein_work(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] c_double, m : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, z : [] complex(128), ldz : c_int, work : [] c_double, iwork : [] c_int, ifailv : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sstemr_work
 */
extern proc LAPACKE_sstemr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstemr_work
 */
inline proc LAPACKE_sstemr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_sstemr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstemr_work
 */
extern proc LAPACKE_dstemr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstemr_work
 */
inline proc LAPACKE_dstemr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dstemr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cstemr_work
 */
extern proc LAPACKE_cstemr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cstemr_work
 */
inline proc LAPACKE_cstemr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] complex(64), ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_cstemr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zstemr_work
 */
extern proc LAPACKE_zstemr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zstemr_work
 */
inline proc LAPACKE_zstemr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] complex(128), ldz : c_int, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_zstemr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssteqr_work
 */
extern proc LAPACKE_ssteqr_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssteqr_work
 */
inline proc LAPACKE_ssteqr_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int{
  return LAPACKE_ssteqr_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsteqr_work
 */
extern proc LAPACKE_dsteqr_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsteqr_work
 */
inline proc LAPACKE_dsteqr_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int{
  return LAPACKE_dsteqr_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csteqr_work
 */
extern proc LAPACKE_csteqr_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csteqr_work
 */
inline proc LAPACKE_csteqr_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ldz : c_int, work : [] c_float) : c_int{
  return LAPACKE_csteqr_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsteqr_work
 */
extern proc LAPACKE_zsteqr_work(matrix_order : lapack_memory_order, compz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsteqr_work
 */
inline proc LAPACKE_zsteqr_work(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ldz : c_int, work : [] c_double) : c_int{
  return LAPACKE_zsteqr_work(matrix_order, ascii(compz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssterf_work
 */
extern proc LAPACKE_ssterf_work(n : c_int, d : [] c_float, e : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dsterf_work
 */
extern proc LAPACKE_dsterf_work(n : c_int, d : [] c_double, e : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sstev_work
 */
extern proc LAPACKE_sstev_work(matrix_order : lapack_memory_order, jobz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstev_work
 */
inline proc LAPACKE_sstev_work(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float) : c_int{
  return LAPACKE_sstev_work(matrix_order, ascii(jobz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstev_work
 */
extern proc LAPACKE_dstev_work(matrix_order : lapack_memory_order, jobz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstev_work
 */
inline proc LAPACKE_dstev_work(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double) : c_int{
  return LAPACKE_dstev_work(matrix_order, ascii(jobz) : c_char, n, d, e, z, ldz, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstevd_work
 */
extern proc LAPACKE_sstevd_work(matrix_order : lapack_memory_order, jobz : c_char, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstevd_work
 */
inline proc LAPACKE_sstevd_work(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_sstevd_work(matrix_order, ascii(jobz) : c_char, n, d, e, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstevd_work
 */
extern proc LAPACKE_dstevd_work(matrix_order : lapack_memory_order, jobz : c_char, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstevd_work
 */
inline proc LAPACKE_dstevd_work(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dstevd_work(matrix_order, ascii(jobz) : c_char, n, d, e, z, ldz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstevr_work
 */
extern proc LAPACKE_sstevr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstevr_work
 */
inline proc LAPACKE_sstevr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_sstevr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstevr_work
 */
extern proc LAPACKE_dstevr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstevr_work
 */
inline proc LAPACKE_dstevr_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dstevr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sstevx_work
 */
extern proc LAPACKE_sstevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sstevx_work
 */
inline proc LAPACKE_sstevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_sstevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dstevx_work
 */
extern proc LAPACKE_dstevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dstevx_work
 */
inline proc LAPACKE_dstevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dstevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssycon_work
 */
extern proc LAPACKE_ssycon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssycon_work
 */
inline proc LAPACKE_ssycon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_ssycon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsycon_work
 */
extern proc LAPACKE_dsycon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsycon_work
 */
inline proc LAPACKE_dsycon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dsycon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csycon_work
 */
extern proc LAPACKE_csycon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csycon_work
 */
inline proc LAPACKE_csycon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, anorm : c_float, ref rcond : c_float, work : [] complex(64)) : c_int{
  return LAPACKE_csycon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsycon_work
 */
extern proc LAPACKE_zsycon_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsycon_work
 */
inline proc LAPACKE_zsycon_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, anorm : c_double, ref rcond : c_double, work : [] complex(128)) : c_int{
  return LAPACKE_zsycon_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, anorm, rcond, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyequb_work
 */
extern proc LAPACKE_ssyequb_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyequb_work
 */
inline proc LAPACKE_ssyequb_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, work : [] c_float) : c_int{
  return LAPACKE_ssyequb_work(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyequb_work
 */
extern proc LAPACKE_dsyequb_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyequb_work
 */
inline proc LAPACKE_dsyequb_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, work : [] c_double) : c_int{
  return LAPACKE_dsyequb_work(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyequb_work
 */
extern proc LAPACKE_csyequb_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyequb_work
 */
inline proc LAPACKE_csyequb_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, work : [] complex(64)) : c_int{
  return LAPACKE_csyequb_work(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyequb_work
 */
extern proc LAPACKE_zsyequb_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyequb_work
 */
inline proc LAPACKE_zsyequb_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, work : [] complex(128)) : c_int{
  return LAPACKE_zsyequb_work(matrix_order, ascii(uplo) : c_char, n, a, lda, s, scond, amax, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyev_work
 */
extern proc LAPACKE_ssyev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, w : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyev_work
 */
inline proc LAPACKE_ssyev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, w : [] c_float, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_ssyev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyev_work
 */
extern proc LAPACKE_dsyev_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, w : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyev_work
 */
inline proc LAPACKE_dsyev_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, w : [] c_double, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dsyev_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyevd_work
 */
extern proc LAPACKE_ssyevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, w : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyevd_work
 */
inline proc LAPACKE_ssyevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, w : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_ssyevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyevd_work
 */
extern proc LAPACKE_dsyevd_work(matrix_order : lapack_memory_order, jobz : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, w : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyevd_work
 */
inline proc LAPACKE_dsyevd_work(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, w : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dsyevd_work(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, w, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyevr_work
 */
extern proc LAPACKE_ssyevr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyevr_work
 */
inline proc LAPACKE_ssyevr_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, isuppz : [] c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_ssyevr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyevr_work
 */
extern proc LAPACKE_dsyevr_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyevr_work
 */
inline proc LAPACKE_dsyevr_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, isuppz : [] c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dsyevr_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyevx_work
 */
extern proc LAPACKE_ssyevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyevx_work
 */
inline proc LAPACKE_ssyevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_ssyevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyevx_work
 */
extern proc LAPACKE_dsyevx_work(matrix_order : lapack_memory_order, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyevx_work
 */
inline proc LAPACKE_dsyevx_work(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dsyevx_work(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssygst_work
 */
extern proc LAPACKE_ssygst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssygst_work
 */
inline proc LAPACKE_ssygst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_ssygst_work(matrix_order, itype, ascii(uplo) : c_char, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsygst_work
 */
extern proc LAPACKE_dsygst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsygst_work
 */
inline proc LAPACKE_dsygst_work(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dsygst_work(matrix_order, itype, ascii(uplo) : c_char, n, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssygv_work
 */
extern proc LAPACKE_ssygv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, w : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssygv_work
 */
inline proc LAPACKE_ssygv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, w : [] c_float, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_ssygv_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsygv_work
 */
extern proc LAPACKE_dsygv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, w : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsygv_work
 */
inline proc LAPACKE_dsygv_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, w : [] c_double, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dsygv_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssygvd_work
 */
extern proc LAPACKE_ssygvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, w : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssygvd_work
 */
inline proc LAPACKE_ssygvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, w : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_ssygvd_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsygvd_work
 */
extern proc LAPACKE_dsygvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, w : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsygvd_work
 */
inline proc LAPACKE_dsygvd_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, w : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dsygvd_work(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssygvx_work
 */
extern proc LAPACKE_ssygvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssygvx_work
 */
inline proc LAPACKE_ssygvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ldz : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_ssygvx_work(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsygvx_work
 */
extern proc LAPACKE_dsygvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : c_char, range : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, ifail : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsygvx_work
 */
inline proc LAPACKE_dsygvx_work(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ldz : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int, ifail : [] c_int) : c_int{
  return LAPACKE_dsygvx_work(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyrfs_work
 */
extern proc LAPACKE_ssyrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyrfs_work
 */
inline proc LAPACKE_ssyrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_ssyrfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyrfs_work
 */
extern proc LAPACKE_dsyrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyrfs_work
 */
inline proc LAPACKE_dsyrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dsyrfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyrfs_work
 */
extern proc LAPACKE_csyrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyrfs_work
 */
inline proc LAPACKE_csyrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_csyrfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyrfs_work
 */
extern proc LAPACKE_zsyrfs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyrfs_work
 */
inline proc LAPACKE_zsyrfs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zsyrfs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyrfsx_work
 */
extern proc LAPACKE_ssyrfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyrfsx_work
 */
inline proc LAPACKE_ssyrfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_ssyrfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyrfsx_work
 */
extern proc LAPACKE_dsyrfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyrfsx_work
 */
inline proc LAPACKE_dsyrfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dsyrfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyrfsx_work
 */
extern proc LAPACKE_csyrfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyrfsx_work
 */
inline proc LAPACKE_csyrfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_csyrfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyrfsx_work
 */
extern proc LAPACKE_zsyrfsx_work(matrix_order : lapack_memory_order, uplo : c_char, equed : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyrfsx_work
 */
inline proc LAPACKE_zsyrfsx_work(matrix_order : lapack_memory_order, uplo : string, equed : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zsyrfsx_work(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssysv_work
 */
extern proc LAPACKE_ssysv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssysv_work
 */
inline proc LAPACKE_ssysv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_ssysv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsysv_work
 */
extern proc LAPACKE_dsysv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsysv_work
 */
inline proc LAPACKE_dsysv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dsysv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csysv_work
 */
extern proc LAPACKE_csysv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csysv_work
 */
inline proc LAPACKE_csysv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_csysv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsysv_work
 */
extern proc LAPACKE_zsysv_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsysv_work
 */
inline proc LAPACKE_zsysv_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zsysv_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssysv_rook_work
 */
extern proc LAPACKE_ssysv_rook_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssysv_rook_work
 */
inline proc LAPACKE_ssysv_rook_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_ssysv_rook_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsysv_rook_work
 */
extern proc LAPACKE_dsysv_rook_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsysv_rook_work
 */
inline proc LAPACKE_dsysv_rook_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dsysv_rook_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csysv_rook_work
 */
extern proc LAPACKE_csysv_rook_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csysv_rook_work
 */
inline proc LAPACKE_csysv_rook_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_csysv_rook_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsysv_rook_work
 */
extern proc LAPACKE_zsysv_rook_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsysv_rook_work
 */
inline proc LAPACKE_zsysv_rook_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zsysv_rook_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssysvx_work
 */
extern proc LAPACKE_ssysvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssysvx_work
 */
inline proc LAPACKE_ssysvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_ssysvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsysvx_work
 */
extern proc LAPACKE_dsysvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsysvx_work
 */
inline proc LAPACKE_dsysvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_dsysvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csysvx_work
 */
extern proc LAPACKE_csysvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csysvx_work
 */
inline proc LAPACKE_csysvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), lwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_csysvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsysvx_work
 */
extern proc LAPACKE_zsysvx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsysvx_work
 */
inline proc LAPACKE_zsysvx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), lwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_zsysvx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssysvxx_work
 */
extern proc LAPACKE_ssysvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssysvxx_work
 */
inline proc LAPACKE_ssysvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, af : [] c_float, ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_ssysvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsysvxx_work
 */
extern proc LAPACKE_dsysvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsysvxx_work
 */
inline proc LAPACKE_dsysvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, af : [] c_double, ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dsysvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csysvxx_work
 */
extern proc LAPACKE_csysvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csysvxx_work
 */
inline proc LAPACKE_csysvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, af : [] complex(64), ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_float, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_csysvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsysvxx_work
 */
extern proc LAPACKE_zsysvxx_work(matrix_order : lapack_memory_order, fact : c_char, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsysvxx_work
 */
inline proc LAPACKE_zsysvxx_work(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, af : [] complex(128), ldaf : c_int, ipiv : [] c_int, ref equed : string, s : [] c_double, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_zsysvxx_work(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, nrhs, a, lda, af, ldaf, ipiv, ascii(equed) : c_char, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytrd_work
 */
extern proc LAPACKE_ssytrd_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, d : [] c_float, e : [] c_float, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytrd_work
 */
inline proc LAPACKE_ssytrd_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, d : [] c_float, e : [] c_float, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_ssytrd_work(matrix_order, ascii(uplo) : c_char, n, a, lda, d, e, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytrd_work
 */
extern proc LAPACKE_dsytrd_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, d : [] c_double, e : [] c_double, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytrd_work
 */
inline proc LAPACKE_dsytrd_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, d : [] c_double, e : [] c_double, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dsytrd_work(matrix_order, ascii(uplo) : c_char, n, a, lda, d, e, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytrf_work
 */
extern proc LAPACKE_ssytrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytrf_work
 */
inline proc LAPACKE_ssytrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_ssytrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytrf_work
 */
extern proc LAPACKE_dsytrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytrf_work
 */
inline proc LAPACKE_dsytrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dsytrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytrf_work
 */
extern proc LAPACKE_csytrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytrf_work
 */
inline proc LAPACKE_csytrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_csytrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytrf_work
 */
extern proc LAPACKE_zsytrf_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytrf_work
 */
inline proc LAPACKE_zsytrf_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zsytrf_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytri_work
 */
extern proc LAPACKE_ssytri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytri_work
 */
inline proc LAPACKE_ssytri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] c_float) : c_int{
  return LAPACKE_ssytri_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytri_work
 */
extern proc LAPACKE_dsytri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytri_work
 */
inline proc LAPACKE_dsytri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] c_double) : c_int{
  return LAPACKE_dsytri_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytri_work
 */
extern proc LAPACKE_csytri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytri_work
 */
inline proc LAPACKE_csytri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64)) : c_int{
  return LAPACKE_csytri_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytri_work
 */
extern proc LAPACKE_zsytri_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytri_work
 */
inline proc LAPACKE_zsytri_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zsytri_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytrs_work
 */
extern proc LAPACKE_ssytrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytrs_work
 */
inline proc LAPACKE_ssytrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_ssytrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytrs_work
 */
extern proc LAPACKE_dsytrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytrs_work
 */
inline proc LAPACKE_dsytrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dsytrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytrs_work
 */
extern proc LAPACKE_csytrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytrs_work
 */
inline proc LAPACKE_csytrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_csytrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytrs_work
 */
extern proc LAPACKE_zsytrs_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytrs_work
 */
inline proc LAPACKE_zsytrs_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zsytrs_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stbcon_work
 */
extern proc LAPACKE_stbcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stbcon_work
 */
inline proc LAPACKE_stbcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] c_float, ldab : c_int, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_stbcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, ldab, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtbcon_work
 */
extern proc LAPACKE_dtbcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtbcon_work
 */
inline proc LAPACKE_dtbcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] c_double, ldab : c_int, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dtbcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, ldab, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctbcon_work
 */
extern proc LAPACKE_ctbcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctbcon_work
 */
inline proc LAPACKE_ctbcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] complex(64), ldab : c_int, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_ctbcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, ldab, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztbcon_work
 */
extern proc LAPACKE_ztbcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztbcon_work
 */
inline proc LAPACKE_ztbcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] complex(128), ldab : c_int, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_ztbcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, ldab, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stbrfs_work
 */
extern proc LAPACKE_stbrfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stbrfs_work
 */
inline proc LAPACKE_stbrfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_stbrfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtbrfs_work
 */
extern proc LAPACKE_dtbrfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtbrfs_work
 */
inline proc LAPACKE_dtbrfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dtbrfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctbrfs_work
 */
extern proc LAPACKE_ctbrfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctbrfs_work
 */
inline proc LAPACKE_ctbrfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_ctbrfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztbrfs_work
 */
extern proc LAPACKE_ztbrfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztbrfs_work
 */
inline proc LAPACKE_ztbrfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_ztbrfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stbtrs_work
 */
extern proc LAPACKE_stbtrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stbtrs_work
 */
inline proc LAPACKE_stbtrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_float, ldab : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_stbtrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtbtrs_work
 */
extern proc LAPACKE_dtbtrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtbtrs_work
 */
inline proc LAPACKE_dtbtrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] c_double, ldab : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtbtrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctbtrs_work
 */
extern proc LAPACKE_ctbtrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctbtrs_work
 */
inline proc LAPACKE_ctbtrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(64), ldab : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctbtrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztbtrs_work
 */
extern proc LAPACKE_ztbtrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztbtrs_work
 */
inline proc LAPACKE_ztbtrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, nrhs : c_int, ab : [] complex(128), ldab : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztbtrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, nrhs, ab, ldab, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stfsm_work
 */
extern proc LAPACKE_stfsm_work(matrix_order : lapack_memory_order, transr : c_char, side : c_char, uplo : c_char, trans : c_char, diag : c_char, m : c_int, n : c_int, alpha : c_float, a : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stfsm_work
 */
inline proc LAPACKE_stfsm_work(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, m : c_int, n : c_int, alpha : c_float, a : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_stfsm_work(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, m, n, alpha, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtfsm_work
 */
extern proc LAPACKE_dtfsm_work(matrix_order : lapack_memory_order, transr : c_char, side : c_char, uplo : c_char, trans : c_char, diag : c_char, m : c_int, n : c_int, alpha : c_double, a : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtfsm_work
 */
inline proc LAPACKE_dtfsm_work(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, m : c_int, n : c_int, alpha : c_double, a : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtfsm_work(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, m, n, alpha, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctfsm_work
 */
extern proc LAPACKE_ctfsm_work(matrix_order : lapack_memory_order, transr : c_char, side : c_char, uplo : c_char, trans : c_char, diag : c_char, m : c_int, n : c_int, alpha : complex(64), a : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctfsm_work
 */
inline proc LAPACKE_ctfsm_work(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, m : c_int, n : c_int, alpha : complex(64), a : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctfsm_work(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, m, n, alpha, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztfsm_work
 */
extern proc LAPACKE_ztfsm_work(matrix_order : lapack_memory_order, transr : c_char, side : c_char, uplo : c_char, trans : c_char, diag : c_char, m : c_int, n : c_int, alpha : complex(128), a : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztfsm_work
 */
inline proc LAPACKE_ztfsm_work(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, m : c_int, n : c_int, alpha : complex(128), a : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztfsm_work(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, m, n, alpha, a, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stftri_work
 */
extern proc LAPACKE_stftri_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stftri_work
 */
inline proc LAPACKE_stftri_work(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, n : c_int, a : [] c_float) : c_int{
  return LAPACKE_stftri_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtftri_work
 */
extern proc LAPACKE_dtftri_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtftri_work
 */
inline proc LAPACKE_dtftri_work(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, n : c_int, a : [] c_double) : c_int{
  return LAPACKE_dtftri_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctftri_work
 */
extern proc LAPACKE_ctftri_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctftri_work
 */
inline proc LAPACKE_ctftri_work(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, n : c_int, a : [] complex(64)) : c_int{
  return LAPACKE_ctftri_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztftri_work
 */
extern proc LAPACKE_ztftri_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztftri_work
 */
inline proc LAPACKE_ztftri_work(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, n : c_int, a : [] complex(128)) : c_int{
  return LAPACKE_ztftri_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stfttp_work
 */
extern proc LAPACKE_stfttp_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] c_float, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stfttp_work
 */
inline proc LAPACKE_stfttp_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_float, ap : [] c_float) : c_int{
  return LAPACKE_stfttp_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtfttp_work
 */
extern proc LAPACKE_dtfttp_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] c_double, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtfttp_work
 */
inline proc LAPACKE_dtfttp_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_double, ap : [] c_double) : c_int{
  return LAPACKE_dtfttp_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctfttp_work
 */
extern proc LAPACKE_ctfttp_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] complex(64), ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctfttp_work
 */
inline proc LAPACKE_ctfttp_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(64), ap : [] complex(64)) : c_int{
  return LAPACKE_ctfttp_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztfttp_work
 */
extern proc LAPACKE_ztfttp_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] complex(128), ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztfttp_work
 */
inline proc LAPACKE_ztfttp_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(128), ap : [] complex(128)) : c_int{
  return LAPACKE_ztfttp_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stfttr_work
 */
extern proc LAPACKE_stfttr_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] c_float, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stfttr_work
 */
inline proc LAPACKE_stfttr_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_float, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_stfttr_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtfttr_work
 */
extern proc LAPACKE_dtfttr_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] c_double, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtfttr_work
 */
inline proc LAPACKE_dtfttr_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_double, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dtfttr_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctfttr_work
 */
extern proc LAPACKE_ctfttr_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] complex(64), a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctfttr_work
 */
inline proc LAPACKE_ctfttr_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(64), a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_ctfttr_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztfttr_work
 */
extern proc LAPACKE_ztfttr_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, arf : [] complex(128), a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztfttr_work
 */
inline proc LAPACKE_ztfttr_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(128), a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_ztfttr_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stgevc_work
 */
extern proc LAPACKE_stgevc_work(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, s : [] c_float, lds : c_int, p : [] c_float, ldp : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stgevc_work
 */
inline proc LAPACKE_stgevc_work(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, s : [] c_float, lds : c_int, p : [] c_float, ldp : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_float) : c_int{
  return LAPACKE_stgevc_work(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgevc_work
 */
extern proc LAPACKE_dtgevc_work(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, s : [] c_double, lds : c_int, p : [] c_double, ldp : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtgevc_work
 */
inline proc LAPACKE_dtgevc_work(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, s : [] c_double, lds : c_int, p : [] c_double, ldp : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_double) : c_int{
  return LAPACKE_dtgevc_work(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgevc_work
 */
extern proc LAPACKE_ctgevc_work(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, s : [] complex(64), lds : c_int, p : [] complex(64), ldp : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctgevc_work
 */
inline proc LAPACKE_ctgevc_work(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, s : [] complex(64), lds : c_int, p : [] complex(64), ldp : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_ctgevc_work(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgevc_work
 */
extern proc LAPACKE_ztgevc_work(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, s : [] complex(128), lds : c_int, p : [] complex(128), ldp : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztgevc_work
 */
inline proc LAPACKE_ztgevc_work(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, s : [] complex(128), lds : c_int, p : [] complex(128), ldp : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_ztgevc_work(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stgexc_work
 */
extern proc LAPACKE_stgexc_work(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgexc_work
 */
extern proc LAPACKE_dtgexc_work(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgexc_work
 */
extern proc LAPACKE_ctgexc_work(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int, ifst : c_int, ilst : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgexc_work
 */
extern proc LAPACKE_ztgexc_work(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int, ifst : c_int, ilst : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stgsen_work
 */
extern proc LAPACKE_stgsen_work(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, ldq : c_int, z : [] c_float, ldz : c_int, ref m : c_int, ref pl : c_float, ref pr : c_float, dif : [] c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgsen_work
 */
extern proc LAPACKE_dtgsen_work(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, ldq : c_int, z : [] c_double, ldz : c_int, ref m : c_int, ref pl : c_double, ref pr : c_double, dif : [] c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgsen_work
 */
extern proc LAPACKE_ctgsen_work(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), ldq : c_int, z : [] complex(64), ldz : c_int, ref m : c_int, ref pl : c_float, ref pr : c_float, dif : [] c_float, work : [] complex(64), lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgsen_work
 */
extern proc LAPACKE_ztgsen_work(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), ldq : c_int, z : [] complex(128), ldz : c_int, ref m : c_int, ref pl : c_double, ref pr : c_double, dif : [] c_double, work : [] complex(128), lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stgsja_work
 */
extern proc LAPACKE_stgsja_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, work : [] c_float, ref ncycle : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stgsja_work
 */
inline proc LAPACKE_stgsja_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] c_float, ldu : c_int, v : [] c_float, ldv : c_int, q : [] c_float, ldq : c_int, work : [] c_float, ref ncycle : c_int) : c_int{
  return LAPACKE_stgsja_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgsja_work
 */
extern proc LAPACKE_dtgsja_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, work : [] c_double, ref ncycle : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtgsja_work
 */
inline proc LAPACKE_dtgsja_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] c_double, ldu : c_int, v : [] c_double, ldv : c_int, q : [] c_double, ldq : c_int, work : [] c_double, ref ncycle : c_int) : c_int{
  return LAPACKE_dtgsja_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgsja_work
 */
extern proc LAPACKE_ctgsja_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, work : [] complex(64), ref ncycle : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctgsja_work
 */
inline proc LAPACKE_ctgsja_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ldu : c_int, v : [] complex(64), ldv : c_int, q : [] complex(64), ldq : c_int, work : [] complex(64), ref ncycle : c_int) : c_int{
  return LAPACKE_ctgsja_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgsja_work
 */
extern proc LAPACKE_ztgsja_work(matrix_order : lapack_memory_order, jobu : c_char, jobv : c_char, jobq : c_char, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, work : [] complex(128), ref ncycle : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztgsja_work
 */
inline proc LAPACKE_ztgsja_work(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, m : c_int, p : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ldu : c_int, v : [] complex(128), ldv : c_int, q : [] complex(128), ldq : c_int, work : [] complex(128), ref ncycle : c_int) : c_int{
  return LAPACKE_ztgsja_work(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stgsna_work
 */
extern proc LAPACKE_stgsna_work(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stgsna_work
 */
inline proc LAPACKE_stgsna_work(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_stgsna_work(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgsna_work
 */
extern proc LAPACKE_dtgsna_work(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtgsna_work
 */
inline proc LAPACKE_dtgsna_work(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_dtgsna_work(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgsna_work
 */
extern proc LAPACKE_ctgsna_work(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int, work : [] complex(64), lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctgsna_work
 */
inline proc LAPACKE_ctgsna_work(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int, work : [] complex(64), lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_ctgsna_work(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgsna_work
 */
extern proc LAPACKE_ztgsna_work(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int, work : [] complex(128), lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztgsna_work
 */
inline proc LAPACKE_ztgsna_work(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int, work : [] complex(128), lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_ztgsna_work(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stgsyl_work
 */
extern proc LAPACKE_stgsyl_work(matrix_order : lapack_memory_order, trans : c_char, ijob : c_int, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, ldc : c_int, d : [] c_float, ldd : c_int, e : [] c_float, lde : c_int, f : [] c_float, ldf : c_int, ref scale : c_float, ref dif : c_float, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stgsyl_work
 */
inline proc LAPACKE_stgsyl_work(matrix_order : lapack_memory_order, trans : string, ijob : c_int, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, ldc : c_int, d : [] c_float, ldd : c_int, e : [] c_float, lde : c_int, f : [] c_float, ldf : c_int, ref scale : c_float, ref dif : c_float, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_stgsyl_work(matrix_order, ascii(trans) : c_char, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtgsyl_work
 */
extern proc LAPACKE_dtgsyl_work(matrix_order : lapack_memory_order, trans : c_char, ijob : c_int, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, ldc : c_int, d : [] c_double, ldd : c_int, e : [] c_double, lde : c_int, f : [] c_double, ldf : c_int, ref scale : c_double, ref dif : c_double, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtgsyl_work
 */
inline proc LAPACKE_dtgsyl_work(matrix_order : lapack_memory_order, trans : string, ijob : c_int, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, ldc : c_int, d : [] c_double, ldd : c_int, e : [] c_double, lde : c_int, f : [] c_double, ldf : c_int, ref scale : c_double, ref dif : c_double, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_dtgsyl_work(matrix_order, ascii(trans) : c_char, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctgsyl_work
 */
extern proc LAPACKE_ctgsyl_work(matrix_order : lapack_memory_order, trans : c_char, ijob : c_int, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), ldc : c_int, d : [] complex(64), ldd : c_int, e : [] complex(64), lde : c_int, f : [] complex(64), ldf : c_int, ref scale : c_float, ref dif : c_float, work : [] complex(64), lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctgsyl_work
 */
inline proc LAPACKE_ctgsyl_work(matrix_order : lapack_memory_order, trans : string, ijob : c_int, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), ldc : c_int, d : [] complex(64), ldd : c_int, e : [] complex(64), lde : c_int, f : [] complex(64), ldf : c_int, ref scale : c_float, ref dif : c_float, work : [] complex(64), lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_ctgsyl_work(matrix_order, ascii(trans) : c_char, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztgsyl_work
 */
extern proc LAPACKE_ztgsyl_work(matrix_order : lapack_memory_order, trans : c_char, ijob : c_int, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), ldc : c_int, d : [] complex(128), ldd : c_int, e : [] complex(128), lde : c_int, f : [] complex(128), ldf : c_int, ref scale : c_double, ref dif : c_double, work : [] complex(128), lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztgsyl_work
 */
inline proc LAPACKE_ztgsyl_work(matrix_order : lapack_memory_order, trans : string, ijob : c_int, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), ldc : c_int, d : [] complex(128), ldd : c_int, e : [] complex(128), lde : c_int, f : [] complex(128), ldf : c_int, ref scale : c_double, ref dif : c_double, work : [] complex(128), lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_ztgsyl_work(matrix_order, ascii(trans) : c_char, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stpcon_work
 */
extern proc LAPACKE_stpcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, ap : [] c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stpcon_work
 */
inline proc LAPACKE_stpcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_stpcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpcon_work
 */
extern proc LAPACKE_dtpcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, ap : [] c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtpcon_work
 */
inline proc LAPACKE_dtpcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dtpcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpcon_work
 */
extern proc LAPACKE_ctpcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, ap : [] complex(64), ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctpcon_work
 */
inline proc LAPACKE_ctpcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] complex(64), ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_ctpcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpcon_work
 */
extern proc LAPACKE_ztpcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, ap : [] complex(128), ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztpcon_work
 */
inline proc LAPACKE_ztpcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] complex(128), ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_ztpcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stprfs_work
 */
extern proc LAPACKE_stprfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stprfs_work
 */
inline proc LAPACKE_stprfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_stprfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtprfs_work
 */
extern proc LAPACKE_dtprfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtprfs_work
 */
inline proc LAPACKE_dtprfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dtprfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctprfs_work
 */
extern proc LAPACKE_ctprfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctprfs_work
 */
inline proc LAPACKE_ctprfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_ctprfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztprfs_work
 */
extern proc LAPACKE_ztprfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztprfs_work
 */
inline proc LAPACKE_ztprfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_ztprfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stptri_work
 */
extern proc LAPACKE_stptri_work(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stptri_work
 */
inline proc LAPACKE_stptri_work(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] c_float) : c_int{
  return LAPACKE_stptri_work(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtptri_work
 */
extern proc LAPACKE_dtptri_work(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtptri_work
 */
inline proc LAPACKE_dtptri_work(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] c_double) : c_int{
  return LAPACKE_dtptri_work(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctptri_work
 */
extern proc LAPACKE_ctptri_work(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctptri_work
 */
inline proc LAPACKE_ctptri_work(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] complex(64)) : c_int{
  return LAPACKE_ctptri_work(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztptri_work
 */
extern proc LAPACKE_ztptri_work(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztptri_work
 */
inline proc LAPACKE_ztptri_work(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] complex(128)) : c_int{
  return LAPACKE_ztptri_work(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stptrs_work
 */
extern proc LAPACKE_stptrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stptrs_work
 */
inline proc LAPACKE_stptrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] c_float, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_stptrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtptrs_work
 */
extern proc LAPACKE_dtptrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtptrs_work
 */
inline proc LAPACKE_dtptrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] c_double, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtptrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctptrs_work
 */
extern proc LAPACKE_ctptrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctptrs_work
 */
inline proc LAPACKE_ctptrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] complex(64), b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctptrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztptrs_work
 */
extern proc LAPACKE_ztptrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztptrs_work
 */
inline proc LAPACKE_ztptrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, ap : [] complex(128), b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztptrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, ap, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stpttf_work
 */
extern proc LAPACKE_stpttf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, ap : [] c_float, arf : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stpttf_work
 */
inline proc LAPACKE_stpttf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] c_float, arf : [] c_float) : c_int{
  return LAPACKE_stpttf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpttf_work
 */
extern proc LAPACKE_dtpttf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, ap : [] c_double, arf : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtpttf_work
 */
inline proc LAPACKE_dtpttf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] c_double, arf : [] c_double) : c_int{
  return LAPACKE_dtpttf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpttf_work
 */
extern proc LAPACKE_ctpttf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, ap : [] complex(64), arf : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctpttf_work
 */
inline proc LAPACKE_ctpttf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] complex(64), arf : [] complex(64)) : c_int{
  return LAPACKE_ctpttf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpttf_work
 */
extern proc LAPACKE_ztpttf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, ap : [] complex(128), arf : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztpttf_work
 */
inline proc LAPACKE_ztpttf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] complex(128), arf : [] complex(128)) : c_int{
  return LAPACKE_ztpttf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stpttr_work
 */
extern proc LAPACKE_stpttr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_float, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stpttr_work
 */
inline proc LAPACKE_stpttr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_stpttr_work(matrix_order, ascii(uplo) : c_char, n, ap, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpttr_work
 */
extern proc LAPACKE_dtpttr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] c_double, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtpttr_work
 */
inline proc LAPACKE_dtpttr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dtpttr_work(matrix_order, ascii(uplo) : c_char, n, ap, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpttr_work
 */
extern proc LAPACKE_ctpttr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctpttr_work
 */
inline proc LAPACKE_ctpttr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_ctpttr_work(matrix_order, ascii(uplo) : c_char, n, ap, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpttr_work
 */
extern proc LAPACKE_ztpttr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztpttr_work
 */
inline proc LAPACKE_ztpttr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_ztpttr_work(matrix_order, ascii(uplo) : c_char, n, ap, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strcon_work
 */
extern proc LAPACKE_strcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] c_float, lda : c_int, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strcon_work
 */
inline proc LAPACKE_strcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, a : [] c_float, lda : c_int, ref rcond : c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_strcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrcon_work
 */
extern proc LAPACKE_dtrcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] c_double, lda : c_int, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrcon_work
 */
inline proc LAPACKE_dtrcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, a : [] c_double, lda : c_int, ref rcond : c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dtrcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda, rcond, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrcon_work
 */
extern proc LAPACKE_ctrcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] complex(64), lda : c_int, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrcon_work
 */
inline proc LAPACKE_ctrcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, a : [] complex(64), lda : c_int, ref rcond : c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_ctrcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrcon_work
 */
extern proc LAPACKE_ztrcon_work(matrix_order : lapack_memory_order, norm : c_char, uplo : c_char, diag : c_char, n : c_int, a : [] complex(128), lda : c_int, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrcon_work
 */
inline proc LAPACKE_ztrcon_work(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, a : [] complex(128), lda : c_int, ref rcond : c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_ztrcon_work(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda, rcond, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strevc_work
 */
extern proc LAPACKE_strevc_work(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strevc_work
 */
inline proc LAPACKE_strevc_work(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_float) : c_int{
  return LAPACKE_strevc_work(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrevc_work
 */
extern proc LAPACKE_dtrevc_work(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrevc_work
 */
inline proc LAPACKE_dtrevc_work(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, mm : c_int, ref m : c_int, work : [] c_double) : c_int{
  return LAPACKE_dtrevc_work(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrevc_work
 */
extern proc LAPACKE_ctrevc_work(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrevc_work
 */
inline proc LAPACKE_ctrevc_work(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_ctrevc_work(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrevc_work
 */
extern proc LAPACKE_ztrevc_work(matrix_order : lapack_memory_order, side : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrevc_work
 */
inline proc LAPACKE_ztrevc_work(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, mm : c_int, ref m : c_int, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_ztrevc_work(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strexc_work
 */
extern proc LAPACKE_strexc_work(matrix_order : lapack_memory_order, compq : c_char, n : c_int, t : [] c_float, ldt : c_int, q : [] c_float, ldq : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strexc_work
 */
inline proc LAPACKE_strexc_work(matrix_order : lapack_memory_order, compq : string, n : c_int, t : [] c_float, ldt : c_int, q : [] c_float, ldq : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_float) : c_int{
  return LAPACKE_strexc_work(matrix_order, ascii(compq) : c_char, n, t, ldt, q, ldq, ifst, ilst, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrexc_work
 */
extern proc LAPACKE_dtrexc_work(matrix_order : lapack_memory_order, compq : c_char, n : c_int, t : [] c_double, ldt : c_int, q : [] c_double, ldq : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrexc_work
 */
inline proc LAPACKE_dtrexc_work(matrix_order : lapack_memory_order, compq : string, n : c_int, t : [] c_double, ldt : c_int, q : [] c_double, ldq : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_double) : c_int{
  return LAPACKE_dtrexc_work(matrix_order, ascii(compq) : c_char, n, t, ldt, q, ldq, ifst, ilst, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrexc_work
 */
extern proc LAPACKE_ctrexc_work(matrix_order : lapack_memory_order, compq : c_char, n : c_int, t : [] complex(64), ldt : c_int, q : [] complex(64), ldq : c_int, ifst : c_int, ilst : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrexc_work
 */
inline proc LAPACKE_ctrexc_work(matrix_order : lapack_memory_order, compq : string, n : c_int, t : [] complex(64), ldt : c_int, q : [] complex(64), ldq : c_int, ifst : c_int, ilst : c_int) : c_int{
  return LAPACKE_ctrexc_work(matrix_order, ascii(compq) : c_char, n, t, ldt, q, ldq, ifst, ilst);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrexc_work
 */
extern proc LAPACKE_ztrexc_work(matrix_order : lapack_memory_order, compq : c_char, n : c_int, t : [] complex(128), ldt : c_int, q : [] complex(128), ldq : c_int, ifst : c_int, ilst : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrexc_work
 */
inline proc LAPACKE_ztrexc_work(matrix_order : lapack_memory_order, compq : string, n : c_int, t : [] complex(128), ldt : c_int, q : [] complex(128), ldq : c_int, ifst : c_int, ilst : c_int) : c_int{
  return LAPACKE_ztrexc_work(matrix_order, ascii(compq) : c_char, n, t, ldt, q, ldq, ifst, ilst);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strrfs_work
 */
extern proc LAPACKE_strrfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strrfs_work
 */
inline proc LAPACKE_strrfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, x : [] c_float, ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int) : c_int{
  return LAPACKE_strrfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrrfs_work
 */
extern proc LAPACKE_dtrrfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrrfs_work
 */
inline proc LAPACKE_dtrrfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, x : [] c_double, ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int) : c_int{
  return LAPACKE_dtrrfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrrfs_work
 */
extern proc LAPACKE_ctrrfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrrfs_work
 */
inline proc LAPACKE_ctrrfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, x : [] complex(64), ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float) : c_int{
  return LAPACKE_ctrrfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrrfs_work
 */
extern proc LAPACKE_ztrrfs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrrfs_work
 */
inline proc LAPACKE_ztrrfs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, x : [] complex(128), ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double) : c_int{
  return LAPACKE_ztrrfs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strsen_work
 */
extern proc LAPACKE_strsen_work(matrix_order : lapack_memory_order, job : c_char, compq : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, q : [] c_float, ldq : c_int, wr : [] c_float, wi : [] c_float, ref m : c_int, ref s : c_float, ref sep : c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strsen_work
 */
inline proc LAPACKE_strsen_work(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, q : [] c_float, ldq : c_int, wr : [] c_float, wi : [] c_float, ref m : c_int, ref s : c_float, ref sep : c_float, work : [] c_float, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_strsen_work(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrsen_work
 */
extern proc LAPACKE_dtrsen_work(matrix_order : lapack_memory_order, job : c_char, compq : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, q : [] c_double, ldq : c_int, wr : [] c_double, wi : [] c_double, ref m : c_int, ref s : c_double, ref sep : c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrsen_work
 */
inline proc LAPACKE_dtrsen_work(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, q : [] c_double, ldq : c_int, wr : [] c_double, wi : [] c_double, ref m : c_int, ref s : c_double, ref sep : c_double, work : [] c_double, lwork : c_int, iwork : [] c_int, liwork : c_int) : c_int{
  return LAPACKE_dtrsen_work(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrsen_work
 */
extern proc LAPACKE_ctrsen_work(matrix_order : lapack_memory_order, job : c_char, compq : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, q : [] complex(64), ldq : c_int, w : [] complex(64), ref m : c_int, ref s : c_float, ref sep : c_float, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrsen_work
 */
inline proc LAPACKE_ctrsen_work(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, q : [] complex(64), ldq : c_int, w : [] complex(64), ref m : c_int, ref s : c_float, ref sep : c_float, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_ctrsen_work(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrsen_work
 */
extern proc LAPACKE_ztrsen_work(matrix_order : lapack_memory_order, job : c_char, compq : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, q : [] complex(128), ldq : c_int, w : [] complex(128), ref m : c_int, ref s : c_double, ref sep : c_double, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrsen_work
 */
inline proc LAPACKE_ztrsen_work(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, q : [] complex(128), ldq : c_int, w : [] complex(128), ref m : c_int, ref s : c_double, ref sep : c_double, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_ztrsen_work(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strsna_work
 */
extern proc LAPACKE_strsna_work(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int, work : [] c_float, ldwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strsna_work
 */
inline proc LAPACKE_strsna_work(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] c_float, ldt : c_int, vl : [] c_float, ldvl : c_int, vr : [] c_float, ldvr : c_int, s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int, work : [] c_float, ldwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_strsna_work(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrsna_work
 */
extern proc LAPACKE_dtrsna_work(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int, work : [] c_double, ldwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrsna_work
 */
inline proc LAPACKE_dtrsna_work(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] c_double, ldt : c_int, vl : [] c_double, ldvl : c_int, vr : [] c_double, ldvr : c_int, s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int, work : [] c_double, ldwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_dtrsna_work(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrsna_work
 */
extern proc LAPACKE_ctrsna_work(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int, work : [] complex(64), ldwork : c_int, rwork : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrsna_work
 */
inline proc LAPACKE_ctrsna_work(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] complex(64), ldt : c_int, vl : [] complex(64), ldvl : c_int, vr : [] complex(64), ldvr : c_int, s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int, work : [] complex(64), ldwork : c_int, rwork : [] c_float) : c_int{
  return LAPACKE_ctrsna_work(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrsna_work
 */
extern proc LAPACKE_ztrsna_work(matrix_order : lapack_memory_order, job : c_char, howmny : c_char, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int, work : [] complex(128), ldwork : c_int, rwork : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrsna_work
 */
inline proc LAPACKE_ztrsna_work(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, t : [] complex(128), ldt : c_int, vl : [] complex(128), ldvl : c_int, vr : [] complex(128), ldvr : c_int, s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int, work : [] complex(128), ldwork : c_int, rwork : [] c_double) : c_int{
  return LAPACKE_ztrsna_work(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strsyl_work
 */
extern proc LAPACKE_strsyl_work(matrix_order : lapack_memory_order, trana : c_char, tranb : c_char, isgn : c_int, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, ldc : c_int, ref scale : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strsyl_work
 */
inline proc LAPACKE_strsyl_work(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, m : c_int, n : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, c : [] c_float, ldc : c_int, ref scale : c_float) : c_int{
  return LAPACKE_strsyl_work(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrsyl_work
 */
extern proc LAPACKE_dtrsyl_work(matrix_order : lapack_memory_order, trana : c_char, tranb : c_char, isgn : c_int, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, ldc : c_int, ref scale : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrsyl_work
 */
inline proc LAPACKE_dtrsyl_work(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, m : c_int, n : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, c : [] c_double, ldc : c_int, ref scale : c_double) : c_int{
  return LAPACKE_dtrsyl_work(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrsyl_work
 */
extern proc LAPACKE_ctrsyl_work(matrix_order : lapack_memory_order, trana : c_char, tranb : c_char, isgn : c_int, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), ldc : c_int, ref scale : c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrsyl_work
 */
inline proc LAPACKE_ctrsyl_work(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, m : c_int, n : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, c : [] complex(64), ldc : c_int, ref scale : c_float) : c_int{
  return LAPACKE_ctrsyl_work(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrsyl_work
 */
extern proc LAPACKE_ztrsyl_work(matrix_order : lapack_memory_order, trana : c_char, tranb : c_char, isgn : c_int, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), ldc : c_int, ref scale : c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrsyl_work
 */
inline proc LAPACKE_ztrsyl_work(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, m : c_int, n : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, c : [] complex(128), ldc : c_int, ref scale : c_double) : c_int{
  return LAPACKE_ztrsyl_work(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strtri_work
 */
extern proc LAPACKE_strtri_work(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, a : [] c_float, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strtri_work
 */
inline proc LAPACKE_strtri_work(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, a : [] c_float, lda : c_int) : c_int{
  return LAPACKE_strtri_work(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrtri_work
 */
extern proc LAPACKE_dtrtri_work(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, a : [] c_double, lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrtri_work
 */
inline proc LAPACKE_dtrtri_work(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, a : [] c_double, lda : c_int) : c_int{
  return LAPACKE_dtrtri_work(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrtri_work
 */
extern proc LAPACKE_ctrtri_work(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrtri_work
 */
inline proc LAPACKE_ctrtri_work(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_ctrtri_work(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrtri_work
 */
extern proc LAPACKE_ztrtri_work(matrix_order : lapack_memory_order, uplo : c_char, diag : c_char, n : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrtri_work
 */
inline proc LAPACKE_ztrtri_work(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_ztrtri_work(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strtrs_work
 */
extern proc LAPACKE_strtrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strtrs_work
 */
inline proc LAPACKE_strtrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_strtrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrtrs_work
 */
extern proc LAPACKE_dtrtrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrtrs_work
 */
inline proc LAPACKE_dtrtrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtrtrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrtrs_work
 */
extern proc LAPACKE_ctrtrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrtrs_work
 */
inline proc LAPACKE_ctrtrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctrtrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrtrs_work
 */
extern proc LAPACKE_ztrtrs_work(matrix_order : lapack_memory_order, uplo : c_char, trans : c_char, diag : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrtrs_work
 */
inline proc LAPACKE_ztrtrs_work(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztrtrs_work(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, nrhs, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strttf_work
 */
extern proc LAPACKE_strttf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, arf : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strttf_work
 */
inline proc LAPACKE_strttf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_float, lda : c_int, arf : [] c_float) : c_int{
  return LAPACKE_strttf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a, lda, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrttf_work
 */
extern proc LAPACKE_dtrttf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, arf : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrttf_work
 */
inline proc LAPACKE_dtrttf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] c_double, lda : c_int, arf : [] c_double) : c_int{
  return LAPACKE_dtrttf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a, lda, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrttf_work
 */
extern proc LAPACKE_ctrttf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, arf : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrttf_work
 */
inline proc LAPACKE_ctrttf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(64), lda : c_int, arf : [] complex(64)) : c_int{
  return LAPACKE_ctrttf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a, lda, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrttf_work
 */
extern proc LAPACKE_ztrttf_work(matrix_order : lapack_memory_order, transr : c_char, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, arf : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrttf_work
 */
inline proc LAPACKE_ztrttf_work(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, a : [] complex(128), lda : c_int, arf : [] complex(128)) : c_int{
  return LAPACKE_ztrttf_work(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, a, lda, arf);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_strttp_work
 */
extern proc LAPACKE_strttp_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ap : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_strttp_work
 */
inline proc LAPACKE_strttp_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ap : [] c_float) : c_int{
  return LAPACKE_strttp_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtrttp_work
 */
extern proc LAPACKE_dtrttp_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ap : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtrttp_work
 */
inline proc LAPACKE_dtrttp_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ap : [] c_double) : c_int{
  return LAPACKE_dtrttp_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctrttp_work
 */
extern proc LAPACKE_ctrttp_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ap : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctrttp_work
 */
inline proc LAPACKE_ctrttp_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ap : [] complex(64)) : c_int{
  return LAPACKE_ctrttp_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztrttp_work
 */
extern proc LAPACKE_ztrttp_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ap : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztrttp_work
 */
inline proc LAPACKE_ztrttp_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ap : [] complex(128)) : c_int{
  return LAPACKE_ztrttp_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ap);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_stzrzf_work
 */
extern proc LAPACKE_stzrzf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, tau : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dtzrzf_work
 */
extern proc LAPACKE_dtzrzf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, tau : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctzrzf_work
 */
extern proc LAPACKE_ctzrzf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztzrzf_work
 */
extern proc LAPACKE_ztzrzf_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungbr_work
 */
extern proc LAPACKE_cungbr_work(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cungbr_work
 */
inline proc LAPACKE_cungbr_work(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cungbr_work(matrix_order, ascii(vect) : c_char, m, n, k, a, lda, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zungbr_work
 */
extern proc LAPACKE_zungbr_work(matrix_order : lapack_memory_order, vect : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zungbr_work
 */
inline proc LAPACKE_zungbr_work(matrix_order : lapack_memory_order, vect : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zungbr_work(matrix_order, ascii(vect) : c_char, m, n, k, a, lda, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunghr_work
 */
extern proc LAPACKE_cunghr_work(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zunghr_work
 */
extern proc LAPACKE_zunghr_work(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cunglq_work
 */
extern proc LAPACKE_cunglq_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zunglq_work
 */
extern proc LAPACKE_zunglq_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungql_work
 */
extern proc LAPACKE_cungql_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zungql_work
 */
extern proc LAPACKE_zungql_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungqr_work
 */
extern proc LAPACKE_cungqr_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zungqr_work
 */
extern proc LAPACKE_zungqr_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungrq_work
 */
extern proc LAPACKE_cungrq_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zungrq_work
 */
extern proc LAPACKE_zungrq_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cungtr_work
 */
extern proc LAPACKE_cungtr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cungtr_work
 */
inline proc LAPACKE_cungtr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cungtr_work(matrix_order, ascii(uplo) : c_char, n, a, lda, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zungtr_work
 */
extern proc LAPACKE_zungtr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zungtr_work
 */
inline proc LAPACKE_zungtr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zungtr_work(matrix_order, ascii(uplo) : c_char, n, a, lda, tau, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmbr_work
 */
extern proc LAPACKE_cunmbr_work(matrix_order : lapack_memory_order, vect : c_char, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmbr_work
 */
inline proc LAPACKE_cunmbr_work(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cunmbr_work(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmbr_work
 */
extern proc LAPACKE_zunmbr_work(matrix_order : lapack_memory_order, vect : c_char, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmbr_work
 */
inline proc LAPACKE_zunmbr_work(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zunmbr_work(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmhr_work
 */
extern proc LAPACKE_cunmhr_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmhr_work
 */
inline proc LAPACKE_cunmhr_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cunmhr_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmhr_work
 */
extern proc LAPACKE_zunmhr_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmhr_work
 */
inline proc LAPACKE_zunmhr_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zunmhr_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmlq_work
 */
extern proc LAPACKE_cunmlq_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmlq_work
 */
inline proc LAPACKE_cunmlq_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cunmlq_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmlq_work
 */
extern proc LAPACKE_zunmlq_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmlq_work
 */
inline proc LAPACKE_zunmlq_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zunmlq_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmql_work
 */
extern proc LAPACKE_cunmql_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmql_work
 */
inline proc LAPACKE_cunmql_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cunmql_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmql_work
 */
extern proc LAPACKE_zunmql_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmql_work
 */
inline proc LAPACKE_zunmql_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zunmql_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmqr_work
 */
extern proc LAPACKE_cunmqr_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmqr_work
 */
inline proc LAPACKE_cunmqr_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cunmqr_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmqr_work
 */
extern proc LAPACKE_zunmqr_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmqr_work
 */
inline proc LAPACKE_zunmqr_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zunmqr_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmrq_work
 */
extern proc LAPACKE_cunmrq_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmrq_work
 */
inline proc LAPACKE_cunmrq_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cunmrq_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmrq_work
 */
extern proc LAPACKE_zunmrq_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmrq_work
 */
inline proc LAPACKE_zunmrq_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zunmrq_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmrz_work
 */
extern proc LAPACKE_cunmrz_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmrz_work
 */
inline proc LAPACKE_cunmrz_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cunmrz_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmrz_work
 */
extern proc LAPACKE_zunmrz_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmrz_work
 */
inline proc LAPACKE_zunmrz_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zunmrz_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunmtr_work
 */
extern proc LAPACKE_cunmtr_work(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunmtr_work
 */
inline proc LAPACKE_cunmtr_work(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, a : [] complex(64), lda : c_int, tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cunmtr_work(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunmtr_work
 */
extern proc LAPACKE_zunmtr_work(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunmtr_work
 */
inline proc LAPACKE_zunmtr_work(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, a : [] complex(128), lda : c_int, tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zunmtr_work(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, a, lda, tau, c, ldc, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cupgtr_work
 */
extern proc LAPACKE_cupgtr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(64), tau : [] complex(64), q : [] complex(64), ldq : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cupgtr_work
 */
inline proc LAPACKE_cupgtr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), tau : [] complex(64), q : [] complex(64), ldq : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_cupgtr_work(matrix_order, ascii(uplo) : c_char, n, ap, tau, q, ldq, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zupgtr_work
 */
extern proc LAPACKE_zupgtr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, ap : [] complex(128), tau : [] complex(128), q : [] complex(128), ldq : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zupgtr_work
 */
inline proc LAPACKE_zupgtr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), tau : [] complex(128), q : [] complex(128), ldq : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zupgtr_work(matrix_order, ascii(uplo) : c_char, n, ap, tau, q, ldq, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cupmtr_work
 */
extern proc LAPACKE_cupmtr_work(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, ap : [] complex(64), tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cupmtr_work
 */
inline proc LAPACKE_cupmtr_work(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, ap : [] complex(64), tau : [] complex(64), c : [] complex(64), ldc : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_cupmtr_work(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, ap, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zupmtr_work
 */
extern proc LAPACKE_zupmtr_work(matrix_order : lapack_memory_order, side : c_char, uplo : c_char, trans : c_char, m : c_int, n : c_int, ap : [] complex(128), tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zupmtr_work
 */
inline proc LAPACKE_zupmtr_work(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, m : c_int, n : c_int, ap : [] complex(128), tau : [] complex(128), c : [] complex(128), ldc : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zupmtr_work(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, m, n, ap, tau, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_claghe

Original Fortran LAPACK documentation for CLAGHE::

 CLAGHE generates a complex hermitian matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 unitary transformations.

 */
extern proc LAPACKE_claghe(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_float, a : [] complex(64), lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlaghe

Original Fortran LAPACK documentation for ZLAGHE::

 ZLAGHE generates a complex hermitian matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 unitary transformations.

 */
extern proc LAPACKE_zlaghe(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_double, a : [] complex(128), lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slagsy

Original Fortran LAPACK documentation for SLAGSY::

 SLAGSY generates a real symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random orthogonal matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 orthogonal transformations.

 */
extern proc LAPACKE_slagsy(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_float, a : [] c_float, lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlagsy

Original Fortran LAPACK documentation for DLAGSY::

 DLAGSY generates a real symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random orthogonal matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 orthogonal transformations.

 */
extern proc LAPACKE_dlagsy(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_double, a : [] c_double, lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clagsy

Original Fortran LAPACK documentation for CLAGSY::

 CLAGSY generates a complex symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U**T. The semi-bandwidth may then be reduced to k by
 additional unitary transformations.

 */
extern proc LAPACKE_clagsy(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_float, a : [] complex(64), lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlagsy

Original Fortran LAPACK documentation for ZLAGSY::

 ZLAGSY generates a complex symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U**T. The semi-bandwidth may then be reduced to k by
 additional unitary transformations.

 */
extern proc LAPACKE_zlagsy(matrix_order : lapack_memory_order, n : c_int, k : c_int, d : [] c_double, a : [] complex(128), lda : c_int, iseed : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slapmr

Original Fortran LAPACK documentation for SLAPMR::

 SLAPMR rearranges the rows of the M by N matrix X as specified
 by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
 If FORWRD = .TRUE., forward permutation:

 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

 If FORWRD = .FALSE., backward permutation:

 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

 */
extern proc LAPACKE_slapmr(matrix_order : lapack_memory_order, forwrd : c_int, m : c_int, n : c_int, x : [] c_float, ldx : c_int, k : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlapmr

Original Fortran LAPACK documentation for DLAPMR::

 DLAPMR rearranges the rows of the M by N matrix X as specified
 by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
 If FORWRD = .TRUE., forward permutation:

 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

 If FORWRD = .FALSE., backward permutation:

 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

 */
extern proc LAPACKE_dlapmr(matrix_order : lapack_memory_order, forwrd : c_int, m : c_int, n : c_int, x : [] c_double, ldx : c_int, k : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_clapmr

Original Fortran LAPACK documentation for CLAPMR::

 CLAPMR rearranges the rows of the M by N matrix X as specified
 by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
 If FORWRD = .TRUE., forward permutation:

 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

 If FORWRD = .FALSE., backward permutation:

 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

 */
extern proc LAPACKE_clapmr(matrix_order : lapack_memory_order, forwrd : c_int, m : c_int, n : c_int, x : [] complex(64), ldx : c_int, k : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zlapmr

Original Fortran LAPACK documentation for ZLAPMR::

 ZLAPMR rearranges the rows of the M by N matrix X as specified
 by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
 If FORWRD = .TRUE., forward permutation:

 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

 If FORWRD = .FALSE., backward permutation:

 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

 */
extern proc LAPACKE_zlapmr(matrix_order : lapack_memory_order, forwrd : c_int, m : c_int, n : c_int, x : [] complex(128), ldx : c_int, k : [] c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slapy2

Original Fortran LAPACK documentation for SLAPY2::

 SLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
 overflow.

 */
extern proc LAPACKE_slapy2(x : c_float, y : c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlapy2

Original Fortran LAPACK documentation for DLAPY2::

 DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
 overflow.

 */
extern proc LAPACKE_dlapy2(x : c_double, y : c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACKE_slapy3

Original Fortran LAPACK documentation for SLAPY3::

 SLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
 unnecessary overflow.

 */
extern proc LAPACKE_slapy3(x : c_float, y : c_float, z : c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlapy3

Original Fortran LAPACK documentation for DLAPY3::

 DLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
 unnecessary overflow.

 */
extern proc LAPACKE_dlapy3(x : c_double, y : c_double, z : c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACKE_slartgp

Original Fortran LAPACK documentation for SLARTGP::

 SLARTGP generates a plane rotation so that

 [ CS SN ] . [ F ] = [ R ] where CS**2 + SN**2 = 1.
 [ -SN CS ] [ G ] [ 0 ]

 This is a slower, more accurate version of the Level 1 BLAS routine SROTG,
 with the following other differences:
 F and G are unchanged on return.
 If G=0, then CS=(+/-)1 and SN=0.
 If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.

 The sign is chosen so that R >= 0.

 */
extern proc LAPACKE_slartgp(f : c_float, g : c_float, ref cs : c_float, ref sn : c_float, ref r : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlartgp

Original Fortran LAPACK documentation for DLARTGP::

 DLARTGP generates a plane rotation so that

 [ CS SN ] . [ F ] = [ R ] where CS**2 + SN**2 = 1.
 [ -SN CS ] [ G ] [ 0 ]

 This is a slower, more accurate version of the Level 1 BLAS routine DROTG,
 with the following other differences:
 F and G are unchanged on return.
 If G=0, then CS=(+/-)1 and SN=0.
 If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.

 The sign is chosen so that R >= 0.

 */
extern proc LAPACKE_dlartgp(f : c_double, g : c_double, ref cs : c_double, ref sn : c_double, ref r : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_slartgs

Original Fortran LAPACK documentation for SLARTGS::

 SLARTGS generates a plane rotation designed to introduce a bulge in
 Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
 problem. X and Y are the top-row entries, and SIGMA is the shift.
 The computed CS and SN define a plane rotation satisfying

 [ CS SN ] . [ X^2 - SIGMA ] = [ R ],
 [ -SN CS ] [ X * Y ] [ 0 ]

 with R nonnegative. If X^2 - SIGMA and X * Y are 0, then the
 rotation is by PI/2.

 */
extern proc LAPACKE_slartgs(x : c_float, y : c_float, sigma : c_float, ref cs : c_float, ref sn : c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dlartgs

Original Fortran LAPACK documentation for DLARTGS::

 DLARTGS generates a plane rotation designed to introduce a bulge in
 Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
 problem. X and Y are the top-row entries, and SIGMA is the shift.
 The computed CS and SN define a plane rotation satisfying

 [ CS SN ] . [ X^2 - SIGMA ] = [ R ],
 [ -SN CS ] [ X * Y ] [ 0 ]

 with R nonnegative. If X^2 - SIGMA and X * Y are 0, then the
 rotation is by PI/2.

 */
extern proc LAPACKE_dlartgs(x : c_double, y : c_double, sigma : c_double, ref cs : c_double, ref sn : c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cbbcsd

Original Fortran LAPACK documentation for CBBCSD::

 CBBCSD computes the CS decomposition of a unitary matrix in
 bidiagonal-block form,


 [ B11 | B12 0 0 ]
 [ 0 | 0 -I 0 ]
 X = [----------------]
 [ B21 | B22 0 0 ]
 [ 0 | 0 0 I ]

 [ C | -S 0 0 ]
 [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**H
 = [---------] [---------------] [---------] .
 [ | U2 ] [ S | C 0 0 ] [ | V2 ]
 [ 0 | 0 0 I ]

 X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
 than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
 transposed and/or permuted. This can be done in constant time using
 the TRANS and SIGNS options. See CUNCSD for details.)

 The bidiagonal matrices B11, B12, B21, and B22 are represented
 implicitly by angles THETA(1:Q) and PHI(1:Q-1).

 The unitary matrices U1, U2, V1T, and V2T are input/output.
 The input matrices are pre- or post-multiplied by the appropriate
 singular vector matrices.

 */
extern proc LAPACKE_cbbcsd(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, m : c_int, p : c_int, q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] complex(64), ldu1 : c_int, u2 : [] complex(64), ldu2 : c_int, v1t : [] complex(64), ldv1t : c_int, v2t : [] complex(64), ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cbbcsd
 */
inline proc LAPACKE_cbbcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, p : c_int, q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] complex(64), ldu1 : c_int, u2 : [] complex(64), ldu2 : c_int, v1t : [] complex(64), ldv1t : c_int, v2t : [] complex(64), ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float) : c_int{
  return LAPACKE_cbbcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cbbcsd_work
 */
extern proc LAPACKE_cbbcsd_work(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, m : c_int, p : c_int, q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] complex(64), ldu1 : c_int, u2 : [] complex(64), ldu2 : c_int, v1t : [] complex(64), ldv1t : c_int, v2t : [] complex(64), ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float, rwork : [] c_float, lrwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cbbcsd_work
 */
inline proc LAPACKE_cbbcsd_work(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, p : c_int, q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] complex(64), ldu1 : c_int, u2 : [] complex(64), ldu2 : c_int, v1t : [] complex(64), ldv1t : c_int, v2t : [] complex(64), ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float, rwork : [] c_float, lrwork : c_int) : c_int{
  return LAPACKE_cbbcsd_work(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheswapr

Original Fortran LAPACK documentation for CHESWAPR::

 CHESWAPR applies an elementary permutation on the rows and the columns of
 a hermitian matrix.

 */
extern proc LAPACKE_cheswapr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheswapr
 */
inline proc LAPACKE_cheswapr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_cheswapr(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cheswapr_work
 */
extern proc LAPACKE_cheswapr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cheswapr_work
 */
inline proc LAPACKE_cheswapr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_cheswapr_work(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetri2

Original Fortran LAPACK documentation for CHETRI2::

 CHETRI2 computes the inverse of a COMPLEX hermitian indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CHETRF. CHETRI2 set the LEADING DIMENSION of the workspace
 before calling CHETRI2X that actually computes the inverse.

 */
extern proc LAPACKE_chetri2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetri2
 */
inline proc LAPACKE_chetri2(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_chetri2(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetri2_work
 */
extern proc LAPACKE_chetri2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetri2_work
 */
inline proc LAPACKE_chetri2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_chetri2_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetri2x

Original Fortran LAPACK documentation for CHETRI2X::

 CHETRI2X computes the inverse of a complex Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 CHETRF.

 */
extern proc LAPACKE_chetri2x(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetri2x
 */
inline proc LAPACKE_chetri2x(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, nb : c_int) : c_int{
  return LAPACKE_chetri2x(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetri2x_work
 */
extern proc LAPACKE_chetri2x_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetri2x_work
 */
inline proc LAPACKE_chetri2x_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), nb : c_int) : c_int{
  return LAPACKE_chetri2x_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetrs2

Original Fortran LAPACK documentation for CHETRS2::

 CHETRS2 solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHETRF and converted by CSYCONV.

 */
extern proc LAPACKE_chetrs2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetrs2
 */
inline proc LAPACKE_chetrs2(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_chetrs2(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_chetrs2_work
 */
extern proc LAPACKE_chetrs2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_chetrs2_work
 */
inline proc LAPACKE_chetrs2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_chetrs2_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyconv

Original Fortran LAPACK documentation for CSYCONV::

 CSYCONV convert A given by TRF into L and D and vice-versa.
 Get Non-diag elements of D (returned in workspace) and 
 apply or reverse permutation done in TRF.

 */
extern proc LAPACKE_csyconv(matrix_order : lapack_memory_order, uplo : c_char, way : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyconv
 */
inline proc LAPACKE_csyconv(matrix_order : lapack_memory_order, uplo : string, way : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_csyconv(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyconv_work
 */
extern proc LAPACKE_csyconv_work(matrix_order : lapack_memory_order, uplo : c_char, way : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyconv_work
 */
inline proc LAPACKE_csyconv_work(matrix_order : lapack_memory_order, uplo : string, way : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64)) : c_int{
  return LAPACKE_csyconv_work(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyswapr

Original Fortran LAPACK documentation for CSYSWAPR::

 CSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.

 */
extern proc LAPACKE_csyswapr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyswapr
 */
inline proc LAPACKE_csyswapr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_csyswapr(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyswapr_work
 */
extern proc LAPACKE_csyswapr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyswapr_work
 */
inline proc LAPACKE_csyswapr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_csyswapr_work(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytri2

Original Fortran LAPACK documentation for CSYTRI2::

 CSYTRI2 computes the inverse of a COMPLEX symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CSYTRF. CSYTRI2 sets the LEADING DIMENSION of the workspace
 before calling CSYTRI2X that actually computes the inverse.

 */
extern proc LAPACKE_csytri2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytri2
 */
inline proc LAPACKE_csytri2(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_csytri2(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytri2_work
 */
extern proc LAPACKE_csytri2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytri2_work
 */
inline proc LAPACKE_csytri2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_csytri2_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytri2x

Original Fortran LAPACK documentation for CSYTRI2X::

 CSYTRI2X computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CSYTRF.

 */
extern proc LAPACKE_csytri2x(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytri2x
 */
inline proc LAPACKE_csytri2x(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, nb : c_int) : c_int{
  return LAPACKE_csytri2x(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytri2x_work
 */
extern proc LAPACKE_csytri2x_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytri2x_work
 */
inline proc LAPACKE_csytri2x_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, work : [] complex(64), nb : c_int) : c_int{
  return LAPACKE_csytri2x_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytrs2

Original Fortran LAPACK documentation for CSYTRS2::

 CSYTRS2 solves a system of linear equations A*X = B with a COMPLEX
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by CSYTRF and converted by CSYCONV.

 */
extern proc LAPACKE_csytrs2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytrs2
 */
inline proc LAPACKE_csytrs2(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_csytrs2(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csytrs2_work
 */
extern proc LAPACKE_csytrs2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csytrs2_work
 */
inline proc LAPACKE_csytrs2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_csytrs2_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunbdb

Original Fortran LAPACK documentation for CUNBDB::

 CUNBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned unitary matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**H
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See CUNCSD
 for details.)

 The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

 */
extern proc LAPACKE_cunbdb(matrix_order : lapack_memory_order, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] complex(64), ldx11 : c_int, x12 : [] complex(64), ldx12 : c_int, x21 : [] complex(64), ldx21 : c_int, x22 : [] complex(64), ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] complex(64), taup2 : [] complex(64), tauq1 : [] complex(64), tauq2 : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunbdb
 */
inline proc LAPACKE_cunbdb(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] complex(64), ldx11 : c_int, x12 : [] complex(64), ldx12 : c_int, x21 : [] complex(64), ldx21 : c_int, x22 : [] complex(64), ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] complex(64), taup2 : [] complex(64), tauq1 : [] complex(64), tauq2 : [] complex(64)) : c_int{
  return LAPACKE_cunbdb(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cunbdb_work
 */
extern proc LAPACKE_cunbdb_work(matrix_order : lapack_memory_order, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] complex(64), ldx11 : c_int, x12 : [] complex(64), ldx12 : c_int, x21 : [] complex(64), ldx21 : c_int, x22 : [] complex(64), ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] complex(64), taup2 : [] complex(64), tauq1 : [] complex(64), tauq2 : [] complex(64), work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cunbdb_work
 */
inline proc LAPACKE_cunbdb_work(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] complex(64), ldx11 : c_int, x12 : [] complex(64), ldx12 : c_int, x21 : [] complex(64), ldx21 : c_int, x22 : [] complex(64), ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] complex(64), taup2 : [] complex(64), tauq1 : [] complex(64), tauq2 : [] complex(64), work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_cunbdb_work(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cuncsd

Original Fortran LAPACK documentation for CUNCSD::

 CUNCSD computes the CS decomposition of an M-by-M partitioned
 unitary matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**H
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

 */
extern proc LAPACKE_cuncsd(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] complex(64), ldx11 : c_int, x12 : [] complex(64), ldx12 : c_int, x21 : [] complex(64), ldx21 : c_int, x22 : [] complex(64), ldx22 : c_int, theta : [] c_float, u1 : [] complex(64), ldu1 : c_int, u2 : [] complex(64), ldu2 : c_int, v1t : [] complex(64), ldv1t : c_int, v2t : [] complex(64), ldv2t : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cuncsd
 */
inline proc LAPACKE_cuncsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] complex(64), ldx11 : c_int, x12 : [] complex(64), ldx12 : c_int, x21 : [] complex(64), ldx21 : c_int, x22 : [] complex(64), ldx22 : c_int, theta : [] c_float, u1 : [] complex(64), ldu1 : c_int, u2 : [] complex(64), ldu2 : c_int, v1t : [] complex(64), ldv1t : c_int, v2t : [] complex(64), ldv2t : c_int) : c_int{
  return LAPACKE_cuncsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cuncsd_work
 */
extern proc LAPACKE_cuncsd_work(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] complex(64), ldx11 : c_int, x12 : [] complex(64), ldx12 : c_int, x21 : [] complex(64), ldx21 : c_int, x22 : [] complex(64), ldx22 : c_int, theta : [] c_float, u1 : [] complex(64), ldu1 : c_int, u2 : [] complex(64), ldu2 : c_int, v1t : [] complex(64), ldv1t : c_int, v2t : [] complex(64), ldv2t : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cuncsd_work
 */
inline proc LAPACKE_cuncsd_work(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] complex(64), ldx11 : c_int, x12 : [] complex(64), ldx12 : c_int, x21 : [] complex(64), ldx21 : c_int, x22 : [] complex(64), ldx22 : c_int, theta : [] c_float, u1 : [] complex(64), ldu1 : c_int, u2 : [] complex(64), ldu2 : c_int, v1t : [] complex(64), ldv1t : c_int, v2t : [] complex(64), ldv2t : c_int, work : [] complex(64), lwork : c_int, rwork : [] c_float, lrwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_cuncsd_work(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dbbcsd

Original Fortran LAPACK documentation for DBBCSD::

 DBBCSD computes the CS decomposition of an orthogonal matrix in
 bidiagonal-block form,


 [ B11 | B12 0 0 ]
 [ 0 | 0 -I 0 ]
 X = [----------------]
 [ B21 | B22 0 0 ]
 [ 0 | 0 0 I ]

 [ C | -S 0 0 ]
 [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**T
 = [---------] [---------------] [---------] .
 [ | U2 ] [ S | C 0 0 ] [ | V2 ]
 [ 0 | 0 0 I ]

 X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
 than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
 transposed and/or permuted. This can be done in constant time using
 the TRANS and SIGNS options. See DORCSD for details.)

 The bidiagonal matrices B11, B12, B21, and B22 are represented
 implicitly by angles THETA(1:Q) and PHI(1:Q-1).

 The orthogonal matrices U1, U2, V1T, and V2T are input/output.
 The input matrices are pre- or post-multiplied by the appropriate
 singular vector matrices.

 */
extern proc LAPACKE_dbbcsd(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, m : c_int, p : c_int, q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] c_double, ldu1 : c_int, u2 : [] c_double, ldu2 : c_int, v1t : [] c_double, ldv1t : c_int, v2t : [] c_double, ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dbbcsd
 */
inline proc LAPACKE_dbbcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, p : c_int, q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] c_double, ldu1 : c_int, u2 : [] c_double, ldu2 : c_int, v1t : [] c_double, ldv1t : c_int, v2t : [] c_double, ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double) : c_int{
  return LAPACKE_dbbcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dbbcsd_work
 */
extern proc LAPACKE_dbbcsd_work(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, m : c_int, p : c_int, q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] c_double, ldu1 : c_int, u2 : [] c_double, ldu2 : c_int, v1t : [] c_double, ldv1t : c_int, v2t : [] c_double, ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dbbcsd_work
 */
inline proc LAPACKE_dbbcsd_work(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, p : c_int, q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] c_double, ldu1 : c_int, u2 : [] c_double, ldu2 : c_int, v1t : [] c_double, ldv1t : c_int, v2t : [] c_double, ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dbbcsd_work(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dorbdb

Original Fortran LAPACK documentation for DORBDB::

 DORBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned orthogonal matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**T
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See DORCSD
 for details.)

 The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

 */
extern proc LAPACKE_dorbdb(matrix_order : lapack_memory_order, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] c_double, ldx11 : c_int, x12 : [] c_double, ldx12 : c_int, x21 : [] c_double, ldx21 : c_int, x22 : [] c_double, ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] c_double, taup2 : [] c_double, tauq1 : [] c_double, tauq2 : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dorbdb
 */
inline proc LAPACKE_dorbdb(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] c_double, ldx11 : c_int, x12 : [] c_double, ldx12 : c_int, x21 : [] c_double, ldx21 : c_int, x22 : [] c_double, ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] c_double, taup2 : [] c_double, tauq1 : [] c_double, tauq2 : [] c_double) : c_int{
  return LAPACKE_dorbdb(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dorbdb_work
 */
extern proc LAPACKE_dorbdb_work(matrix_order : lapack_memory_order, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] c_double, ldx11 : c_int, x12 : [] c_double, ldx12 : c_int, x21 : [] c_double, ldx21 : c_int, x22 : [] c_double, ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] c_double, taup2 : [] c_double, tauq1 : [] c_double, tauq2 : [] c_double, work : [] c_double, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dorbdb_work
 */
inline proc LAPACKE_dorbdb_work(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] c_double, ldx11 : c_int, x12 : [] c_double, ldx12 : c_int, x21 : [] c_double, ldx21 : c_int, x22 : [] c_double, ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] c_double, taup2 : [] c_double, tauq1 : [] c_double, tauq2 : [] c_double, work : [] c_double, lwork : c_int) : c_int{
  return LAPACKE_dorbdb_work(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dorcsd

Original Fortran LAPACK documentation for DORCSD::

 DORCSD computes the CS decomposition of an M-by-M partitioned
 orthogonal matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**T
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

 */
extern proc LAPACKE_dorcsd(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] c_double, ldx11 : c_int, x12 : [] c_double, ldx12 : c_int, x21 : [] c_double, ldx21 : c_int, x22 : [] c_double, ldx22 : c_int, theta : [] c_double, u1 : [] c_double, ldu1 : c_int, u2 : [] c_double, ldu2 : c_int, v1t : [] c_double, ldv1t : c_int, v2t : [] c_double, ldv2t : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dorcsd
 */
inline proc LAPACKE_dorcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] c_double, ldx11 : c_int, x12 : [] c_double, ldx12 : c_int, x21 : [] c_double, ldx21 : c_int, x22 : [] c_double, ldx22 : c_int, theta : [] c_double, u1 : [] c_double, ldu1 : c_int, u2 : [] c_double, ldu2 : c_int, v1t : [] c_double, ldv1t : c_int, v2t : [] c_double, ldv2t : c_int) : c_int{
  return LAPACKE_dorcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dorcsd_work
 */
extern proc LAPACKE_dorcsd_work(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] c_double, ldx11 : c_int, x12 : [] c_double, ldx12 : c_int, x21 : [] c_double, ldx21 : c_int, x22 : [] c_double, ldx22 : c_int, theta : [] c_double, u1 : [] c_double, ldu1 : c_int, u2 : [] c_double, ldu2 : c_int, v1t : [] c_double, ldv1t : c_int, v2t : [] c_double, ldv2t : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dorcsd_work
 */
inline proc LAPACKE_dorcsd_work(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] c_double, ldx11 : c_int, x12 : [] c_double, ldx12 : c_int, x21 : [] c_double, ldx21 : c_int, x22 : [] c_double, ldx22 : c_int, theta : [] c_double, u1 : [] c_double, ldu1 : c_int, u2 : [] c_double, ldu2 : c_int, v1t : [] c_double, ldv1t : c_int, v2t : [] c_double, ldv2t : c_int, work : [] c_double, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_dorcsd_work(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyconv

Original Fortran LAPACK documentation for DSYCONV::

 DSYCONV convert A given by TRF into L and D and vice-versa.
 Get Non-diag elements of D (returned in workspace) and 
 apply or reverse permutation done in TRF.

 */
extern proc LAPACKE_dsyconv(matrix_order : lapack_memory_order, uplo : c_char, way : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyconv
 */
inline proc LAPACKE_dsyconv(matrix_order : lapack_memory_order, uplo : string, way : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_dsyconv(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyconv_work
 */
extern proc LAPACKE_dsyconv_work(matrix_order : lapack_memory_order, uplo : c_char, way : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyconv_work
 */
inline proc LAPACKE_dsyconv_work(matrix_order : lapack_memory_order, uplo : string, way : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] c_double) : c_int{
  return LAPACKE_dsyconv_work(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyswapr

Original Fortran LAPACK documentation for DSYSWAPR::

 DSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.

 */
extern proc LAPACKE_dsyswapr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyswapr
 */
inline proc LAPACKE_dsyswapr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_dsyswapr(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsyswapr_work
 */
extern proc LAPACKE_dsyswapr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsyswapr_work
 */
inline proc LAPACKE_dsyswapr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_dsyswapr_work(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytri2

Original Fortran LAPACK documentation for DSYTRI2::

 DSYTRI2 computes the inverse of a DOUBLE PRECISION symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 DSYTRF. DSYTRI2 sets the LEADING DIMENSION of the workspace
 before calling DSYTRI2X that actually computes the inverse.

 */
extern proc LAPACKE_dsytri2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytri2
 */
inline proc LAPACKE_dsytri2(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_dsytri2(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytri2_work
 */
extern proc LAPACKE_dsytri2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytri2_work
 */
inline proc LAPACKE_dsytri2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_dsytri2_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytri2x

Original Fortran LAPACK documentation for DSYTRI2X::

 DSYTRI2X computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 DSYTRF.

 */
extern proc LAPACKE_dsytri2x(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytri2x
 */
inline proc LAPACKE_dsytri2x(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, nb : c_int) : c_int{
  return LAPACKE_dsytri2x(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytri2x_work
 */
extern proc LAPACKE_dsytri2x_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] c_double, nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytri2x_work
 */
inline proc LAPACKE_dsytri2x_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, work : [] c_double, nb : c_int) : c_int{
  return LAPACKE_dsytri2x_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytrs2

Original Fortran LAPACK documentation for DSYTRS2::

 DSYTRS2 solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by DSYTRF and converted by DSYCONV.

 */
extern proc LAPACKE_dsytrs2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytrs2
 */
inline proc LAPACKE_dsytrs2(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dsytrs2(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsytrs2_work
 */
extern proc LAPACKE_dsytrs2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsytrs2_work
 */
inline proc LAPACKE_dsytrs2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int, work : [] c_double) : c_int{
  return LAPACKE_dsytrs2_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sbbcsd

Original Fortran LAPACK documentation for SBBCSD::

 SBBCSD computes the CS decomposition of an orthogonal matrix in
 bidiagonal-block form,


 [ B11 | B12 0 0 ]
 [ 0 | 0 -I 0 ]
 X = [----------------]
 [ B21 | B22 0 0 ]
 [ 0 | 0 0 I ]

 [ C | -S 0 0 ]
 [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**T
 = [---------] [---------------] [---------] .
 [ | U2 ] [ S | C 0 0 ] [ | V2 ]
 [ 0 | 0 0 I ]

 X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
 than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
 transposed and/or permuted. This can be done in constant time using
 the TRANS and SIGNS options. See SORCSD for details.)

 The bidiagonal matrices B11, B12, B21, and B22 are represented
 implicitly by angles THETA(1:Q) and PHI(1:Q-1).

 The orthogonal matrices U1, U2, V1T, and V2T are input/output.
 The input matrices are pre- or post-multiplied by the appropriate
 singular vector matrices.

 */
extern proc LAPACKE_sbbcsd(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, m : c_int, p : c_int, q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] c_float, ldu1 : c_int, u2 : [] c_float, ldu2 : c_int, v1t : [] c_float, ldv1t : c_int, v2t : [] c_float, ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sbbcsd
 */
inline proc LAPACKE_sbbcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, p : c_int, q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] c_float, ldu1 : c_int, u2 : [] c_float, ldu2 : c_int, v1t : [] c_float, ldv1t : c_int, v2t : [] c_float, ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float) : c_int{
  return LAPACKE_sbbcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sbbcsd_work
 */
extern proc LAPACKE_sbbcsd_work(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, m : c_int, p : c_int, q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] c_float, ldu1 : c_int, u2 : [] c_float, ldu2 : c_int, v1t : [] c_float, ldv1t : c_int, v2t : [] c_float, ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sbbcsd_work
 */
inline proc LAPACKE_sbbcsd_work(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, p : c_int, q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] c_float, ldu1 : c_int, u2 : [] c_float, ldu2 : c_int, v1t : [] c_float, ldv1t : c_int, v2t : [] c_float, ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sbbcsd_work(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sorbdb

Original Fortran LAPACK documentation for SORBDB::

 SORBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned orthogonal matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**T
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See SORCSD
 for details.)

 The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

 */
extern proc LAPACKE_sorbdb(matrix_order : lapack_memory_order, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] c_float, ldx11 : c_int, x12 : [] c_float, ldx12 : c_int, x21 : [] c_float, ldx21 : c_int, x22 : [] c_float, ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] c_float, taup2 : [] c_float, tauq1 : [] c_float, tauq2 : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sorbdb
 */
inline proc LAPACKE_sorbdb(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] c_float, ldx11 : c_int, x12 : [] c_float, ldx12 : c_int, x21 : [] c_float, ldx21 : c_int, x22 : [] c_float, ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] c_float, taup2 : [] c_float, tauq1 : [] c_float, tauq2 : [] c_float) : c_int{
  return LAPACKE_sorbdb(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sorbdb_work
 */
extern proc LAPACKE_sorbdb_work(matrix_order : lapack_memory_order, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] c_float, ldx11 : c_int, x12 : [] c_float, ldx12 : c_int, x21 : [] c_float, ldx21 : c_int, x22 : [] c_float, ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] c_float, taup2 : [] c_float, tauq1 : [] c_float, tauq2 : [] c_float, work : [] c_float, lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sorbdb_work
 */
inline proc LAPACKE_sorbdb_work(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] c_float, ldx11 : c_int, x12 : [] c_float, ldx12 : c_int, x21 : [] c_float, ldx21 : c_int, x22 : [] c_float, ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] c_float, taup2 : [] c_float, tauq1 : [] c_float, tauq2 : [] c_float, work : [] c_float, lwork : c_int) : c_int{
  return LAPACKE_sorbdb_work(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sorcsd

Original Fortran LAPACK documentation for SORCSD::

 SORCSD computes the CS decomposition of an M-by-M partitioned
 orthogonal matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**T
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

 */
extern proc LAPACKE_sorcsd(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] c_float, ldx11 : c_int, x12 : [] c_float, ldx12 : c_int, x21 : [] c_float, ldx21 : c_int, x22 : [] c_float, ldx22 : c_int, theta : [] c_float, u1 : [] c_float, ldu1 : c_int, u2 : [] c_float, ldu2 : c_int, v1t : [] c_float, ldv1t : c_int, v2t : [] c_float, ldv2t : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sorcsd
 */
inline proc LAPACKE_sorcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] c_float, ldx11 : c_int, x12 : [] c_float, ldx12 : c_int, x21 : [] c_float, ldx21 : c_int, x22 : [] c_float, ldx22 : c_int, theta : [] c_float, u1 : [] c_float, ldu1 : c_int, u2 : [] c_float, ldu2 : c_int, v1t : [] c_float, ldv1t : c_int, v2t : [] c_float, ldv2t : c_int) : c_int{
  return LAPACKE_sorcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sorcsd_work
 */
extern proc LAPACKE_sorcsd_work(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] c_float, ldx11 : c_int, x12 : [] c_float, ldx12 : c_int, x21 : [] c_float, ldx21 : c_int, x22 : [] c_float, ldx22 : c_int, theta : [] c_float, u1 : [] c_float, ldu1 : c_int, u2 : [] c_float, ldu2 : c_int, v1t : [] c_float, ldv1t : c_int, v2t : [] c_float, ldv2t : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sorcsd_work
 */
inline proc LAPACKE_sorcsd_work(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] c_float, ldx11 : c_int, x12 : [] c_float, ldx12 : c_int, x21 : [] c_float, ldx21 : c_int, x22 : [] c_float, ldx22 : c_int, theta : [] c_float, u1 : [] c_float, ldu1 : c_int, u2 : [] c_float, ldu2 : c_int, v1t : [] c_float, ldv1t : c_int, v2t : [] c_float, ldv2t : c_int, work : [] c_float, lwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_sorcsd_work(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyconv

Original Fortran LAPACK documentation for SSYCONV::

 SSYCONV convert A given by TRF into L and D and vice-versa.
 Get Non-diag elements of D (returned in workspace) and 
 apply or reverse permutation done in TRF.

 */
extern proc LAPACKE_ssyconv(matrix_order : lapack_memory_order, uplo : c_char, way : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyconv
 */
inline proc LAPACKE_ssyconv(matrix_order : lapack_memory_order, uplo : string, way : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_ssyconv(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyconv_work
 */
extern proc LAPACKE_ssyconv_work(matrix_order : lapack_memory_order, uplo : c_char, way : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyconv_work
 */
inline proc LAPACKE_ssyconv_work(matrix_order : lapack_memory_order, uplo : string, way : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] c_float) : c_int{
  return LAPACKE_ssyconv_work(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyswapr

Original Fortran LAPACK documentation for SSYSWAPR::

 SSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.

 */
extern proc LAPACKE_ssyswapr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyswapr
 */
inline proc LAPACKE_ssyswapr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_ssyswapr(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssyswapr_work
 */
extern proc LAPACKE_ssyswapr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssyswapr_work
 */
inline proc LAPACKE_ssyswapr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_ssyswapr_work(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytri2

Original Fortran LAPACK documentation for SSYTRI2::

 SSYTRI2 computes the inverse of a REAL symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 SSYTRF. SSYTRI2 sets the LEADING DIMENSION of the workspace
 before calling SSYTRI2X that actually computes the inverse.

 */
extern proc LAPACKE_ssytri2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytri2
 */
inline proc LAPACKE_ssytri2(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_ssytri2(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytri2_work
 */
extern proc LAPACKE_ssytri2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytri2_work
 */
inline proc LAPACKE_ssytri2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] complex(64), lwork : c_int) : c_int{
  return LAPACKE_ssytri2_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytri2x

Original Fortran LAPACK documentation for SSYTRI2X::

 SSYTRI2X computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 SSYTRF.

 */
extern proc LAPACKE_ssytri2x(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytri2x
 */
inline proc LAPACKE_ssytri2x(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, nb : c_int) : c_int{
  return LAPACKE_ssytri2x(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytri2x_work
 */
extern proc LAPACKE_ssytri2x_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] c_float, nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytri2x_work
 */
inline proc LAPACKE_ssytri2x_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, work : [] c_float, nb : c_int) : c_int{
  return LAPACKE_ssytri2x_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytrs2

Original Fortran LAPACK documentation for SSYTRS2::

 SSYTRS2 solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by SSYTRF and converted by SSYCONV.

 */
extern proc LAPACKE_ssytrs2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytrs2
 */
inline proc LAPACKE_ssytrs2(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_ssytrs2(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssytrs2_work
 */
extern proc LAPACKE_ssytrs2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssytrs2_work
 */
inline proc LAPACKE_ssytrs2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int, work : [] c_float) : c_int{
  return LAPACKE_ssytrs2_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zbbcsd

Original Fortran LAPACK documentation for ZBBCSD::

 ZBBCSD computes the CS decomposition of a unitary matrix in
 bidiagonal-block form,


 [ B11 | B12 0 0 ]
 [ 0 | 0 -I 0 ]
 X = [----------------]
 [ B21 | B22 0 0 ]
 [ 0 | 0 0 I ]

 [ C | -S 0 0 ]
 [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**H
 = [---------] [---------------] [---------] .
 [ | U2 ] [ S | C 0 0 ] [ | V2 ]
 [ 0 | 0 0 I ]

 X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
 than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
 transposed and/or permuted. This can be done in constant time using
 the TRANS and SIGNS options. See ZUNCSD for details.)

 The bidiagonal matrices B11, B12, B21, and B22 are represented
 implicitly by angles THETA(1:Q) and PHI(1:Q-1).

 The unitary matrices U1, U2, V1T, and V2T are input/output.
 The input matrices are pre- or post-multiplied by the appropriate
 singular vector matrices.

 */
extern proc LAPACKE_zbbcsd(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, m : c_int, p : c_int, q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] complex(128), ldu1 : c_int, u2 : [] complex(128), ldu2 : c_int, v1t : [] complex(128), ldv1t : c_int, v2t : [] complex(128), ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zbbcsd
 */
inline proc LAPACKE_zbbcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, p : c_int, q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] complex(128), ldu1 : c_int, u2 : [] complex(128), ldu2 : c_int, v1t : [] complex(128), ldv1t : c_int, v2t : [] complex(128), ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double) : c_int{
  return LAPACKE_zbbcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zbbcsd_work
 */
extern proc LAPACKE_zbbcsd_work(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, m : c_int, p : c_int, q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] complex(128), ldu1 : c_int, u2 : [] complex(128), ldu2 : c_int, v1t : [] complex(128), ldv1t : c_int, v2t : [] complex(128), ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double, rwork : [] c_double, lrwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zbbcsd_work
 */
inline proc LAPACKE_zbbcsd_work(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, p : c_int, q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] complex(128), ldu1 : c_int, u2 : [] complex(128), ldu2 : c_int, v1t : [] complex(128), ldv1t : c_int, v2t : [] complex(128), ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double, rwork : [] c_double, lrwork : c_int) : c_int{
  return LAPACKE_zbbcsd_work(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheswapr

Original Fortran LAPACK documentation for ZHESWAPR::

 ZHESWAPR applies an elementary permutation on the rows and the columns of
 a hermitian matrix.

 */
extern proc LAPACKE_zheswapr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheswapr
 */
inline proc LAPACKE_zheswapr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_zheswapr(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zheswapr_work
 */
extern proc LAPACKE_zheswapr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zheswapr_work
 */
inline proc LAPACKE_zheswapr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_zheswapr_work(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetri2

Original Fortran LAPACK documentation for ZHETRI2::

 ZHETRI2 computes the inverse of a COMPLEX*16 hermitian indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 ZHETRF. ZHETRI2 set the LEADING DIMENSION of the workspace
 before calling ZHETRI2X that actually computes the inverse.

 */
extern proc LAPACKE_zhetri2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetri2
 */
inline proc LAPACKE_zhetri2(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_zhetri2(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetri2_work
 */
extern proc LAPACKE_zhetri2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetri2_work
 */
inline proc LAPACKE_zhetri2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zhetri2_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetri2x

Original Fortran LAPACK documentation for ZHETRI2X::

 ZHETRI2X computes the inverse of a COMPLEX*16 Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 ZHETRF.

 */
extern proc LAPACKE_zhetri2x(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetri2x
 */
inline proc LAPACKE_zhetri2x(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, nb : c_int) : c_int{
  return LAPACKE_zhetri2x(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetri2x_work
 */
extern proc LAPACKE_zhetri2x_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetri2x_work
 */
inline proc LAPACKE_zhetri2x_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), nb : c_int) : c_int{
  return LAPACKE_zhetri2x_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetrs2

Original Fortran LAPACK documentation for ZHETRS2::

 ZHETRS2 solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHETRF and converted by ZSYCONV.

 */
extern proc LAPACKE_zhetrs2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetrs2
 */
inline proc LAPACKE_zhetrs2(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zhetrs2(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zhetrs2_work
 */
extern proc LAPACKE_zhetrs2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zhetrs2_work
 */
inline proc LAPACKE_zhetrs2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zhetrs2_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyconv

Original Fortran LAPACK documentation for ZSYCONV::

 ZSYCONV converts A given by ZHETRF into L and D or vice-versa.
 Get nondiagonal elements of D (returned in workspace) and 
 apply or reverse permutation done in TRF.

 */
extern proc LAPACKE_zsyconv(matrix_order : lapack_memory_order, uplo : c_char, way : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyconv
 */
inline proc LAPACKE_zsyconv(matrix_order : lapack_memory_order, uplo : string, way : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_zsyconv(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyconv_work
 */
extern proc LAPACKE_zsyconv_work(matrix_order : lapack_memory_order, uplo : c_char, way : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyconv_work
 */
inline proc LAPACKE_zsyconv_work(matrix_order : lapack_memory_order, uplo : string, way : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zsyconv_work(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, n, a, lda, ipiv, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyswapr

Original Fortran LAPACK documentation for ZSYSWAPR::

 ZSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.

 */
extern proc LAPACKE_zsyswapr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyswapr
 */
inline proc LAPACKE_zsyswapr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_zsyswapr(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyswapr_work
 */
extern proc LAPACKE_zsyswapr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), i1 : c_int, i2 : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyswapr_work
 */
inline proc LAPACKE_zsyswapr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), i1 : c_int, i2 : c_int) : c_int{
  return LAPACKE_zsyswapr_work(matrix_order, ascii(uplo) : c_char, n, a, i1, i2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytri2

Original Fortran LAPACK documentation for ZSYTRI2::

 ZSYTRI2 computes the inverse of a COMPLEX*16 symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 ZSYTRF. ZSYTRI2 sets the LEADING DIMENSION of the workspace
 before calling ZSYTRI2X that actually computes the inverse.

 */
extern proc LAPACKE_zsytri2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytri2
 */
inline proc LAPACKE_zsytri2(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int) : c_int{
  return LAPACKE_zsytri2(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytri2_work
 */
extern proc LAPACKE_zsytri2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytri2_work
 */
inline proc LAPACKE_zsytri2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zsytri2_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytri2x

Original Fortran LAPACK documentation for ZSYTRI2X::

 ZSYTRI2X computes the inverse of a complex symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 ZSYTRF.

 */
extern proc LAPACKE_zsytri2x(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytri2x
 */
inline proc LAPACKE_zsytri2x(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, nb : c_int) : c_int{
  return LAPACKE_zsytri2x(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytri2x_work
 */
extern proc LAPACKE_zsytri2x_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), nb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytri2x_work
 */
inline proc LAPACKE_zsytri2x_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, work : [] complex(128), nb : c_int) : c_int{
  return LAPACKE_zsytri2x_work(matrix_order, ascii(uplo) : c_char, n, a, lda, ipiv, work, nb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytrs2

Original Fortran LAPACK documentation for ZSYTRS2::

 ZSYTRS2 solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by ZSYTRF and converted by ZSYCONV.

 */
extern proc LAPACKE_zsytrs2(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytrs2
 */
inline proc LAPACKE_zsytrs2(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zsytrs2(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsytrs2_work
 */
extern proc LAPACKE_zsytrs2_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsytrs2_work
 */
inline proc LAPACKE_zsytrs2_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zsytrs2_work(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunbdb

Original Fortran LAPACK documentation for ZUNBDB::

 ZUNBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned unitary matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**H
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See ZUNCSD
 for details.)

 The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

 */
extern proc LAPACKE_zunbdb(matrix_order : lapack_memory_order, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] complex(128), ldx11 : c_int, x12 : [] complex(128), ldx12 : c_int, x21 : [] complex(128), ldx21 : c_int, x22 : [] complex(128), ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] complex(128), taup2 : [] complex(128), tauq1 : [] complex(128), tauq2 : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunbdb
 */
inline proc LAPACKE_zunbdb(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] complex(128), ldx11 : c_int, x12 : [] complex(128), ldx12 : c_int, x21 : [] complex(128), ldx21 : c_int, x22 : [] complex(128), ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] complex(128), taup2 : [] complex(128), tauq1 : [] complex(128), tauq2 : [] complex(128)) : c_int{
  return LAPACKE_zunbdb(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zunbdb_work
 */
extern proc LAPACKE_zunbdb_work(matrix_order : lapack_memory_order, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] complex(128), ldx11 : c_int, x12 : [] complex(128), ldx12 : c_int, x21 : [] complex(128), ldx21 : c_int, x22 : [] complex(128), ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] complex(128), taup2 : [] complex(128), tauq1 : [] complex(128), tauq2 : [] complex(128), work : [] complex(128), lwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zunbdb_work
 */
inline proc LAPACKE_zunbdb_work(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] complex(128), ldx11 : c_int, x12 : [] complex(128), ldx12 : c_int, x21 : [] complex(128), ldx21 : c_int, x22 : [] complex(128), ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] complex(128), taup2 : [] complex(128), tauq1 : [] complex(128), tauq2 : [] complex(128), work : [] complex(128), lwork : c_int) : c_int{
  return LAPACKE_zunbdb_work(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zuncsd

Original Fortran LAPACK documentation for ZUNCSD::

 ZUNCSD computes the CS decomposition of an M-by-M partitioned
 unitary matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**H
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

 */
extern proc LAPACKE_zuncsd(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] complex(128), ldx11 : c_int, x12 : [] complex(128), ldx12 : c_int, x21 : [] complex(128), ldx21 : c_int, x22 : [] complex(128), ldx22 : c_int, theta : [] c_double, u1 : [] complex(128), ldu1 : c_int, u2 : [] complex(128), ldu2 : c_int, v1t : [] complex(128), ldv1t : c_int, v2t : [] complex(128), ldv2t : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zuncsd
 */
inline proc LAPACKE_zuncsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] complex(128), ldx11 : c_int, x12 : [] complex(128), ldx12 : c_int, x21 : [] complex(128), ldx21 : c_int, x22 : [] complex(128), ldx22 : c_int, theta : [] c_double, u1 : [] complex(128), ldu1 : c_int, u2 : [] complex(128), ldu2 : c_int, v1t : [] complex(128), ldv1t : c_int, v2t : [] complex(128), ldv2t : c_int) : c_int{
  return LAPACKE_zuncsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zuncsd_work
 */
extern proc LAPACKE_zuncsd_work(matrix_order : lapack_memory_order, jobu1 : c_char, jobu2 : c_char, jobv1t : c_char, jobv2t : c_char, trans : c_char, signs : c_char, m : c_int, p : c_int, q : c_int, x11 : [] complex(128), ldx11 : c_int, x12 : [] complex(128), ldx12 : c_int, x21 : [] complex(128), ldx21 : c_int, x22 : [] complex(128), ldx22 : c_int, theta : [] c_double, u1 : [] complex(128), ldu1 : c_int, u2 : [] complex(128), ldu2 : c_int, v1t : [] complex(128), ldv1t : c_int, v2t : [] complex(128), ldv2t : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zuncsd_work
 */
inline proc LAPACKE_zuncsd_work(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, p : c_int, q : c_int, x11 : [] complex(128), ldx11 : c_int, x12 : [] complex(128), ldx12 : c_int, x21 : [] complex(128), ldx21 : c_int, x22 : [] complex(128), ldx22 : c_int, theta : [] c_double, u1 : [] complex(128), ldu1 : c_int, u2 : [] complex(128), ldu2 : c_int, v1t : [] complex(128), ldv1t : c_int, v2t : [] complex(128), ldv2t : c_int, work : [] complex(128), lwork : c_int, rwork : [] c_double, lrwork : c_int, iwork : [] c_int) : c_int{
  return LAPACKE_zuncsd_work(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgemqrt

Original Fortran LAPACK documentation for SGEMQRT::

 SGEMQRT overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q C C Q
 TRANS = 'T': Q**T C C Q**T

 where Q is a real orthogonal matrix defined as the product of K
 elementary reflectors:

 Q = H(1) H(2) . . . H(K) = I - V T V**T

 generated using the compact WY representation as returned by SGEQRT. 

 Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.

 */
extern proc LAPACKE_sgemqrt(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, c : [] c_float, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgemqrt
 */
inline proc LAPACKE_sgemqrt(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, c : [] c_float, ldc : c_int) : c_int{
  return LAPACKE_sgemqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, nb, v, ldv, t, ldt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgemqrt

Original Fortran LAPACK documentation for DGEMQRT::

 DGEMQRT overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q C C Q
 TRANS = 'T': Q**T C C Q**T

 where Q is a real orthogonal matrix defined as the product of K
 elementary reflectors:

 Q = H(1) H(2) . . . H(K) = I - V T V**T

 generated using the compact WY representation as returned by DGEQRT. 

 Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.

 */
extern proc LAPACKE_dgemqrt(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, c : [] c_double, ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgemqrt
 */
inline proc LAPACKE_dgemqrt(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, c : [] c_double, ldc : c_int) : c_int{
  return LAPACKE_dgemqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, nb, v, ldv, t, ldt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgemqrt

Original Fortran LAPACK documentation for CGEMQRT::

 CGEMQRT overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q C C Q
 TRANS = 'C': Q**H C C Q**H

 where Q is a complex orthogonal matrix defined as the product of K
 elementary reflectors:

 Q = H(1) H(2) . . . H(K) = I - V T V**H

 generated using the compact WY representation as returned by CGEQRT. 

 Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.

 */
extern proc LAPACKE_cgemqrt(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, c : [] complex(64), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgemqrt
 */
inline proc LAPACKE_cgemqrt(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, c : [] complex(64), ldc : c_int) : c_int{
  return LAPACKE_cgemqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, nb, v, ldv, t, ldt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgemqrt

Original Fortran LAPACK documentation for ZGEMQRT::

 ZGEMQRT overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q C C Q
 TRANS = 'C': Q**H C C Q**H

 where Q is a complex orthogonal matrix defined as the product of K
 elementary reflectors:

 Q = H(1) H(2) . . . H(K) = I - V T V**H

 generated using the compact WY representation as returned by ZGEQRT. 

 Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.

 */
extern proc LAPACKE_zgemqrt(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, c : [] complex(128), ldc : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgemqrt
 */
inline proc LAPACKE_zgemqrt(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, c : [] complex(128), ldc : c_int) : c_int{
  return LAPACKE_zgemqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, nb, v, ldv, t, ldt, c, ldc);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrt

Original Fortran LAPACK documentation for SGEQRT::

 SGEQRT computes a blocked QR factorization of a real M-by-N matrix A
 using the compact WY representation of Q.

 */
extern proc LAPACKE_sgeqrt(matrix_order : lapack_memory_order, m : c_int, n : c_int, nb : c_int, a : [] c_float, lda : c_int, t : [] c_float, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrt

Original Fortran LAPACK documentation for DGEQRT::

 DGEQRT computes a blocked QR factorization of a real M-by-N matrix A
 using the compact WY representation of Q.

 */
extern proc LAPACKE_dgeqrt(matrix_order : lapack_memory_order, m : c_int, n : c_int, nb : c_int, a : [] c_double, lda : c_int, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrt

Original Fortran LAPACK documentation for CGEQRT::

 CGEQRT computes a blocked QR factorization of a complex M-by-N matrix A
 using the compact WY representation of Q.

 */
extern proc LAPACKE_cgeqrt(matrix_order : lapack_memory_order, m : c_int, n : c_int, nb : c_int, a : [] complex(64), lda : c_int, t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrt

Original Fortran LAPACK documentation for ZGEQRT::

 ZGEQRT computes a blocked QR factorization of a complex M-by-N matrix A
 using the compact WY representation of Q.

 */
extern proc LAPACKE_zgeqrt(matrix_order : lapack_memory_order, m : c_int, n : c_int, nb : c_int, a : [] complex(128), lda : c_int, t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrt2

Original Fortran LAPACK documentation for SGEQRT2::

 SGEQRT2 computes a QR factorization of a real M-by-N matrix A, 
 using the compact WY representation of Q.

 */
extern proc LAPACKE_sgeqrt2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, t : [] c_float, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrt2

Original Fortran LAPACK documentation for DGEQRT2::

 DGEQRT2 computes a QR factorization of a real M-by-N matrix A, 
 using the compact WY representation of Q.

 */
extern proc LAPACKE_dgeqrt2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrt2

Original Fortran LAPACK documentation for CGEQRT2::

 CGEQRT2 computes a QR factorization of a complex M-by-N matrix A, 
 using the compact WY representation of Q.

 */
extern proc LAPACKE_cgeqrt2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrt2

Original Fortran LAPACK documentation for ZGEQRT2::

 ZGEQRT2 computes a QR factorization of a complex M-by-N matrix A, 
 using the compact WY representation of Q.

 */
extern proc LAPACKE_zgeqrt2(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrt3

Original Fortran LAPACK documentation for SGEQRT3::

 SGEQRT3 recursively computes a QR factorization of a real M-by-N 
 matrix A, using the compact WY representation of Q. 

 Based on the algorithm of Elmroth and Gustavson, 
 IBM J. Res. Develop. Vol 44 No. 4 July 2000.

 */
extern proc LAPACKE_sgeqrt3(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, t : [] c_float, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrt3

Original Fortran LAPACK documentation for DGEQRT3::

 DGEQRT3 recursively computes a QR factorization of a real M-by-N 
 matrix A, using the compact WY representation of Q. 

 Based on the algorithm of Elmroth and Gustavson, 
 IBM J. Res. Develop. Vol 44 No. 4 July 2000.

 */
extern proc LAPACKE_dgeqrt3(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrt3

Original Fortran LAPACK documentation for CGEQRT3::

 CGEQRT3 recursively computes a QR factorization of a complex M-by-N matrix A, 
 using the compact WY representation of Q. 

 Based on the algorithm of Elmroth and Gustavson, 
 IBM J. Res. Develop. Vol 44 No. 4 July 2000.

 */
extern proc LAPACKE_cgeqrt3(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrt3

Original Fortran LAPACK documentation for ZGEQRT3::

 ZGEQRT3 recursively computes a QR factorization of a complex M-by-N 
 matrix A, using the compact WY representation of Q. 

 Based on the algorithm of Elmroth and Gustavson, 
 IBM J. Res. Develop. Vol 44 No. 4 July 2000.

 */
extern proc LAPACKE_zgeqrt3(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stpmqrt

Original Fortran LAPACK documentation for STPMQRT::

 STPMQRT applies a real orthogonal matrix Q obtained from a 
 "triangular-pentagonal" real block reflector H to a general
 real matrix C, which consists of two blocks A and B.

 */
extern proc LAPACKE_stpmqrt(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stpmqrt
 */
inline proc LAPACKE_stpmqrt(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_stpmqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpmqrt

Original Fortran LAPACK documentation for DTPMQRT::

 DTPMQRT applies a real orthogonal matrix Q obtained from a 
 "triangular-pentagonal" real block reflector H to a general
 real matrix C, which consists of two blocks A and B.

 */
extern proc LAPACKE_dtpmqrt(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtpmqrt
 */
inline proc LAPACKE_dtpmqrt(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtpmqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpmqrt

Original Fortran LAPACK documentation for CTPMQRT::

 CTPMQRT applies a complex orthogonal matrix Q obtained from a 
 "triangular-pentagonal" complex block reflector H to a general
 complex matrix C, which consists of two blocks A and B.

 */
extern proc LAPACKE_ctpmqrt(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctpmqrt
 */
inline proc LAPACKE_ctpmqrt(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctpmqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpmqrt

Original Fortran LAPACK documentation for ZTPMQRT::

 ZTPMQRT applies a complex orthogonal matrix Q obtained from a 
 "triangular-pentagonal" complex block reflector H to a general
 complex matrix C, which consists of two blocks A and B.

 */
extern proc LAPACKE_ztpmqrt(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztpmqrt
 */
inline proc LAPACKE_ztpmqrt(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztpmqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpqrt

Original Fortran LAPACK documentation for DTPQRT::

 DTPQRT computes a blocked QR factorization of a real 
 "triangular-pentagonal" matrix C, which is composed of a 
 triangular block A and pentagonal block B, using the compact 
 WY representation for Q.

 */
extern proc LAPACKE_dtpqrt(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, nb : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpqrt

Original Fortran LAPACK documentation for CTPQRT::

 CTPQRT computes a blocked QR factorization of a complex 
 "triangular-pentagonal" matrix C, which is composed of a 
 triangular block A and pentagonal block B, using the compact 
 WY representation for Q.

 */
extern proc LAPACKE_ctpqrt(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, nb : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpqrt

Original Fortran LAPACK documentation for ZTPQRT::

 ZTPQRT computes a blocked QR factorization of a complex 
 "triangular-pentagonal" matrix C, which is composed of a 
 triangular block A and pentagonal block B, using the compact 
 WY representation for Q.

 */
extern proc LAPACKE_ztpqrt(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, nb : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stpqrt2

Original Fortran LAPACK documentation for STPQRT2::

 STPQRT2 computes a QR factorization of a real "triangular-pentagonal"
 matrix C, which is composed of a triangular block A and pentagonal block B, 
 using the compact WY representation for Q.

 */
extern proc LAPACKE_stpqrt2(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, t : [] c_float, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpqrt2

Original Fortran LAPACK documentation for DTPQRT2::

 DTPQRT2 computes a QR factorization of a real "triangular-pentagonal"
 matrix C, which is composed of a triangular block A and pentagonal block B, 
 using the compact WY representation for Q.

 */
extern proc LAPACKE_dtpqrt2(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpqrt2

Original Fortran LAPACK documentation for CTPQRT2::

 CTPQRT2 computes a QR factorization of a complex "triangular-pentagonal"
 matrix C, which is composed of a triangular block A and pentagonal block B, 
 using the compact WY representation for Q.

 */
extern proc LAPACKE_ctpqrt2(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpqrt2

Original Fortran LAPACK documentation for ZTPQRT2::

 ZTPQRT2 computes a QR factorization of a complex "triangular-pentagonal"
 matrix C, which is composed of a triangular block A and pentagonal block B, 
 using the compact WY representation for Q.

 */
extern proc LAPACKE_ztpqrt2(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stprfb

Original Fortran LAPACK documentation for STPRFB::

 STPRFB applies a real "triangular-pentagonal" block reflector H or its 
 conjugate transpose H^H to a real matrix C, which is composed of two 
 blocks A and B, either from the left or right.

 */
extern proc LAPACKE_stprfb(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, l : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stprfb
 */
inline proc LAPACKE_stprfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, l : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_stprfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtprfb

Original Fortran LAPACK documentation for DTPRFB::

 DTPRFB applies a real "triangular-pentagonal" block reflector H or its 
 transpose H**T to a real matrix C, which is composed of two 
 blocks A and B, either from the left or right.

 */
extern proc LAPACKE_dtprfb(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, l : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtprfb
 */
inline proc LAPACKE_dtprfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, l : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dtprfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctprfb

Original Fortran LAPACK documentation for CTPRFB::

 CTPRFB applies a complex "triangular-pentagonal" block reflector H or its 
 conjugate transpose H**H to a complex matrix C, which is composed of two 
 blocks A and B, either from the left or right.

 */
extern proc LAPACKE_ctprfb(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, l : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctprfb
 */
inline proc LAPACKE_ctprfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, l : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_ctprfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztprfb

Original Fortran LAPACK documentation for ZTPRFB::

 ZTPRFB applies a complex "triangular-pentagonal" block reflector H or its 
 conjugate transpose H**H to a complex matrix C, which is composed of two 
 blocks A and B, either from the left or right.

 */
extern proc LAPACKE_ztprfb(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, l : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztprfb
 */
inline proc LAPACKE_ztprfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, l : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_ztprfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgemqrt_work
 */
extern proc LAPACKE_sgemqrt_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, c : [] c_float, ldc : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_sgemqrt_work
 */
inline proc LAPACKE_sgemqrt_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, c : [] c_float, ldc : c_int, work : [] c_float) : c_int{
  return LAPACKE_sgemqrt_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dgemqrt_work
 */
extern proc LAPACKE_dgemqrt_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, c : [] c_double, ldc : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dgemqrt_work
 */
inline proc LAPACKE_dgemqrt_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, c : [] c_double, ldc : c_int, work : [] c_double) : c_int{
  return LAPACKE_dgemqrt_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_cgemqrt_work
 */
extern proc LAPACKE_cgemqrt_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, c : [] complex(64), ldc : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_cgemqrt_work
 */
inline proc LAPACKE_cgemqrt_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, c : [] complex(64), ldc : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_cgemqrt_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zgemqrt_work
 */
extern proc LAPACKE_zgemqrt_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, c : [] complex(128), ldc : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zgemqrt_work
 */
inline proc LAPACKE_zgemqrt_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, nb : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, c : [] complex(128), ldc : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_zgemqrt_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrt_work
 */
extern proc LAPACKE_sgeqrt_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nb : c_int, a : [] c_float, lda : c_int, t : [] c_float, ldt : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrt_work
 */
extern proc LAPACKE_dgeqrt_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nb : c_int, a : [] c_double, lda : c_int, t : [] c_double, ldt : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrt_work
 */
extern proc LAPACKE_cgeqrt_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nb : c_int, a : [] complex(64), lda : c_int, t : [] complex(64), ldt : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrt_work
 */
extern proc LAPACKE_zgeqrt_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, nb : c_int, a : [] complex(128), lda : c_int, t : [] complex(128), ldt : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrt2_work
 */
extern proc LAPACKE_sgeqrt2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, t : [] c_float, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrt2_work
 */
extern proc LAPACKE_dgeqrt2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrt2_work
 */
extern proc LAPACKE_cgeqrt2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrt2_work
 */
extern proc LAPACKE_zgeqrt2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_sgeqrt3_work
 */
extern proc LAPACKE_sgeqrt3_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_float, lda : c_int, t : [] c_float, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dgeqrt3_work
 */
extern proc LAPACKE_dgeqrt3_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] c_double, lda : c_int, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_cgeqrt3_work
 */
extern proc LAPACKE_cgeqrt3_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(64), lda : c_int, t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_zgeqrt3_work
 */
extern proc LAPACKE_zgeqrt3_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, a : [] complex(128), lda : c_int, t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stpmqrt_work
 */
extern proc LAPACKE_stpmqrt_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, work : [] c_float) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stpmqrt_work
 */
inline proc LAPACKE_stpmqrt_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, work : [] c_float) : c_int{
  return LAPACKE_stpmqrt_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpmqrt_work
 */
extern proc LAPACKE_dtpmqrt_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtpmqrt_work
 */
inline proc LAPACKE_dtpmqrt_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, work : [] c_double) : c_int{
  return LAPACKE_dtpmqrt_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpmqrt_work
 */
extern proc LAPACKE_ctpmqrt_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctpmqrt_work
 */
inline proc LAPACKE_ctpmqrt_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, work : [] complex(64)) : c_int{
  return LAPACKE_ctpmqrt_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpmqrt_work
 */
extern proc LAPACKE_ztpmqrt_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztpmqrt_work
 */
inline proc LAPACKE_ztpmqrt_work(matrix_order : lapack_memory_order, side : string, trans : string, m : c_int, n : c_int, k : c_int, l : c_int, nb : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, work : [] complex(128)) : c_int{
  return LAPACKE_ztpmqrt_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpqrt_work
 */
extern proc LAPACKE_dtpqrt_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, nb : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, t : [] c_double, ldt : c_int, work : [] c_double) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpqrt_work
 */
extern proc LAPACKE_ctpqrt_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, nb : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, t : [] complex(64), ldt : c_int, work : [] complex(64)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpqrt_work
 */
extern proc LAPACKE_ztpqrt_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, nb : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, t : [] complex(128), ldt : c_int, work : [] complex(128)) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stpqrt2_work
 */
extern proc LAPACKE_stpqrt2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, t : [] c_float, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_dtpqrt2_work
 */
extern proc LAPACKE_dtpqrt2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, t : [] c_double, ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ctpqrt2_work
 */
extern proc LAPACKE_ctpqrt2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, t : [] complex(64), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_ztpqrt2_work
 */
extern proc LAPACKE_ztpqrt2_work(matrix_order : lapack_memory_order, m : c_int, n : c_int, l : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, t : [] complex(128), ldt : c_int) : c_int;

pragma"no doc"
/* 
External Procedure to LAPACKE_stprfb_work
 */
extern proc LAPACKE_stprfb_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, l : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, work : [] c_float, ldwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_stprfb_work
 */
inline proc LAPACKE_stprfb_work(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, l : c_int, v : [] c_float, ldv : c_int, t : [] c_float, ldt : c_int, a : [] c_float, lda : c_int, b : [] c_float, ldb : c_int, work : [] c_float, ldwork : c_int) : c_int{
  return LAPACKE_stprfb_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dtprfb_work
 */
extern proc LAPACKE_dtprfb_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, l : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, work : [] c_double, ldwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dtprfb_work
 */
inline proc LAPACKE_dtprfb_work(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, l : c_int, v : [] c_double, ldv : c_int, t : [] c_double, ldt : c_int, a : [] c_double, lda : c_int, b : [] c_double, ldb : c_int, work : [] c_double, ldwork : c_int) : c_int{
  return LAPACKE_dtprfb_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ctprfb_work
 */
extern proc LAPACKE_ctprfb_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, l : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, work : [] c_float, ldwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ctprfb_work
 */
inline proc LAPACKE_ctprfb_work(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, l : c_int, v : [] complex(64), ldv : c_int, t : [] complex(64), ldt : c_int, a : [] complex(64), lda : c_int, b : [] complex(64), ldb : c_int, work : [] c_float, ldwork : c_int) : c_int{
  return LAPACKE_ctprfb_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ztprfb_work
 */
extern proc LAPACKE_ztprfb_work(matrix_order : lapack_memory_order, side : c_char, trans : c_char, direct : c_char, storev : c_char, m : c_int, n : c_int, k : c_int, l : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, work : [] c_double, ldwork : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ztprfb_work
 */
inline proc LAPACKE_ztprfb_work(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, m : c_int, n : c_int, k : c_int, l : c_int, v : [] complex(128), ldv : c_int, t : [] complex(128), ldt : c_int, a : [] complex(128), lda : c_int, b : [] complex(128), ldb : c_int, work : [] c_double, ldwork : c_int) : c_int{
  return LAPACKE_ztprfb_work(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ssysv_rook

Original Fortran LAPACK documentation for SSYSV_ROOK::

 SSYSV_ROOK computes the solution to a real system of linear
 equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 SSYTRF_ROOK is called to compute the factorization of a real
 symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
 pivoting method.

 The factored form of A is then used to solve the system 
 of equations A * X = B by calling SSYTRS_ROOK.

 */
extern proc LAPACKE_ssysv_rook(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_ssysv_rook
 */
inline proc LAPACKE_ssysv_rook(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int{
  return LAPACKE_ssysv_rook(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_dsysv_rook

Original Fortran LAPACK documentation for DSYSV_ROOK::

 DSYSV_ROOK computes the solution to a real system of linear
 equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 DSYTRF_ROOK is called to compute the factorization of a real
 symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
 pivoting method.

 The factored form of A is then used to solve the system 
 of equations A * X = B by calling DSYTRS_ROOK.

 */
extern proc LAPACKE_dsysv_rook(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_dsysv_rook
 */
inline proc LAPACKE_dsysv_rook(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] c_double, lda : c_int, ipiv : [] c_int, b : [] c_double, ldb : c_int) : c_int{
  return LAPACKE_dsysv_rook(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csysv_rook

Original Fortran LAPACK documentation for CSYSV_ROOK::

 CSYSV_ROOK computes the solution to a complex system of linear
 equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. 

 CSYTRF_ROOK is called to compute the factorization of a complex
 symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
 pivoting method.

 The factored form of A is then used to solve the system 
 of equations A * X = B by calling CSYTRS_ROOK.

 */
extern proc LAPACKE_csysv_rook(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csysv_rook
 */
inline proc LAPACKE_csysv_rook(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(64), lda : c_int, ipiv : [] c_int, b : [] complex(64), ldb : c_int) : c_int{
  return LAPACKE_csysv_rook(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsysv_rook

Original Fortran LAPACK documentation for ZSYSV_ROOK::

 ZSYSV_ROOK computes the solution to a complex system of linear
 equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. 

 ZSYTRF_ROOK is called to compute the factorization of a complex
 symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
 pivoting method.

 The factored form of A is then used to solve the system 
 of equations A * X = B by calling ZSYTRS_ROOK.

 */
extern proc LAPACKE_zsysv_rook(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsysv_rook
 */
inline proc LAPACKE_zsysv_rook(matrix_order : lapack_memory_order, uplo : string, n : c_int, nrhs : c_int, a : [] complex(128), lda : c_int, ipiv : [] c_int, b : [] complex(128), ldb : c_int) : c_int{
  return LAPACKE_zsysv_rook(matrix_order, ascii(uplo) : c_char, n, nrhs, a, lda, ipiv, b, ldb);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyr

Original Fortran LAPACK documentation for CSYR::

 CSYR performs the symmetric rank 1 operation

 A := alpha*x*x**H + A,

 where alpha is a complex scalar, x is an n element vector and A is an
 n by n symmetric matrix.

 */
extern proc LAPACKE_csyr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, alpha : complex(64), x : [] complex(64), incx : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyr
 */
inline proc LAPACKE_csyr(matrix_order : lapack_memory_order, uplo : string, n : c_int, alpha : complex(64), x : [] complex(64), incx : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_csyr(matrix_order, ascii(uplo) : c_char, n, alpha, x, incx, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyr

Original Fortran LAPACK documentation for ZSYR::

 ZSYR performs the symmetric rank 1 operation

 A := alpha*x*x**H + A,

 where alpha is a complex scalar, x is an n element vector and A is an
 n by n symmetric matrix.

 */
extern proc LAPACKE_zsyr(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, alpha : complex(128), x : [] complex(128), incx : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyr
 */
inline proc LAPACKE_zsyr(matrix_order : lapack_memory_order, uplo : string, n : c_int, alpha : complex(128), x : [] complex(128), incx : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zsyr(matrix_order, ascii(uplo) : c_char, n, alpha, x, incx, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_csyr_work
 */
extern proc LAPACKE_csyr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, alpha : complex(64), x : [] complex(64), incx : c_int, a : [] complex(64), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_csyr_work
 */
inline proc LAPACKE_csyr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, alpha : complex(64), x : [] complex(64), incx : c_int, a : [] complex(64), lda : c_int) : c_int{
  return LAPACKE_csyr_work(matrix_order, ascii(uplo) : c_char, n, alpha, x, incx, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_zsyr_work
 */
extern proc LAPACKE_zsyr_work(matrix_order : lapack_memory_order, uplo : c_char, n : c_int, alpha : complex(128), x : [] complex(128), incx : c_int, a : [] complex(128), lda : c_int) : c_int;

pragma"no doc"
/* 
String wrapped procedure of LAPACKE_zsyr_work
 */
inline proc LAPACKE_zsyr_work(matrix_order : lapack_memory_order, uplo : string, n : c_int, alpha : complex(128), x : [] complex(128), incx : c_int, a : [] complex(128), lda : c_int) : c_int{
  return LAPACKE_zsyr_work(matrix_order, ascii(uplo) : c_char, n, alpha, x, incx, a, lda);
}

pragma"no doc"
/* 
External Procedure to LAPACKE_ilaver

Original Fortran LAPACK documentation for ILAVER::

 This subroutine returns the LAPACK version.

 */
extern proc LAPACKE_ilaver(ref vers_major : c_int, ref vers_minor : c_int, ref vers_patch : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgetrf

Original Fortran LAPACK documentation for SGETRF::

 SGETRF computes an LU factorization of a general M-by-N matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_sgetrf(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgetrf

Original Fortran LAPACK documentation for DGETRF::

 DGETRF computes an LU factorization of a general M-by-N matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_dgetrf(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgetrf

Original Fortran LAPACK documentation for CGETRF::

 CGETRF computes an LU factorization of a general M-by-N matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_cgetrf(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgetrf

Original Fortran LAPACK documentation for ZGETRF::

 ZGETRF computes an LU factorization of a general M-by-N matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_zgetrf(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbtrf

Original Fortran LAPACK documentation for SGBTRF::

 SGBTRF computes an LU factorization of a real m-by-n band matrix A
 using partial pivoting with row interchanges.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_sgbtrf(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_float, ref ldab : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbtrf

Original Fortran LAPACK documentation for DGBTRF::

 DGBTRF computes an LU factorization of a real m-by-n band matrix A
 using partial pivoting with row interchanges.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_dgbtrf(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_double, ref ldab : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbtrf

Original Fortran LAPACK documentation for CGBTRF::

 CGBTRF computes an LU factorization of a complex m-by-n band matrix A
 using partial pivoting with row interchanges.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_cgbtrf(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(64), ref ldab : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbtrf

Original Fortran LAPACK documentation for ZGBTRF::

 ZGBTRF computes an LU factorization of a complex m-by-n band matrix A
 using partial pivoting with row interchanges.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_zgbtrf(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(128), ref ldab : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgttrf

Original Fortran LAPACK documentation for SGTTRF::

 SGTTRF computes an LU factorization of a real tridiagonal matrix A
 using elimination with partial pivoting and row interchanges.

 The factorization has the form
 A = L * U
 where L is a product of permutation and unit lower bidiagonal
 matrices and U is upper triangular with nonzeros in only the main
 diagonal and first two superdiagonals.

 */
extern proc LAPACK_sgttrf(ref n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgttrf

Original Fortran LAPACK documentation for DGTTRF::

 DGTTRF computes an LU factorization of a real tridiagonal matrix A
 using elimination with partial pivoting and row interchanges.

 The factorization has the form
 A = L * U
 where L is a product of permutation and unit lower bidiagonal
 matrices and U is upper triangular with nonzeros in only the main
 diagonal and first two superdiagonals.

 */
extern proc LAPACK_dgttrf(ref n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgttrf

Original Fortran LAPACK documentation for CGTTRF::

 CGTTRF computes an LU factorization of a complex tridiagonal matrix A
 using elimination with partial pivoting and row interchanges.

 The factorization has the form
 A = L * U
 where L is a product of permutation and unit lower bidiagonal
 matrices and U is upper triangular with nonzeros in only the main
 diagonal and first two superdiagonals.

 */
extern proc LAPACK_cgttrf(ref n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgttrf

Original Fortran LAPACK documentation for ZGTTRF::

 ZGTTRF computes an LU factorization of a complex tridiagonal matrix A
 using elimination with partial pivoting and row interchanges.

 The factorization has the form
 A = L * U
 where L is a product of permutation and unit lower bidiagonal
 matrices and U is upper triangular with nonzeros in only the main
 diagonal and first two superdiagonals.

 */
extern proc LAPACK_zgttrf(ref n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spotrf

Original Fortran LAPACK documentation for SPOTRF::

 SPOTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_spotrf(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpotrf

Original Fortran LAPACK documentation for DPOTRF::

 DPOTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_dpotrf(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpotrf

Original Fortran LAPACK documentation for CPOTRF::

 CPOTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_cpotrf(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpotrf

Original Fortran LAPACK documentation for ZPOTRF::

 ZPOTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_zpotrf(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpstrf

Original Fortran LAPACK documentation for DPSTRF::

 DPSTRF computes the Cholesky factorization with complete
 pivoting of a real symmetric positive semidefinite matrix A.

 The factorization has the form
 P**T * A * P = U**T * U , if UPLO = 'U',
 P**T * A * P = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular, and
 P is stored as vector PIV.

 This algorithm does not attempt to check that A is positive
 semidefinite. This version of the algorithm calls level 3 BLAS.

 */
extern proc LAPACK_dpstrf(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, piv : [] c_int, ref rank : c_int, ref tol : c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spstrf

Original Fortran LAPACK documentation for SPSTRF::

 SPSTRF computes the Cholesky factorization with complete
 pivoting of a real symmetric positive semidefinite matrix A.

 The factorization has the form
 P**T * A * P = U**T * U , if UPLO = 'U',
 P**T * A * P = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular, and
 P is stored as vector PIV.

 This algorithm does not attempt to check that A is positive
 semidefinite. This version of the algorithm calls level 3 BLAS.

 */
extern proc LAPACK_spstrf(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, piv : [] c_int, ref rank : c_int, ref tol : c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpstrf

Original Fortran LAPACK documentation for ZPSTRF::

 ZPSTRF computes the Cholesky factorization with complete
 pivoting of a complex Hermitian positive semidefinite matrix A.

 The factorization has the form
 P**T * A * P = U**H * U , if UPLO = 'U',
 P**T * A * P = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular, and
 P is stored as vector PIV.

 This algorithm does not attempt to check that A is positive
 semidefinite. This version of the algorithm calls level 3 BLAS.

 */
extern proc LAPACK_zpstrf(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, piv : [] c_int, ref rank : c_int, ref tol : c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpstrf

Original Fortran LAPACK documentation for CPSTRF::

 CPSTRF computes the Cholesky factorization with complete
 pivoting of a complex Hermitian positive semidefinite matrix A.

 The factorization has the form
 P**T * A * P = U**H * U , if UPLO = 'U',
 P**T * A * P = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular, and
 P is stored as vector PIV.

 This algorithm does not attempt to check that A is positive
 semidefinite. This version of the algorithm calls level 3 BLAS.

 */
extern proc LAPACK_cpstrf(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, piv : [] c_int, ref rank : c_int, ref tol : c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpftrf

Original Fortran LAPACK documentation for DPFTRF::

 DPFTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_dpftrf(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spftrf

Original Fortran LAPACK documentation for SPFTRF::

 SPFTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_spftrf(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpftrf

Original Fortran LAPACK documentation for ZPFTRF::

 ZPFTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_zpftrf(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpftrf

Original Fortran LAPACK documentation for CPFTRF::

 CPFTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_cpftrf(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spptrf

Original Fortran LAPACK documentation for SPPTRF::

 SPPTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A stored in packed format.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACK_spptrf(ref uplo : c_char, ref n : c_int, ap : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpptrf

Original Fortran LAPACK documentation for DPPTRF::

 DPPTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A stored in packed format.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACK_dpptrf(ref uplo : c_char, ref n : c_int, ap : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpptrf

Original Fortran LAPACK documentation for CPPTRF::

 CPPTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A stored in packed format.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACK_cpptrf(ref uplo : c_char, ref n : c_int, ap : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpptrf

Original Fortran LAPACK documentation for ZPPTRF::

 ZPPTRF computes the Cholesky factorization of a complex Hermitian
 positive definite matrix A stored in packed format.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACK_zpptrf(ref uplo : c_char, ref n : c_int, ap : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spbtrf

Original Fortran LAPACK documentation for SPBTRF::

 SPBTRF computes the Cholesky factorization of a real symmetric
 positive definite band matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACK_spbtrf(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_float, ref ldab : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpbtrf

Original Fortran LAPACK documentation for DPBTRF::

 DPBTRF computes the Cholesky factorization of a real symmetric
 positive definite band matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACK_dpbtrf(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_double, ref ldab : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpbtrf

Original Fortran LAPACK documentation for CPBTRF::

 CPBTRF computes the Cholesky factorization of a complex Hermitian
 positive definite band matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACK_cpbtrf(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(64), ref ldab : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpbtrf

Original Fortran LAPACK documentation for ZPBTRF::

 ZPBTRF computes the Cholesky factorization of a complex Hermitian
 positive definite band matrix A.

 The factorization has the form
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 */
extern proc LAPACK_zpbtrf(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(128), ref ldab : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spttrf

Original Fortran LAPACK documentation for SPTTRF::

 SPTTRF computes the L*D*L**T factorization of a real symmetric
 positive definite tridiagonal matrix A. The factorization may also
 be regarded as having the form A = U**T*D*U.

 */
extern proc LAPACK_spttrf(ref n : c_int, d : [] c_float, e : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpttrf

Original Fortran LAPACK documentation for DPTTRF::

 DPTTRF computes the L*D*L**T factorization of a real symmetric
 positive definite tridiagonal matrix A. The factorization may also
 be regarded as having the form A = U**T*D*U.

 */
extern proc LAPACK_dpttrf(ref n : c_int, d : [] c_double, e : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpttrf

Original Fortran LAPACK documentation for CPTTRF::

 CPTTRF computes the L*D*L**H factorization of a complex Hermitian
 positive definite tridiagonal matrix A. The factorization may also
 be regarded as having the form A = U**H *D*U.

 */
extern proc LAPACK_cpttrf(ref n : c_int, d : [] c_float, e : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpttrf

Original Fortran LAPACK documentation for ZPTTRF::

 ZPTTRF computes the L*D*L**H factorization of a complex Hermitian
 positive definite tridiagonal matrix A. The factorization may also
 be regarded as having the form A = U**H *D*U.

 */
extern proc LAPACK_zpttrf(ref n : c_int, d : [] c_double, e : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssytrf

Original Fortran LAPACK documentation for SSYTRF::

 SSYTRF computes the factorization of a real symmetric matrix A using
 the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with 
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_ssytrf(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsytrf

Original Fortran LAPACK documentation for DSYTRF::

 DSYTRF computes the factorization of a real symmetric matrix A using
 the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_dsytrf(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csytrf

Original Fortran LAPACK documentation for CSYTRF::

 CSYTRF computes the factorization of a complex symmetric matrix A
 using the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 with 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_csytrf(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsytrf

Original Fortran LAPACK documentation for ZSYTRF::

 ZSYTRF computes the factorization of a complex symmetric matrix A
 using the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 with 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_zsytrf(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chetrf

Original Fortran LAPACK documentation for CHETRF::

 CHETRF computes the factorization of a complex Hermitian matrix A
 using the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with 
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_chetrf(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhetrf

Original Fortran LAPACK documentation for ZHETRF::

 ZHETRF computes the factorization of a complex Hermitian matrix A
 using the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_zhetrf(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssptrf

Original Fortran LAPACK documentation for SSPTRF::

 SSPTRF computes the factorization of a real symmetric matrix A stored
 in packed format using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACK_ssptrf(ref uplo : c_char, ref n : c_int, ap : [] c_float, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsptrf

Original Fortran LAPACK documentation for DSPTRF::

 DSPTRF computes the factorization of a real symmetric matrix A stored
 in packed format using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACK_dsptrf(ref uplo : c_char, ref n : c_int, ap : [] c_double, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csptrf

Original Fortran LAPACK documentation for CSPTRF::

 CSPTRF computes the factorization of a complex symmetric matrix A
 stored in packed format using the Bunch-Kaufman diagonal pivoting
 method:

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACK_csptrf(ref uplo : c_char, ref n : c_int, ap : [] complex(64), ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsptrf

Original Fortran LAPACK documentation for ZSPTRF::

 ZSPTRF computes the factorization of a complex symmetric matrix A
 stored in packed format using the Bunch-Kaufman diagonal pivoting
 method:

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACK_zsptrf(ref uplo : c_char, ref n : c_int, ap : [] complex(128), ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chptrf

Original Fortran LAPACK documentation for CHPTRF::

 CHPTRF computes the factorization of a complex Hermitian packed
 matrix A using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACK_chptrf(ref uplo : c_char, ref n : c_int, ap : [] complex(64), ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhptrf

Original Fortran LAPACK documentation for ZHPTRF::

 ZHPTRF computes the factorization of a complex Hermitian packed
 matrix A using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 */
extern proc LAPACK_zhptrf(ref uplo : c_char, ref n : c_int, ap : [] complex(128), ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgetrs

Original Fortran LAPACK documentation for SGETRS::

 SGETRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general N-by-N matrix A using the LU factorization computed
 by SGETRF.

 */
extern proc LAPACK_sgetrs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgetrs

Original Fortran LAPACK documentation for DGETRS::

 DGETRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general N-by-N matrix A using the LU factorization computed
 by DGETRF.

 */
extern proc LAPACK_dgetrs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgetrs

Original Fortran LAPACK documentation for CGETRS::

 CGETRS solves a system of linear equations
 A * X = B, A**T * X = B, or A**H * X = B
 with a general N-by-N matrix A using the LU factorization computed
 by CGETRF.

 */
extern proc LAPACK_cgetrs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgetrs

Original Fortran LAPACK documentation for ZGETRS::

 ZGETRS solves a system of linear equations
 A * X = B, A**T * X = B, or A**H * X = B
 with a general N-by-N matrix A using the LU factorization computed
 by ZGETRF.

 */
extern proc LAPACK_zgetrs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbtrs

Original Fortran LAPACK documentation for SGBTRS::

 SGBTRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general band matrix A using the LU factorization computed
 by SGBTRF.

 */
extern proc LAPACK_sgbtrs(ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbtrs

Original Fortran LAPACK documentation for DGBTRS::

 DGBTRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general band matrix A using the LU factorization computed
 by DGBTRF.

 */
extern proc LAPACK_dgbtrs(ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbtrs

Original Fortran LAPACK documentation for CGBTRS::

 CGBTRS solves a system of linear equations
 A * X = B, A**T * X = B, or A**H * X = B
 with a general band matrix A using the LU factorization computed
 by CGBTRF.

 */
extern proc LAPACK_cgbtrs(ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbtrs

Original Fortran LAPACK documentation for ZGBTRS::

 ZGBTRS solves a system of linear equations
 A * X = B, A**T * X = B, or A**H * X = B
 with a general band matrix A using the LU factorization computed
 by ZGBTRF.

 */
extern proc LAPACK_zgbtrs(ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgttrs

Original Fortran LAPACK documentation for SGTTRS::

 SGTTRS solves one of the systems of equations
 A*X = B or A**T*X = B,
 with a tridiagonal matrix A using the LU factorization computed
 by SGTTRF.

 */
extern proc LAPACK_sgttrs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgttrs

Original Fortran LAPACK documentation for DGTTRS::

 DGTTRS solves one of the systems of equations
 A*X = B or A**T*X = B,
 with a tridiagonal matrix A using the LU factorization computed
 by DGTTRF.

 */
extern proc LAPACK_dgttrs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgttrs

Original Fortran LAPACK documentation for CGTTRS::

 CGTTRS solves one of the systems of equations
 A * X = B, A**T * X = B, or A**H * X = B,
 with a tridiagonal matrix A using the LU factorization computed
 by CGTTRF.

 */
extern proc LAPACK_cgttrs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgttrs

Original Fortran LAPACK documentation for ZGTTRS::

 ZGTTRS solves one of the systems of equations
 A * X = B, A**T * X = B, or A**H * X = B,
 with a tridiagonal matrix A using the LU factorization computed
 by ZGTTRF.

 */
extern proc LAPACK_zgttrs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spotrs

Original Fortran LAPACK documentation for SPOTRS::

 SPOTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by SPOTRF.

 */
extern proc LAPACK_spotrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpotrs

Original Fortran LAPACK documentation for DPOTRS::

 DPOTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by DPOTRF.

 */
extern proc LAPACK_dpotrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpotrs

Original Fortran LAPACK documentation for CPOTRS::

 CPOTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A using the Cholesky factorization 
 A = U**H*U or A = L*L**H computed by CPOTRF.

 */
extern proc LAPACK_cpotrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpotrs

Original Fortran LAPACK documentation for ZPOTRS::

 ZPOTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A using the Cholesky factorization
 A = U**H * U or A = L * L**H computed by ZPOTRF.

 */
extern proc LAPACK_zpotrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpftrs

Original Fortran LAPACK documentation for DPFTRS::

 DPFTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by DPFTRF.

 */
extern proc LAPACK_dpftrs(ref transr : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spftrs

Original Fortran LAPACK documentation for SPFTRS::

 SPFTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by SPFTRF.

 */
extern proc LAPACK_spftrs(ref transr : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpftrs

Original Fortran LAPACK documentation for ZPFTRS::

 ZPFTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A using the Cholesky factorization
 A = U**H*U or A = L*L**H computed by ZPFTRF.

 */
extern proc LAPACK_zpftrs(ref transr : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpftrs

Original Fortran LAPACK documentation for CPFTRS::

 CPFTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A using the Cholesky factorization
 A = U**H*U or A = L*L**H computed by CPFTRF.

 */
extern proc LAPACK_cpftrs(ref transr : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spptrs

Original Fortran LAPACK documentation for SPPTRS::

 SPPTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A in packed storage using the Cholesky
 factorization A = U**T*U or A = L*L**T computed by SPPTRF.

 */
extern proc LAPACK_spptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpptrs

Original Fortran LAPACK documentation for DPPTRS::

 DPPTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A in packed storage using the Cholesky
 factorization A = U**T*U or A = L*L**T computed by DPPTRF.

 */
extern proc LAPACK_dpptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpptrs

Original Fortran LAPACK documentation for CPPTRS::

 CPPTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A in packed storage using the Cholesky
 factorization A = U**H*U or A = L*L**H computed by CPPTRF.

 */
extern proc LAPACK_cpptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpptrs

Original Fortran LAPACK documentation for ZPPTRS::

 ZPPTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite matrix A in packed storage using the Cholesky
 factorization A = U**H * U or A = L * L**H computed by ZPPTRF.

 */
extern proc LAPACK_zpptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spbtrs

Original Fortran LAPACK documentation for SPBTRS::

 SPBTRS solves a system of linear equations A*X = B with a symmetric
 positive definite band matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by SPBTRF.

 */
extern proc LAPACK_spbtrs(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpbtrs

Original Fortran LAPACK documentation for DPBTRS::

 DPBTRS solves a system of linear equations A*X = B with a symmetric
 positive definite band matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by DPBTRF.

 */
extern proc LAPACK_dpbtrs(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpbtrs

Original Fortran LAPACK documentation for CPBTRS::

 CPBTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite band matrix A using the Cholesky factorization
 A = U**H*U or A = L*L**H computed by CPBTRF.

 */
extern proc LAPACK_cpbtrs(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpbtrs

Original Fortran LAPACK documentation for ZPBTRS::

 ZPBTRS solves a system of linear equations A*X = B with a Hermitian
 positive definite band matrix A using the Cholesky factorization
 A = U**H *U or A = L*L**H computed by ZPBTRF.

 */
extern proc LAPACK_zpbtrs(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spttrs

Original Fortran LAPACK documentation for SPTTRS::

 SPTTRS solves a tridiagonal system of the form
 A * X = B
 using the L*D*L**T factorization of A computed by SPTTRF. D is a
 diagonal matrix specified in the vector D, L is a unit bidiagonal
 matrix whose subdiagonal is specified in the vector E, and X and B
 are N by NRHS matrices.

 */
extern proc LAPACK_spttrs(ref n : c_int, ref nrhs : c_int, d : [] c_float, e : [] c_float, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpttrs

Original Fortran LAPACK documentation for DPTTRS::

 DPTTRS solves a tridiagonal system of the form
 A * X = B
 using the L*D*L**T factorization of A computed by DPTTRF. D is a
 diagonal matrix specified in the vector D, L is a unit bidiagonal
 matrix whose subdiagonal is specified in the vector E, and X and B
 are N by NRHS matrices.

 */
extern proc LAPACK_dpttrs(ref n : c_int, ref nrhs : c_int, d : [] c_double, e : [] c_double, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpttrs

Original Fortran LAPACK documentation for CPTTRS::

 CPTTRS solves a tridiagonal system of the form
 A * X = B
 using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.
 D is a diagonal matrix specified in the vector D, U (or L) is a unit
 bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
 the vector E, and X and B are N by NRHS matrices.

 */
extern proc LAPACK_cpttrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpttrs

Original Fortran LAPACK documentation for ZPTTRS::

 ZPTTRS solves a tridiagonal system of the form
 A * X = B
 using the factorization A = U**H *D* U or A = L*D*L**H computed by ZPTTRF.
 D is a diagonal matrix specified in the vector D, U (or L) is a unit
 bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
 the vector E, and X and B are N by NRHS matrices.

 */
extern proc LAPACK_zpttrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssytrs

Original Fortran LAPACK documentation for SSYTRS::

 SSYTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by SSYTRF.

 */
extern proc LAPACK_ssytrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsytrs

Original Fortran LAPACK documentation for DSYTRS::

 DSYTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by DSYTRF.

 */
extern proc LAPACK_dsytrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csytrs

Original Fortran LAPACK documentation for CSYTRS::

 CSYTRS solves a system of linear equations A*X = B with a complex
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by CSYTRF.

 */
extern proc LAPACK_csytrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsytrs

Original Fortran LAPACK documentation for ZSYTRS::

 ZSYTRS solves a system of linear equations A*X = B with a complex
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by ZSYTRF.

 */
extern proc LAPACK_zsytrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chetrs

Original Fortran LAPACK documentation for CHETRS::

 CHETRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHETRF.

 */
extern proc LAPACK_chetrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhetrs

Original Fortran LAPACK documentation for ZHETRS::

 ZHETRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHETRF.

 */
extern proc LAPACK_zhetrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssptrs

Original Fortran LAPACK documentation for SSPTRS::

 SSPTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A stored in packed format using the factorization
 A = U*D*U**T or A = L*D*L**T computed by SSPTRF.

 */
extern proc LAPACK_ssptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsptrs

Original Fortran LAPACK documentation for DSPTRS::

 DSPTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A stored in packed format using the factorization
 A = U*D*U**T or A = L*D*L**T computed by DSPTRF.

 */
extern proc LAPACK_dsptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csptrs

Original Fortran LAPACK documentation for CSPTRS::

 CSPTRS solves a system of linear equations A*X = B with a complex
 symmetric matrix A stored in packed format using the factorization
 A = U*D*U**T or A = L*D*L**T computed by CSPTRF.

 */
extern proc LAPACK_csptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsptrs

Original Fortran LAPACK documentation for ZSPTRS::

 ZSPTRS solves a system of linear equations A*X = B with a complex
 symmetric matrix A stored in packed format using the factorization
 A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.

 */
extern proc LAPACK_zsptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chptrs

Original Fortran LAPACK documentation for CHPTRS::

 CHPTRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A stored in packed format using the factorization
 A = U*D*U**H or A = L*D*L**H computed by CHPTRF.

 */
extern proc LAPACK_chptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhptrs

Original Fortran LAPACK documentation for ZHPTRS::

 ZHPTRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A stored in packed format using the factorization
 A = U*D*U**H or A = L*D*L**H computed by ZHPTRF.

 */
extern proc LAPACK_zhptrs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strtrs

Original Fortran LAPACK documentation for STRTRS::

 STRTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N, and B is an N-by-NRHS
 matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACK_strtrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrtrs

Original Fortran LAPACK documentation for DTRTRS::

 DTRTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N, and B is an N-by-NRHS
 matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACK_dtrtrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrtrs

Original Fortran LAPACK documentation for CTRTRS::

 CTRTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular matrix of order N, and B is an N-by-NRHS
 matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACK_ctrtrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrtrs

Original Fortran LAPACK documentation for ZTRTRS::

 ZTRTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular matrix of order N, and B is an N-by-NRHS
 matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACK_ztrtrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stptrs

Original Fortran LAPACK documentation for STPTRS::

 STPTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N stored in packed format,
 and B is an N-by-NRHS matrix. A check is made to verify that A is
 nonsingular.

 */
extern proc LAPACK_stptrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtptrs

Original Fortran LAPACK documentation for DTPTRS::

 DTPTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N stored in packed format,
 and B is an N-by-NRHS matrix. A check is made to verify that A is
 nonsingular.

 */
extern proc LAPACK_dtptrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctptrs

Original Fortran LAPACK documentation for CTPTRS::

 CTPTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular matrix of order N stored in packed format,
 and B is an N-by-NRHS matrix. A check is made to verify that A is
 nonsingular.

 */
extern proc LAPACK_ctptrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztptrs

Original Fortran LAPACK documentation for ZTPTRS::

 ZTPTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular matrix of order N stored in packed format,
 and B is an N-by-NRHS matrix. A check is made to verify that A is
 nonsingular.

 */
extern proc LAPACK_ztptrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stbtrs

Original Fortran LAPACK documentation for STBTRS::

 STBTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular band matrix of order N, and B is an
 N-by NRHS matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACK_stbtrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtbtrs

Original Fortran LAPACK documentation for DTBTRS::

 DTBTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular band matrix of order N, and B is an
 N-by NRHS matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACK_dtbtrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctbtrs

Original Fortran LAPACK documentation for CTBTRS::

 CTBTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular band matrix of order N, and B is an
 N-by-NRHS matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACK_ctbtrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztbtrs

Original Fortran LAPACK documentation for ZTBTRS::

 ZTBTRS solves a triangular system of the form

 A * X = B, A**T * X = B, or A**H * X = B,

 where A is a triangular band matrix of order N, and B is an
 N-by-NRHS matrix. A check is made to verify that A is nonsingular.

 */
extern proc LAPACK_ztbtrs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgecon

Original Fortran LAPACK documentation for SGECON::

 SGECON estimates the reciprocal of the condition number of a general
 real matrix A, in either the 1-norm or the infinity-norm, using
 the LU factorization computed by SGETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_sgecon(ref norm : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgecon

Original Fortran LAPACK documentation for DGECON::

 DGECON estimates the reciprocal of the condition number of a general
 real matrix A, in either the 1-norm or the infinity-norm, using
 the LU factorization computed by DGETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_dgecon(ref norm : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgecon

Original Fortran LAPACK documentation for CGECON::

 CGECON estimates the reciprocal of the condition number of a general
 complex matrix A, in either the 1-norm or the infinity-norm, using
 the LU factorization computed by CGETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_cgecon(ref norm : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgecon

Original Fortran LAPACK documentation for ZGECON::

 ZGECON estimates the reciprocal of the condition number of a general
 complex matrix A, in either the 1-norm or the infinity-norm, using
 the LU factorization computed by ZGETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_zgecon(ref norm : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbcon

Original Fortran LAPACK documentation for SGBCON::

 SGBCON estimates the reciprocal of the condition number of a real
 general band matrix A, in either the 1-norm or the infinity-norm,
 using the LU factorization computed by SGBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_sgbcon(ref norm : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_float, ref ldab : c_int, ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbcon

Original Fortran LAPACK documentation for DGBCON::

 DGBCON estimates the reciprocal of the condition number of a real
 general band matrix A, in either the 1-norm or the infinity-norm,
 using the LU factorization computed by DGBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_dgbcon(ref norm : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_double, ref ldab : c_int, ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbcon

Original Fortran LAPACK documentation for CGBCON::

 CGBCON estimates the reciprocal of the condition number of a complex
 general band matrix A, in either the 1-norm or the infinity-norm,
 using the LU factorization computed by CGBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_cgbcon(ref norm : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(64), ref ldab : c_int, ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbcon

Original Fortran LAPACK documentation for ZGBCON::

 ZGBCON estimates the reciprocal of the condition number of a complex
 general band matrix A, in either the 1-norm or the infinity-norm,
 using the LU factorization computed by ZGBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_zgbcon(ref norm : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(128), ref ldab : c_int, ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgtcon

Original Fortran LAPACK documentation for SGTCON::

 SGTCON estimates the reciprocal of the condition number of a real
 tridiagonal matrix A using the LU factorization as computed by
 SGTTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_sgtcon(ref norm : c_char, ref n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgtcon

Original Fortran LAPACK documentation for DGTCON::

 DGTCON estimates the reciprocal of the condition number of a real
 tridiagonal matrix A using the LU factorization as computed by
 DGTTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_dgtcon(ref norm : c_char, ref n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgtcon

Original Fortran LAPACK documentation for CGTCON::

 CGTCON estimates the reciprocal of the condition number of a complex
 tridiagonal matrix A using the LU factorization as computed by
 CGTTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_cgtcon(ref norm : c_char, ref n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgtcon

Original Fortran LAPACK documentation for ZGTCON::

 ZGTCON estimates the reciprocal of the condition number of a complex
 tridiagonal matrix A using the LU factorization as computed by
 ZGTTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_zgtcon(ref norm : c_char, ref n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spocon

Original Fortran LAPACK documentation for SPOCON::

 SPOCON estimates the reciprocal of the condition number (in the 
 1-norm) of a real symmetric positive definite matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_spocon(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpocon

Original Fortran LAPACK documentation for DPOCON::

 DPOCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by DPOTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_dpocon(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpocon

Original Fortran LAPACK documentation for CPOCON::

 CPOCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite matrix using the
 Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_cpocon(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpocon

Original Fortran LAPACK documentation for ZPOCON::

 ZPOCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite matrix using the
 Cholesky factorization A = U**H*U or A = L*L**H computed by ZPOTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_zpocon(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sppcon

Original Fortran LAPACK documentation for SPPCON::

 SPPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite packed matrix using
 the Cholesky factorization A = U**T*U or A = L*L**T computed by
 SPPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_sppcon(ref uplo : c_char, ref n : c_int, ap : [] c_float, ref anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dppcon

Original Fortran LAPACK documentation for DPPCON::

 DPPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite packed matrix using
 the Cholesky factorization A = U**T*U or A = L*L**T computed by
 DPPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_dppcon(ref uplo : c_char, ref n : c_int, ap : [] c_double, ref anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cppcon

Original Fortran LAPACK documentation for CPPCON::

 CPPCON estimates the reciprocal of the condition number (in the 
 1-norm) of a complex Hermitian positive definite packed matrix using
 the Cholesky factorization A = U**H*U or A = L*L**H computed by
 CPPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_cppcon(ref uplo : c_char, ref n : c_int, ap : [] complex(64), ref anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zppcon

Original Fortran LAPACK documentation for ZPPCON::

 ZPPCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite packed matrix using
 the Cholesky factorization A = U**H*U or A = L*L**H computed by
 ZPPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_zppcon(ref uplo : c_char, ref n : c_int, ap : [] complex(128), ref anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spbcon

Original Fortran LAPACK documentation for SPBCON::

 SPBCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite band matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_spbcon(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_float, ref ldab : c_int, ref anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpbcon

Original Fortran LAPACK documentation for DPBCON::

 DPBCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite band matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by DPBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_dpbcon(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_double, ref ldab : c_int, ref anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpbcon

Original Fortran LAPACK documentation for CPBCON::

 CPBCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite band matrix using
 the Cholesky factorization A = U**H*U or A = L*L**H computed by
 CPBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_cpbcon(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(64), ref ldab : c_int, ref anorm : c_float, ref rcond : c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpbcon

Original Fortran LAPACK documentation for ZPBCON::

 ZPBCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite band matrix using
 the Cholesky factorization A = U**H*U or A = L*L**H computed by
 ZPBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_zpbcon(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(128), ref ldab : c_int, ref anorm : c_double, ref rcond : c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sptcon

Original Fortran LAPACK documentation for SPTCON::

 SPTCON computes the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite tridiagonal matrix
 using the factorization A = L*D*L**T or A = U**T*D*U computed by
 SPTTRF.

 Norm(inv(A)) is computed by a direct method, and the reciprocal of
 the condition number is computed as
 RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_sptcon(ref n : c_int, d : [] c_float, e : [] c_float, ref anorm : c_float, ref rcond : c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dptcon

Original Fortran LAPACK documentation for DPTCON::

 DPTCON computes the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite tridiagonal matrix
 using the factorization A = L*D*L**T or A = U**T*D*U computed by
 DPTTRF.

 Norm(inv(A)) is computed by a direct method, and the reciprocal of
 the condition number is computed as
 RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_dptcon(ref n : c_int, d : [] c_double, e : [] c_double, ref anorm : c_double, ref rcond : c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cptcon

Original Fortran LAPACK documentation for CPTCON::

 CPTCON computes the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite tridiagonal matrix
 using the factorization A = L*D*L**H or A = U**H*D*U computed by
 CPTTRF.

 Norm(inv(A)) is computed by a direct method, and the reciprocal of
 the condition number is computed as
 RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_cptcon(ref n : c_int, d : [] c_float, e : [] complex(64), ref anorm : c_float, ref rcond : c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zptcon

Original Fortran LAPACK documentation for ZPTCON::

 ZPTCON computes the reciprocal of the condition number (in the
 1-norm) of a complex Hermitian positive definite tridiagonal matrix
 using the factorization A = L*D*L**H or A = U**H*D*U computed by
 ZPTTRF.

 Norm(inv(A)) is computed by a direct method, and the reciprocal of
 the condition number is computed as
 RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_zptcon(ref n : c_int, d : [] c_double, e : [] complex(128), ref anorm : c_double, ref rcond : c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssycon

Original Fortran LAPACK documentation for SSYCON::

 SSYCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by SSYTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_ssycon(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsycon

Original Fortran LAPACK documentation for DSYCON::

 DSYCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by DSYTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_dsycon(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csycon

Original Fortran LAPACK documentation for CSYCON::

 CSYCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex symmetric matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by CSYTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_csycon(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsycon

Original Fortran LAPACK documentation for ZSYCON::

 ZSYCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex symmetric matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by ZSYTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_zsycon(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_checon

Original Fortran LAPACK documentation for CHECON::

 CHECON estimates the reciprocal of the condition number of a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_checon(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhecon

Original Fortran LAPACK documentation for ZHECON::

 ZHECON estimates the reciprocal of the condition number of a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_zhecon(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspcon

Original Fortran LAPACK documentation for SSPCON::

 SSPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric packed matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by SSPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_sspcon(ref uplo : c_char, ref n : c_int, ap : [] c_float, ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspcon

Original Fortran LAPACK documentation for DSPCON::

 DSPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric packed matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by DSPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_dspcon(ref uplo : c_char, ref n : c_int, ap : [] c_double, ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cspcon

Original Fortran LAPACK documentation for CSPCON::

 CSPCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex symmetric packed matrix A using the
 factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_cspcon(ref uplo : c_char, ref n : c_int, ap : [] complex(64), ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zspcon

Original Fortran LAPACK documentation for ZSPCON::

 ZSPCON estimates the reciprocal of the condition number (in the
 1-norm) of a complex symmetric packed matrix A using the
 factorization A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_zspcon(ref uplo : c_char, ref n : c_int, ap : [] complex(128), ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpcon

Original Fortran LAPACK documentation for CHPCON::

 CHPCON estimates the reciprocal of the condition number of a complex
 Hermitian packed matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_chpcon(ref uplo : c_char, ref n : c_int, ap : [] complex(64), ipiv : [] c_int, ref anorm : c_float, ref rcond : c_float, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpcon

Original Fortran LAPACK documentation for ZHPCON::

 ZHPCON estimates the reciprocal of the condition number of a complex
 Hermitian packed matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

 */
extern proc LAPACK_zhpcon(ref uplo : c_char, ref n : c_int, ap : [] complex(128), ipiv : [] c_int, ref anorm : c_double, ref rcond : c_double, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strcon

Original Fortran LAPACK documentation for STRCON::

 STRCON estimates the reciprocal of the condition number of a
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_strcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrcon

Original Fortran LAPACK documentation for DTRCON::

 DTRCON estimates the reciprocal of the condition number of a
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_dtrcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrcon

Original Fortran LAPACK documentation for CTRCON::

 CTRCON estimates the reciprocal of the condition number of a
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_ctrcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref rcond : c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrcon

Original Fortran LAPACK documentation for ZTRCON::

 ZTRCON estimates the reciprocal of the condition number of a
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_ztrcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref rcond : c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stpcon

Original Fortran LAPACK documentation for STPCON::

 STPCON estimates the reciprocal of the condition number of a packed
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_stpcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, ap : [] c_float, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtpcon

Original Fortran LAPACK documentation for DTPCON::

 DTPCON estimates the reciprocal of the condition number of a packed
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_dtpcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, ap : [] c_double, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctpcon

Original Fortran LAPACK documentation for CTPCON::

 CTPCON estimates the reciprocal of the condition number of a packed
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_ctpcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, ap : [] complex(64), ref rcond : c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztpcon

Original Fortran LAPACK documentation for ZTPCON::

 ZTPCON estimates the reciprocal of the condition number of a packed
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_ztpcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, ap : [] complex(128), ref rcond : c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stbcon

Original Fortran LAPACK documentation for STBCON::

 STBCON estimates the reciprocal of the condition number of a
 triangular band matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_stbcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ab : [] c_float, ref ldab : c_int, ref rcond : c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtbcon

Original Fortran LAPACK documentation for DTBCON::

 DTBCON estimates the reciprocal of the condition number of a
 triangular band matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_dtbcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ab : [] c_double, ref ldab : c_int, ref rcond : c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctbcon

Original Fortran LAPACK documentation for CTBCON::

 CTBCON estimates the reciprocal of the condition number of a
 triangular band matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_ctbcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(64), ref ldab : c_int, ref rcond : c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztbcon

Original Fortran LAPACK documentation for ZTBCON::

 ZTBCON estimates the reciprocal of the condition number of a
 triangular band matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

 */
extern proc LAPACK_ztbcon(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(128), ref ldab : c_int, ref rcond : c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgerfs

Original Fortran LAPACK documentation for SGERFS::

 SGERFS improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates for
 the solution.

 */
extern proc LAPACK_sgerfs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgerfs

Original Fortran LAPACK documentation for DGERFS::

 DGERFS improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates for
 the solution.

 */
extern proc LAPACK_dgerfs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgerfs

Original Fortran LAPACK documentation for CGERFS::

 CGERFS improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates for
 the solution.

 */
extern proc LAPACK_cgerfs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgerfs

Original Fortran LAPACK documentation for ZGERFS::

 ZGERFS improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates for
 the solution.

 */
extern proc LAPACK_zgerfs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgerfsx

Original Fortran LAPACK documentation for DGERFSX::

 DGERFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACK_dgerfsx(ref trans : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgerfsx

Original Fortran LAPACK documentation for SGERFSX::

 SGERFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACK_sgerfsx(ref trans : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgerfsx

Original Fortran LAPACK documentation for ZGERFSX::

 ZGERFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACK_zgerfsx(ref trans : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgerfsx

Original Fortran LAPACK documentation for CGERFSX::

 CGERFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACK_cgerfsx(ref trans : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbrfs

Original Fortran LAPACK documentation for SGBRFS::

 SGBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is banded, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_sgbrfs(ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, afb : [] c_float, ref ldafb : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbrfs

Original Fortran LAPACK documentation for DGBRFS::

 DGBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is banded, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_dgbrfs(ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, afb : [] c_double, ref ldafb : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbrfs

Original Fortran LAPACK documentation for CGBRFS::

 CGBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is banded, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_cgbrfs(ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, afb : [] complex(64), ref ldafb : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbrfs

Original Fortran LAPACK documentation for ZGBRFS::

 ZGBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is banded, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_zgbrfs(ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, afb : [] complex(128), ref ldafb : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbrfsx

Original Fortran LAPACK documentation for DGBRFSX::

 DGBRFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACK_dgbrfsx(ref trans : c_char, ref equed : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, afb : [] c_double, ref ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbrfsx

Original Fortran LAPACK documentation for SGBRFSX::

 SGBRFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACK_sgbrfsx(ref trans : c_char, ref equed : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, afb : [] c_float, ref ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbrfsx

Original Fortran LAPACK documentation for ZGBRFSX::

 ZGBRFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACK_zgbrfsx(ref trans : c_char, ref equed : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, afb : [] complex(128), ref ldafb : c_int, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbrfsx

Original Fortran LAPACK documentation for CGBRFSX::

 CGBRFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

 */
extern proc LAPACK_cgbrfsx(ref trans : c_char, ref equed : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, afb : [] complex(64), ref ldafb : c_int, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgtrfs

Original Fortran LAPACK documentation for SGTRFS::

 SGTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is tridiagonal, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_sgtrfs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgtrfs

Original Fortran LAPACK documentation for DGTRFS::

 DGTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is tridiagonal, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_dgtrfs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgtrfs

Original Fortran LAPACK documentation for CGTRFS::

 CGTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is tridiagonal, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_cgtrfs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgtrfs

Original Fortran LAPACK documentation for ZGTRFS::

 ZGTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is tridiagonal, and provides
 error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_zgtrfs(ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sporfs

Original Fortran LAPACK documentation for SPORFS::

 SPORFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite,
 and provides error bounds and backward error estimates for the
 solution.

 */
extern proc LAPACK_sporfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dporfs

Original Fortran LAPACK documentation for DPORFS::

 DPORFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite,
 and provides error bounds and backward error estimates for the
 solution.

 */
extern proc LAPACK_dporfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cporfs

Original Fortran LAPACK documentation for CPORFS::

 CPORFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite,
 and provides error bounds and backward error estimates for the
 solution.

 */
extern proc LAPACK_cporfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zporfs

Original Fortran LAPACK documentation for ZPORFS::

 ZPORFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite,
 and provides error bounds and backward error estimates for the
 solution.

 */
extern proc LAPACK_zporfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dporfsx

Original Fortran LAPACK documentation for DPORFSX::

 DPORFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive
 definite, and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_dporfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, s : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sporfsx

Original Fortran LAPACK documentation for SPORFSX::

 SPORFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive
 definite, and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_sporfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, s : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zporfsx

Original Fortran LAPACK documentation for ZPORFSX::

 ZPORFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive
 definite, and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_zporfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, s : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cporfsx

Original Fortran LAPACK documentation for CPORFSX::

 CPORFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive
 definite, and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_cporfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, s : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spprfs

Original Fortran LAPACK documentation for SPPRFS::

 SPPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_spprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, afp : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpprfs

Original Fortran LAPACK documentation for DPPRFS::

 DPPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_dpprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, afp : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpprfs

Original Fortran LAPACK documentation for CPPRFS::

 CPPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_cpprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), afp : [] complex(64), b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpprfs

Original Fortran LAPACK documentation for ZPPRFS::

 ZPPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_zpprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), afp : [] complex(128), b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spbrfs

Original Fortran LAPACK documentation for SPBRFS::

 SPBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and banded, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_spbrfs(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, afb : [] c_float, ref ldafb : c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpbrfs

Original Fortran LAPACK documentation for DPBRFS::

 DPBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and banded, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_dpbrfs(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, afb : [] c_double, ref ldafb : c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpbrfs

Original Fortran LAPACK documentation for CPBRFS::

 CPBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and banded, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_cpbrfs(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, afb : [] complex(64), ref ldafb : c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpbrfs

Original Fortran LAPACK documentation for ZPBRFS::

 ZPBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and banded, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_zpbrfs(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, afb : [] complex(128), ref ldafb : c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sptrfs

Original Fortran LAPACK documentation for SPTRFS::

 SPTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and tridiagonal, and provides error bounds and backward error
 estimates for the solution.

 */
extern proc LAPACK_sptrfs(ref n : c_int, ref nrhs : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dptrfs

Original Fortran LAPACK documentation for DPTRFS::

 DPTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and tridiagonal, and provides error bounds and backward error
 estimates for the solution.

 */
extern proc LAPACK_dptrfs(ref n : c_int, ref nrhs : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cptrfs

Original Fortran LAPACK documentation for CPTRFS::

 CPTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and tridiagonal, and provides error bounds and backward error
 estimates for the solution.

 */
extern proc LAPACK_cptrfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zptrfs

Original Fortran LAPACK documentation for ZPTRFS::

 ZPTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian positive definite
 and tridiagonal, and provides error bounds and backward error
 estimates for the solution.

 */
extern proc LAPACK_zptrfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssyrfs

Original Fortran LAPACK documentation for SSYRFS::

 SSYRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_ssyrfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsyrfs

Original Fortran LAPACK documentation for DSYRFS::

 DSYRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_dsyrfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csyrfs

Original Fortran LAPACK documentation for CSYRFS::

 CSYRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_csyrfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsyrfs

Original Fortran LAPACK documentation for ZSYRFS::

 ZSYRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_zsyrfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsyrfsx

Original Fortran LAPACK documentation for DSYRFSX::

 DSYRFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_dsyrfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssyrfsx

Original Fortran LAPACK documentation for SSYRFSX::

 SSYRFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_ssyrfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsyrfsx

Original Fortran LAPACK documentation for ZSYRFSX::

 ZSYRFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_zsyrfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csyrfsx

Original Fortran LAPACK documentation for CSYRFSX::

 CSYRFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_csyrfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cherfs

Original Fortran LAPACK documentation for CHERFS::

 CHERFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_cherfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zherfs

Original Fortran LAPACK documentation for ZHERFS::

 ZHERFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the solution.

 */
extern proc LAPACK_zherfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zherfsx

Original Fortran LAPACK documentation for ZHERFSX::

 ZHERFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_zherfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, s : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cherfsx

Original Fortran LAPACK documentation for CHERFSX::

 CHERFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

 */
extern proc LAPACK_cherfsx(ref uplo : c_char, ref equed : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, s : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssprfs

Original Fortran LAPACK documentation for SSPRFS::

 SSPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_ssprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsprfs

Original Fortran LAPACK documentation for DSPRFS::

 DSPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_dsprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csprfs

Original Fortran LAPACK documentation for CSPRFS::

 CSPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_csprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsprfs

Original Fortran LAPACK documentation for ZSPRFS::

 ZSPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_zsprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chprfs

Original Fortran LAPACK documentation for CHPRFS::

 CHPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_chprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhprfs

Original Fortran LAPACK documentation for ZHPRFS::

 ZHPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

 */
extern proc LAPACK_zhprfs(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strrfs

Original Fortran LAPACK documentation for STRRFS::

 STRRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular
 coefficient matrix.

 The solution matrix X must be computed by STRTRS or some other
 means before entering this routine. STRRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_strrfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrrfs

Original Fortran LAPACK documentation for DTRRFS::

 DTRRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular
 coefficient matrix.

 The solution matrix X must be computed by DTRTRS or some other
 means before entering this routine. DTRRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_dtrrfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrrfs

Original Fortran LAPACK documentation for CTRRFS::

 CTRRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular
 coefficient matrix.

 The solution matrix X must be computed by CTRTRS or some other
 means before entering this routine. CTRRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_ctrrfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrrfs

Original Fortran LAPACK documentation for ZTRRFS::

 ZTRRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular
 coefficient matrix.

 The solution matrix X must be computed by ZTRTRS or some other
 means before entering this routine. ZTRRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_ztrrfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stprfs

Original Fortran LAPACK documentation for STPRFS::

 STPRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular packed
 coefficient matrix.

 The solution matrix X must be computed by STPTRS or some other
 means before entering this routine. STPRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_stprfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtprfs

Original Fortran LAPACK documentation for DTPRFS::

 DTPRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular packed
 coefficient matrix.

 The solution matrix X must be computed by DTPTRS or some other
 means before entering this routine. DTPRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_dtprfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctprfs

Original Fortran LAPACK documentation for CTPRFS::

 CTPRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular packed
 coefficient matrix.

 The solution matrix X must be computed by CTPTRS or some other
 means before entering this routine. CTPRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_ctprfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztprfs

Original Fortran LAPACK documentation for ZTPRFS::

 ZTPRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular packed
 coefficient matrix.

 The solution matrix X must be computed by ZTPTRS or some other
 means before entering this routine. ZTPRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_ztprfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stbrfs

Original Fortran LAPACK documentation for STBRFS::

 STBRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular band
 coefficient matrix.

 The solution matrix X must be computed by STBTRS or some other
 means before entering this routine. STBRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_stbrfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtbrfs

Original Fortran LAPACK documentation for DTBRFS::

 DTBRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular band
 coefficient matrix.

 The solution matrix X must be computed by DTBTRS or some other
 means before entering this routine. DTBRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_dtbrfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctbrfs

Original Fortran LAPACK documentation for CTBRFS::

 CTBRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular band
 coefficient matrix.

 The solution matrix X must be computed by CTBTRS or some other
 means before entering this routine. CTBRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_ctbrfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztbrfs

Original Fortran LAPACK documentation for ZTBRFS::

 ZTBRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular band
 coefficient matrix.

 The solution matrix X must be computed by ZTBTRS or some other
 means before entering this routine. ZTBRFS does not do iterative
 refinement because doing so cannot improve the backward error.

 */
extern proc LAPACK_ztbrfs(ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgetri

Original Fortran LAPACK documentation for SGETRI::

 SGETRI computes the inverse of a matrix using the LU factorization
 computed by SGETRF.

 This method inverts U and then computes inv(A) by solving the system
 inv(A)*L = inv(U) for inv(A).

 */
extern proc LAPACK_sgetri(ref n : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgetri

Original Fortran LAPACK documentation for DGETRI::

 DGETRI computes the inverse of a matrix using the LU factorization
 computed by DGETRF.

 This method inverts U and then computes inv(A) by solving the system
 inv(A)*L = inv(U) for inv(A).

 */
extern proc LAPACK_dgetri(ref n : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgetri

Original Fortran LAPACK documentation for CGETRI::

 CGETRI computes the inverse of a matrix using the LU factorization
 computed by CGETRF.

 This method inverts U and then computes inv(A) by solving the system
 inv(A)*L = inv(U) for inv(A).

 */
extern proc LAPACK_cgetri(ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgetri

Original Fortran LAPACK documentation for ZGETRI::

 ZGETRI computes the inverse of a matrix using the LU factorization
 computed by ZGETRF.

 This method inverts U and then computes inv(A) by solving the system
 inv(A)*L = inv(U) for inv(A).

 */
extern proc LAPACK_zgetri(ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spotri

Original Fortran LAPACK documentation for SPOTRI::

 SPOTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by SPOTRF.

 */
extern proc LAPACK_spotri(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpotri

Original Fortran LAPACK documentation for DPOTRI::

 DPOTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by DPOTRF.

 */
extern proc LAPACK_dpotri(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpotri

Original Fortran LAPACK documentation for CPOTRI::

 CPOTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by CPOTRF.

 */
extern proc LAPACK_cpotri(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpotri

Original Fortran LAPACK documentation for ZPOTRI::

 ZPOTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by ZPOTRF.

 */
extern proc LAPACK_zpotri(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpftri

Original Fortran LAPACK documentation for DPFTRI::

 DPFTRI computes the inverse of a (real) symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by DPFTRF.

 */
extern proc LAPACK_dpftri(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spftri

Original Fortran LAPACK documentation for SPFTRI::

 SPFTRI computes the inverse of a real (symmetric) positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by SPFTRF.

 */
extern proc LAPACK_spftri(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpftri

Original Fortran LAPACK documentation for ZPFTRI::

 ZPFTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by ZPFTRF.

 */
extern proc LAPACK_zpftri(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpftri

Original Fortran LAPACK documentation for CPFTRI::

 CPFTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by CPFTRF.

 */
extern proc LAPACK_cpftri(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spptri

Original Fortran LAPACK documentation for SPPTRI::

 SPPTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by SPPTRF.

 */
extern proc LAPACK_spptri(ref uplo : c_char, ref n : c_int, ap : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpptri

Original Fortran LAPACK documentation for DPPTRI::

 DPPTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by DPPTRF.

 */
extern proc LAPACK_dpptri(ref uplo : c_char, ref n : c_int, ap : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpptri

Original Fortran LAPACK documentation for CPPTRI::

 CPPTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by CPPTRF.

 */
extern proc LAPACK_cpptri(ref uplo : c_char, ref n : c_int, ap : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpptri

Original Fortran LAPACK documentation for ZPPTRI::

 ZPPTRI computes the inverse of a complex Hermitian positive definite
 matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
 computed by ZPPTRF.

 */
extern proc LAPACK_zpptri(ref uplo : c_char, ref n : c_int, ap : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssytri

Original Fortran LAPACK documentation for SSYTRI::

 SSYTRI computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 SSYTRF.

 */
extern proc LAPACK_ssytri(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsytri

Original Fortran LAPACK documentation for DSYTRI::

 DSYTRI computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 DSYTRF.

 */
extern proc LAPACK_dsytri(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csytri

Original Fortran LAPACK documentation for CSYTRI::

 CSYTRI computes the inverse of a complex symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CSYTRF.

 */
extern proc LAPACK_csytri(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsytri

Original Fortran LAPACK documentation for ZSYTRI::

 ZSYTRI computes the inverse of a complex symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 ZSYTRF.

 */
extern proc LAPACK_zsytri(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chetri

Original Fortran LAPACK documentation for CHETRI::

 CHETRI computes the inverse of a complex Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 CHETRF.

 */
extern proc LAPACK_chetri(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhetri

Original Fortran LAPACK documentation for ZHETRI::

 ZHETRI computes the inverse of a complex Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 ZHETRF.

 */
extern proc LAPACK_zhetri(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssptri

Original Fortran LAPACK documentation for SSPTRI::

 SSPTRI computes the inverse of a real symmetric indefinite matrix
 A in packed storage using the factorization A = U*D*U**T or
 A = L*D*L**T computed by SSPTRF.

 */
extern proc LAPACK_ssptri(ref uplo : c_char, ref n : c_int, ap : [] c_float, ipiv : [] c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsptri

Original Fortran LAPACK documentation for DSPTRI::

 DSPTRI computes the inverse of a real symmetric indefinite matrix
 A in packed storage using the factorization A = U*D*U**T or
 A = L*D*L**T computed by DSPTRF.

 */
extern proc LAPACK_dsptri(ref uplo : c_char, ref n : c_int, ap : [] c_double, ipiv : [] c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csptri

Original Fortran LAPACK documentation for CSPTRI::

 CSPTRI computes the inverse of a complex symmetric indefinite matrix
 A in packed storage using the factorization A = U*D*U**T or
 A = L*D*L**T computed by CSPTRF.

 */
extern proc LAPACK_csptri(ref uplo : c_char, ref n : c_int, ap : [] complex(64), ipiv : [] c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsptri

Original Fortran LAPACK documentation for ZSPTRI::

 ZSPTRI computes the inverse of a complex symmetric indefinite matrix
 A in packed storage using the factorization A = U*D*U**T or
 A = L*D*L**T computed by ZSPTRF.

 */
extern proc LAPACK_zsptri(ref uplo : c_char, ref n : c_int, ap : [] complex(128), ipiv : [] c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chptri

Original Fortran LAPACK documentation for CHPTRI::

 CHPTRI computes the inverse of a complex Hermitian indefinite matrix
 A in packed storage using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHPTRF.

 */
extern proc LAPACK_chptri(ref uplo : c_char, ref n : c_int, ap : [] complex(64), ipiv : [] c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhptri

Original Fortran LAPACK documentation for ZHPTRI::

 ZHPTRI computes the inverse of a complex Hermitian indefinite matrix
 A in packed storage using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHPTRF.

 */
extern proc LAPACK_zhptri(ref uplo : c_char, ref n : c_int, ap : [] complex(128), ipiv : [] c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strtri

Original Fortran LAPACK documentation for STRTRI::

 STRTRI computes the inverse of a real upper or lower triangular
 matrix A.

 This is the Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_strtri(ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrtri

Original Fortran LAPACK documentation for DTRTRI::

 DTRTRI computes the inverse of a real upper or lower triangular
 matrix A.

 This is the Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_dtrtri(ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrtri

Original Fortran LAPACK documentation for CTRTRI::

 CTRTRI computes the inverse of a complex upper or lower triangular
 matrix A.

 This is the Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_ctrtri(ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrtri

Original Fortran LAPACK documentation for ZTRTRI::

 ZTRTRI computes the inverse of a complex upper or lower triangular
 matrix A.

 This is the Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_ztrtri(ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtftri

Original Fortran LAPACK documentation for DTFTRI::

 DTFTRI computes the inverse of a triangular matrix A stored in RFP
 format.

 This is a Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_dtftri(ref transr : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stftri

Original Fortran LAPACK documentation for STFTRI::

 STFTRI computes the inverse of a triangular matrix A stored in RFP
 format.

 This is a Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_stftri(ref transr : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztftri

Original Fortran LAPACK documentation for ZTFTRI::

 ZTFTRI computes the inverse of a triangular matrix A stored in RFP
 format.

 This is a Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_ztftri(ref transr : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctftri

Original Fortran LAPACK documentation for CTFTRI::

 CTFTRI computes the inverse of a triangular matrix A stored in RFP
 format.

 This is a Level 3 BLAS version of the algorithm.

 */
extern proc LAPACK_ctftri(ref transr : c_char, ref uplo : c_char, ref diag : c_char, ref n : c_int, a : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stptri

Original Fortran LAPACK documentation for STPTRI::

 STPTRI computes the inverse of a real upper or lower triangular
 matrix A stored in packed format.

 */
extern proc LAPACK_stptri(ref uplo : c_char, ref diag : c_char, ref n : c_int, ap : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtptri

Original Fortran LAPACK documentation for DTPTRI::

 DTPTRI computes the inverse of a real upper or lower triangular
 matrix A stored in packed format.

 */
extern proc LAPACK_dtptri(ref uplo : c_char, ref diag : c_char, ref n : c_int, ap : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctptri

Original Fortran LAPACK documentation for CTPTRI::

 CTPTRI computes the inverse of a complex upper or lower triangular
 matrix A stored in packed format.

 */
extern proc LAPACK_ctptri(ref uplo : c_char, ref diag : c_char, ref n : c_int, ap : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztptri

Original Fortran LAPACK documentation for ZTPTRI::

 ZTPTRI computes the inverse of a complex upper or lower triangular
 matrix A stored in packed format.

 */
extern proc LAPACK_ztptri(ref uplo : c_char, ref diag : c_char, ref n : c_int, ap : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeequ

Original Fortran LAPACK documentation for SGEEQU::

 SGEEQU computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACK_sgeequ(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeequ

Original Fortran LAPACK documentation for DGEEQU::

 DGEEQU computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACK_dgeequ(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeequ

Original Fortran LAPACK documentation for CGEEQU::

 CGEEQU computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACK_cgeequ(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeequ

Original Fortran LAPACK documentation for ZGEEQU::

 ZGEEQU computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACK_zgeequ(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeequb

Original Fortran LAPACK documentation for DGEEQUB::

 DGEEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from DGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACK_dgeequb(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeequb

Original Fortran LAPACK documentation for SGEEQUB::

 SGEEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from SGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACK_sgeequb(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeequb

Original Fortran LAPACK documentation for ZGEEQUB::

 ZGEEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from ZGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACK_zgeequb(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeequb

Original Fortran LAPACK documentation for CGEEQUB::

 CGEEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from CGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACK_cgeequb(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbequ

Original Fortran LAPACK documentation for SGBEQU::

 SGBEQU computes row and column scalings intended to equilibrate an
 M-by-N band matrix A and reduce its condition number. R returns the
 row scale factors and C the column scale factors, chosen to try to
 make the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACK_sgbequ(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_float, ref ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbequ

Original Fortran LAPACK documentation for DGBEQU::

 DGBEQU computes row and column scalings intended to equilibrate an
 M-by-N band matrix A and reduce its condition number. R returns the
 row scale factors and C the column scale factors, chosen to try to
 make the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACK_dgbequ(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_double, ref ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbequ

Original Fortran LAPACK documentation for CGBEQU::

 CGBEQU computes row and column scalings intended to equilibrate an
 M-by-N band matrix A and reduce its condition number. R returns the
 row scale factors and C the column scale factors, chosen to try to
 make the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACK_cgbequ(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(64), ref ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbequ

Original Fortran LAPACK documentation for ZGBEQU::

 ZGBEQU computes row and column scalings intended to equilibrate an
 M-by-N band matrix A and reduce its condition number. R returns the
 row scale factors and C the column scale factors, chosen to try to
 make the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

 */
extern proc LAPACK_zgbequ(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(128), ref ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbequb

Original Fortran LAPACK documentation for DGBEQUB::

 DGBEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from DGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACK_dgbequb(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_double, ref ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbequb

Original Fortran LAPACK documentation for SGBEQUB::

 SGBEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from SGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACK_sgbequb(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_float, ref ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbequb

Original Fortran LAPACK documentation for ZGBEQUB::

 ZGBEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from ZGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACK_zgbequb(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(128), ref ldab : c_int, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbequb

Original Fortran LAPACK documentation for CGBEQUB::

 CGBEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from CGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

 */
extern proc LAPACK_cgbequb(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(64), ref ldab : c_int, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spoequ

Original Fortran LAPACK documentation for SPOEQU::

 SPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_spoequ(ref n : c_int, a : [] c_float, ref lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpoequ

Original Fortran LAPACK documentation for DPOEQU::

 DPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_dpoequ(ref n : c_int, a : [] c_double, ref lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpoequ

Original Fortran LAPACK documentation for CPOEQU::

 CPOEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_cpoequ(ref n : c_int, a : [] complex(64), ref lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpoequ

Original Fortran LAPACK documentation for ZPOEQU::

 ZPOEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_zpoequ(ref n : c_int, a : [] complex(128), ref lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpoequb

Original Fortran LAPACK documentation for DPOEQUB::

 DPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_dpoequb(ref n : c_int, a : [] c_double, ref lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spoequb

Original Fortran LAPACK documentation for SPOEQUB::

 SPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_spoequb(ref n : c_int, a : [] c_float, ref lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpoequb

Original Fortran LAPACK documentation for ZPOEQUB::

 ZPOEQUB computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_zpoequb(ref n : c_int, a : [] complex(128), ref lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpoequb

Original Fortran LAPACK documentation for CPOEQUB::

 CPOEQUB computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_cpoequb(ref n : c_int, a : [] complex(64), ref lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sppequ

Original Fortran LAPACK documentation for SPPEQU::

 SPPEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A in packed storage and reduce
 its condition number (with respect to the two-norm). S contains the
 scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
 B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
 This choice of S puts the condition number of B within a factor N of
 the smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_sppequ(ref uplo : c_char, ref n : c_int, ap : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dppequ

Original Fortran LAPACK documentation for DPPEQU::

 DPPEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A in packed storage and reduce
 its condition number (with respect to the two-norm). S contains the
 scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
 B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
 This choice of S puts the condition number of B within a factor N of
 the smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_dppequ(ref uplo : c_char, ref n : c_int, ap : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cppequ

Original Fortran LAPACK documentation for CPPEQU::

 CPPEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite matrix A in packed storage and reduce
 its condition number (with respect to the two-norm). S contains the
 scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
 B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
 This choice of S puts the condition number of B within a factor N of
 the smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_cppequ(ref uplo : c_char, ref n : c_int, ap : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zppequ

Original Fortran LAPACK documentation for ZPPEQU::

 ZPPEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite matrix A in packed storage and reduce
 its condition number (with respect to the two-norm). S contains the
 scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
 B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
 This choice of S puts the condition number of B within a factor N of
 the smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_zppequ(ref uplo : c_char, ref n : c_int, ap : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spbequ

Original Fortran LAPACK documentation for SPBEQU::

 SPBEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite band matrix A and reduce its condition
 number (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_spbequ(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_float, ref ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpbequ

Original Fortran LAPACK documentation for DPBEQU::

 DPBEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite band matrix A and reduce its condition
 number (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_dpbequ(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_double, ref ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpbequ

Original Fortran LAPACK documentation for CPBEQU::

 CPBEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite band matrix A and reduce its condition
 number (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_cpbequ(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(64), ref ldab : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpbequ

Original Fortran LAPACK documentation for ZPBEQU::

 ZPBEQU computes row and column scalings intended to equilibrate a
 Hermitian positive definite band matrix A and reduce its condition
 number (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_zpbequ(ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(128), ref ldab : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsyequb

Original Fortran LAPACK documentation for DSYEQUB::

 DSYEQUB computes row and column scalings intended to equilibrate a
 symmetric matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_dsyequb(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssyequb

Original Fortran LAPACK documentation for SSYEQUB::

 SSYEQUB computes row and column scalings intended to equilibrate a
 symmetric matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_ssyequb(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsyequb

Original Fortran LAPACK documentation for ZSYEQUB::

 ZSYEQUB computes row and column scalings intended to equilibrate a
 symmetric matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_zsyequb(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csyequb

Original Fortran LAPACK documentation for CSYEQUB::

 CSYEQUB computes row and column scalings intended to equilibrate a
 symmetric matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_csyequb(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zheequb

Original Fortran LAPACK documentation for ZHEEQUB::

 ZHEEQUB computes row and column scalings intended to equilibrate a
 Hermitian matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_zheequb(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, s : [] c_double, ref scond : c_double, ref amax : c_double, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cheequb

Original Fortran LAPACK documentation for CHEEQUB::

 CHEEQUB computes row and column scalings intended to equilibrate a
 Hermitian matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

 */
extern proc LAPACK_cheequb(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, s : [] c_float, ref scond : c_float, ref amax : c_float, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgesv

Original Fortran LAPACK documentation for SGESV::

 SGESV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as
 A = P * L * U,
 where P is a permutation matrix, L is unit lower triangular, and U is
 upper triangular. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACK_sgesv(ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgesv

Original Fortran LAPACK documentation for DGESV::

 DGESV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as
 A = P * L * U,
 where P is a permutation matrix, L is unit lower triangular, and U is
 upper triangular. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACK_dgesv(ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgesv

Original Fortran LAPACK documentation for CGESV::

 CGESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as
 A = P * L * U,
 where P is a permutation matrix, L is unit lower triangular, and U is
 upper triangular. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACK_cgesv(ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgesv

Original Fortran LAPACK documentation for ZGESV::

 ZGESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as
 A = P * L * U,
 where P is a permutation matrix, L is unit lower triangular, and U is
 upper triangular. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACK_zgesv(ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsgesv

Original Fortran LAPACK documentation for DSGESV::

 DSGESV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 DSGESV first attempts to factorize the matrix in SINGLE PRECISION
 and use this factorization within an iterative refinement procedure
 to produce a solution with DOUBLE PRECISION normwise backward error
 quality (see below). If the approach fails the method switches to a
 DOUBLE PRECISION factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio SINGLE PRECISION performance over DOUBLE PRECISION
 performance is too small. A reasonable strategy should take the
 number of right-hand sides and the size of the matrix into account.
 This might be done with a call to ILAENV in the future. Up to now, we
 always try iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

 */
extern proc LAPACK_dsgesv(ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, work : [] c_double, swork : [] c_float, ref chlapack_iter : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zcgesv

Original Fortran LAPACK documentation for ZCGESV::

 ZCGESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 ZCGESV first attempts to factorize the matrix in COMPLEX and use this
 factorization within an iterative refinement procedure to produce a
 solution with COMPLEX*16 normwise backward error quality (see below).
 If the approach fails the method switches to a COMPLEX*16
 factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio COMPLEX performance over COMPLEX*16 performance is too
 small. A reasonable strategy should take the number of right-hand
 sides and the size of the matrix into account. This might be done
 with a call to ILAENV in the future. Up to now, we always try
 iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

 */
extern proc LAPACK_zcgesv(ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, work : [] complex(128), swork : [] complex(64), rwork : [] c_double, ref chlapack_iter : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgesvx

Original Fortran LAPACK documentation for SGESVX::

 SGESVX uses the LU factorization to compute the solution to a real
 system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_sgesvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgesvx

Original Fortran LAPACK documentation for DGESVX::

 DGESVX uses the LU factorization to compute the solution to a real
 system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_dgesvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgesvx

Original Fortran LAPACK documentation for CGESVX::

 CGESVX uses the LU factorization to compute the solution to a complex
 system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_cgesvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgesvx

Original Fortran LAPACK documentation for ZGESVX::

 ZGESVX uses the LU factorization to compute the solution to a complex
 system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zgesvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgesvxx

Original Fortran LAPACK documentation for DGESVXX::

 DGESVXX uses the LU factorization to compute the solution to a
 double precision system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. DGESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 DGESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 DGESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what DGESVXX would itself produce.

 */
extern proc LAPACK_dgesvxx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgesvxx

Original Fortran LAPACK documentation for SGESVXX::

 SGESVXX uses the LU factorization to compute the solution to a
 real system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SGESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SGESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SGESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SGESVXX would itself produce.

 */
extern proc LAPACK_sgesvxx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgesvxx

Original Fortran LAPACK documentation for ZGESVXX::

 ZGESVXX uses the LU factorization to compute the solution to a
 complex*16 system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZGESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZGESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZGESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZGESVXX would itself produce.

 */
extern proc LAPACK_zgesvxx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgesvxx

Original Fortran LAPACK documentation for CGESVXX::

 CGESVXX uses the LU factorization to compute the solution to a
 complex system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CGESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CGESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CGESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CGESVXX would itself produce.

 */
extern proc LAPACK_cgesvxx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbsv

Original Fortran LAPACK documentation for SGBSV::

 SGBSV computes the solution to a real system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals. The factored form of A
 is then used to solve the system of equations A * X = B.

 */
extern proc LAPACK_sgbsv(ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbsv

Original Fortran LAPACK documentation for DGBSV::

 DGBSV computes the solution to a real system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals. The factored form of A
 is then used to solve the system of equations A * X = B.

 */
extern proc LAPACK_dgbsv(ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbsv

Original Fortran LAPACK documentation for CGBSV::

 CGBSV computes the solution to a complex system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals. The factored form of A
 is then used to solve the system of equations A * X = B.

 */
extern proc LAPACK_cgbsv(ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbsv

Original Fortran LAPACK documentation for ZGBSV::

 ZGBSV computes the solution to a complex system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals. The factored form of A
 is then used to solve the system of equations A * X = B.

 */
extern proc LAPACK_zgbsv(ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbsvx

Original Fortran LAPACK documentation for SGBSVX::

 SGBSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a band matrix of order N with KL subdiagonals and KU
 superdiagonals, and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_sgbsvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, afb : [] c_float, ref ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbsvx

Original Fortran LAPACK documentation for DGBSVX::

 DGBSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a band matrix of order N with KL subdiagonals and KU
 superdiagonals, and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_dgbsvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, afb : [] c_double, ref ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbsvx

Original Fortran LAPACK documentation for CGBSVX::

 CGBSVX uses the LU factorization to compute the solution to a complex
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a band matrix of order N with KL subdiagonals and KU
 superdiagonals, and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_cgbsvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, afb : [] complex(64), ref ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbsvx

Original Fortran LAPACK documentation for ZGBSVX::

 ZGBSVX uses the LU factorization to compute the solution to a complex
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a band matrix of order N with KL subdiagonals and KU
 superdiagonals, and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zgbsvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, afb : [] complex(128), ref ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbsvxx

Original Fortran LAPACK documentation for DGBSVXX::

 DGBSVXX uses the LU factorization to compute the solution to a
 double precision system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. DGBSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 DGBSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 DGBSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what DGBSVXX would itself produce.

 */
extern proc LAPACK_dgbsvxx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, afb : [] c_double, ref ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbsvxx

Original Fortran LAPACK documentation for SGBSVXX::

 SGBSVXX uses the LU factorization to compute the solution to a
 real system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SGBSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SGBSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SGBSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SGBSVXX would itself produce.

 */
extern proc LAPACK_sgbsvxx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, afb : [] c_float, ref ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbsvxx

Original Fortran LAPACK documentation for ZGBSVXX::

 ZGBSVXX uses the LU factorization to compute the solution to a
 complex*16 system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZGBSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZGBSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZGBSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZGBSVXX would itself produce.

 */
extern proc LAPACK_zgbsvxx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, afb : [] complex(128), ref ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_double, c : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbsvxx

Original Fortran LAPACK documentation for CGBSVXX::

 CGBSVXX uses the LU factorization to compute the solution to a
 complex system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CGBSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CGBSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CGBSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CGBSVXX would itself produce.

 */
extern proc LAPACK_cgbsvxx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref kl : c_int, ref ku : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, afb : [] complex(64), ref ldafb : c_int, ipiv : [] c_int, ref equed : c_char, r : [] c_float, c : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgtsv

Original Fortran LAPACK documentation for SGTSV::

 SGTSV solves the equation

 A*X = B,

 where A is an n by n tridiagonal matrix, by Gaussian elimination with
 partial pivoting.

 Note that the equation A**T*X = B may be solved by interchanging the
 order of the arguments DU and DL.

 */
extern proc LAPACK_sgtsv(ref n : c_int, ref nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgtsv

Original Fortran LAPACK documentation for DGTSV::

 DGTSV solves the equation

 A*X = B,

 where A is an n by n tridiagonal matrix, by Gaussian elimination with
 partial pivoting.

 Note that the equation A**T*X = B may be solved by interchanging the
 order of the arguments DU and DL.

 */
extern proc LAPACK_dgtsv(ref n : c_int, ref nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgtsv

Original Fortran LAPACK documentation for CGTSV::

 CGTSV solves the equation

 A*X = B,

 where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
 partial pivoting.

 Note that the equation A**T *X = B may be solved by interchanging the
 order of the arguments DU and DL.

 */
extern proc LAPACK_cgtsv(ref n : c_int, ref nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgtsv

Original Fortran LAPACK documentation for ZGTSV::

 ZGTSV solves the equation

 A*X = B,

 where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
 partial pivoting.

 Note that the equation A**T *X = B may be solved by interchanging the
 order of the arguments DU and DL.

 */
extern proc LAPACK_zgtsv(ref n : c_int, ref nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgtsvx

Original Fortran LAPACK documentation for SGTSVX::

 SGTSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B or A**T * X = B,
 where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_sgtsvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgtsvx

Original Fortran LAPACK documentation for DGTSVX::

 DGTSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B or A**T * X = B,
 where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_dgtsvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgtsvx

Original Fortran LAPACK documentation for CGTSVX::

 CGTSVX uses the LU factorization to compute the solution to a complex
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_cgtsvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgtsvx

Original Fortran LAPACK documentation for ZGTSVX::

 ZGTSVX uses the LU factorization to compute the solution to a complex
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zgtsvx(ref fact : c_char, ref trans : c_char, ref n : c_int, ref nrhs : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sposv

Original Fortran LAPACK documentation for SPOSV::

 SPOSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACK_sposv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dposv

Original Fortran LAPACK documentation for DPOSV::

 DPOSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACK_dposv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cposv

Original Fortran LAPACK documentation for CPOSV::

 CPOSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H* U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACK_cposv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zposv

Original Fortran LAPACK documentation for ZPOSV::

 ZPOSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H* U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACK_zposv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsposv

Original Fortran LAPACK documentation for DSPOSV::

 DSPOSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 DSPOSV first attempts to factorize the matrix in SINGLE PRECISION
 and use this factorization within an iterative refinement procedure
 to produce a solution with DOUBLE PRECISION normwise backward error
 quality (see below). If the approach fails the method switches to a
 DOUBLE PRECISION factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio SINGLE PRECISION performance over DOUBLE PRECISION
 performance is too small. A reasonable strategy should take the
 number of right-hand sides and the size of the matrix into account.
 This might be done with a call to ILAENV in the future. Up to now, we
 always try iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

 */
extern proc LAPACK_dsposv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, work : [] c_double, swork : [] c_float, ref chlapack_iter : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zcposv

Original Fortran LAPACK documentation for ZCPOSV::

 ZCPOSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 ZCPOSV first attempts to factorize the matrix in COMPLEX and use this
 factorization within an iterative refinement procedure to produce a
 solution with COMPLEX*16 normwise backward error quality (see below).
 If the approach fails the method switches to a COMPLEX*16
 factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio COMPLEX performance over COMPLEX*16 performance is too
 small. A reasonable strategy should take the number of right-hand
 sides and the size of the matrix into account. This might be done
 with a call to ILAENV in the future. Up to now, we always try
 iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

 */
extern proc LAPACK_zcposv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, work : [] complex(128), swork : [] complex(64), rwork : [] c_double, ref chlapack_iter : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sposvx

Original Fortran LAPACK documentation for SPOSVX::

 SPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_sposvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dposvx

Original Fortran LAPACK documentation for DPOSVX::

 DPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_dposvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cposvx

Original Fortran LAPACK documentation for CPOSVX::

 CPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_cposvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zposvx

Original Fortran LAPACK documentation for ZPOSVX::

 ZPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zposvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dposvxx

Original Fortran LAPACK documentation for DPOSVXX::

 DPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
 to compute the solution to a double precision system of linear equations
 A * X = B, where A is an N-by-N symmetric positive definite matrix
 and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. DPOSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 DPOSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 DPOSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what DPOSVXX would itself produce.

 */
extern proc LAPACK_dposvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sposvxx

Original Fortran LAPACK documentation for SPOSVXX::

 SPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
 to compute the solution to a real system of linear equations
 A * X = B, where A is an N-by-N symmetric positive definite matrix
 and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SPOSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SPOSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SPOSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SPOSVXX would itself produce.

 */
extern proc LAPACK_sposvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zposvxx

Original Fortran LAPACK documentation for ZPOSVXX::

 ZPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
 to compute the solution to a complex*16 system of linear equations
 A * X = B, where A is an N-by-N symmetric positive definite matrix
 and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZPOSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZPOSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZPOSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZPOSVXX would itself produce.

 */
extern proc LAPACK_zposvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cposvxx

Original Fortran LAPACK documentation for CPOSVXX::

 CPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
 to compute the solution to a complex system of linear equations
 A * X = B, where A is an N-by-N symmetric positive definite matrix
 and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CPOSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CPOSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CPOSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CPOSVXX would itself produce.

 */
extern proc LAPACK_cposvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sppsv

Original Fortran LAPACK documentation for SPPSV::

 SPPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACK_sppsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dppsv

Original Fortran LAPACK documentation for DPPSV::

 DPPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACK_dppsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cppsv

Original Fortran LAPACK documentation for CPPSV::

 CPPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACK_cppsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zppsv

Original Fortran LAPACK documentation for ZPPSV::

 ZPPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

 */
extern proc LAPACK_zppsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sppsvx

Original Fortran LAPACK documentation for SPPSVX::

 SPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_sppsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, afp : [] c_float, ref equed : c_char, s : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dppsvx

Original Fortran LAPACK documentation for DPPSVX::

 DPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_dppsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, afp : [] c_double, ref equed : c_char, s : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cppsvx

Original Fortran LAPACK documentation for CPPSVX::

 CPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_cppsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ref equed : c_char, s : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zppsvx

Original Fortran LAPACK documentation for ZPPSVX::

 ZPPSVX uses the Cholesky factorization A = U**H * U or A = L * L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zppsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ref equed : c_char, s : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spbsv

Original Fortran LAPACK documentation for SPBSV::

 SPBSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular band matrix, and L is a lower
 triangular band matrix, with the same number of superdiagonals or
 subdiagonals as A. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACK_spbsv(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpbsv

Original Fortran LAPACK documentation for DPBSV::

 DPBSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular band matrix, and L is a lower
 triangular band matrix, with the same number of superdiagonals or
 subdiagonals as A. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACK_dpbsv(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpbsv

Original Fortran LAPACK documentation for CPBSV::

 CPBSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite band matrix and X
 and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular band matrix, and L is a lower
 triangular band matrix, with the same number of superdiagonals or
 subdiagonals as A. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACK_cpbsv(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpbsv

Original Fortran LAPACK documentation for ZPBSV::

 ZPBSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite band matrix and X
 and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**H * U, if UPLO = 'U', or
 A = L * L**H, if UPLO = 'L',
 where U is an upper triangular band matrix, and L is a lower
 triangular band matrix, with the same number of superdiagonals or
 subdiagonals as A. The factored form of A is then used to solve the
 system of equations A * X = B.

 */
extern proc LAPACK_zpbsv(ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spbsvx

Original Fortran LAPACK documentation for SPBSVX::

 SPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_spbsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_float, ref ldab : c_int, afb : [] c_float, ref ldafb : c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpbsvx

Original Fortran LAPACK documentation for DPBSVX::

 DPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_dpbsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] c_double, ref ldab : c_int, afb : [] c_double, ref ldafb : c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpbsvx

Original Fortran LAPACK documentation for CPBSVX::

 CPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite band matrix and X
 and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_cpbsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(64), ref ldab : c_int, afb : [] complex(64), ref ldafb : c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpbsvx

Original Fortran LAPACK documentation for ZPBSVX::

 ZPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
 compute the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite band matrix and X
 and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zpbsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ref nrhs : c_int, ab : [] complex(128), ref ldab : c_int, afb : [] complex(128), ref ldafb : c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sptsv

Original Fortran LAPACK documentation for SPTSV::

 SPTSV computes the solution to a real system of linear equations
 A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
 matrix, and X and B are N-by-NRHS matrices.

 A is factored as A = L*D*L**T, and the factored form of A is then
 used to solve the system of equations.

 */
extern proc LAPACK_sptsv(ref n : c_int, ref nrhs : c_int, d : [] c_float, e : [] c_float, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dptsv

Original Fortran LAPACK documentation for DPTSV::

 DPTSV computes the solution to a real system of linear equations
 A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
 matrix, and X and B are N-by-NRHS matrices.

 A is factored as A = L*D*L**T, and the factored form of A is then
 used to solve the system of equations.

 */
extern proc LAPACK_dptsv(ref n : c_int, ref nrhs : c_int, d : [] c_double, e : [] c_double, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cptsv

Original Fortran LAPACK documentation for CPTSV::

 CPTSV computes the solution to a complex system of linear equations
 A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
 matrix, and X and B are N-by-NRHS matrices.

 A is factored as A = L*D*L**H, and the factored form of A is then
 used to solve the system of equations.

 */
extern proc LAPACK_cptsv(ref n : c_int, ref nrhs : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zptsv

Original Fortran LAPACK documentation for ZPTSV::

 ZPTSV computes the solution to a complex system of linear equations
 A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
 matrix, and X and B are N-by-NRHS matrices.

 A is factored as A = L*D*L**H, and the factored form of A is then
 used to solve the system of equations.

 */
extern proc LAPACK_zptsv(ref n : c_int, ref nrhs : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sptsvx

Original Fortran LAPACK documentation for SPTSVX::

 SPTSVX uses the factorization A = L*D*L**T to compute the solution
 to a real system of linear equations A*X = B, where A is an N-by-N
 symmetric positive definite tridiagonal matrix and X and B are
 N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_sptsvx(ref fact : c_char, ref n : c_int, ref nrhs : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dptsvx

Original Fortran LAPACK documentation for DPTSVX::

 DPTSVX uses the factorization A = L*D*L**T to compute the solution
 to a real system of linear equations A*X = B, where A is an N-by-N
 symmetric positive definite tridiagonal matrix and X and B are
 N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_dptsvx(ref fact : c_char, ref n : c_int, ref nrhs : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cptsvx

Original Fortran LAPACK documentation for CPTSVX::

 CPTSVX uses the factorization A = L*D*L**H to compute the solution
 to a complex system of linear equations A*X = B, where A is an
 N-by-N Hermitian positive definite tridiagonal matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_cptsvx(ref fact : c_char, ref n : c_int, ref nrhs : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zptsvx

Original Fortran LAPACK documentation for ZPTSVX::

 ZPTSVX uses the factorization A = L*D*L**H to compute the solution
 to a complex system of linear equations A*X = B, where A is an
 N-by-N Hermitian positive definite tridiagonal matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zptsvx(ref fact : c_char, ref n : c_int, ref nrhs : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssysv

Original Fortran LAPACK documentation for SSYSV::

 SSYSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACK_ssysv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsysv

Original Fortran LAPACK documentation for DSYSV::

 DSYSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACK_dsysv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csysv

Original Fortran LAPACK documentation for CSYSV::

 CSYSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACK_csysv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsysv

Original Fortran LAPACK documentation for ZSYSV::

 ZSYSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACK_zsysv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssysvx

Original Fortran LAPACK documentation for SSYSVX::

 SSYSVX uses the diagonal pivoting factorization to compute the
 solution to a real system of linear equations A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_ssysvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsysvx

Original Fortran LAPACK documentation for DSYSVX::

 DSYSVX uses the diagonal pivoting factorization to compute the
 solution to a real system of linear equations A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_dsysvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csysvx

Original Fortran LAPACK documentation for CSYSVX::

 CSYSVX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_csysvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsysvx

Original Fortran LAPACK documentation for ZSYSVX::

 ZSYSVX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zsysvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsysvxx

Original Fortran LAPACK documentation for DSYSVXX::

 DSYSVXX uses the diagonal pivoting factorization to compute the
 solution to a double precision system of linear equations A * X = B, where A
 is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. DSYSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 DSYSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 DSYSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what DSYSVXX would itself produce.

 */
extern proc LAPACK_dsysvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, af : [] c_double, ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_double, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssysvxx

Original Fortran LAPACK documentation for SSYSVXX::

 SSYSVXX uses the diagonal pivoting factorization to compute the
 solution to a real system of linear equations A * X = B, where A
 is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SSYSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SSYSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SSYSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SSYSVXX would itself produce.

 */
extern proc LAPACK_ssysvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, af : [] c_float, ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_float, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsysvxx

Original Fortran LAPACK documentation for ZSYSVXX::

 ZSYSVXX uses the diagonal pivoting factorization to compute the
 solution to a complex*16 system of linear equations A * X = B, where
 A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZSYSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZSYSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZSYSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZSYSVXX would itself produce.

 */
extern proc LAPACK_zsysvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csysvxx

Original Fortran LAPACK documentation for CSYSVXX::

 CSYSVXX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B, where
 A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CSYSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CSYSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CSYSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CSYSVXX would itself produce.

 */
extern proc LAPACK_csysvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chesv

Original Fortran LAPACK documentation for CHESV::

 CHESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACK_chesv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhesv

Original Fortran LAPACK documentation for ZHESV::

 ZHESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

 */
extern proc LAPACK_zhesv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chesvx

Original Fortran LAPACK documentation for CHESVX::

 CHESVX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_chesvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhesvx

Original Fortran LAPACK documentation for ZHESVX::

 ZHESVX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zhesvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhesvxx

Original Fortran LAPACK documentation for ZHESVXX::

 ZHESVXX uses the diagonal pivoting factorization to compute the
 solution to a complex*16 system of linear equations A * X = B, where
 A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. ZHESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 ZHESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 ZHESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what ZHESVXX would itself produce.

 */
extern proc LAPACK_zhesvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, af : [] complex(128), ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_double, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, ref n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, ref nparams : c_int, params : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chesvxx

Original Fortran LAPACK documentation for CHESVXX::

 CHESVXX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B, where
 A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CHESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CHESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CHESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CHESVXX would itself produce.

 */
extern proc LAPACK_chesvxx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, af : [] complex(64), ref ldaf : c_int, ipiv : [] c_int, ref equed : c_char, s : [] c_float, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, ref n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, ref nparams : c_int, params : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspsv

Original Fortran LAPACK documentation for SSPSV::

 SSPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is symmetric and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACK_sspsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspsv

Original Fortran LAPACK documentation for DSPSV::

 DSPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is symmetric and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACK_dspsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cspsv

Original Fortran LAPACK documentation for CSPSV::

 CSPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is symmetric and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACK_cspsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zspsv

Original Fortran LAPACK documentation for ZSPSV::

 ZSPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is symmetric and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACK_zspsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspsvx

Original Fortran LAPACK documentation for SSPSVX::

 SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a real system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_sspsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, x : [] c_float, ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspsvx

Original Fortran LAPACK documentation for DSPSVX::

 DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a real system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_dspsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, x : [] c_double, ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cspsvx

Original Fortran LAPACK documentation for CSPSVX::

 CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a complex system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_cspsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zspsvx

Original Fortran LAPACK documentation for ZSPSVX::

 ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a complex system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zspsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpsv

Original Fortran LAPACK documentation for CHPSV::

 CHPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is Hermitian and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACK_chpsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpsv

Original Fortran LAPACK documentation for ZHPSV::

 ZHPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is Hermitian and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

 */
extern proc LAPACK_zhpsv(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpsvx

Original Fortran LAPACK documentation for CHPSVX::

 CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
 A = L*D*L**H to compute the solution to a complex system of linear
 equations A * X = B, where A is an N-by-N Hermitian matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_chpsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, x : [] complex(64), ref ldx : c_int, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpsvx

Original Fortran LAPACK documentation for ZHPSVX::

 ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
 A = L*D*L**H to compute the solution to a complex system of linear
 equations A * X = B, where A is an N-by-N Hermitian matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

 */
extern proc LAPACK_zhpsvx(ref fact : c_char, ref uplo : c_char, ref n : c_int, ref nrhs : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, x : [] complex(128), ref ldx : c_int, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeqrf

Original Fortran LAPACK documentation for SGEQRF::

 SGEQRF computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACK_sgeqrf(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeqrf

Original Fortran LAPACK documentation for DGEQRF::

 DGEQRF computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACK_dgeqrf(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeqrf

Original Fortran LAPACK documentation for CGEQRF::

 CGEQRF computes a QR factorization of a complex M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACK_cgeqrf(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeqrf

Original Fortran LAPACK documentation for ZGEQRF::

 ZGEQRF computes a QR factorization of a complex M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACK_zgeqrf(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeqpf

Original Fortran LAPACK documentation for SGEQPF::

 This routine is deprecated and has been replaced by routine SGEQP3.

 SGEQPF computes a QR factorization with column pivoting of a
 real M-by-N matrix A: A*P = Q*R.

 */
extern proc LAPACK_sgeqpf(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, jpvt : [] c_int, tau : [] c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeqpf

Original Fortran LAPACK documentation for DGEQPF::

 This routine is deprecated and has been replaced by routine DGEQP3.

 DGEQPF computes a QR factorization with column pivoting of a
 real M-by-N matrix A: A*P = Q*R.

 */
extern proc LAPACK_dgeqpf(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, jpvt : [] c_int, tau : [] c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeqpf

Original Fortran LAPACK documentation for CGEQPF::

 This routine is deprecated and has been replaced by routine CGEQP3.

 CGEQPF computes a QR factorization with column pivoting of a
 complex M-by-N matrix A: A*P = Q*R.

 */
extern proc LAPACK_cgeqpf(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, jpvt : [] c_int, tau : [] complex(64), work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeqpf

Original Fortran LAPACK documentation for ZGEQPF::

 This routine is deprecated and has been replaced by routine ZGEQP3.

 ZGEQPF computes a QR factorization with column pivoting of a
 complex M-by-N matrix A: A*P = Q*R.

 */
extern proc LAPACK_zgeqpf(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, jpvt : [] c_int, tau : [] complex(128), work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeqp3

Original Fortran LAPACK documentation for SGEQP3::

 SGEQP3 computes a QR factorization with column pivoting of a
 matrix A: A*P = Q*R using Level 3 BLAS.

 */
extern proc LAPACK_sgeqp3(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, jpvt : [] c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeqp3

Original Fortran LAPACK documentation for DGEQP3::

 DGEQP3 computes a QR factorization with column pivoting of a
 matrix A: A*P = Q*R using Level 3 BLAS.

 */
extern proc LAPACK_dgeqp3(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, jpvt : [] c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeqp3

Original Fortran LAPACK documentation for CGEQP3::

 CGEQP3 computes a QR factorization with column pivoting of a
 matrix A: A*P = Q*R using Level 3 BLAS.

 */
extern proc LAPACK_cgeqp3(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, jpvt : [] c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeqp3

Original Fortran LAPACK documentation for ZGEQP3::

 ZGEQP3 computes a QR factorization with column pivoting of a
 matrix A: A*P = Q*R using Level 3 BLAS.

 */
extern proc LAPACK_zgeqp3(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, jpvt : [] c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sorgqr

Original Fortran LAPACK documentation for SORGQR::

 SORGQR generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by SGEQRF.

 */
extern proc LAPACK_sorgqr(ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dorgqr

Original Fortran LAPACK documentation for DORGQR::

 DORGQR generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by DGEQRF.

 */
extern proc LAPACK_dorgqr(ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sormqr

Original Fortran LAPACK documentation for SORMQR::

 SORMQR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_sormqr(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, c : [] c_float, ref ldc : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dormqr

Original Fortran LAPACK documentation for DORMQR::

 DORMQR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_dormqr(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, c : [] c_double, ref ldc : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cungqr

Original Fortran LAPACK documentation for CUNGQR::

 CUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by CGEQRF.

 */
extern proc LAPACK_cungqr(ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zungqr

Original Fortran LAPACK documentation for ZUNGQR::

 ZUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by ZGEQRF.

 */
extern proc LAPACK_zungqr(ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunmqr

Original Fortran LAPACK documentation for CUNMQR::

 CUNMQR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_cunmqr(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunmqr

Original Fortran LAPACK documentation for ZUNMQR::

 ZUNMQR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_zunmqr(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgelqf

Original Fortran LAPACK documentation for SGELQF::

 SGELQF computes an LQ factorization of a real M-by-N matrix A:
 A = L * Q.

 */
extern proc LAPACK_sgelqf(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgelqf

Original Fortran LAPACK documentation for DGELQF::

 DGELQF computes an LQ factorization of a real M-by-N matrix A:
 A = L * Q.

 */
extern proc LAPACK_dgelqf(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgelqf

Original Fortran LAPACK documentation for CGELQF::

 CGELQF computes an LQ factorization of a complex M-by-N matrix A:
 A = L * Q.

 */
extern proc LAPACK_cgelqf(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgelqf

Original Fortran LAPACK documentation for ZGELQF::

 ZGELQF computes an LQ factorization of a complex M-by-N matrix A:
 A = L * Q.

 */
extern proc LAPACK_zgelqf(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sorglq

Original Fortran LAPACK documentation for SORGLQ::

 SORGLQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k) . . . H(2) H(1)

 as returned by SGELQF.

 */
extern proc LAPACK_sorglq(ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dorglq

Original Fortran LAPACK documentation for DORGLQ::

 DORGLQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k) . . . H(2) H(1)

 as returned by DGELQF.

 */
extern proc LAPACK_dorglq(ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sormlq

Original Fortran LAPACK documentation for SORMLQ::

 SORMLQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by SGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_sormlq(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, c : [] c_float, ref ldc : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dormlq

Original Fortran LAPACK documentation for DORMLQ::

 DORMLQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_dormlq(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, c : [] c_double, ref ldc : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunglq

Original Fortran LAPACK documentation for CUNGLQ::

 CUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by CGELQF.

 */
extern proc LAPACK_cunglq(ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunglq

Original Fortran LAPACK documentation for ZUNGLQ::

 ZUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by ZGELQF.

 */
extern proc LAPACK_zunglq(ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunmlq

Original Fortran LAPACK documentation for CUNMLQ::

 CUNMLQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_cunmlq(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunmlq

Original Fortran LAPACK documentation for ZUNMLQ::

 ZUNMLQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_zunmlq(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeqlf

Original Fortran LAPACK documentation for SGEQLF::

 SGEQLF computes a QL factorization of a real M-by-N matrix A:
 A = Q * L.

 */
extern proc LAPACK_sgeqlf(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeqlf

Original Fortran LAPACK documentation for DGEQLF::

 DGEQLF computes a QL factorization of a real M-by-N matrix A:
 A = Q * L.

 */
extern proc LAPACK_dgeqlf(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeqlf

Original Fortran LAPACK documentation for CGEQLF::

 CGEQLF computes a QL factorization of a complex M-by-N matrix A:
 A = Q * L.

 */
extern proc LAPACK_cgeqlf(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeqlf

Original Fortran LAPACK documentation for ZGEQLF::

 ZGEQLF computes a QL factorization of a complex M-by-N matrix A:
 A = Q * L.

 */
extern proc LAPACK_zgeqlf(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sorgql

Original Fortran LAPACK documentation for SORGQL::

 SORGQL generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by SGEQLF.

 */
extern proc LAPACK_sorgql(ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dorgql

Original Fortran LAPACK documentation for DORGQL::

 DORGQL generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by DGEQLF.

 */
extern proc LAPACK_dorgql(ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cungql

Original Fortran LAPACK documentation for CUNGQL::

 CUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by CGEQLF.

 */
extern proc LAPACK_cungql(ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zungql

Original Fortran LAPACK documentation for ZUNGQL::

 ZUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by ZGEQLF.

 */
extern proc LAPACK_zungql(ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sormql

Original Fortran LAPACK documentation for SORMQL::

 SORMQL overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_sormql(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, c : [] c_float, ref ldc : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dormql

Original Fortran LAPACK documentation for DORMQL::

 DORMQL overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_dormql(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, c : [] c_double, ref ldc : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunmql

Original Fortran LAPACK documentation for CUNMQL::

 CUNMQL overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_cunmql(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunmql

Original Fortran LAPACK documentation for ZUNMQL::

 ZUNMQL overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by ZGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_zunmql(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgerqf

Original Fortran LAPACK documentation for SGERQF::

 SGERQF computes an RQ factorization of a real M-by-N matrix A:
 A = R * Q.

 */
extern proc LAPACK_sgerqf(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgerqf

Original Fortran LAPACK documentation for DGERQF::

 DGERQF computes an RQ factorization of a real M-by-N matrix A:
 A = R * Q.

 */
extern proc LAPACK_dgerqf(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgerqf

Original Fortran LAPACK documentation for CGERQF::

 CGERQF computes an RQ factorization of a complex M-by-N matrix A:
 A = R * Q.

 */
extern proc LAPACK_cgerqf(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgerqf

Original Fortran LAPACK documentation for ZGERQF::

 ZGERQF computes an RQ factorization of a complex M-by-N matrix A:
 A = R * Q.

 */
extern proc LAPACK_zgerqf(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sorgrq

Original Fortran LAPACK documentation for SORGRQ::

 SORGRQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1) H(2) . . . H(k)

 as returned by SGERQF.

 */
extern proc LAPACK_sorgrq(ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dorgrq

Original Fortran LAPACK documentation for DORGRQ::

 DORGRQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1) H(2) . . . H(k)

 as returned by DGERQF.

 */
extern proc LAPACK_dorgrq(ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cungrq

Original Fortran LAPACK documentation for CUNGRQ::

 CUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by CGERQF.

 */
extern proc LAPACK_cungrq(ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zungrq

Original Fortran LAPACK documentation for ZUNGRQ::

 ZUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by ZGERQF.

 */
extern proc LAPACK_zungrq(ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sormrq

Original Fortran LAPACK documentation for SORMRQ::

 SORMRQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by SGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_sormrq(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, c : [] c_float, ref ldc : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dormrq

Original Fortran LAPACK documentation for DORMRQ::

 DORMRQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_dormrq(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, c : [] c_double, ref ldc : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunmrq

Original Fortran LAPACK documentation for CUNMRQ::

 CUNMRQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_cunmrq(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunmrq

Original Fortran LAPACK documentation for ZUNMRQ::

 ZUNMRQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by ZGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_zunmrq(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stzrzf

Original Fortran LAPACK documentation for STZRZF::

 STZRZF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
 to upper triangular form by means of orthogonal transformations.

 The upper trapezoidal matrix A is factored as

 A = ( R 0 ) * Z,

 where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
 triangular matrix.

 */
extern proc LAPACK_stzrzf(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtzrzf

Original Fortran LAPACK documentation for DTZRZF::

 DTZRZF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
 to upper triangular form by means of orthogonal transformations.

 The upper trapezoidal matrix A is factored as

 A = ( R 0 ) * Z,

 where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
 triangular matrix.

 */
extern proc LAPACK_dtzrzf(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctzrzf

Original Fortran LAPACK documentation for CTZRZF::

 CTZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
 to upper triangular form by means of unitary transformations.

 The upper trapezoidal matrix A is factored as

 A = ( R 0 ) * Z,

 where Z is an N-by-N unitary matrix and R is an M-by-M upper
 triangular matrix.

 */
extern proc LAPACK_ctzrzf(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztzrzf

Original Fortran LAPACK documentation for ZTZRZF::

 ZTZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
 to upper triangular form by means of unitary transformations.

 The upper trapezoidal matrix A is factored as

 A = ( R 0 ) * Z,

 where Z is an N-by-N unitary matrix and R is an M-by-M upper
 triangular matrix.

 */
extern proc LAPACK_ztzrzf(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sormrz

Original Fortran LAPACK documentation for SORMRZ::

 SORMRZ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by STZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_sormrz(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, c : [] c_float, ref ldc : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dormrz

Original Fortran LAPACK documentation for DORMRZ::

 DORMRZ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_dormrz(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, c : [] c_double, ref ldc : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunmrz

Original Fortran LAPACK documentation for CUNMRZ::

 CUNMRZ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_cunmrz(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunmrz

Original Fortran LAPACK documentation for ZUNMRZ::

 ZUNMRZ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by ZTZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

 */
extern proc LAPACK_zunmrz(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggqrf

Original Fortran LAPACK documentation for SGGQRF::

 SGGQRF computes a generalized QR factorization of an N-by-M matrix A
 and an N-by-P matrix B:

 A = Q*R, B = Q*T*Z,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if N >= M, R = ( R11 ) M , or if N < M, R = ( R11 R12 ) N,
 ( 0 ) N-M N M-N
 M

 where R11 is upper triangular, and

 if N <= P, T = ( 0 T12 ) N, or if N > P, T = ( T11 ) N-P,
 P-N N ( T21 ) P
 P

 where T12 or T21 is upper triangular.

 In particular, if B is square and nonsingular, the GQR factorization
 of A and B implicitly gives the QR factorization of inv(B)*A:

 inv(B)*A = Z**T*(inv(T)*R)

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

 */
extern proc LAPACK_sggqrf(ref n : c_int, ref m : c_int, ref p : c_int, a : [] c_float, ref lda : c_int, taua : [] c_float, b : [] c_float, ref ldb : c_int, taub : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggqrf

Original Fortran LAPACK documentation for DGGQRF::

 DGGQRF computes a generalized QR factorization of an N-by-M matrix A
 and an N-by-P matrix B:

 A = Q*R, B = Q*T*Z,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if N >= M, R = ( R11 ) M , or if N < M, R = ( R11 R12 ) N,
 ( 0 ) N-M N M-N
 M

 where R11 is upper triangular, and

 if N <= P, T = ( 0 T12 ) N, or if N > P, T = ( T11 ) N-P,
 P-N N ( T21 ) P
 P

 where T12 or T21 is upper triangular.

 In particular, if B is square and nonsingular, the GQR factorization
 of A and B implicitly gives the QR factorization of inv(B)*A:

 inv(B)*A = Z**T*(inv(T)*R)

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

 */
extern proc LAPACK_dggqrf(ref n : c_int, ref m : c_int, ref p : c_int, a : [] c_double, ref lda : c_int, taua : [] c_double, b : [] c_double, ref ldb : c_int, taub : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggqrf

Original Fortran LAPACK documentation for CGGQRF::

 CGGQRF computes a generalized QR factorization of an N-by-M matrix A
 and an N-by-P matrix B:

 A = Q*R, B = Q*T*Z,

 where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
 and R and T assume one of the forms:

 if N >= M, R = ( R11 ) M , or if N < M, R = ( R11 R12 ) N,
 ( 0 ) N-M N M-N
 M

 where R11 is upper triangular, and

 if N <= P, T = ( 0 T12 ) N, or if N > P, T = ( T11 ) N-P,
 P-N N ( T21 ) P
 P

 where T12 or T21 is upper triangular.

 In particular, if B is square and nonsingular, the GQR factorization
 of A and B implicitly gives the QR factorization of inv(B)*A:

 inv(B)*A = Z**H * (inv(T)*R)

 where inv(B) denotes the inverse of the matrix B, and Z' denotes the
 conjugate transpose of matrix Z.

 */
extern proc LAPACK_cggqrf(ref n : c_int, ref m : c_int, ref p : c_int, a : [] complex(64), ref lda : c_int, taua : [] complex(64), b : [] complex(64), ref ldb : c_int, taub : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggqrf

Original Fortran LAPACK documentation for ZGGQRF::

 ZGGQRF computes a generalized QR factorization of an N-by-M matrix A
 and an N-by-P matrix B:

 A = Q*R, B = Q*T*Z,

 where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
 and R and T assume one of the forms:

 if N >= M, R = ( R11 ) M , or if N < M, R = ( R11 R12 ) N,
 ( 0 ) N-M N M-N
 M

 where R11 is upper triangular, and

 if N <= P, T = ( 0 T12 ) N, or if N > P, T = ( T11 ) N-P,
 P-N N ( T21 ) P
 P

 where T12 or T21 is upper triangular.

 In particular, if B is square and nonsingular, the GQR factorization
 of A and B implicitly gives the QR factorization of inv(B)*A:

 inv(B)*A = Z**H * (inv(T)*R)

 where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
 conjugate transpose of matrix Z.

 */
extern proc LAPACK_zggqrf(ref n : c_int, ref m : c_int, ref p : c_int, a : [] complex(128), ref lda : c_int, taua : [] complex(128), b : [] complex(128), ref ldb : c_int, taub : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggrqf

Original Fortran LAPACK documentation for SGGRQF::

 SGGRQF computes a generalized RQ factorization of an M-by-N matrix A
 and a P-by-N matrix B:

 A = R*Q, B = Z*T*Q,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if M <= N, R = ( 0 R12 ) M, or if M > N, R = ( R11 ) M-N,
 N-M M ( R21 ) N
 N

 where R12 or R21 is upper triangular, and

 if P >= N, T = ( T11 ) N , or if P < N, T = ( T11 T12 ) P,
 ( 0 ) P-N P N-P
 N

 where T11 is upper triangular.

 In particular, if B is square and nonsingular, the GRQ factorization
 of A and B implicitly gives the RQ factorization of A*inv(B):

 A*inv(B) = (R*inv(T))*Z**T

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

 */
extern proc LAPACK_sggrqf(ref m : c_int, ref p : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, taua : [] c_float, b : [] c_float, ref ldb : c_int, taub : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggrqf

Original Fortran LAPACK documentation for DGGRQF::

 DGGRQF computes a generalized RQ factorization of an M-by-N matrix A
 and a P-by-N matrix B:

 A = R*Q, B = Z*T*Q,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if M <= N, R = ( 0 R12 ) M, or if M > N, R = ( R11 ) M-N,
 N-M M ( R21 ) N
 N

 where R12 or R21 is upper triangular, and

 if P >= N, T = ( T11 ) N , or if P < N, T = ( T11 T12 ) P,
 ( 0 ) P-N P N-P
 N

 where T11 is upper triangular.

 In particular, if B is square and nonsingular, the GRQ factorization
 of A and B implicitly gives the RQ factorization of A*inv(B):

 A*inv(B) = (R*inv(T))*Z**T

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

 */
extern proc LAPACK_dggrqf(ref m : c_int, ref p : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, taua : [] c_double, b : [] c_double, ref ldb : c_int, taub : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggrqf

Original Fortran LAPACK documentation for CGGRQF::

 CGGRQF computes a generalized RQ factorization of an M-by-N matrix A
 and a P-by-N matrix B:

 A = R*Q, B = Z*T*Q,

 where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
 matrix, and R and T assume one of the forms:

 if M <= N, R = ( 0 R12 ) M, or if M > N, R = ( R11 ) M-N,
 N-M M ( R21 ) N
 N

 where R12 or R21 is upper triangular, and

 if P >= N, T = ( T11 ) N , or if P < N, T = ( T11 T12 ) P,
 ( 0 ) P-N P N-P
 N

 where T11 is upper triangular.

 In particular, if B is square and nonsingular, the GRQ factorization
 of A and B implicitly gives the RQ factorization of A*inv(B):

 A*inv(B) = (R*inv(T))*Z**H

 where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
 conjugate transpose of the matrix Z.

 */
extern proc LAPACK_cggrqf(ref m : c_int, ref p : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, taua : [] complex(64), b : [] complex(64), ref ldb : c_int, taub : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggrqf

Original Fortran LAPACK documentation for ZGGRQF::

 ZGGRQF computes a generalized RQ factorization of an M-by-N matrix A
 and a P-by-N matrix B:

 A = R*Q, B = Z*T*Q,

 where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
 matrix, and R and T assume one of the forms:

 if M <= N, R = ( 0 R12 ) M, or if M > N, R = ( R11 ) M-N,
 N-M M ( R21 ) N
 N

 where R12 or R21 is upper triangular, and

 if P >= N, T = ( T11 ) N , or if P < N, T = ( T11 T12 ) P,
 ( 0 ) P-N P N-P
 N

 where T11 is upper triangular.

 In particular, if B is square and nonsingular, the GRQ factorization
 of A and B implicitly gives the RQ factorization of A*inv(B):

 A*inv(B) = (R*inv(T))*Z**H

 where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
 conjugate transpose of the matrix Z.

 */
extern proc LAPACK_zggrqf(ref m : c_int, ref p : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, taua : [] complex(128), b : [] complex(128), ref ldb : c_int, taub : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgebrd

Original Fortran LAPACK documentation for SGEBRD::

 SGEBRD reduces a general real M-by-N matrix A to upper or lower
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

 */
extern proc LAPACK_sgebrd(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, d : [] c_float, e : [] c_float, tauq : [] c_float, taup : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgebrd

Original Fortran LAPACK documentation for DGEBRD::

 DGEBRD reduces a general real M-by-N matrix A to upper or lower
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

 */
extern proc LAPACK_dgebrd(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, d : [] c_double, e : [] c_double, tauq : [] c_double, taup : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgebrd

Original Fortran LAPACK documentation for CGEBRD::

 CGEBRD reduces a general complex M-by-N matrix A to upper or lower
 bidiagonal form B by a unitary transformation: Q**H * A * P = B.

 If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

 */
extern proc LAPACK_cgebrd(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, d : [] c_float, e : [] c_float, tauq : [] complex(64), taup : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgebrd

Original Fortran LAPACK documentation for ZGEBRD::

 ZGEBRD reduces a general complex M-by-N matrix A to upper or lower
 bidiagonal form B by a unitary transformation: Q**H * A * P = B.

 If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

 */
extern proc LAPACK_zgebrd(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, d : [] c_double, e : [] c_double, tauq : [] complex(128), taup : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgbbrd

Original Fortran LAPACK documentation for SGBBRD::

 SGBBRD reduces a real general m-by-n band matrix A to upper
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 The routine computes B, and optionally forms Q or P**T, or computes
 Q**T*C for a given matrix C.

 */
extern proc LAPACK_sgbbrd(ref vect : c_char, ref m : c_int, ref n : c_int, ref ncc : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_float, ref ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ref ldq : c_int, pt : [] c_float, ref ldpt : c_int, c : [] c_float, ref ldc : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgbbrd

Original Fortran LAPACK documentation for DGBBRD::

 DGBBRD reduces a real general m-by-n band matrix A to upper
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 The routine computes B, and optionally forms Q or P**T, or computes
 Q**T*C for a given matrix C.

 */
extern proc LAPACK_dgbbrd(ref vect : c_char, ref m : c_int, ref n : c_int, ref ncc : c_int, ref kl : c_int, ref ku : c_int, ab : [] c_double, ref ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ref ldq : c_int, pt : [] c_double, ref ldpt : c_int, c : [] c_double, ref ldc : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgbbrd

Original Fortran LAPACK documentation for CGBBRD::

 CGBBRD reduces a complex general m-by-n band matrix A to real upper
 bidiagonal form B by a unitary transformation: Q**H * A * P = B.

 The routine computes B, and optionally forms Q or P**H, or computes
 Q**H*C for a given matrix C.

 */
extern proc LAPACK_cgbbrd(ref vect : c_char, ref m : c_int, ref n : c_int, ref ncc : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(64), ref ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ref ldq : c_int, pt : [] complex(64), ref ldpt : c_int, c : [] complex(64), ref ldc : c_int, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgbbrd

Original Fortran LAPACK documentation for ZGBBRD::

 ZGBBRD reduces a complex general m-by-n band matrix A to real upper
 bidiagonal form B by a unitary transformation: Q**H * A * P = B.

 The routine computes B, and optionally forms Q or P**H, or computes
 Q**H*C for a given matrix C.

 */
extern proc LAPACK_zgbbrd(ref vect : c_char, ref m : c_int, ref n : c_int, ref ncc : c_int, ref kl : c_int, ref ku : c_int, ab : [] complex(128), ref ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ref ldq : c_int, pt : [] complex(128), ref ldpt : c_int, c : [] complex(128), ref ldc : c_int, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sorgbr

Original Fortran LAPACK documentation for SORGBR::

 SORGBR generates one of the real orthogonal matrices Q or P**T
 determined by SGEBRD when reducing a real matrix A to bidiagonal
 form: A = Q * B * P**T. Q and P**T are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
 is of order N:
 if k < n, P**T = G(k) . . . G(2) G(1) and SORGBR returns the first m
 rows of P**T, where n >= m >= k;
 if k >= n, P**T = G(n-1) . . . G(2) G(1) and SORGBR returns P**T as
 an N-by-N matrix.

 */
extern proc LAPACK_sorgbr(ref vect : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dorgbr

Original Fortran LAPACK documentation for DORGBR::

 DORGBR generates one of the real orthogonal matrices Q or P**T
 determined by DGEBRD when reducing a real matrix A to bidiagonal
 form: A = Q * B * P**T. Q and P**T are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
 is of order N:
 if k < n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
 rows of P**T, where n >= m >= k;
 if k >= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
 an N-by-N matrix.

 */
extern proc LAPACK_dorgbr(ref vect : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sormbr

Original Fortran LAPACK documentation for SORMBR::

 If VECT = 'Q', SORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 If VECT = 'P', SORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'T': P**T * C C * P**T

 Here Q and P**T are the orthogonal matrices determined by SGEBRD when
 reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
 P**T are defined as products of elementary reflectors H(i) and G(i)
 respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the orthogonal matrix Q or P**T that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

 */
extern proc LAPACK_sormbr(ref vect : c_char, ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, c : [] c_float, ref ldc : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dormbr

Original Fortran LAPACK documentation for DORMBR::

 If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'T': P**T * C C * P**T

 Here Q and P**T are the orthogonal matrices determined by DGEBRD when
 reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
 P**T are defined as products of elementary reflectors H(i) and G(i)
 respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the orthogonal matrix Q or P**T that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

 */
extern proc LAPACK_dormbr(ref vect : c_char, ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, c : [] c_double, ref ldc : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cungbr

Original Fortran LAPACK documentation for CUNGBR::

 CUNGBR generates one of the complex unitary matrices Q or P**H
 determined by CGEBRD when reducing a complex matrix A to bidiagonal
 form: A = Q * B * P**H. Q and P**H are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
 is of order N:
 if k < n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m
 rows of P**H, where n >= m >= k;
 if k >= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as
 an N-by-N matrix.

 */
extern proc LAPACK_cungbr(ref vect : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zungbr

Original Fortran LAPACK documentation for ZUNGBR::

 ZUNGBR generates one of the complex unitary matrices Q or P**H
 determined by ZGEBRD when reducing a complex matrix A to bidiagonal
 form: A = Q * B * P**H. Q and P**H are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and ZUNGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and ZUNGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
 is of order N:
 if k < n, P**H = G(k) . . . G(2) G(1) and ZUNGBR returns the first m
 rows of P**H, where n >= m >= k;
 if k >= n, P**H = G(n-1) . . . G(2) G(1) and ZUNGBR returns P**H as
 an N-by-N matrix.

 */
extern proc LAPACK_zungbr(ref vect : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunmbr

Original Fortran LAPACK documentation for CUNMBR::

 If VECT = 'Q', CUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'C': P**H * C C * P**H

 Here Q and P**H are the unitary matrices determined by CGEBRD when
 reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
 and P**H are defined as products of elementary reflectors H(i) and
 G(i) respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the unitary matrix Q or P**H that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

 */
extern proc LAPACK_cunmbr(ref vect : c_char, ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunmbr

Original Fortran LAPACK documentation for ZUNMBR::

 If VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 If VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'C': P**H * C C * P**H

 Here Q and P**H are the unitary matrices determined by ZGEBRD when
 reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
 and P**H are defined as products of elementary reflectors H(i) and
 G(i) respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the unitary matrix Q or P**H that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

 */
extern proc LAPACK_zunmbr(ref vect : c_char, ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sbdsqr

Original Fortran LAPACK documentation for SBDSQR::

 SBDSQR computes the singular values and, optionally, the right and/or
 left singular vectors from the singular value decomposition (SVD) of
 a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
 zero-shift QR algorithm. The SVD of B has the form
 
 B = Q * S * P**T
 
 where S is the diagonal matrix of singular values, Q is an orthogonal
 matrix of left singular vectors, and P is an orthogonal matrix of
 right singular vectors. If left singular vectors are requested, this
 subroutine actually returns U*Q instead of Q, and, if right singular
 vectors are requested, this subroutine returns P**T*VT instead of
 P**T, for given real input matrices U and VT. When U and VT are the
 orthogonal matrices that reduce a general matrix A to bidiagonal
 form: A = U*B*VT, as computed by SGEBRD, then
 
 A = (U*Q) * S * (P**T*VT)
 
 is the SVD of A. Optionally, the subroutine may also compute Q**T*C
 for a given real input matrix C.

 See "Computing Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
 no. 5, pp. 873-912, Sept 1990) and
 "Accurate singular values and differential qd algorithms," by
 B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
 Department, University of California at Berkeley, July 1992
 for a detailed description of the algorithm.

 */
extern proc LAPACK_sbdsqr(ref uplo : c_char, ref n : c_int, ref ncvt : c_int, ref nru : c_int, ref ncc : c_int, d : [] c_float, e : [] c_float, vt : [] c_float, ref ldvt : c_int, u : [] c_float, ref ldu : c_int, c : [] c_float, ref ldc : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dbdsqr

Original Fortran LAPACK documentation for DBDSQR::

 DBDSQR computes the singular values and, optionally, the right and/or
 left singular vectors from the singular value decomposition (SVD) of
 a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
 zero-shift QR algorithm. The SVD of B has the form
 
 B = Q * S * P**T
 
 where S is the diagonal matrix of singular values, Q is an orthogonal
 matrix of left singular vectors, and P is an orthogonal matrix of
 right singular vectors. If left singular vectors are requested, this
 subroutine actually returns U*Q instead of Q, and, if right singular
 vectors are requested, this subroutine returns P**T*VT instead of
 P**T, for given real input matrices U and VT. When U and VT are the
 orthogonal matrices that reduce a general matrix A to bidiagonal
 form: A = U*B*VT, as computed by DGEBRD, then

 A = (U*Q) * S * (P**T*VT)

 is the SVD of A. Optionally, the subroutine may also compute Q**T*C
 for a given real input matrix C.

 See "Computing Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
 no. 5, pp. 873-912, Sept 1990) and
 "Accurate singular values and differential qd algorithms," by
 B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
 Department, University of California at Berkeley, July 1992
 for a detailed description of the algorithm.

 */
extern proc LAPACK_dbdsqr(ref uplo : c_char, ref n : c_int, ref ncvt : c_int, ref nru : c_int, ref ncc : c_int, d : [] c_double, e : [] c_double, vt : [] c_double, ref ldvt : c_int, u : [] c_double, ref ldu : c_int, c : [] c_double, ref ldc : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cbdsqr

Original Fortran LAPACK documentation for CBDSQR::

 CBDSQR computes the singular values and, optionally, the right and/or
 left singular vectors from the singular value decomposition (SVD) of
 a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
 zero-shift QR algorithm. The SVD of B has the form
 
 B = Q * S * P**H
 
 where S is the diagonal matrix of singular values, Q is an orthogonal
 matrix of left singular vectors, and P is an orthogonal matrix of
 right singular vectors. If left singular vectors are requested, this
 subroutine actually returns U*Q instead of Q, and, if right singular
 vectors are requested, this subroutine returns P**H*VT instead of
 P**H, for given complex input matrices U and VT. When U and VT are
 the unitary matrices that reduce a general matrix A to bidiagonal
 form: A = U*B*VT, as computed by CGEBRD, then
 
 A = (U*Q) * S * (P**H*VT)
 
 is the SVD of A. Optionally, the subroutine may also compute Q**H*C
 for a given complex input matrix C.

 See "Computing Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
 no. 5, pp. 873-912, Sept 1990) and
 "Accurate singular values and differential qd algorithms," by
 B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
 Department, University of California at Berkeley, July 1992
 for a detailed description of the algorithm.

 */
extern proc LAPACK_cbdsqr(ref uplo : c_char, ref n : c_int, ref ncvt : c_int, ref nru : c_int, ref ncc : c_int, d : [] c_float, e : [] c_float, vt : [] complex(64), ref ldvt : c_int, u : [] complex(64), ref ldu : c_int, c : [] complex(64), ref ldc : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zbdsqr

Original Fortran LAPACK documentation for ZBDSQR::

 ZBDSQR computes the singular values and, optionally, the right and/or
 left singular vectors from the singular value decomposition (SVD) of
 a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
 zero-shift QR algorithm. The SVD of B has the form
 
 B = Q * S * P**H
 
 where S is the diagonal matrix of singular values, Q is an orthogonal
 matrix of left singular vectors, and P is an orthogonal matrix of
 right singular vectors. If left singular vectors are requested, this
 subroutine actually returns U*Q instead of Q, and, if right singular
 vectors are requested, this subroutine returns P**H*VT instead of
 P**H, for given complex input matrices U and VT. When U and VT are
 the unitary matrices that reduce a general matrix A to bidiagonal
 form: A = U*B*VT, as computed by ZGEBRD, then
 
 A = (U*Q) * S * (P**H*VT)
 
 is the SVD of A. Optionally, the subroutine may also compute Q**H*C
 for a given complex input matrix C.

 See "Computing Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
 no. 5, pp. 873-912, Sept 1990) and
 "Accurate singular values and differential qd algorithms," by
 B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
 Department, University of California at Berkeley, July 1992
 for a detailed description of the algorithm.

 */
extern proc LAPACK_zbdsqr(ref uplo : c_char, ref n : c_int, ref ncvt : c_int, ref nru : c_int, ref ncc : c_int, d : [] c_double, e : [] c_double, vt : [] complex(128), ref ldvt : c_int, u : [] complex(128), ref ldu : c_int, c : [] complex(128), ref ldc : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sbdsdc

Original Fortran LAPACK documentation for SBDSDC::

 SBDSDC computes the singular value decomposition (SVD) of a real
 N-by-N (upper or lower) bidiagonal matrix B: B = U * S * VT,
 using a divide and conquer method, where S is a diagonal matrix
 with non-negative diagonal elements (the singular values of B), and
 U and VT are orthogonal matrices of left and right singular vectors,
 respectively. SBDSDC can be used to compute all singular values,
 and optionally, singular vectors or singular vectors in compact form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See SLASD3 for details.

 The code currently calls SLASDQ if singular values only are desired.
 However, it can be slightly modified to compute singular values
 using the divide and conquer method.

 */
extern proc LAPACK_sbdsdc(ref uplo : c_char, ref compq : c_char, ref n : c_int, d : [] c_float, e : [] c_float, u : [] c_float, ref ldu : c_int, vt : [] c_float, ref ldvt : c_int, q : [] c_float, iq : [] c_int, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dbdsdc

Original Fortran LAPACK documentation for DBDSDC::

 DBDSDC computes the singular value decomposition (SVD) of a real
 N-by-N (upper or lower) bidiagonal matrix B: B = U * S * VT,
 using a divide and conquer method, where S is a diagonal matrix
 with non-negative diagonal elements (the singular values of B), and
 U and VT are orthogonal matrices of left and right singular vectors,
 respectively. DBDSDC can be used to compute all singular values,
 and optionally, singular vectors or singular vectors in compact form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See DLASD3 for details.

 The code currently calls DLASDQ if singular values only are desired.
 However, it can be slightly modified to compute singular values
 using the divide and conquer method.

 */
extern proc LAPACK_dbdsdc(ref uplo : c_char, ref compq : c_char, ref n : c_int, d : [] c_double, e : [] c_double, u : [] c_double, ref ldu : c_int, vt : [] c_double, ref ldvt : c_int, q : [] c_double, iq : [] c_int, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssytrd

Original Fortran LAPACK documentation for SSYTRD::

 SSYTRD reduces a real symmetric matrix A to real symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

 */
extern proc LAPACK_ssytrd(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, d : [] c_float, e : [] c_float, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsytrd

Original Fortran LAPACK documentation for DSYTRD::

 DSYTRD reduces a real symmetric matrix A to real symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

 */
extern proc LAPACK_dsytrd(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, d : [] c_double, e : [] c_double, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sorgtr

Original Fortran LAPACK documentation for SORGTR::

 SORGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 SSYTRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACK_sorgtr(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dorgtr

Original Fortran LAPACK documentation for DORGTR::

 DORGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 DSYTRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACK_dorgtr(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sormtr

Original Fortran LAPACK documentation for SORMTR::

 SORMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by SSYTRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACK_sormtr(ref side : c_char, ref uplo : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, c : [] c_float, ref ldc : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dormtr

Original Fortran LAPACK documentation for DORMTR::

 DORMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by DSYTRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACK_dormtr(ref side : c_char, ref uplo : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, c : [] c_double, ref ldc : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chetrd

Original Fortran LAPACK documentation for CHETRD::

 CHETRD reduces a complex Hermitian matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

 */
extern proc LAPACK_chetrd(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, d : [] c_float, e : [] c_float, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhetrd

Original Fortran LAPACK documentation for ZHETRD::

 ZHETRD reduces a complex Hermitian matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

 */
extern proc LAPACK_zhetrd(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, d : [] c_double, e : [] c_double, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cungtr

Original Fortran LAPACK documentation for CUNGTR::

 CUNGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 CHETRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACK_cungtr(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zungtr

Original Fortran LAPACK documentation for ZUNGTR::

 ZUNGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 ZHETRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACK_zungtr(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunmtr

Original Fortran LAPACK documentation for CUNMTR::

 CUNMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by CHETRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACK_cunmtr(ref side : c_char, ref uplo : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunmtr

Original Fortran LAPACK documentation for ZUNMTR::

 ZUNMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by ZHETRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACK_zunmtr(ref side : c_char, ref uplo : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssptrd

Original Fortran LAPACK documentation for SSPTRD::

 SSPTRD reduces a real symmetric matrix A stored in packed form to
 symmetric tridiagonal form T by an orthogonal similarity
 transformation: Q**T * A * Q = T.

 */
extern proc LAPACK_ssptrd(ref uplo : c_char, ref n : c_int, ap : [] c_float, d : [] c_float, e : [] c_float, tau : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsptrd

Original Fortran LAPACK documentation for DSPTRD::

 DSPTRD reduces a real symmetric matrix A stored in packed form to
 symmetric tridiagonal form T by an orthogonal similarity
 transformation: Q**T * A * Q = T.

 */
extern proc LAPACK_dsptrd(ref uplo : c_char, ref n : c_int, ap : [] c_double, d : [] c_double, e : [] c_double, tau : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sopgtr

Original Fortran LAPACK documentation for SOPGTR::

 SOPGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 SSPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACK_sopgtr(ref uplo : c_char, ref n : c_int, ap : [] c_float, tau : [] c_float, q : [] c_float, ref ldq : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dopgtr

Original Fortran LAPACK documentation for DOPGTR::

 DOPGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 DSPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACK_dopgtr(ref uplo : c_char, ref n : c_int, ap : [] c_double, tau : [] c_double, q : [] c_double, ref ldq : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sopmtr

Original Fortran LAPACK documentation for SOPMTR::

 SOPMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by SSPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACK_sopmtr(ref side : c_char, ref uplo : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ap : [] c_float, tau : [] c_float, c : [] c_float, ref ldc : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dopmtr

Original Fortran LAPACK documentation for DOPMTR::

 DOPMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by DSPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACK_dopmtr(ref side : c_char, ref uplo : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ap : [] c_double, tau : [] c_double, c : [] c_double, ref ldc : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chptrd

Original Fortran LAPACK documentation for CHPTRD::

 CHPTRD reduces a complex Hermitian matrix A stored in packed form to
 real symmetric tridiagonal form T by a unitary similarity
 transformation: Q**H * A * Q = T.

 */
extern proc LAPACK_chptrd(ref uplo : c_char, ref n : c_int, ap : [] complex(64), d : [] c_float, e : [] c_float, tau : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhptrd

Original Fortran LAPACK documentation for ZHPTRD::

 ZHPTRD reduces a complex Hermitian matrix A stored in packed form to
 real symmetric tridiagonal form T by a unitary similarity
 transformation: Q**H * A * Q = T.

 */
extern proc LAPACK_zhptrd(ref uplo : c_char, ref n : c_int, ap : [] complex(128), d : [] c_double, e : [] c_double, tau : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cupgtr

Original Fortran LAPACK documentation for CUPGTR::

 CUPGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 CHPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACK_cupgtr(ref uplo : c_char, ref n : c_int, ap : [] complex(64), tau : [] complex(64), q : [] complex(64), ref ldq : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zupgtr

Original Fortran LAPACK documentation for ZUPGTR::

 ZUPGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 ZHPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

 */
extern proc LAPACK_zupgtr(ref uplo : c_char, ref n : c_int, ap : [] complex(128), tau : [] complex(128), q : [] complex(128), ref ldq : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cupmtr

Original Fortran LAPACK documentation for CUPMTR::

 CUPMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by CHPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACK_cupmtr(ref side : c_char, ref uplo : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ap : [] complex(64), tau : [] complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zupmtr

Original Fortran LAPACK documentation for ZUPMTR::

 ZUPMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by ZHPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

 */
extern proc LAPACK_zupmtr(ref side : c_char, ref uplo : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ap : [] complex(128), tau : [] complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssbtrd

Original Fortran LAPACK documentation for SSBTRD::

 SSBTRD reduces a real symmetric band matrix A to symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

 */
extern proc LAPACK_ssbtrd(ref vect : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_float, ref ldab : c_int, d : [] c_float, e : [] c_float, q : [] c_float, ref ldq : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsbtrd

Original Fortran LAPACK documentation for DSBTRD::

 DSBTRD reduces a real symmetric band matrix A to symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

 */
extern proc LAPACK_dsbtrd(ref vect : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_double, ref ldab : c_int, d : [] c_double, e : [] c_double, q : [] c_double, ref ldq : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chbtrd

Original Fortran LAPACK documentation for CHBTRD::

 CHBTRD reduces a complex Hermitian band matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

 */
extern proc LAPACK_chbtrd(ref vect : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(64), ref ldab : c_int, d : [] c_float, e : [] c_float, q : [] complex(64), ref ldq : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhbtrd

Original Fortran LAPACK documentation for ZHBTRD::

 ZHBTRD reduces a complex Hermitian band matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

 */
extern proc LAPACK_zhbtrd(ref vect : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(128), ref ldab : c_int, d : [] c_double, e : [] c_double, q : [] complex(128), ref ldq : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssterf

Original Fortran LAPACK documentation for SSTERF::

 SSTERF computes all eigenvalues of a symmetric tridiagonal matrix
 using the Pal-Walker-Kahan variant of the QL or QR algorithm.

 */
extern proc LAPACK_ssterf(ref n : c_int, d : [] c_float, e : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsterf

Original Fortran LAPACK documentation for DSTERF::

 DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
 using the Pal-Walker-Kahan variant of the QL or QR algorithm.

 */
extern proc LAPACK_dsterf(ref n : c_int, d : [] c_double, e : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssteqr

Original Fortran LAPACK documentation for SSTEQR::

 SSTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the implicit QL or QR method.
 The eigenvectors of a full or band symmetric matrix can also be found
 if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to
 tridiagonal form.

 */
extern proc LAPACK_ssteqr(ref compz : c_char, ref n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsteqr

Original Fortran LAPACK documentation for DSTEQR::

 DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the implicit QL or QR method.
 The eigenvectors of a full or band symmetric matrix can also be found
 if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
 tridiagonal form.

 */
extern proc LAPACK_dsteqr(ref compz : c_char, ref n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csteqr

Original Fortran LAPACK documentation for CSTEQR::

 CSTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the implicit QL or QR method.
 The eigenvectors of a full or band complex Hermitian matrix can also
 be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
 matrix to tridiagonal form.

 */
extern proc LAPACK_csteqr(ref compz : c_char, ref n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsteqr

Original Fortran LAPACK documentation for ZSTEQR::

 ZSTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the implicit QL or QR method.
 The eigenvectors of a full or band complex Hermitian matrix can also
 be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
 matrix to tridiagonal form.

 */
extern proc LAPACK_zsteqr(ref compz : c_char, ref n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sstemr

Original Fortran LAPACK documentation for SSTEMR::

 SSTEMR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 Depending on the number of desired eigenvalues, these are computed either
 by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
 computed by the use of various suitable L D L^T factorizations near clusters
 of close eigenvalues (referred to as RRRs, Relatively Robust
 Representations). An informal sketch of the algorithm follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 For more details, see:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.

 Further Details
 1.SSTEMR works only on machines which follow IEEE-754
 floating-point standard in their handling of infinities and NaNs.
 This permits the use of efficient inner loops avoiding a check for
 zero divisors.

 */
extern proc LAPACK_sstemr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_float, e : [] c_float, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, ref nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dstemr

Original Fortran LAPACK documentation for DSTEMR::

 DSTEMR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 Depending on the number of desired eigenvalues, these are computed either
 by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
 computed by the use of various suitable L D L^T factorizations near clusters
 of close eigenvalues (referred to as RRRs, Relatively Robust
 Representations). An informal sketch of the algorithm follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 For more details, see:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.

 Further Details
 1.DSTEMR works only on machines which follow IEEE-754
 floating-point standard in their handling of infinities and NaNs.
 This permits the use of efficient inner loops avoiding a check for
 zero divisors.

 */
extern proc LAPACK_dstemr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_double, e : [] c_double, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, ref nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cstemr

Original Fortran LAPACK documentation for CSTEMR::

 CSTEMR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 Depending on the number of desired eigenvalues, these are computed either
 by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
 computed by the use of various suitable L D L^T factorizations near clusters
 of close eigenvalues (referred to as RRRs, Relatively Robust
 Representations). An informal sketch of the algorithm follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 For more details, see:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.

 Further Details
 1.CSTEMR works only on machines which follow IEEE-754
 floating-point standard in their handling of infinities and NaNs.
 This permits the use of efficient inner loops avoiding a check for
 zero divisors.

 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
 real symmetric tridiagonal form.

 (Any complex Hermitean tridiagonal matrix has real values on its diagonal
 and potentially complex numbers on its off-diagonals. By applying a
 similarity transform with an appropriate diagonal matrix
 diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
 matrix can be transformed into a real symmetric matrix and complex
 arithmetic can be entirely avoided.)

 While the eigenvectors of the real symmetric tridiagonal matrix are real,
 the eigenvectors of original complex Hermitean matrix have complex entries
 in general.
 Since LAPACK drivers overwrite the matrix data with the eigenvectors,
 CSTEMR accepts complex workspace to facilitate interoperability
 with CUNMTR or CUPMTR.

 */
extern proc LAPACK_cstemr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_float, e : [] c_float, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref m : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, ref nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zstemr

Original Fortran LAPACK documentation for ZSTEMR::

 ZSTEMR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 Depending on the number of desired eigenvalues, these are computed either
 by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
 computed by the use of various suitable L D L^T factorizations near clusters
 of close eigenvalues (referred to as RRRs, Relatively Robust
 Representations). An informal sketch of the algorithm follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 For more details, see:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.

 Further Details
 1.ZSTEMR works only on machines which follow IEEE-754
 floating-point standard in their handling of infinities and NaNs.
 This permits the use of efficient inner loops avoiding a check for
 zero divisors.

 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
 real symmetric tridiagonal form.

 (Any complex Hermitean tridiagonal matrix has real values on its diagonal
 and potentially complex numbers on its off-diagonals. By applying a
 similarity transform with an appropriate diagonal matrix
 diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
 matrix can be transformed into a real symmetric matrix and complex
 arithmetic can be entirely avoided.)

 While the eigenvectors of the real symmetric tridiagonal matrix are real,
 the eigenvectors of original complex Hermitean matrix have complex entries
 in general.
 Since LAPACK drivers overwrite the matrix data with the eigenvectors,
 ZSTEMR accepts complex workspace to facilitate interoperability
 with ZUNMTR or ZUPMTR.

 */
extern proc LAPACK_zstemr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_double, e : [] c_double, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref m : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, ref nzc : c_int, isuppz : [] c_int, ref tryrac : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sstedc

Original Fortran LAPACK documentation for SSTEDC::

 SSTEDC computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the divide and conquer method.
 The eigenvectors of a full or band real symmetric matrix can also be
 found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this
 matrix to tridiagonal form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See SLAED3 for details.

 */
extern proc LAPACK_sstedc(ref compz : c_char, ref n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dstedc

Original Fortran LAPACK documentation for DSTEDC::

 DSTEDC computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the divide and conquer method.
 The eigenvectors of a full or band real symmetric matrix can also be
 found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
 matrix to tridiagonal form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See DLAED3 for details.

 */
extern proc LAPACK_dstedc(ref compz : c_char, ref n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cstedc

Original Fortran LAPACK documentation for CSTEDC::

 CSTEDC computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the divide and conquer method.
 The eigenvectors of a full or band complex Hermitian matrix can also
 be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
 matrix to tridiagonal form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See SLAED3 for details.

 */
extern proc LAPACK_cstedc(ref compz : c_char, ref n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zstedc

Original Fortran LAPACK documentation for ZSTEDC::

 ZSTEDC computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the divide and conquer method.
 The eigenvectors of a full or band complex Hermitian matrix can also
 be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
 matrix to tridiagonal form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See DLAED3 for details.

 */
extern proc LAPACK_zstedc(ref compz : c_char, ref n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sstegr

Original Fortran LAPACK documentation for SSTEGR::

 SSTEGR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 SSTEGR is a compatability wrapper around the improved SSTEMR routine.
 See SSTEMR for further details.

 One important change is that the ABSTOL parameter no longer provides any
 benefit and hence is no longer used.

 Note : SSTEGR and SSTEMR work only on machines which follow
 IEEE-754 floating-point standard in their handling of infinities and
 NaNs. Normal execution may create these exceptiona values and hence
 may abort due to a floating point exception in environments which
 do not conform to the IEEE-754 standard.

 */
extern proc LAPACK_sstegr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_float, e : [] c_float, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, isuppz : [] c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dstegr

Original Fortran LAPACK documentation for DSTEGR::

 DSTEGR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 DSTEGR is a compatability wrapper around the improved DSTEMR routine.
 See DSTEMR for further details.

 One important change is that the ABSTOL parameter no longer provides any
 benefit and hence is no longer used.

 Note : DSTEGR and DSTEMR work only on machines which follow
 IEEE-754 floating-point standard in their handling of infinities and
 NaNs. Normal execution may create these exceptiona values and hence
 may abort due to a floating point exception in environments which
 do not conform to the IEEE-754 standard.

 */
extern proc LAPACK_dstegr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_double, e : [] c_double, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, isuppz : [] c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cstegr

Original Fortran LAPACK documentation for CSTEGR::

 CSTEGR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 CSTEGR is a compatability wrapper around the improved CSTEMR routine.
 See SSTEMR for further details.

 One important change is that the ABSTOL parameter no longer provides any
 benefit and hence is no longer used.

 Note : CSTEGR and CSTEMR work only on machines which follow
 IEEE-754 floating-point standard in their handling of infinities and
 NaNs. Normal execution may create these exceptiona values and hence
 may abort due to a floating point exception in environments which
 do not conform to the IEEE-754 standard.

 */
extern proc LAPACK_cstegr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_float, e : [] c_float, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, isuppz : [] c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zstegr

Original Fortran LAPACK documentation for ZSTEGR::

 ZSTEGR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 ZSTEGR is a compatability wrapper around the improved ZSTEMR routine.
 See DSTEMR for further details.

 One important change is that the ABSTOL parameter no longer provides any
 benefit and hence is no longer used.

 Note : ZSTEGR and ZSTEMR work only on machines which follow
 IEEE-754 floating-point standard in their handling of infinities and
 NaNs. Normal execution may create these exceptiona values and hence
 may abort due to a floating point exception in environments which
 do not conform to the IEEE-754 standard.

 */
extern proc LAPACK_zstegr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_double, e : [] c_double, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, isuppz : [] c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spteqr

Original Fortran LAPACK documentation for SPTEQR::

 SPTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric positive definite tridiagonal matrix by first factoring the
 matrix using SPTTRF, and then calling SBDSQR to compute the singular
 values of the bidiagonal factor.

 This routine computes the eigenvalues of the positive definite
 tridiagonal matrix to high relative accuracy. This means that if the
 eigenvalues range over many orders of magnitude in size, then the
 small eigenvalues and corresponding eigenvectors will be computed
 more accurately than, for example, with the standard QR method.

 The eigenvectors of a full or band symmetric positive definite matrix
 can also be found if SSYTRD, SSPTRD, or SSBTRD has been used to
 reduce this matrix to tridiagonal form. (The reduction to tridiagonal
 form, however, may preclude the possibility of obtaining high
 relative accuracy in the small eigenvalues of the original matrix, if
 these eigenvalues range over many orders of magnitude.)

 */
extern proc LAPACK_spteqr(ref compz : c_char, ref n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpteqr

Original Fortran LAPACK documentation for DPTEQR::

 DPTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric positive definite tridiagonal matrix by first factoring the
 matrix using DPTTRF, and then calling DBDSQR to compute the singular
 values of the bidiagonal factor.

 This routine computes the eigenvalues of the positive definite
 tridiagonal matrix to high relative accuracy. This means that if the
 eigenvalues range over many orders of magnitude in size, then the
 small eigenvalues and corresponding eigenvectors will be computed
 more accurately than, for example, with the standard QR method.

 The eigenvectors of a full or band symmetric positive definite matrix
 can also be found if DSYTRD, DSPTRD, or DSBTRD has been used to
 reduce this matrix to tridiagonal form. (The reduction to tridiagonal
 form, however, may preclude the possibility of obtaining high
 relative accuracy in the small eigenvalues of the original matrix, if
 these eigenvalues range over many orders of magnitude.)

 */
extern proc LAPACK_dpteqr(ref compz : c_char, ref n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpteqr

Original Fortran LAPACK documentation for CPTEQR::

 CPTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric positive definite tridiagonal matrix by first factoring the
 matrix using SPTTRF and then calling CBDSQR to compute the singular
 values of the bidiagonal factor.

 This routine computes the eigenvalues of the positive definite
 tridiagonal matrix to high relative accuracy. This means that if the
 eigenvalues range over many orders of magnitude in size, then the
 small eigenvalues and corresponding eigenvectors will be computed
 more accurately than, for example, with the standard QR method.

 The eigenvectors of a full or band positive definite Hermitian matrix
 can also be found if CHETRD, CHPTRD, or CHBTRD has been used to
 reduce this matrix to tridiagonal form. (The reduction to
 tridiagonal form, however, may preclude the possibility of obtaining
 high relative accuracy in the small eigenvalues of the original
 matrix, if these eigenvalues range over many orders of magnitude.)

 */
extern proc LAPACK_cpteqr(ref compz : c_char, ref n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpteqr

Original Fortran LAPACK documentation for ZPTEQR::

 ZPTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric positive definite tridiagonal matrix by first factoring the
 matrix using DPTTRF and then calling ZBDSQR to compute the singular
 values of the bidiagonal factor.

 This routine computes the eigenvalues of the positive definite
 tridiagonal matrix to high relative accuracy. This means that if the
 eigenvalues range over many orders of magnitude in size, then the
 small eigenvalues and corresponding eigenvectors will be computed
 more accurately than, for example, with the standard QR method.

 The eigenvectors of a full or band positive definite Hermitian matrix
 can also be found if ZHETRD, ZHPTRD, or ZHBTRD has been used to
 reduce this matrix to tridiagonal form. (The reduction to
 tridiagonal form, however, may preclude the possibility of obtaining
 high relative accuracy in the small eigenvalues of the original
 matrix, if these eigenvalues range over many orders of magnitude.)

 */
extern proc LAPACK_zpteqr(ref compz : c_char, ref n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sstebz

Original Fortran LAPACK documentation for SSTEBZ::

 SSTEBZ computes the eigenvalues of a symmetric tridiagonal
 matrix T. The user may ask for all eigenvalues, all eigenvalues
 in the half-open interval (VL, VU], or the IL-th through IU-th
 eigenvalues.

 To avoid overflow, the matrix must be scaled so that its
 largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
 accuracy, it should not be much smaller than that.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966.

 */
extern proc LAPACK_sstebz(ref range : c_char, ref order : c_char, ref n : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, d : [] c_float, e : [] c_float, ref m : c_int, ref nsplit : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dstebz

Original Fortran LAPACK documentation for DSTEBZ::

 DSTEBZ computes the eigenvalues of a symmetric tridiagonal
 matrix T. The user may ask for all eigenvalues, all eigenvalues
 in the half-open interval (VL, VU], or the IL-th through IU-th
 eigenvalues.

 To avoid overflow, the matrix must be scaled so that its
 largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
 accuracy, it should not be much smaller than that.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966.

 */
extern proc LAPACK_dstebz(ref range : c_char, ref order : c_char, ref n : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, d : [] c_double, e : [] c_double, ref m : c_int, ref nsplit : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sstein

Original Fortran LAPACK documentation for SSTEIN::

 SSTEIN computes the eigenvectors of a real symmetric tridiagonal
 matrix T corresponding to specified eigenvalues, using inverse
 iteration.

 The maximum number of iterations allowed for each eigenvector is
 specified by an internal parameter MAXITS (currently set to 5).

 */
extern proc LAPACK_sstein(ref n : c_int, d : [] c_float, e : [] c_float, ref m : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, z : [] c_float, ref ldz : c_int, work : [] c_float, iwork : [] c_int, ifailv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dstein

Original Fortran LAPACK documentation for DSTEIN::

 DSTEIN computes the eigenvectors of a real symmetric tridiagonal
 matrix T corresponding to specified eigenvalues, using inverse
 iteration.

 The maximum number of iterations allowed for each eigenvector is
 specified by an internal parameter MAXITS (currently set to 5).

 */
extern proc LAPACK_dstein(ref n : c_int, d : [] c_double, e : [] c_double, ref m : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, z : [] c_double, ref ldz : c_int, work : [] c_double, iwork : [] c_int, ifailv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cstein

Original Fortran LAPACK documentation for CSTEIN::

 CSTEIN computes the eigenvectors of a real symmetric tridiagonal
 matrix T corresponding to specified eigenvalues, using inverse
 iteration.

 The maximum number of iterations allowed for each eigenvector is
 specified by an internal parameter MAXITS (currently set to 5).

 Although the eigenvectors are real, they are stored in a complex
 array, which may be passed to CUNMTR or CUPMTR for back
 transformation to the eigenvectors of a complex Hermitian matrix
 which was reduced to tridiagonal form.

 */
extern proc LAPACK_cstein(ref n : c_int, d : [] c_float, e : [] c_float, ref m : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, z : [] complex(64), ref ldz : c_int, work : [] c_float, iwork : [] c_int, ifailv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zstein

Original Fortran LAPACK documentation for ZSTEIN::

 ZSTEIN computes the eigenvectors of a real symmetric tridiagonal
 matrix T corresponding to specified eigenvalues, using inverse
 iteration.

 The maximum number of iterations allowed for each eigenvector is
 specified by an internal parameter MAXITS (currently set to 5).

 Although the eigenvectors are real, they are stored in a complex
 array, which may be passed to ZUNMTR or ZUPMTR for back
 transformation to the eigenvectors of a complex Hermitian matrix
 which was reduced to tridiagonal form.

 */
extern proc LAPACK_zstein(ref n : c_int, d : [] c_double, e : [] c_double, ref m : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, z : [] complex(128), ref ldz : c_int, work : [] c_double, iwork : [] c_int, ifailv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sdisna

Original Fortran LAPACK documentation for SDISNA::

 SDISNA computes the reciprocal condition numbers for the eigenvectors
 of a real symmetric or complex Hermitian matrix or for the left or
 right singular vectors of a general m-by-n matrix. The reciprocal
 condition number is the 'gap' between the corresponding eigenvalue or
 singular value and the nearest other one.

 The bound on the error, measured by angle in radians, in the I-th
 computed vector is given by

 SLAMCH( 'E' ) * ( ANORM / SEP( I ) )

 where ANORM = 2-norm(A) = max( abs( D(j) ) ). SEP(I) is not allowed
 to be smaller than SLAMCH( 'E' )*ANORM in order to limit the size of
 the error bound.

 SDISNA may also be used to compute error bounds for eigenvectors of
 the generalized symmetric definite eigenproblem.

 */
extern proc LAPACK_sdisna(ref job : c_char, ref m : c_int, ref n : c_int, d : [] c_float, sep : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ddisna

Original Fortran LAPACK documentation for DDISNA::

 DDISNA computes the reciprocal condition numbers for the eigenvectors
 of a real symmetric or complex Hermitian matrix or for the left or
 right singular vectors of a general m-by-n matrix. The reciprocal
 condition number is the 'gap' between the corresponding eigenvalue or
 singular value and the nearest other one.

 The bound on the error, measured by angle in radians, in the I-th
 computed vector is given by

 DLAMCH( 'E' ) * ( ANORM / SEP( I ) )

 where ANORM = 2-norm(A) = max( abs( D(j) ) ). SEP(I) is not allowed
 to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
 the error bound.

 DDISNA may also be used to compute error bounds for eigenvectors of
 the generalized symmetric definite eigenproblem.

 */
extern proc LAPACK_ddisna(ref job : c_char, ref m : c_int, ref n : c_int, d : [] c_double, sep : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssygst

Original Fortran LAPACK documentation for SSYGST::

 SSYGST reduces a real symmetric-definite generalized eigenproblem
 to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by SPOTRF.

 */
extern proc LAPACK_ssygst(ref itype : c_int, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsygst

Original Fortran LAPACK documentation for DSYGST::

 DSYGST reduces a real symmetric-definite generalized eigenproblem
 to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by DPOTRF.

 */
extern proc LAPACK_dsygst(ref itype : c_int, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chegst

Original Fortran LAPACK documentation for CHEGST::

 CHEGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by CPOTRF.

 */
extern proc LAPACK_chegst(ref itype : c_int, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhegst

Original Fortran LAPACK documentation for ZHEGST::

 ZHEGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by ZPOTRF.

 */
extern proc LAPACK_zhegst(ref itype : c_int, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspgst

Original Fortran LAPACK documentation for SSPGST::

 SSPGST reduces a real symmetric-definite generalized eigenproblem
 to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by SPPTRF.

 */
extern proc LAPACK_sspgst(ref itype : c_int, ref uplo : c_char, ref n : c_int, ap : [] c_float, bp : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspgst

Original Fortran LAPACK documentation for DSPGST::

 DSPGST reduces a real symmetric-definite generalized eigenproblem
 to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by DPPTRF.

 */
extern proc LAPACK_dspgst(ref itype : c_int, ref uplo : c_char, ref n : c_int, ap : [] c_double, bp : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpgst

Original Fortran LAPACK documentation for CHPGST::

 CHPGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by CPPTRF.

 */
extern proc LAPACK_chpgst(ref itype : c_int, ref uplo : c_char, ref n : c_int, ap : [] complex(64), bp : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpgst

Original Fortran LAPACK documentation for ZHPGST::

 ZHPGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by ZPPTRF.

 */
extern proc LAPACK_zhpgst(ref itype : c_int, ref uplo : c_char, ref n : c_int, ap : [] complex(128), bp : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssbgst

Original Fortran LAPACK documentation for SSBGST::

 SSBGST reduces a real symmetric-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**T*S by SPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**T*A*X, where
 X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
 bandwidth of A.

 */
extern proc LAPACK_ssbgst(ref vect : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] c_float, ref ldab : c_int, bb : [] c_float, ref ldbb : c_int, x : [] c_float, ref ldx : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsbgst

Original Fortran LAPACK documentation for DSBGST::

 DSBGST reduces a real symmetric-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**T*S by DPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**T*A*X, where
 X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
 bandwidth of A.

 */
extern proc LAPACK_dsbgst(ref vect : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] c_double, ref ldab : c_int, bb : [] c_double, ref ldbb : c_int, x : [] c_double, ref ldx : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chbgst

Original Fortran LAPACK documentation for CHBGST::

 CHBGST reduces a complex Hermitian-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**H*S by CPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**H*A*X, where
 X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
 bandwidth of A.

 */
extern proc LAPACK_chbgst(ref vect : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] complex(64), ref ldab : c_int, bb : [] complex(64), ref ldbb : c_int, x : [] complex(64), ref ldx : c_int, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhbgst

Original Fortran LAPACK documentation for ZHBGST::

 ZHBGST reduces a complex Hermitian-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**H*S by ZPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**H*A*X, where
 X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
 bandwidth of A.

 */
extern proc LAPACK_zhbgst(ref vect : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] complex(128), ref ldab : c_int, bb : [] complex(128), ref ldbb : c_int, x : [] complex(128), ref ldx : c_int, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_spbstf

Original Fortran LAPACK documentation for SPBSTF::

 SPBSTF computes a split Cholesky factorization of a real
 symmetric positive definite band matrix A.

 This routine is designed to be used in conjunction with SSBGST.

 The factorization has the form A = S**T*S where S is a band matrix
 of the same bandwidth as A and the following structure:

 S = ( U )
 ( M L )

 where U is upper triangular of order m = (n+kd)/2, and L is lower
 triangular of order n-m.

 */
extern proc LAPACK_spbstf(ref uplo : c_char, ref n : c_int, ref kb : c_int, bb : [] c_float, ref ldbb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dpbstf

Original Fortran LAPACK documentation for DPBSTF::

 DPBSTF computes a split Cholesky factorization of a real
 symmetric positive definite band matrix A.

 This routine is designed to be used in conjunction with DSBGST.

 The factorization has the form A = S**T*S where S is a band matrix
 of the same bandwidth as A and the following structure:

 S = ( U )
 ( M L )

 where U is upper triangular of order m = (n+kd)/2, and L is lower
 triangular of order n-m.

 */
extern proc LAPACK_dpbstf(ref uplo : c_char, ref n : c_int, ref kb : c_int, bb : [] c_double, ref ldbb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cpbstf

Original Fortran LAPACK documentation for CPBSTF::

 CPBSTF computes a split Cholesky factorization of a complex
 Hermitian positive definite band matrix A.

 This routine is designed to be used in conjunction with CHBGST.

 The factorization has the form A = S**H*S where S is a band matrix
 of the same bandwidth as A and the following structure:

 S = ( U )
 ( M L )

 where U is upper triangular of order m = (n+kd)/2, and L is lower
 triangular of order n-m.

 */
extern proc LAPACK_cpbstf(ref uplo : c_char, ref n : c_int, ref kb : c_int, bb : [] complex(64), ref ldbb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zpbstf

Original Fortran LAPACK documentation for ZPBSTF::

 ZPBSTF computes a split Cholesky factorization of a complex
 Hermitian positive definite band matrix A.

 This routine is designed to be used in conjunction with ZHBGST.

 The factorization has the form A = S**H*S where S is a band matrix
 of the same bandwidth as A and the following structure:

 S = ( U )
 ( M L )

 where U is upper triangular of order m = (n+kd)/2, and L is lower
 triangular of order n-m.

 */
extern proc LAPACK_zpbstf(ref uplo : c_char, ref n : c_int, ref kb : c_int, bb : [] complex(128), ref ldbb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgehrd

Original Fortran LAPACK documentation for SGEHRD::

 SGEHRD reduces a real general matrix A to upper Hessenberg form H by
 an orthogonal similarity transformation: Q**T * A * Q = H .

 */
extern proc LAPACK_sgehrd(ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgehrd

Original Fortran LAPACK documentation for DGEHRD::

 DGEHRD reduces a real general matrix A to upper Hessenberg form H by
 an orthogonal similarity transformation: Q**T * A * Q = H .

 */
extern proc LAPACK_dgehrd(ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgehrd

Original Fortran LAPACK documentation for CGEHRD::

 CGEHRD reduces a complex general matrix A to upper Hessenberg form H by
 an unitary similarity transformation: Q**H * A * Q = H .

 */
extern proc LAPACK_cgehrd(ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgehrd

Original Fortran LAPACK documentation for ZGEHRD::

 ZGEHRD reduces a complex general matrix A to upper Hessenberg form H by
 an unitary similarity transformation: Q**H * A * Q = H .

 */
extern proc LAPACK_zgehrd(ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sorghr

Original Fortran LAPACK documentation for SORGHR::

 SORGHR generates a real orthogonal matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 SGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACK_sorghr(ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dorghr

Original Fortran LAPACK documentation for DORGHR::

 DORGHR generates a real orthogonal matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 DGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACK_dorghr(ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sormhr

Original Fortran LAPACK documentation for SORMHR::

 SORMHR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by SGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACK_sormhr(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, c : [] c_float, ref ldc : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dormhr

Original Fortran LAPACK documentation for DORMHR::

 DORMHR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by DGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACK_dormhr(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, c : [] c_double, ref ldc : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunghr

Original Fortran LAPACK documentation for CUNGHR::

 CUNGHR generates a complex unitary matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 CGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACK_cunghr(ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunghr

Original Fortran LAPACK documentation for ZUNGHR::

 ZUNGHR generates a complex unitary matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 ZGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACK_zunghr(ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunmhr

Original Fortran LAPACK documentation for CUNMHR::

 CUNMHR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by CGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACK_cunmhr(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunmhr

Original Fortran LAPACK documentation for ZUNMHR::

 ZUNMHR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by ZGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

 */
extern proc LAPACK_zunmhr(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgebal

Original Fortran LAPACK documentation for SGEBAL::

 SGEBAL balances a general real matrix A. This involves, first,
 permuting A by a similarity transformation to isolate eigenvalues
 in the first 1 to ILO-1 and last IHI+1 to N elements on the
 diagonal; and second, applying a diagonal similarity transformation
 to rows and columns ILO to IHI to make the rows and columns as
 close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrix, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors.

 */
extern proc LAPACK_sgebal(ref job : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgebal

Original Fortran LAPACK documentation for DGEBAL::

 DGEBAL balances a general real matrix A. This involves, first,
 permuting A by a similarity transformation to isolate eigenvalues
 in the first 1 to ILO-1 and last IHI+1 to N elements on the
 diagonal; and second, applying a diagonal similarity transformation
 to rows and columns ILO to IHI to make the rows and columns as
 close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrix, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors.

 */
extern proc LAPACK_dgebal(ref job : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgebal

Original Fortran LAPACK documentation for CGEBAL::

 CGEBAL balances a general complex matrix A. This involves, first,
 permuting A by a similarity transformation to isolate eigenvalues
 in the first 1 to ILO-1 and last IHI+1 to N elements on the
 diagonal; and second, applying a diagonal similarity transformation
 to rows and columns ILO to IHI to make the rows and columns as
 close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrix, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors.

 */
extern proc LAPACK_cgebal(ref job : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgebal

Original Fortran LAPACK documentation for ZGEBAL::

 ZGEBAL balances a general complex matrix A. This involves, first,
 permuting A by a similarity transformation to isolate eigenvalues
 in the first 1 to ILO-1 and last IHI+1 to N elements on the
 diagonal; and second, applying a diagonal similarity transformation
 to rows and columns ILO to IHI to make the rows and columns as
 close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrix, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors.

 */
extern proc LAPACK_zgebal(ref job : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgebak

Original Fortran LAPACK documentation for SGEBAK::

 SGEBAK forms the right or left eigenvectors of a real general matrix
 by backward transformation on the computed eigenvectors of the
 balanced matrix output by SGEBAL.

 */
extern proc LAPACK_sgebak(ref job : c_char, ref side : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref m : c_int, v : [] c_float, ref ldv : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgebak

Original Fortran LAPACK documentation for DGEBAK::

 DGEBAK forms the right or left eigenvectors of a real general matrix
 by backward transformation on the computed eigenvectors of the
 balanced matrix output by DGEBAL.

 */
extern proc LAPACK_dgebak(ref job : c_char, ref side : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref m : c_int, v : [] c_double, ref ldv : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgebak

Original Fortran LAPACK documentation for CGEBAK::

 CGEBAK forms the right or left eigenvectors of a complex general
 matrix by backward transformation on the computed eigenvectors of the
 balanced matrix output by CGEBAL.

 */
extern proc LAPACK_cgebak(ref job : c_char, ref side : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref m : c_int, v : [] complex(64), ref ldv : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgebak

Original Fortran LAPACK documentation for ZGEBAK::

 ZGEBAK forms the right or left eigenvectors of a complex general
 matrix by backward transformation on the computed eigenvectors of the
 balanced matrix output by ZGEBAL.

 */
extern proc LAPACK_zgebak(ref job : c_char, ref side : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref m : c_int, v : [] complex(128), ref ldv : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_shseqr

Original Fortran LAPACK documentation for SHSEQR::

 SHSEQR computes the eigenvalues of a Hessenberg matrix H
 and, optionally, the matrices T and Z from the Schur decomposition
 H = Z T Z**T, where T is an upper quasi-triangular matrix (the
 Schur form), and Z is the orthogonal matrix of Schur vectors.

 Optionally Z may be postmultiplied into an input orthogonal
 matrix Q so that this routine can give the Schur factorization
 of a matrix A which has been reduced to the Hessenberg form H
 by the orthogonal matrix Q: A = Q*H*Q**T = (QZ)*T*(QZ)**T.

 */
extern proc LAPACK_shseqr(ref job : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, h : [] c_float, ref ldh : c_int, wr : [] c_float, wi : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dhseqr

Original Fortran LAPACK documentation for DHSEQR::

 DHSEQR computes the eigenvalues of a Hessenberg matrix H
 and, optionally, the matrices T and Z from the Schur decomposition
 H = Z T Z**T, where T is an upper quasi-triangular matrix (the
 Schur form), and Z is the orthogonal matrix of Schur vectors.

 Optionally Z may be postmultiplied into an input orthogonal
 matrix Q so that this routine can give the Schur factorization
 of a matrix A which has been reduced to the Hessenberg form H
 by the orthogonal matrix Q: A = Q*H*Q**T = (QZ)*T*(QZ)**T.

 */
extern proc LAPACK_dhseqr(ref job : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, h : [] c_double, ref ldh : c_int, wr : [] c_double, wi : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chseqr

Original Fortran LAPACK documentation for CHSEQR::

 CHSEQR computes the eigenvalues of a Hessenberg matrix H
 and, optionally, the matrices T and Z from the Schur decomposition
 H = Z T Z**H, where T is an upper triangular matrix (the
 Schur form), and Z is the unitary matrix of Schur vectors.

 Optionally Z may be postmultiplied into an input unitary
 matrix Q so that this routine can give the Schur factorization
 of a matrix A which has been reduced to the Hessenberg form H
 by the unitary matrix Q: A = Q*H*Q**H = (QZ)*T*(QZ)**H.

 */
extern proc LAPACK_chseqr(ref job : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, h : [] complex(64), ref ldh : c_int, w : [] complex(64), z : [] complex(64), ref ldz : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhseqr

Original Fortran LAPACK documentation for ZHSEQR::

 ZHSEQR computes the eigenvalues of a Hessenberg matrix H
 and, optionally, the matrices T and Z from the Schur decomposition
 H = Z T Z**H, where T is an upper triangular matrix (the
 Schur form), and Z is the unitary matrix of Schur vectors.

 Optionally Z may be postmultiplied into an input unitary
 matrix Q so that this routine can give the Schur factorization
 of a matrix A which has been reduced to the Hessenberg form H
 by the unitary matrix Q: A = Q*H*Q**H = (QZ)*T*(QZ)**H.

 */
extern proc LAPACK_zhseqr(ref job : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, h : [] complex(128), ref ldh : c_int, w : [] complex(128), z : [] complex(128), ref ldz : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_shsein

Original Fortran LAPACK documentation for SHSEIN::

 SHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a real upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

 H * x = w * x, y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.

 */
extern proc LAPACK_shsein(ref job : c_char, ref eigsrc : c_char, ref initv : c_char, chlapack_select : [] c_int, ref n : c_int, h : [] c_float, ref ldh : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ref ldvl : c_int, vr : [] c_float, ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] c_float, ifaill : [] c_int, ifailr : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dhsein

Original Fortran LAPACK documentation for DHSEIN::

 DHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a real upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

 H * x = w * x, y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.

 */
extern proc LAPACK_dhsein(ref job : c_char, ref eigsrc : c_char, ref initv : c_char, chlapack_select : [] c_int, ref n : c_int, h : [] c_double, ref ldh : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ref ldvl : c_int, vr : [] c_double, ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] c_double, ifaill : [] c_int, ifailr : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chsein

Original Fortran LAPACK documentation for CHSEIN::

 CHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a complex upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

 H * x = w * x, y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.

 */
extern proc LAPACK_chsein(ref job : c_char, ref eigsrc : c_char, ref initv : c_char, chlapack_select : [] c_int, ref n : c_int, h : [] complex(64), ref ldh : c_int, w : [] complex(64), vl : [] complex(64), ref ldvl : c_int, vr : [] complex(64), ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] complex(64), rwork : [] c_float, ifaill : [] c_int, ifailr : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhsein

Original Fortran LAPACK documentation for ZHSEIN::

 ZHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a complex upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

 H * x = w * x, y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.

 */
extern proc LAPACK_zhsein(ref job : c_char, ref eigsrc : c_char, ref initv : c_char, chlapack_select : [] c_int, ref n : c_int, h : [] complex(128), ref ldh : c_int, w : [] complex(128), vl : [] complex(128), ref ldvl : c_int, vr : [] complex(128), ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] complex(128), rwork : [] c_double, ifaill : [] c_int, ifailr : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strevc

Original Fortran LAPACK documentation for STREVC::

 STREVC computes some or all of the right and/or left eigenvectors of
 a real upper quasi-triangular matrix T.
 Matrices of this type are produced by the Schur factorization of
 a real general matrix: A = Q*T*Q**T, as computed by SHSEQR.
 
 The right eigenvector x and the left eigenvector y of T corresponding
 to an eigenvalue w are defined by:
 
 T*x = w*x, (y**T)*T = w*(y**T)
 
 where y**T denotes the transpose of y.
 The eigenvalues are not input to this routine, but are read directly
 from the diagonal blocks of T.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
 input matrix. If Q is the orthogonal factor that reduces a matrix
 A to Schur form T, then Q*X and Q*Y are the matrices of right and
 left eigenvectors of A.

 */
extern proc LAPACK_strevc(ref side : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] c_float, ref ldt : c_int, vl : [] c_float, ref ldvl : c_int, vr : [] c_float, ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrevc

Original Fortran LAPACK documentation for DTREVC::

 DTREVC computes some or all of the right and/or left eigenvectors of
 a real upper quasi-triangular matrix T.
 Matrices of this type are produced by the Schur factorization of
 a real general matrix: A = Q*T*Q**T, as computed by DHSEQR.
 
 The right eigenvector x and the left eigenvector y of T corresponding
 to an eigenvalue w are defined by:
 
 T*x = w*x, (y**T)*T = w*(y**T)
 
 where y**T denotes the transpose of y.
 The eigenvalues are not input to this routine, but are read directly
 from the diagonal blocks of T.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
 input matrix. If Q is the orthogonal factor that reduces a matrix
 A to Schur form T, then Q*X and Q*Y are the matrices of right and
 left eigenvectors of A.

 */
extern proc LAPACK_dtrevc(ref side : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] c_double, ref ldt : c_int, vl : [] c_double, ref ldvl : c_int, vr : [] c_double, ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrevc

Original Fortran LAPACK documentation for CTREVC::

 CTREVC computes some or all of the right and/or left eigenvectors of
 a complex upper triangular matrix T.
 Matrices of this type are produced by the Schur factorization of
 a complex general matrix: A = Q*T*Q**H, as computed by CHSEQR.
 
 The right eigenvector x and the left eigenvector y of T corresponding
 to an eigenvalue w are defined by:
 
 T*x = w*x, (y**H)*T = w*(y**H)
 
 where y**H denotes the conjugate transpose of the vector y.
 The eigenvalues are not input to this routine, but are read directly
 from the diagonal of T.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
 input matrix. If Q is the unitary factor that reduces a matrix A to
 Schur form T, then Q*X and Q*Y are the matrices of right and left
 eigenvectors of A.

 */
extern proc LAPACK_ctrevc(ref side : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] complex(64), ref ldt : c_int, vl : [] complex(64), ref ldvl : c_int, vr : [] complex(64), ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrevc

Original Fortran LAPACK documentation for ZTREVC::

 ZTREVC computes some or all of the right and/or left eigenvectors of
 a complex upper triangular matrix T.
 Matrices of this type are produced by the Schur factorization of
 a complex general matrix: A = Q*T*Q**H, as computed by ZHSEQR.
 
 The right eigenvector x and the left eigenvector y of T corresponding
 to an eigenvalue w are defined by:
 
 T*x = w*x, (y**H)*T = w*(y**H)
 
 where y**H denotes the conjugate transpose of the vector y.
 The eigenvalues are not input to this routine, but are read directly
 from the diagonal of T.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
 input matrix. If Q is the unitary factor that reduces a matrix A to
 Schur form T, then Q*X and Q*Y are the matrices of right and left
 eigenvectors of A.

 */
extern proc LAPACK_ztrevc(ref side : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] complex(128), ref ldt : c_int, vl : [] complex(128), ref ldvl : c_int, vr : [] complex(128), ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strsna

Original Fortran LAPACK documentation for STRSNA::

 STRSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or right eigenvectors of a real upper
 quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
 orthogonal).

 T must be in Schur canonical form (as returned by SHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACK_strsna(ref job : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] c_float, ref ldt : c_int, vl : [] c_float, ref ldvl : c_int, vr : [] c_float, ref ldvr : c_int, s : [] c_float, sep : [] c_float, ref mm : c_int, ref m : c_int, work : [] c_float, ref ldwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrsna

Original Fortran LAPACK documentation for DTRSNA::

 DTRSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or right eigenvectors of a real upper
 quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
 orthogonal).

 T must be in Schur canonical form (as returned by DHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACK_dtrsna(ref job : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] c_double, ref ldt : c_int, vl : [] c_double, ref ldvl : c_int, vr : [] c_double, ref ldvr : c_int, s : [] c_double, sep : [] c_double, ref mm : c_int, ref m : c_int, work : [] c_double, ref ldwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrsna

Original Fortran LAPACK documentation for CTRSNA::

 CTRSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or right eigenvectors of a complex upper triangular
 matrix T (or of any matrix Q*T*Q**H with Q unitary).

 */
extern proc LAPACK_ctrsna(ref job : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] complex(64), ref ldt : c_int, vl : [] complex(64), ref ldvl : c_int, vr : [] complex(64), ref ldvr : c_int, s : [] c_float, sep : [] c_float, ref mm : c_int, ref m : c_int, work : [] complex(64), ref ldwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrsna

Original Fortran LAPACK documentation for ZTRSNA::

 ZTRSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or right eigenvectors of a complex upper triangular
 matrix T (or of any matrix Q*T*Q**H with Q unitary).

 */
extern proc LAPACK_ztrsna(ref job : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] complex(128), ref ldt : c_int, vl : [] complex(128), ref ldvl : c_int, vr : [] complex(128), ref ldvr : c_int, s : [] c_double, sep : [] c_double, ref mm : c_int, ref m : c_int, work : [] complex(128), ref ldwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strexc

Original Fortran LAPACK documentation for STREXC::

 STREXC reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
 moved to row ILST.

 The real Schur form T is reordered by an orthogonal similarity
 transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
 is updated by postmultiplying it with Z.

 T must be in Schur canonical form (as returned by SHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACK_strexc(ref compq : c_char, ref n : c_int, t : [] c_float, ref ldt : c_int, q : [] c_float, ref ldq : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrexc

Original Fortran LAPACK documentation for DTREXC::

 DTREXC reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
 moved to row ILST.

 The real Schur form T is reordered by an orthogonal similarity
 transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
 is updated by postmultiplying it with Z.

 T must be in Schur canonical form (as returned by DHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACK_dtrexc(ref compq : c_char, ref n : c_int, t : [] c_double, ref ldt : c_int, q : [] c_double, ref ldq : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrexc

Original Fortran LAPACK documentation for CTREXC::

 CTREXC reorders the Schur factorization of a complex matrix
 A = Q*T*Q**H, so that the diagonal element of T with row index IFST
 is moved to row ILST.

 The Schur form T is reordered by a unitary similarity transformation
 Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
 postmultplying it with Z.

 */
extern proc LAPACK_ctrexc(ref compq : c_char, ref n : c_int, t : [] complex(64), ref ldt : c_int, q : [] complex(64), ref ldq : c_int, ref ifst : c_int, ref ilst : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrexc

Original Fortran LAPACK documentation for ZTREXC::

 ZTREXC reorders the Schur factorization of a complex matrix
 A = Q*T*Q**H, so that the diagonal element of T with row index IFST
 is moved to row ILST.

 The Schur form T is reordered by a unitary similarity transformation
 Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
 postmultplying it with Z.

 */
extern proc LAPACK_ztrexc(ref compq : c_char, ref n : c_int, t : [] complex(128), ref ldt : c_int, q : [] complex(128), ref ldq : c_int, ref ifst : c_int, ref ilst : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strsen

Original Fortran LAPACK documentation for STRSEN::

 STRSEN reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
 the leading diagonal blocks of the upper quasi-triangular matrix T,
 and the leading columns of Q form an orthonormal basis of the
 corresponding right invariant subspace.

 Optionally the routine computes the reciprocal condition numbers of
 the cluster of eigenvalues and/or the invariant subspace.

 T must be in Schur canonical form (as returned by SHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACK_strsen(ref job : c_char, ref compq : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] c_float, ref ldt : c_int, q : [] c_float, ref ldq : c_int, wr : [] c_float, wi : [] c_float, ref m : c_int, ref s : c_float, ref sep : c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrsen

Original Fortran LAPACK documentation for DTRSEN::

 DTRSEN reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
 the leading diagonal blocks of the upper quasi-triangular matrix T,
 and the leading columns of Q form an orthonormal basis of the
 corresponding right invariant subspace.

 Optionally the routine computes the reciprocal condition numbers of
 the cluster of eigenvalues and/or the invariant subspace.

 T must be in Schur canonical form (as returned by DHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACK_dtrsen(ref job : c_char, ref compq : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] c_double, ref ldt : c_int, q : [] c_double, ref ldq : c_int, wr : [] c_double, wi : [] c_double, ref m : c_int, ref s : c_double, ref sep : c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrsen

Original Fortran LAPACK documentation for CTRSEN::

 CTRSEN reorders the Schur factorization of a complex matrix
 A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
 the leading positions on the diagonal of the upper triangular matrix
 T, and the leading columns of Q form an orthonormal basis of the
 corresponding right invariant subspace.

 Optionally the routine computes the reciprocal condition numbers of
 the cluster of eigenvalues and/or the invariant subspace.

 */
extern proc LAPACK_ctrsen(ref job : c_char, ref compq : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] complex(64), ref ldt : c_int, q : [] complex(64), ref ldq : c_int, w : [] complex(64), ref m : c_int, ref s : c_float, ref sep : c_float, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrsen

Original Fortran LAPACK documentation for ZTRSEN::

 ZTRSEN reorders the Schur factorization of a complex matrix
 A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
 the leading positions on the diagonal of the upper triangular matrix
 T, and the leading columns of Q form an orthonormal basis of the
 corresponding right invariant subspace.

 Optionally the routine computes the reciprocal condition numbers of
 the cluster of eigenvalues and/or the invariant subspace.

 */
extern proc LAPACK_ztrsen(ref job : c_char, ref compq : c_char, chlapack_select : [] c_int, ref n : c_int, t : [] complex(128), ref ldt : c_int, q : [] complex(128), ref ldq : c_int, w : [] complex(128), ref m : c_int, ref s : c_double, ref sep : c_double, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strsyl

Original Fortran LAPACK documentation for STRSYL::

 STRSYL solves the real Sylvester matrix equation:

 op(A)*X + X*op(B) = scale*C or
 op(A)*X - X*op(B) = scale*C,

 where op(A) = A or A**T, and A and B are both upper quasi-
 triangular. A is M-by-M and B is N-by-N; the right hand side C and
 the solution X are M-by-N; and scale is an output scale factor, set
 <= 1 to avoid overflow in X.

 A and B must be in Schur canonical form (as returned by SHSEQR), that
 is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
 each 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACK_strsyl(ref trana : c_char, ref tranb : c_char, ref isgn : c_int, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, c : [] c_float, ref ldc : c_int, ref scale : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrsyl

Original Fortran LAPACK documentation for DTRSYL::

 DTRSYL solves the real Sylvester matrix equation:

 op(A)*X + X*op(B) = scale*C or
 op(A)*X - X*op(B) = scale*C,

 where op(A) = A or A**T, and A and B are both upper quasi-
 triangular. A is M-by-M and B is N-by-N; the right hand side C and
 the solution X are M-by-N; and scale is an output scale factor, set
 <= 1 to avoid overflow in X.

 A and B must be in Schur canonical form (as returned by DHSEQR), that
 is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
 each 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

 */
extern proc LAPACK_dtrsyl(ref trana : c_char, ref tranb : c_char, ref isgn : c_int, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, c : [] c_double, ref ldc : c_int, ref scale : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrsyl

Original Fortran LAPACK documentation for CTRSYL::

 CTRSYL solves the complex Sylvester matrix equation:

 op(A)*X + X*op(B) = scale*C or
 op(A)*X - X*op(B) = scale*C,

 where op(A) = A or A**H, and A and B are both upper triangular. A is
 M-by-M and B is N-by-N; the right hand side C and the solution X are
 M-by-N; and scale is an output scale factor, set <= 1 to avoid
 overflow in X.

 */
extern proc LAPACK_ctrsyl(ref trana : c_char, ref tranb : c_char, ref isgn : c_int, ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, c : [] complex(64), ref ldc : c_int, ref scale : c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrsyl

Original Fortran LAPACK documentation for ZTRSYL::

 ZTRSYL solves the complex Sylvester matrix equation:

 op(A)*X + X*op(B) = scale*C or
 op(A)*X - X*op(B) = scale*C,

 where op(A) = A or A**H, and A and B are both upper triangular. A is
 M-by-M and B is N-by-N; the right hand side C and the solution X are
 M-by-N; and scale is an output scale factor, set <= 1 to avoid
 overflow in X.

 */
extern proc LAPACK_ztrsyl(ref trana : c_char, ref tranb : c_char, ref isgn : c_int, ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, c : [] complex(128), ref ldc : c_int, ref scale : c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgghrd

Original Fortran LAPACK documentation for SGGHRD::

 SGGHRD reduces a pair of real matrices (A,B) to generalized upper
 Hessenberg form using orthogonal transformations, where A is a
 general matrix and B is upper triangular. The form of the
 generalized eigenvalue problem is
 A*x = lambda*B*x,
 and B is typically made upper triangular by computing its QR
 factorization and moving the orthogonal matrix Q to the left side
 of the equation.

 This subroutine simultaneously reduces A to a Hessenberg matrix H:
 Q**T*A*Z = H
 and transforms B to another upper triangular matrix T:
 Q**T*B*Z = T
 in order to reduce the problem to its standard form
 H*y = lambda*T*y
 where y = Z**T*x.

 The orthogonal matrices Q and Z are determined as products of Givens
 rotations. They may either be formed explicitly, or they may be
 postmultiplied into input matrices Q1 and Z1, so that

 Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T

 Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T

 If Q1 is the orthogonal matrix from the QR factorization of B in the
 original equation A*x = lambda*B*x, then SGGHRD reduces the original
 problem to generalized Hessenberg form.

 */
extern proc LAPACK_sgghrd(ref compq : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, q : [] c_float, ref ldq : c_int, z : [] c_float, ref ldz : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgghrd

Original Fortran LAPACK documentation for DGGHRD::

 DGGHRD reduces a pair of real matrices (A,B) to generalized upper
 Hessenberg form using orthogonal transformations, where A is a
 general matrix and B is upper triangular. The form of the
 generalized eigenvalue problem is
 A*x = lambda*B*x,
 and B is typically made upper triangular by computing its QR
 factorization and moving the orthogonal matrix Q to the left side
 of the equation.

 This subroutine simultaneously reduces A to a Hessenberg matrix H:
 Q**T*A*Z = H
 and transforms B to another upper triangular matrix T:
 Q**T*B*Z = T
 in order to reduce the problem to its standard form
 H*y = lambda*T*y
 where y = Z**T*x.

 The orthogonal matrices Q and Z are determined as products of Givens
 rotations. They may either be formed explicitly, or they may be
 postmultiplied into input matrices Q1 and Z1, so that

 Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T

 Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T

 If Q1 is the orthogonal matrix from the QR factorization of B in the
 original equation A*x = lambda*B*x, then DGGHRD reduces the original
 problem to generalized Hessenberg form.

 */
extern proc LAPACK_dgghrd(ref compq : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, q : [] c_double, ref ldq : c_int, z : [] c_double, ref ldz : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgghrd

Original Fortran LAPACK documentation for CGGHRD::

 CGGHRD reduces a pair of complex matrices (A,B) to generalized upper
 Hessenberg form using unitary transformations, where A is a
 general matrix and B is upper triangular. The form of the generalized
 eigenvalue problem is
 A*x = lambda*B*x,
 and B is typically made upper triangular by computing its QR
 factorization and moving the unitary matrix Q to the left side
 of the equation.

 This subroutine simultaneously reduces A to a Hessenberg matrix H:
 Q**H*A*Z = H
 and transforms B to another upper triangular matrix T:
 Q**H*B*Z = T
 in order to reduce the problem to its standard form
 H*y = lambda*T*y
 where y = Z**H*x.

 The unitary matrices Q and Z are determined as products of Givens
 rotations. They may either be formed explicitly, or they may be
 postmultiplied into input matrices Q1 and Z1, so that
 Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
 Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
 If Q1 is the unitary matrix from the QR factorization of B in the
 original equation A*x = lambda*B*x, then CGGHRD reduces the original
 problem to generalized Hessenberg form.

 */
extern proc LAPACK_cgghrd(ref compq : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, q : [] complex(64), ref ldq : c_int, z : [] complex(64), ref ldz : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgghrd

Original Fortran LAPACK documentation for ZGGHRD::

 ZGGHRD reduces a pair of complex matrices (A,B) to generalized upper
 Hessenberg form using unitary transformations, where A is a
 general matrix and B is upper triangular. The form of the
 generalized eigenvalue problem is
 A*x = lambda*B*x,
 and B is typically made upper triangular by computing its QR
 factorization and moving the unitary matrix Q to the left side
 of the equation.

 This subroutine simultaneously reduces A to a Hessenberg matrix H:
 Q**H*A*Z = H
 and transforms B to another upper triangular matrix T:
 Q**H*B*Z = T
 in order to reduce the problem to its standard form
 H*y = lambda*T*y
 where y = Z**H*x.

 The unitary matrices Q and Z are determined as products of Givens
 rotations. They may either be formed explicitly, or they may be
 postmultiplied into input matrices Q1 and Z1, so that
 Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
 Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
 If Q1 is the unitary matrix from the QR factorization of B in the
 original equation A*x = lambda*B*x, then ZGGHRD reduces the original
 problem to generalized Hessenberg form.

 */
extern proc LAPACK_zgghrd(ref compq : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, q : [] complex(128), ref ldq : c_int, z : [] complex(128), ref ldz : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggbal

Original Fortran LAPACK documentation for SGGBAL::

 SGGBAL balances a pair of general real matrices (A,B). This
 involves, first, permuting A and B by similarity transformations to
 isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
 elements on the diagonal; and second, applying a diagonal similarity
 transformation to rows and columns ILO to IHI to make the rows
 and columns as close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrices, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors in the
 generalized eigenvalue problem A*x = lambda*B*x.

 */
extern proc LAPACK_sggbal(ref job : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggbal

Original Fortran LAPACK documentation for DGGBAL::

 DGGBAL balances a pair of general real matrices (A,B). This
 involves, first, permuting A and B by similarity transformations to
 isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
 elements on the diagonal; and second, applying a diagonal similarity
 transformation to rows and columns ILO to IHI to make the rows
 and columns as close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrices, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors in the
 generalized eigenvalue problem A*x = lambda*B*x.

 */
extern proc LAPACK_dggbal(ref job : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggbal

Original Fortran LAPACK documentation for CGGBAL::

 CGGBAL balances a pair of general complex matrices (A,B). This
 involves, first, permuting A and B by similarity transformations to
 isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
 elements on the diagonal; and second, applying a diagonal similarity
 transformation to rows and columns ILO to IHI to make the rows
 and columns as close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrices, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors in the
 generalized eigenvalue problem A*x = lambda*B*x.

 */
extern proc LAPACK_cggbal(ref job : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggbal

Original Fortran LAPACK documentation for ZGGBAL::

 ZGGBAL balances a pair of general complex matrices (A,B). This
 involves, first, permuting A and B by similarity transformations to
 isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
 elements on the diagonal; and second, applying a diagonal similarity
 transformation to rows and columns ILO to IHI to make the rows
 and columns as close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrices, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors in the
 generalized eigenvalue problem A*x = lambda*B*x.

 */
extern proc LAPACK_zggbal(ref job : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggbak

Original Fortran LAPACK documentation for SGGBAK::

 SGGBAK forms the right or left eigenvectors of a real generalized
 eigenvalue problem A*x = lambda*B*x, by backward transformation on
 the computed eigenvectors of the balanced pair of matrices output by
 SGGBAL.

 */
extern proc LAPACK_sggbak(ref job : c_char, ref side : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref m : c_int, v : [] c_float, ref ldv : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggbak

Original Fortran LAPACK documentation for DGGBAK::

 DGGBAK forms the right or left eigenvectors of a real generalized
 eigenvalue problem A*x = lambda*B*x, by backward transformation on
 the computed eigenvectors of the balanced pair of matrices output by
 DGGBAL.

 */
extern proc LAPACK_dggbak(ref job : c_char, ref side : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref m : c_int, v : [] c_double, ref ldv : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggbak

Original Fortran LAPACK documentation for CGGBAK::

 CGGBAK forms the right or left eigenvectors of a complex generalized
 eigenvalue problem A*x = lambda*B*x, by backward transformation on
 the computed eigenvectors of the balanced pair of matrices output by
 CGGBAL.

 */
extern proc LAPACK_cggbak(ref job : c_char, ref side : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref m : c_int, v : [] complex(64), ref ldv : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggbak

Original Fortran LAPACK documentation for ZGGBAK::

 ZGGBAK forms the right or left eigenvectors of a complex generalized
 eigenvalue problem A*x = lambda*B*x, by backward transformation on
 the computed eigenvectors of the balanced pair of matrices output by
 ZGGBAL.

 */
extern proc LAPACK_zggbak(ref job : c_char, ref side : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref m : c_int, v : [] complex(128), ref ldv : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_shgeqz

Original Fortran LAPACK documentation for SHGEQZ::

 SHGEQZ computes the eigenvalues of a real matrix pair (H,T),
 where H is an upper Hessenberg matrix and T is upper triangular,
 using the double-shift QZ method.
 Matrix pairs of this type are produced by the reduction to
 generalized upper Hessenberg form of a real matrix pair (A,B):

 A = Q1*H*Z1**T, B = Q1*T*Z1**T,

 as computed by SGGHRD.

 If JOB='S', then the Hessenberg-triangular pair (H,T) is
 also reduced to generalized Schur form,
 
 H = Q*S*Z**T, T = Q*P*Z**T,
 
 where Q and Z are orthogonal matrices, P is an upper triangular
 matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
 diagonal blocks.

 The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
 (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
 eigenvalues.

 Additionally, the 2-by-2 upper triangular diagonal blocks of P
 corresponding to 2-by-2 blocks of S are reduced to positive diagonal
 form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
 P(j,j) > 0, and P(j+1,j+1) > 0.

 Optionally, the orthogonal matrix Q from the generalized Schur
 factorization may be postmultiplied into an input matrix Q1, and the
 orthogonal matrix Z may be postmultiplied into an input matrix Z1.
 If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced
 the matrix pair (A,B) to generalized upper Hessenberg form, then the
 output matrices Q1*Q and Z1*Z are the orthogonal factors from the
 generalized Schur factorization of (A,B):

 A = (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T.
 
 To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
 of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
 complex and beta real.
 If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
 generalized nonsymmetric eigenvalue problem (GNEP)
 A*x = lambda*B*x
 and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
 alternate form of the GNEP
 mu*A*y = B*y.
 Real eigenvalues can be read directly from the generalized Schur
 form: 
 alpha = S(i,i), beta = P(i,i).

 Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
 Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241--256.

 */
extern proc LAPACK_shgeqz(ref job : c_char, ref compq : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, h : [] c_float, ref ldh : c_int, t : [] c_float, ref ldt : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, ref ldq : c_int, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dhgeqz

Original Fortran LAPACK documentation for DHGEQZ::

 DHGEQZ computes the eigenvalues of a real matrix pair (H,T),
 where H is an upper Hessenberg matrix and T is upper triangular,
 using the double-shift QZ method.
 Matrix pairs of this type are produced by the reduction to
 generalized upper Hessenberg form of a real matrix pair (A,B):

 A = Q1*H*Z1**T, B = Q1*T*Z1**T,

 as computed by DGGHRD.

 If JOB='S', then the Hessenberg-triangular pair (H,T) is
 also reduced to generalized Schur form,
 
 H = Q*S*Z**T, T = Q*P*Z**T,
 
 where Q and Z are orthogonal matrices, P is an upper triangular
 matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
 diagonal blocks.

 The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
 (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
 eigenvalues.

 Additionally, the 2-by-2 upper triangular diagonal blocks of P
 corresponding to 2-by-2 blocks of S are reduced to positive diagonal
 form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
 P(j,j) > 0, and P(j+1,j+1) > 0.

 Optionally, the orthogonal matrix Q from the generalized Schur
 factorization may be postmultiplied into an input matrix Q1, and the
 orthogonal matrix Z may be postmultiplied into an input matrix Z1.
 If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
 the matrix pair (A,B) to generalized upper Hessenberg form, then the
 output matrices Q1*Q and Z1*Z are the orthogonal factors from the
 generalized Schur factorization of (A,B):

 A = (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T.
 
 To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
 of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
 complex and beta real.
 If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
 generalized nonsymmetric eigenvalue problem (GNEP)
 A*x = lambda*B*x
 and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
 alternate form of the GNEP
 mu*A*y = B*y.
 Real eigenvalues can be read directly from the generalized Schur
 form: 
 alpha = S(i,i), beta = P(i,i).

 Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
 Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241--256.

 */
extern proc LAPACK_dhgeqz(ref job : c_char, ref compq : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, h : [] c_double, ref ldh : c_int, t : [] c_double, ref ldt : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, ref ldq : c_int, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chgeqz

Original Fortran LAPACK documentation for CHGEQZ::

 CHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
 where H is an upper Hessenberg matrix and T is upper triangular,
 using the single-shift QZ method.
 Matrix pairs of this type are produced by the reduction to
 generalized upper Hessenberg form of a complex matrix pair (A,B):
 
 A = Q1*H*Z1**H, B = Q1*T*Z1**H,
 
 as computed by CGGHRD.
 
 If JOB='S', then the Hessenberg-triangular pair (H,T) is
 also reduced to generalized Schur form,
 
 H = Q*S*Z**H, T = Q*P*Z**H,
 
 where Q and Z are unitary matrices and S and P are upper triangular.
 
 Optionally, the unitary matrix Q from the generalized Schur
 factorization may be postmultiplied into an input matrix Q1, and the
 unitary matrix Z may be postmultiplied into an input matrix Z1.
 If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
 the matrix pair (A,B) to generalized Hessenberg form, then the output
 matrices Q1*Q and Z1*Z are the unitary factors from the generalized
 Schur factorization of (A,B):
 
 A = (Q1*Q)*S*(Z1*Z)**H, B = (Q1*Q)*P*(Z1*Z)**H.
 
 To avoid overflow, eigenvalues of the matrix pair (H,T)
 (equivalently, of (A,B)) are computed as a pair of complex values
 (alpha,beta). If beta is nonzero, lambda = alpha / beta is an
 eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
 A*x = lambda*B*x
 and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
 alternate form of the GNEP
 mu*A*y = B*y.
 The values of alpha and beta for the i-th eigenvalue can be read
 directly from the generalized Schur form: alpha = S(i,i),
 beta = P(i,i).

 Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
 Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241--256.

 */
extern proc LAPACK_chgeqz(ref job : c_char, ref compq : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, h : [] complex(64), ref ldh : c_int, t : [] complex(64), ref ldt : c_int, alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), ref ldq : c_int, z : [] complex(64), ref ldz : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhgeqz

Original Fortran LAPACK documentation for ZHGEQZ::

 ZHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
 where H is an upper Hessenberg matrix and T is upper triangular,
 using the single-shift QZ method.
 Matrix pairs of this type are produced by the reduction to
 generalized upper Hessenberg form of a complex matrix pair (A,B):
 
 A = Q1*H*Z1**H, B = Q1*T*Z1**H,
 
 as computed by ZGGHRD.
 
 If JOB='S', then the Hessenberg-triangular pair (H,T) is
 also reduced to generalized Schur form,
 
 H = Q*S*Z**H, T = Q*P*Z**H,
 
 where Q and Z are unitary matrices and S and P are upper triangular.
 
 Optionally, the unitary matrix Q from the generalized Schur
 factorization may be postmultiplied into an input matrix Q1, and the
 unitary matrix Z may be postmultiplied into an input matrix Z1.
 If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced
 the matrix pair (A,B) to generalized Hessenberg form, then the output
 matrices Q1*Q and Z1*Z are the unitary factors from the generalized
 Schur factorization of (A,B):
 
 A = (Q1*Q)*S*(Z1*Z)**H, B = (Q1*Q)*P*(Z1*Z)**H.
 
 To avoid overflow, eigenvalues of the matrix pair (H,T)
 (equivalently, of (A,B)) are computed as a pair of complex values
 (alpha,beta). If beta is nonzero, lambda = alpha / beta is an
 eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
 A*x = lambda*B*x
 and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
 alternate form of the GNEP
 mu*A*y = B*y.
 The values of alpha and beta for the i-th eigenvalue can be read
 directly from the generalized Schur form: alpha = S(i,i),
 beta = P(i,i).

 Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
 Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241--256.

 */
extern proc LAPACK_zhgeqz(ref job : c_char, ref compq : c_char, ref compz : c_char, ref n : c_int, ref ilo : c_int, ref ihi : c_int, h : [] complex(128), ref ldh : c_int, t : [] complex(128), ref ldt : c_int, alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), ref ldq : c_int, z : [] complex(128), ref ldz : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stgevc

Original Fortran LAPACK documentation for STGEVC::

 STGEVC computes some or all of the right and/or left eigenvectors of
 a pair of real matrices (S,P), where S is a quasi-triangular matrix
 and P is upper triangular. Matrix pairs of this type are produced by
 the generalized Schur factorization of a matrix pair (A,B):

 A = Q*S*Z**T, B = Q*P*Z**T

 as computed by SGGHRD + SHGEQZ.

 The right eigenvector x and the left eigenvector y of (S,P)
 corresponding to an eigenvalue w are defined by:
 
 S*x = w*P*x, (y**H)*S = w*(y**H)*P,
 
 where y**H denotes the conjugate tranpose of y.
 The eigenvalues are not input to this routine, but are computed
 directly from the diagonal blocks of S and P.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 where Z and Q are input matrices.
 If Q and Z are the orthogonal factors from the generalized Schur
 factorization of a matrix pair (A,B), then Z*X and Q*Y
 are the matrices of right and left eigenvectors of (A,B).

 */
extern proc LAPACK_stgevc(ref side : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, s : [] c_float, ref lds : c_int, p : [] c_float, ref ldp : c_int, vl : [] c_float, ref ldvl : c_int, vr : [] c_float, ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtgevc

Original Fortran LAPACK documentation for DTGEVC::

 DTGEVC computes some or all of the right and/or left eigenvectors of
 a pair of real matrices (S,P), where S is a quasi-triangular matrix
 and P is upper triangular. Matrix pairs of this type are produced by
 the generalized Schur factorization of a matrix pair (A,B):

 A = Q*S*Z**T, B = Q*P*Z**T

 as computed by DGGHRD + DHGEQZ.

 The right eigenvector x and the left eigenvector y of (S,P)
 corresponding to an eigenvalue w are defined by:
 
 S*x = w*P*x, (y**H)*S = w*(y**H)*P,
 
 where y**H denotes the conjugate tranpose of y.
 The eigenvalues are not input to this routine, but are computed
 directly from the diagonal blocks of S and P.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 where Z and Q are input matrices.
 If Q and Z are the orthogonal factors from the generalized Schur
 factorization of a matrix pair (A,B), then Z*X and Q*Y
 are the matrices of right and left eigenvectors of (A,B).

 */
extern proc LAPACK_dtgevc(ref side : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, s : [] c_double, ref lds : c_int, p : [] c_double, ref ldp : c_int, vl : [] c_double, ref ldvl : c_int, vr : [] c_double, ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctgevc

Original Fortran LAPACK documentation for CTGEVC::

 CTGEVC computes some or all of the right and/or left eigenvectors of
 a pair of complex matrices (S,P), where S and P are upper triangular.
 Matrix pairs of this type are produced by the generalized Schur
 factorization of a complex matrix pair (A,B):
 
 A = Q*S*Z**H, B = Q*P*Z**H
 
 as computed by CGGHRD + CHGEQZ.
 
 The right eigenvector x and the left eigenvector y of (S,P)
 corresponding to an eigenvalue w are defined by:
 
 S*x = w*P*x, (y**H)*S = w*(y**H)*P,
 
 where y**H denotes the conjugate tranpose of y.
 The eigenvalues are not input to this routine, but are computed
 directly from the diagonal elements of S and P.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 where Z and Q are input matrices.
 If Q and Z are the unitary factors from the generalized Schur
 factorization of a matrix pair (A,B), then Z*X and Q*Y
 are the matrices of right and left eigenvectors of (A,B).

 */
extern proc LAPACK_ctgevc(ref side : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, s : [] complex(64), ref lds : c_int, p : [] complex(64), ref ldp : c_int, vl : [] complex(64), ref ldvl : c_int, vr : [] complex(64), ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztgevc

Original Fortran LAPACK documentation for ZTGEVC::

 ZTGEVC computes some or all of the right and/or left eigenvectors of
 a pair of complex matrices (S,P), where S and P are upper triangular.
 Matrix pairs of this type are produced by the generalized Schur
 factorization of a complex matrix pair (A,B):
 
 A = Q*S*Z**H, B = Q*P*Z**H
 
 as computed by ZGGHRD + ZHGEQZ.
 
 The right eigenvector x and the left eigenvector y of (S,P)
 corresponding to an eigenvalue w are defined by:
 
 S*x = w*P*x, (y**H)*S = w*(y**H)*P,
 
 where y**H denotes the conjugate tranpose of y.
 The eigenvalues are not input to this routine, but are computed
 directly from the diagonal elements of S and P.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 where Z and Q are input matrices.
 If Q and Z are the unitary factors from the generalized Schur
 factorization of a matrix pair (A,B), then Z*X and Q*Y
 are the matrices of right and left eigenvectors of (A,B).

 */
extern proc LAPACK_ztgevc(ref side : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, s : [] complex(128), ref lds : c_int, p : [] complex(128), ref ldp : c_int, vl : [] complex(128), ref ldvl : c_int, vr : [] complex(128), ref ldvr : c_int, ref mm : c_int, ref m : c_int, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stgexc

Original Fortran LAPACK documentation for STGEXC::

 STGEXC reorders the generalized real Schur decomposition of a real
 matrix pair (A,B) using an orthogonal equivalence transformation

 (A, B) = Q * (A, B) * Z**T,

 so that the diagonal block of (A, B) with row index IFST is moved
 to row ILST.

 (A, B) must be in generalized real Schur canonical form (as returned
 by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
 diagonal blocks. B is upper triangular.

 Optionally, the matrices Q and Z of generalized Schur vectors are
 updated.

 Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
 Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T

 */
extern proc LAPACK_stgexc(ref wantq : c_int, ref wantz : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, q : [] c_float, ref ldq : c_int, z : [] c_float, ref ldz : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtgexc

Original Fortran LAPACK documentation for DTGEXC::

 DTGEXC reorders the generalized real Schur decomposition of a real
 matrix pair (A,B) using an orthogonal equivalence transformation

 (A, B) = Q * (A, B) * Z**T,

 so that the diagonal block of (A, B) with row index IFST is moved
 to row ILST.

 (A, B) must be in generalized real Schur canonical form (as returned
 by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
 diagonal blocks. B is upper triangular.

 Optionally, the matrices Q and Z of generalized Schur vectors are
 updated.

 Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
 Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T

 */
extern proc LAPACK_dtgexc(ref wantq : c_int, ref wantz : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, q : [] c_double, ref ldq : c_int, z : [] c_double, ref ldz : c_int, ref ifst : c_int, ref ilst : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctgexc

Original Fortran LAPACK documentation for CTGEXC::

 CTGEXC reorders the generalized Schur decomposition of a complex
 matrix pair (A,B), using an unitary equivalence transformation
 (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
 row index IFST is moved to row ILST.

 (A, B) must be in generalized Schur canonical form, that is, A and
 B are both upper triangular.

 Optionally, the matrices Q and Z of generalized Schur vectors are
 updated.

 Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
 Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H

 */
extern proc LAPACK_ctgexc(ref wantq : c_int, ref wantz : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, q : [] complex(64), ref ldq : c_int, z : [] complex(64), ref ldz : c_int, ref ifst : c_int, ref ilst : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztgexc

Original Fortran LAPACK documentation for ZTGEXC::

 ZTGEXC reorders the generalized Schur decomposition of a complex
 matrix pair (A,B), using an unitary equivalence transformation
 (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
 row index IFST is moved to row ILST.

 (A, B) must be in generalized Schur canonical form, that is, A and
 B are both upper triangular.

 Optionally, the matrices Q and Z of generalized Schur vectors are
 updated.

 Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
 Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H

 */
extern proc LAPACK_ztgexc(ref wantq : c_int, ref wantz : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, q : [] complex(128), ref ldq : c_int, z : [] complex(128), ref ldz : c_int, ref ifst : c_int, ref ilst : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stgsen

Original Fortran LAPACK documentation for STGSEN::

 STGSEN reorders the generalized real Schur decomposition of a real
 matrix pair (A, B) (in terms of an orthonormal equivalence trans-
 formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
 appears in the leading diagonal blocks of the upper quasi-triangular
 matrix A and the upper triangular B. The leading columns of Q and
 Z form orthonormal bases of the corresponding left and right eigen-
 spaces (deflating subspaces). (A, B) must be in generalized real
 Schur canonical form (as returned by SGGES), i.e. A is block upper
 triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
 triangular.

 STGSEN also computes the generalized eigenvalues

 w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)

 of the reordered matrix pair (A, B).

 Optionally, STGSEN computes the estimates of reciprocal condition
 numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
 (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
 between the matrix pairs (A11, B11) and (A22,B22) that correspond to
 the selected cluster and the eigenvalues outside the cluster, resp.,
 and norms of "projections" onto left and right eigenspaces w.r.t.
 the selected cluster in the (1,1)-block.

 */
extern proc LAPACK_stgsen(ref ijob : c_int, ref wantq : c_int, ref wantz : c_int, chlapack_select : [] c_int, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, ref ldq : c_int, z : [] c_float, ref ldz : c_int, ref m : c_int, ref pl : c_float, ref pr : c_float, dif : [] c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtgsen

Original Fortran LAPACK documentation for DTGSEN::

 DTGSEN reorders the generalized real Schur decomposition of a real
 matrix pair (A, B) (in terms of an orthonormal equivalence trans-
 formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
 appears in the leading diagonal blocks of the upper quasi-triangular
 matrix A and the upper triangular B. The leading columns of Q and
 Z form orthonormal bases of the corresponding left and right eigen-
 spaces (deflating subspaces). (A, B) must be in generalized real
 Schur canonical form (as returned by DGGES), i.e. A is block upper
 triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
 triangular.

 DTGSEN also computes the generalized eigenvalues

 w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)

 of the reordered matrix pair (A, B).

 Optionally, DTGSEN computes the estimates of reciprocal condition
 numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
 (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
 between the matrix pairs (A11, B11) and (A22,B22) that correspond to
 the selected cluster and the eigenvalues outside the cluster, resp.,
 and norms of "projections" onto left and right eigenspaces w.r.t.
 the selected cluster in the (1,1)-block.

 */
extern proc LAPACK_dtgsen(ref ijob : c_int, ref wantq : c_int, ref wantz : c_int, chlapack_select : [] c_int, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, ref ldq : c_int, z : [] c_double, ref ldz : c_int, ref m : c_int, ref pl : c_double, ref pr : c_double, dif : [] c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctgsen

Original Fortran LAPACK documentation for CTGSEN::

 CTGSEN reorders the generalized Schur decomposition of a complex
 matrix pair (A, B) (in terms of an unitary equivalence trans-
 formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
 appears in the leading diagonal blocks of the pair (A,B). The leading
 columns of Q and Z form unitary bases of the corresponding left and
 right eigenspaces (deflating subspaces). (A, B) must be in
 generalized Schur canonical form, that is, A and B are both upper
 triangular.

 CTGSEN also computes the generalized eigenvalues

 w(j)= ALPHA(j) / BETA(j)

 of the reordered matrix pair (A, B).

 Optionally, the routine computes estimates of reciprocal condition
 numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
 (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
 between the matrix pairs (A11, B11) and (A22,B22) that correspond to
 the selected cluster and the eigenvalues outside the cluster, resp.,
 and norms of "projections" onto left and right eigenspaces w.r.t.
 the selected cluster in the (1,1)-block.

 */
extern proc LAPACK_ctgsen(ref ijob : c_int, ref wantq : c_int, ref wantz : c_int, chlapack_select : [] c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), ref ldq : c_int, z : [] complex(64), ref ldz : c_int, ref m : c_int, ref pl : c_float, ref pr : c_float, dif : [] c_float, work : [] complex(64), ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztgsen

Original Fortran LAPACK documentation for ZTGSEN::

 ZTGSEN reorders the generalized Schur decomposition of a complex
 matrix pair (A, B) (in terms of an unitary equivalence trans-
 formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
 appears in the leading diagonal blocks of the pair (A,B). The leading
 columns of Q and Z form unitary bases of the corresponding left and
 right eigenspaces (deflating subspaces). (A, B) must be in
 generalized Schur canonical form, that is, A and B are both upper
 triangular.

 ZTGSEN also computes the generalized eigenvalues

 w(j)= ALPHA(j) / BETA(j)

 of the reordered matrix pair (A, B).

 Optionally, the routine computes estimates of reciprocal condition
 numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
 (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
 between the matrix pairs (A11, B11) and (A22,B22) that correspond to
 the selected cluster and the eigenvalues outside the cluster, resp.,
 and norms of "projections" onto left and right eigenspaces w.r.t.
 the selected cluster in the (1,1)-block.

 */
extern proc LAPACK_ztgsen(ref ijob : c_int, ref wantq : c_int, ref wantz : c_int, chlapack_select : [] c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), ref ldq : c_int, z : [] complex(128), ref ldz : c_int, ref m : c_int, ref pl : c_double, ref pr : c_double, dif : [] c_double, work : [] complex(128), ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stgsyl

Original Fortran LAPACK documentation for STGSYL::

 STGSYL solves the generalized Sylvester equation:

 A * R - L * B = scale * C (1)
 D * R - L * E = scale * F

 where R and L are unknown m-by-n matrices, (A, D), (B, E) and
 (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
 respectively, with real entries. (A, D) and (B, E) must be in
 generalized (real) Schur canonical form, i.e. A, B are upper quasi
 triangular and D, E are upper triangular.

 The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
 scaling factor chosen to avoid overflow.

 In matrix notation (1) is equivalent to solve Zx = scale b, where
 Z is defined as

 Z = [ kron(In, A) -kron(B**T, Im) ] (2)
 [ kron(In, D) -kron(E**T, Im) ].

 Here Ik is the identity matrix of size k and X**T is the transpose of
 X. kron(X, Y) is the Kronecker product between the matrices X and Y.

 If TRANS = 'T', STGSYL solves the transposed system Z**T*y = scale*b,
 which is equivalent to solve for R and L in

 A**T * R + D**T * L = scale * C (3)
 R * B**T + L * E**T = scale * -F

 This case (TRANS = 'T') is used to compute an one-norm-based estimate
 of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
 and (B,E), using SLACON.

 If IJOB >= 1, STGSYL computes a Frobenius norm-based estimate
 of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
 reciprocal of the smallest singular value of Z. See [1-2] for more
 information.

 This is a level 3 BLAS algorithm.

 */
extern proc LAPACK_stgsyl(ref trans : c_char, ref ijob : c_int, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, c : [] c_float, ref ldc : c_int, d : [] c_float, ref ldd : c_int, e : [] c_float, ref lde : c_int, f : [] c_float, ref ldf : c_int, ref scale : c_float, ref dif : c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtgsyl

Original Fortran LAPACK documentation for DTGSYL::

 DTGSYL solves the generalized Sylvester equation:

 A * R - L * B = scale * C (1)
 D * R - L * E = scale * F

 where R and L are unknown m-by-n matrices, (A, D), (B, E) and
 (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
 respectively, with real entries. (A, D) and (B, E) must be in
 generalized (real) Schur canonical form, i.e. A, B are upper quasi
 triangular and D, E are upper triangular.

 The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
 scaling factor chosen to avoid overflow.

 In matrix notation (1) is equivalent to solve Zx = scale b, where
 Z is defined as

 Z = [ kron(In, A) -kron(B**T, Im) ] (2)
 [ kron(In, D) -kron(E**T, Im) ].

 Here Ik is the identity matrix of size k and X**T is the transpose of
 X. kron(X, Y) is the Kronecker product between the matrices X and Y.

 If TRANS = 'T', DTGSYL solves the transposed system Z**T*y = scale*b,
 which is equivalent to solve for R and L in

 A**T * R + D**T * L = scale * C (3)
 R * B**T + L * E**T = scale * -F

 This case (TRANS = 'T') is used to compute an one-norm-based estimate
 of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
 and (B,E), using DLACON.

 If IJOB >= 1, DTGSYL computes a Frobenius norm-based estimate
 of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
 reciprocal of the smallest singular value of Z. See [1-2] for more
 information.

 This is a level 3 BLAS algorithm.

 */
extern proc LAPACK_dtgsyl(ref trans : c_char, ref ijob : c_int, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, c : [] c_double, ref ldc : c_int, d : [] c_double, ref ldd : c_int, e : [] c_double, ref lde : c_int, f : [] c_double, ref ldf : c_int, ref scale : c_double, ref dif : c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctgsyl

Original Fortran LAPACK documentation for CTGSYL::

 CTGSYL solves the generalized Sylvester equation:

 A * R - L * B = scale * C (1)
 D * R - L * E = scale * F

 where R and L are unknown m-by-n matrices, (A, D), (B, E) and
 (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
 respectively, with complex entries. A, B, D and E are upper
 triangular (i.e., (A,D) and (B,E) in generalized Schur form).

 The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
 is an output scaling factor chosen to avoid overflow.

 In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
 is defined as

 Z = [ kron(In, A) -kron(B**H, Im) ] (2)
 [ kron(In, D) -kron(E**H, Im) ],

 Here Ix is the identity matrix of size x and X**H is the conjugate
 transpose of X. Kron(X, Y) is the Kronecker product between the
 matrices X and Y.

 If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
 is solved for, which is equivalent to solve for R and L in

 A**H * R + D**H * L = scale * C (3)
 R * B**H + L * E**H = scale * -F

 This case (TRANS = 'C') is used to compute an one-norm-based estimate
 of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
 and (B,E), using CLACON.

 If IJOB >= 1, CTGSYL computes a Frobenius norm-based estimate of
 Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
 reciprocal of the smallest singular value of Z.

 This is a level-3 BLAS algorithm.

 */
extern proc LAPACK_ctgsyl(ref trans : c_char, ref ijob : c_int, ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, c : [] complex(64), ref ldc : c_int, d : [] complex(64), ref ldd : c_int, e : [] complex(64), ref lde : c_int, f : [] complex(64), ref ldf : c_int, ref scale : c_float, ref dif : c_float, work : [] complex(64), ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztgsyl

Original Fortran LAPACK documentation for ZTGSYL::

 ZTGSYL solves the generalized Sylvester equation:

 A * R - L * B = scale * C (1)
 D * R - L * E = scale * F

 where R and L are unknown m-by-n matrices, (A, D), (B, E) and
 (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
 respectively, with complex entries. A, B, D and E are upper
 triangular (i.e., (A,D) and (B,E) in generalized Schur form).

 The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
 is an output scaling factor chosen to avoid overflow.

 In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
 is defined as

 Z = [ kron(In, A) -kron(B**H, Im) ] (2)
 [ kron(In, D) -kron(E**H, Im) ],

 Here Ix is the identity matrix of size x and X**H is the conjugate
 transpose of X. Kron(X, Y) is the Kronecker product between the
 matrices X and Y.

 If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
 is solved for, which is equivalent to solve for R and L in

 A**H * R + D**H * L = scale * C (3)
 R * B**H + L * E**H = scale * -F

 This case (TRANS = 'C') is used to compute an one-norm-based estimate
 of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
 and (B,E), using ZLACON.

 If IJOB >= 1, ZTGSYL computes a Frobenius norm-based estimate of
 Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
 reciprocal of the smallest singular value of Z.

 This is a level-3 BLAS algorithm.

 */
extern proc LAPACK_ztgsyl(ref trans : c_char, ref ijob : c_int, ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, c : [] complex(128), ref ldc : c_int, d : [] complex(128), ref ldd : c_int, e : [] complex(128), ref lde : c_int, f : [] complex(128), ref ldf : c_int, ref scale : c_double, ref dif : c_double, work : [] complex(128), ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stgsna

Original Fortran LAPACK documentation for STGSNA::

 STGSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or eigenvectors of a matrix pair (A, B) in
 generalized real Schur canonical form (or of any matrix pair
 (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
 Z**T denotes the transpose of Z.

 (A, B) must be in generalized real Schur form (as returned by SGGES),
 i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
 blocks. B is upper triangular.

 */
extern proc LAPACK_stgsna(ref job : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, vl : [] c_float, ref ldvl : c_int, vr : [] c_float, ref ldvr : c_int, s : [] c_float, dif : [] c_float, ref mm : c_int, ref m : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtgsna

Original Fortran LAPACK documentation for DTGSNA::

 DTGSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or eigenvectors of a matrix pair (A, B) in
 generalized real Schur canonical form (or of any matrix pair
 (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
 Z**T denotes the transpose of Z.

 (A, B) must be in generalized real Schur form (as returned by DGGES),
 i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
 blocks. B is upper triangular.

 */
extern proc LAPACK_dtgsna(ref job : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, vl : [] c_double, ref ldvl : c_int, vr : [] c_double, ref ldvr : c_int, s : [] c_double, dif : [] c_double, ref mm : c_int, ref m : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctgsna

Original Fortran LAPACK documentation for CTGSNA::

 CTGSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or eigenvectors of a matrix pair (A, B).

 (A, B) must be in generalized Schur canonical form, that is, A and
 B are both upper triangular.

 */
extern proc LAPACK_ctgsna(ref job : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, vl : [] complex(64), ref ldvl : c_int, vr : [] complex(64), ref ldvr : c_int, s : [] c_float, dif : [] c_float, ref mm : c_int, ref m : c_int, work : [] complex(64), ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztgsna

Original Fortran LAPACK documentation for ZTGSNA::

 ZTGSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or eigenvectors of a matrix pair (A, B).

 (A, B) must be in generalized Schur canonical form, that is, A and
 B are both upper triangular.

 */
extern proc LAPACK_ztgsna(ref job : c_char, ref howmny : c_char, chlapack_select : [] c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, vl : [] complex(128), ref ldvl : c_int, vr : [] complex(128), ref ldvr : c_int, s : [] c_double, dif : [] c_double, ref mm : c_int, ref m : c_int, work : [] complex(128), ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggsvp

Original Fortran LAPACK documentation for SGGSVP::

 SGGSVP computes orthogonal matrices U, V and Q such that

 N-K-L K L
 U**T*A*Q = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 V**T*B*Q = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective
 numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T. 

 This decomposition is the preprocessing step for computing the
 Generalized Singular Value Decomposition (GSVD), see subroutine
 SGGSVD.

 */
extern proc LAPACK_sggsvp(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref p : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref tola : c_float, ref tolb : c_float, ref k : c_int, ref l : c_int, u : [] c_float, ref ldu : c_int, v : [] c_float, ref ldv : c_int, q : [] c_float, ref ldq : c_int, iwork : [] c_int, tau : [] c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggsvp

Original Fortran LAPACK documentation for DGGSVP::

 DGGSVP computes orthogonal matrices U, V and Q such that

 N-K-L K L
 U**T*A*Q = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 V**T*B*Q = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective
 numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T. 

 This decomposition is the preprocessing step for computing the
 Generalized Singular Value Decomposition (GSVD), see subroutine
 DGGSVD.

 */
extern proc LAPACK_dggsvp(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref p : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref tola : c_double, ref tolb : c_double, ref k : c_int, ref l : c_int, u : [] c_double, ref ldu : c_int, v : [] c_double, ref ldv : c_int, q : [] c_double, ref ldq : c_int, iwork : [] c_int, tau : [] c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggsvp

Original Fortran LAPACK documentation for CGGSVP::

 CGGSVP computes unitary matrices U, V and Q such that

 N-K-L K L
 U**H*A*Q = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 V**H*B*Q = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective
 numerical rank of the (M+P)-by-N matrix (A**H,B**H)**H. 

 This decomposition is the preprocessing step for computing the
 Generalized Singular Value Decomposition (GSVD), see subroutine
 CGGSVD.

 */
extern proc LAPACK_cggsvp(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref p : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref tola : c_float, ref tolb : c_float, ref k : c_int, ref l : c_int, u : [] complex(64), ref ldu : c_int, v : [] complex(64), ref ldv : c_int, q : [] complex(64), ref ldq : c_int, iwork : [] c_int, rwork : [] c_float, tau : [] complex(64), work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggsvp

Original Fortran LAPACK documentation for ZGGSVP::

 ZGGSVP computes unitary matrices U, V and Q such that

 N-K-L K L
 U**H*A*Q = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 V**H*B*Q = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective
 numerical rank of the (M+P)-by-N matrix (A**H,B**H)**H. 

 This decomposition is the preprocessing step for computing the
 Generalized Singular Value Decomposition (GSVD), see subroutine
 ZGGSVD.

 */
extern proc LAPACK_zggsvp(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref p : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref tola : c_double, ref tolb : c_double, ref k : c_int, ref l : c_int, u : [] complex(128), ref ldu : c_int, v : [] complex(128), ref ldv : c_int, q : [] complex(128), ref ldq : c_int, iwork : [] c_int, rwork : [] c_double, tau : [] complex(128), work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stgsja

Original Fortran LAPACK documentation for STGSJA::

 STGSJA computes the generalized singular value decomposition (GSVD)
 of two real upper triangular (or trapezoidal) matrices A and B.

 On entry, it is assumed that matrices A and B have the following
 forms, which may be obtained by the preprocessing subroutine SGGSVP
 from a general M-by-N matrix A and P-by-N matrix B:

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 B = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal.

 On exit,

 U**T *A*Q = D1*( 0 R ), V**T *B*Q = D2*( 0 R ),

 where U, V and Q are orthogonal matrices.
 R is a nonsingular upper triangular matrix, and D1 and D2 are
 ``diagonal'' matrices, which are of the following structures:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 ) K
 L ( 0 0 R22 ) L

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where
 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The computation of the orthogonal transformation matrices U, V or Q
 is optional. These matrices may either be formed explicitly, or they
 may be postmultiplied into input matrices U1, V1, or Q1.

 */
extern proc LAPACK_stgsja(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref p : c_int, ref n : c_int, ref k : c_int, ref l : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref tola : c_float, ref tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] c_float, ref ldu : c_int, v : [] c_float, ref ldv : c_int, q : [] c_float, ref ldq : c_int, work : [] c_float, ref ncycle : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtgsja

Original Fortran LAPACK documentation for DTGSJA::

 DTGSJA computes the generalized singular value decomposition (GSVD)
 of two real upper triangular (or trapezoidal) matrices A and B.

 On entry, it is assumed that matrices A and B have the following
 forms, which may be obtained by the preprocessing subroutine DGGSVP
 from a general M-by-N matrix A and P-by-N matrix B:

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 B = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal.

 On exit,

 U**T *A*Q = D1*( 0 R ), V**T *B*Q = D2*( 0 R ),

 where U, V and Q are orthogonal matrices.
 R is a nonsingular upper triangular matrix, and D1 and D2 are
 ``diagonal'' matrices, which are of the following structures:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 ) K
 L ( 0 0 R22 ) L

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where
 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The computation of the orthogonal transformation matrices U, V or Q
 is optional. These matrices may either be formed explicitly, or they
 may be postmultiplied into input matrices U1, V1, or Q1.

 */
extern proc LAPACK_dtgsja(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref p : c_int, ref n : c_int, ref k : c_int, ref l : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref tola : c_double, ref tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] c_double, ref ldu : c_int, v : [] c_double, ref ldv : c_int, q : [] c_double, ref ldq : c_int, work : [] c_double, ref ncycle : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctgsja

Original Fortran LAPACK documentation for CTGSJA::

 CTGSJA computes the generalized singular value decomposition (GSVD)
 of two complex upper triangular (or trapezoidal) matrices A and B.

 On entry, it is assumed that matrices A and B have the following
 forms, which may be obtained by the preprocessing subroutine CGGSVP
 from a general M-by-N matrix A and P-by-N matrix B:

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 B = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal.

 On exit,

 U**H *A*Q = D1*( 0 R ), V**H *B*Q = D2*( 0 R ),

 where U, V and Q are unitary matrices.
 R is a nonsingular upper triangular matrix, and D1
 and D2 are ``diagonal'' matrices, which are of the following
 structures:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 ) K
 L ( 0 0 R22 ) L

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where
 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The computation of the unitary transformation matrices U, V or Q
 is optional. These matrices may either be formed explicitly, or they
 may be postmultiplied into input matrices U1, V1, or Q1.

 */
extern proc LAPACK_ctgsja(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref p : c_int, ref n : c_int, ref k : c_int, ref l : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref tola : c_float, ref tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ref ldu : c_int, v : [] complex(64), ref ldv : c_int, q : [] complex(64), ref ldq : c_int, work : [] complex(64), ref ncycle : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztgsja

Original Fortran LAPACK documentation for ZTGSJA::

 ZTGSJA computes the generalized singular value decomposition (GSVD)
 of two complex upper triangular (or trapezoidal) matrices A and B.

 On entry, it is assumed that matrices A and B have the following
 forms, which may be obtained by the preprocessing subroutine ZGGSVP
 from a general M-by-N matrix A and P-by-N matrix B:

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 B = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal.

 On exit,

 U**H *A*Q = D1*( 0 R ), V**H *B*Q = D2*( 0 R ),

 where U, V and Q are unitary matrices.
 R is a nonsingular upper triangular matrix, and D1
 and D2 are ``diagonal'' matrices, which are of the following
 structures:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 ) K
 L ( 0 0 R22 ) L

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where
 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The computation of the unitary transformation matrices U, V or Q
 is optional. These matrices may either be formed explicitly, or they
 may be postmultiplied into input matrices U1, V1, or Q1.

 */
extern proc LAPACK_ztgsja(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref p : c_int, ref n : c_int, ref k : c_int, ref l : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref tola : c_double, ref tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ref ldu : c_int, v : [] complex(128), ref ldv : c_int, q : [] complex(128), ref ldq : c_int, work : [] complex(128), ref ncycle : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgels

Original Fortran LAPACK documentation for SGELS::

 SGELS solves overdetermined or underdetermined real linear systems
 involving an M-by-N matrix A, or its transpose, using a QR or LQ
 factorization of A. It is assumed that A has full rank.

 The following options are provided: 

 1. If TRANS = 'N' and m >= n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A*X ||.

 2. If TRANS = 'N' and m < n: find the minimum norm solution of
 an underdetermined system A * X = B.

 3. If TRANS = 'T' and m >= n: find the minimum norm solution of
 an undetermined system A**T * X = B.

 4. If TRANS = 'T' and m < n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A**T * X ||.

 Several right hand side vectors b and solution vectors x can be 
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution 
 matrix X.

 */
extern proc LAPACK_sgels(ref trans : c_char, ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgels

Original Fortran LAPACK documentation for DGELS::

 DGELS solves overdetermined or underdetermined real linear systems
 involving an M-by-N matrix A, or its transpose, using a QR or LQ
 factorization of A. It is assumed that A has full rank.

 The following options are provided:

 1. If TRANS = 'N' and m >= n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A*X ||.

 2. If TRANS = 'N' and m < n: find the minimum norm solution of
 an underdetermined system A * X = B.

 3. If TRANS = 'T' and m >= n: find the minimum norm solution of
 an undetermined system A**T * X = B.

 4. If TRANS = 'T' and m < n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A**T * X ||.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 */
extern proc LAPACK_dgels(ref trans : c_char, ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgels

Original Fortran LAPACK documentation for CGELS::

 CGELS solves overdetermined or underdetermined complex linear systems
 involving an M-by-N matrix A, or its conjugate-transpose, using a QR
 or LQ factorization of A. It is assumed that A has full rank.

 The following options are provided:

 1. If TRANS = 'N' and m >= n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A*X ||.

 2. If TRANS = 'N' and m < n: find the minimum norm solution of
 an underdetermined system A * X = B.

 3. If TRANS = 'C' and m >= n: find the minimum norm solution of
 an undetermined system A**H * X = B.

 4. If TRANS = 'C' and m < n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A**H * X ||.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 */
extern proc LAPACK_cgels(ref trans : c_char, ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgels

Original Fortran LAPACK documentation for ZGELS::

 ZGELS solves overdetermined or underdetermined complex linear systems
 involving an M-by-N matrix A, or its conjugate-transpose, using a QR
 or LQ factorization of A. It is assumed that A has full rank.

 The following options are provided:

 1. If TRANS = 'N' and m >= n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A*X ||.

 2. If TRANS = 'N' and m < n: find the minimum norm solution of
 an underdetermined system A * X = B.

 3. If TRANS = 'C' and m >= n: find the minimum norm solution of
 an undetermined system A**H * X = B.

 4. If TRANS = 'C' and m < n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A**H * X ||.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 */
extern proc LAPACK_zgels(ref trans : c_char, ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgelsy

Original Fortran LAPACK documentation for SGELSY::

 SGELSY computes the minimum-norm solution to a real linear least
 squares problem:
 minimize || A * X - B ||
 using a complete orthogonal factorization of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The routine first computes a QR factorization with column pivoting:
 A * P = Q * [ R11 R12 ]
 [ 0 R22 ]
 with R11 defined as the largest leading submatrix whose estimated
 condition number is less than 1/RCOND. The order of R11, RANK,
 is the effective rank of A.

 Then, R22 is considered to be negligible, and R12 is annihilated
 by orthogonal transformations from the right, arriving at the
 complete orthogonal factorization:
 A * P = Q * [ T11 0 ] * Z
 [ 0 0 ]
 The minimum-norm solution is then
 X = P * Z**T [ inv(T11)*Q1**T*B ]
 [ 0 ]
 where Q1 consists of the first RANK columns of Q.

 This routine is basically identical to the original xGELSX except
 three differences:
 o The call to the subroutine xGEQPF has been substituted by the
 the call to the subroutine xGEQP3. This subroutine is a Blas-3
 version of the QR factorization with column pivoting.
 o Matrix B (the right hand side) is updated with Blas-3.
 o The permutation of matrix B (the right hand side) is faster and
 more simple.

 */
extern proc LAPACK_sgelsy(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, jpvt : [] c_int, ref rcond : c_float, ref rank : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgelsy

Original Fortran LAPACK documentation for DGELSY::

 DGELSY computes the minimum-norm solution to a real linear least
 squares problem:
 minimize || A * X - B ||
 using a complete orthogonal factorization of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The routine first computes a QR factorization with column pivoting:
 A * P = Q * [ R11 R12 ]
 [ 0 R22 ]
 with R11 defined as the largest leading submatrix whose estimated
 condition number is less than 1/RCOND. The order of R11, RANK,
 is the effective rank of A.

 Then, R22 is considered to be negligible, and R12 is annihilated
 by orthogonal transformations from the right, arriving at the
 complete orthogonal factorization:
 A * P = Q * [ T11 0 ] * Z
 [ 0 0 ]
 The minimum-norm solution is then
 X = P * Z**T [ inv(T11)*Q1**T*B ]
 [ 0 ]
 where Q1 consists of the first RANK columns of Q.

 This routine is basically identical to the original xGELSX except
 three differences:
 o The call to the subroutine xGEQPF has been substituted by the
 the call to the subroutine xGEQP3. This subroutine is a Blas-3
 version of the QR factorization with column pivoting.
 o Matrix B (the right hand side) is updated with Blas-3.
 o The permutation of matrix B (the right hand side) is faster and
 more simple.

 */
extern proc LAPACK_dgelsy(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, jpvt : [] c_int, ref rcond : c_double, ref rank : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgelsy

Original Fortran LAPACK documentation for CGELSY::

 CGELSY computes the minimum-norm solution to a complex linear least
 squares problem:
 minimize || A * X - B ||
 using a complete orthogonal factorization of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The routine first computes a QR factorization with column pivoting:
 A * P = Q * [ R11 R12 ]
 [ 0 R22 ]
 with R11 defined as the largest leading submatrix whose estimated
 condition number is less than 1/RCOND. The order of R11, RANK,
 is the effective rank of A.

 Then, R22 is considered to be negligible, and R12 is annihilated
 by unitary transformations from the right, arriving at the
 complete orthogonal factorization:
 A * P = Q * [ T11 0 ] * Z
 [ 0 0 ]
 The minimum-norm solution is then
 X = P * Z**H [ inv(T11)*Q1**H*B ]
 [ 0 ]
 where Q1 consists of the first RANK columns of Q.

 This routine is basically identical to the original xGELSX except
 three differences:
 o The permutation of matrix B (the right hand side) is faster and
 more simple.
 o The call to the subroutine xGEQPF has been substituted by the
 the call to the subroutine xGEQP3. This subroutine is a Blas-3
 version of the QR factorization with column pivoting.
 o Matrix B (the right hand side) is updated with Blas-3.

 */
extern proc LAPACK_cgelsy(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, jpvt : [] c_int, ref rcond : c_float, ref rank : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgelsy

Original Fortran LAPACK documentation for ZGELSY::

 ZGELSY computes the minimum-norm solution to a complex linear least
 squares problem:
 minimize || A * X - B ||
 using a complete orthogonal factorization of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The routine first computes a QR factorization with column pivoting:
 A * P = Q * [ R11 R12 ]
 [ 0 R22 ]
 with R11 defined as the largest leading submatrix whose estimated
 condition number is less than 1/RCOND. The order of R11, RANK,
 is the effective rank of A.

 Then, R22 is considered to be negligible, and R12 is annihilated
 by unitary transformations from the right, arriving at the
 complete orthogonal factorization:
 A * P = Q * [ T11 0 ] * Z
 [ 0 0 ]
 The minimum-norm solution is then
 X = P * Z**H [ inv(T11)*Q1**H*B ]
 [ 0 ]
 where Q1 consists of the first RANK columns of Q.

 This routine is basically identical to the original xGELSX except
 three differences:
 o The permutation of matrix B (the right hand side) is faster and
 more simple.
 o The call to the subroutine xGEQPF has been substituted by the
 the call to the subroutine xGEQP3. This subroutine is a Blas-3
 version of the QR factorization with column pivoting.
 o Matrix B (the right hand side) is updated with Blas-3.

 */
extern proc LAPACK_zgelsy(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, jpvt : [] c_int, ref rcond : c_double, ref rank : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgelss

Original Fortran LAPACK documentation for SGELSS::

 SGELSS computes the minimum norm solution to a real linear least
 squares problem:

 Minimize 2-norm(| b - A*x |).

 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
 X.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 */
extern proc LAPACK_sgelss(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, s : [] c_float, ref rcond : c_float, ref rank : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgelss

Original Fortran LAPACK documentation for DGELSS::

 DGELSS computes the minimum norm solution to a real linear least
 squares problem:

 Minimize 2-norm(| b - A*x |).

 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
 X.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 */
extern proc LAPACK_dgelss(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, s : [] c_double, ref rcond : c_double, ref rank : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgelss

Original Fortran LAPACK documentation for CGELSS::

 CGELSS computes the minimum norm solution to a complex linear
 least squares problem:

 Minimize 2-norm(| b - A*x |).

 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
 X.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 */
extern proc LAPACK_cgelss(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, s : [] c_float, ref rcond : c_float, ref rank : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgelss

Original Fortran LAPACK documentation for ZGELSS::

 ZGELSS computes the minimum norm solution to a complex linear
 least squares problem:

 Minimize 2-norm(| b - A*x |).

 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
 X.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 */
extern proc LAPACK_zgelss(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, s : [] c_double, ref rcond : c_double, ref rank : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgelsd

Original Fortran LAPACK documentation for SGELSD::

 SGELSD computes the minimum-norm solution to a real linear least
 squares problem:
 minimize 2-norm(| b - A*x |)
 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The problem is solved in three steps:
 (1) Reduce the coefficient matrix A to bidiagonal form with
 Householder transformations, reducing the original problem
 into a "bidiagonal least squares problem" (BLS)
 (2) Solve the BLS using a divide and conquer approach.
 (3) Apply back all the Householder tranformations to solve
 the original least squares problem.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_sgelsd(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, s : [] c_float, ref rcond : c_float, ref rank : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgelsd

Original Fortran LAPACK documentation for DGELSD::

 DGELSD computes the minimum-norm solution to a real linear least
 squares problem:
 minimize 2-norm(| b - A*x |)
 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The problem is solved in three steps:
 (1) Reduce the coefficient matrix A to bidiagonal form with
 Householder transformations, reducing the original problem
 into a "bidiagonal least squares problem" (BLS)
 (2) Solve the BLS using a divide and conquer approach.
 (3) Apply back all the Householder tranformations to solve
 the original least squares problem.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_dgelsd(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, s : [] c_double, ref rcond : c_double, ref rank : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgelsd

Original Fortran LAPACK documentation for CGELSD::

 CGELSD computes the minimum-norm solution to a real linear least
 squares problem:
 minimize 2-norm(| b - A*x |)
 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The problem is solved in three steps:
 (1) Reduce the coefficient matrix A to bidiagonal form with
 Householder tranformations, reducing the original problem
 into a "bidiagonal least squares problem" (BLS)
 (2) Solve the BLS using a divide and conquer approach.
 (3) Apply back all the Householder tranformations to solve
 the original least squares problem.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_cgelsd(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, s : [] c_float, ref rcond : c_float, ref rank : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgelsd

Original Fortran LAPACK documentation for ZGELSD::

 ZGELSD computes the minimum-norm solution to a real linear least
 squares problem:
 minimize 2-norm(| b - A*x |)
 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The problem is solved in three steps:
 (1) Reduce the coefficient matrix A to bidiagonal form with
 Householder tranformations, reducing the original problem
 into a "bidiagonal least squares problem" (BLS)
 (2) Solve the BLS using a divide and conquer approach.
 (3) Apply back all the Householder tranformations to solve
 the original least squares problem.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_zgelsd(ref m : c_int, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, s : [] c_double, ref rcond : c_double, ref rank : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgglse

Original Fortran LAPACK documentation for SGGLSE::

 SGGLSE solves the linear equality-constrained least squares (LSE)
 problem:

 minimize || c - A*x ||_2 subject to B*x = d

 where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
 M-vector, and d is a given P-vector. It is assumed that
 P <= N <= M+P, and

 rank(B) = P and rank( (A) ) = N.
 ( (B) )

 These conditions ensure that the LSE problem has a unique solution,
 which is obtained using a generalized RQ factorization of the
 matrices (B, A) given by

 B = (0 R)*Q, A = Z*T*Q.

 */
extern proc LAPACK_sgglse(ref m : c_int, ref n : c_int, ref p : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, c : [] c_float, d : [] c_float, x : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgglse

Original Fortran LAPACK documentation for DGGLSE::

 DGGLSE solves the linear equality-constrained least squares (LSE)
 problem:

 minimize || c - A*x ||_2 subject to B*x = d

 where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
 M-vector, and d is a given P-vector. It is assumed that
 P <= N <= M+P, and

 rank(B) = P and rank( (A) ) = N.
 ( (B) )

 These conditions ensure that the LSE problem has a unique solution,
 which is obtained using a generalized RQ factorization of the
 matrices (B, A) given by

 B = (0 R)*Q, A = Z*T*Q.

 */
extern proc LAPACK_dgglse(ref m : c_int, ref n : c_int, ref p : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, c : [] c_double, d : [] c_double, x : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgglse

Original Fortran LAPACK documentation for CGGLSE::

 CGGLSE solves the linear equality-constrained least squares (LSE)
 problem:

 minimize || c - A*x ||_2 subject to B*x = d

 where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
 M-vector, and d is a given P-vector. It is assumed that
 P <= N <= M+P, and

 rank(B) = P and rank( (A) ) = N.
 ( (B) )

 These conditions ensure that the LSE problem has a unique solution,
 which is obtained using a generalized RQ factorization of the
 matrices (B, A) given by

 B = (0 R)*Q, A = Z*T*Q.

 */
extern proc LAPACK_cgglse(ref m : c_int, ref n : c_int, ref p : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, c : [] complex(64), d : [] complex(64), x : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgglse

Original Fortran LAPACK documentation for ZGGLSE::

 ZGGLSE solves the linear equality-constrained least squares (LSE)
 problem:

 minimize || c - A*x ||_2 subject to B*x = d

 where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
 M-vector, and d is a given P-vector. It is assumed that
 P <= N <= M+P, and

 rank(B) = P and rank( (A) ) = N.
 ( (B) )

 These conditions ensure that the LSE problem has a unique solution,
 which is obtained using a generalized RQ factorization of the
 matrices (B, A) given by

 B = (0 R)*Q, A = Z*T*Q.

 */
extern proc LAPACK_zgglse(ref m : c_int, ref n : c_int, ref p : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, c : [] complex(128), d : [] complex(128), x : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggglm

Original Fortran LAPACK documentation for SGGGLM::

 SGGGLM solves a general Gauss-Markov linear model (GLM) problem:

 minimize || y ||_2 subject to d = A*x + B*y
 x

 where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
 given N-vector. It is assumed that M <= N <= M+P, and

 rank(A) = M and rank( A B ) = N.

 Under these assumptions, the constrained equation is always
 consistent, and there is a unique solution x and a minimal 2-norm
 solution y, which is obtained using a generalized QR factorization
 of the matrices (A, B) given by

 A = Q*(R), B = Q*T*Z.
 (0)

 In particular, if matrix B is square nonsingular, then the problem
 GLM is equivalent to the following weighted linear least squares
 problem

 minimize || inv(B)*(d-A*x) ||_2
 x

 where inv(B) denotes the inverse of B.

 */
extern proc LAPACK_sggglm(ref n : c_int, ref m : c_int, ref p : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, d : [] c_float, x : [] c_float, y : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggglm

Original Fortran LAPACK documentation for DGGGLM::

 DGGGLM solves a general Gauss-Markov linear model (GLM) problem:

 minimize || y ||_2 subject to d = A*x + B*y
 x

 where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
 given N-vector. It is assumed that M <= N <= M+P, and

 rank(A) = M and rank( A B ) = N.

 Under these assumptions, the constrained equation is always
 consistent, and there is a unique solution x and a minimal 2-norm
 solution y, which is obtained using a generalized QR factorization
 of the matrices (A, B) given by

 A = Q*(R), B = Q*T*Z.
 (0)

 In particular, if matrix B is square nonsingular, then the problem
 GLM is equivalent to the following weighted linear least squares
 problem

 minimize || inv(B)*(d-A*x) ||_2
 x

 where inv(B) denotes the inverse of B.

 */
extern proc LAPACK_dggglm(ref n : c_int, ref m : c_int, ref p : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, d : [] c_double, x : [] c_double, y : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggglm

Original Fortran LAPACK documentation for CGGGLM::

 CGGGLM solves a general Gauss-Markov linear model (GLM) problem:

 minimize || y ||_2 subject to d = A*x + B*y
 x

 where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
 given N-vector. It is assumed that M <= N <= M+P, and

 rank(A) = M and rank( A B ) = N.

 Under these assumptions, the constrained equation is always
 consistent, and there is a unique solution x and a minimal 2-norm
 solution y, which is obtained using a generalized QR factorization
 of the matrices (A, B) given by

 A = Q*(R), B = Q*T*Z.
 (0)

 In particular, if matrix B is square nonsingular, then the problem
 GLM is equivalent to the following weighted linear least squares
 problem

 minimize || inv(B)*(d-A*x) ||_2
 x

 where inv(B) denotes the inverse of B.

 */
extern proc LAPACK_cggglm(ref n : c_int, ref m : c_int, ref p : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, d : [] complex(64), x : [] complex(64), y : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggglm

Original Fortran LAPACK documentation for ZGGGLM::

 ZGGGLM solves a general Gauss-Markov linear model (GLM) problem:

 minimize || y ||_2 subject to d = A*x + B*y
 x

 where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
 given N-vector. It is assumed that M <= N <= M+P, and

 rank(A) = M and rank( A B ) = N.

 Under these assumptions, the constrained equation is always
 consistent, and there is a unique solution x and a minimal 2-norm
 solution y, which is obtained using a generalized QR factorization
 of the matrices (A, B) given by

 A = Q*(R), B = Q*T*Z.
 (0)

 In particular, if matrix B is square nonsingular, then the problem
 GLM is equivalent to the following weighted linear least squares
 problem

 minimize || inv(B)*(d-A*x) ||_2
 x

 where inv(B) denotes the inverse of B.

 */
extern proc LAPACK_zggglm(ref n : c_int, ref m : c_int, ref p : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, d : [] complex(128), x : [] complex(128), y : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssyev

Original Fortran LAPACK documentation for SSYEV::

 SSYEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A.

 */
extern proc LAPACK_ssyev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, w : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsyev

Original Fortran LAPACK documentation for DSYEV::

 DSYEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A.

 */
extern proc LAPACK_dsyev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, w : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cheev

Original Fortran LAPACK documentation for CHEEV::

 CHEEV computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A.

 */
extern proc LAPACK_cheev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, w : [] c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zheev

Original Fortran LAPACK documentation for ZHEEV::

 ZHEEV computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A.

 */
extern proc LAPACK_zheev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, w : [] c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssyevd

Original Fortran LAPACK documentation for SSYEVD::

 SSYEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 Because of large use of BLAS of level 3, SSYEVD needs N**2 more
 workspace than SSYEVX.

 */
extern proc LAPACK_ssyevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, w : [] c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsyevd

Original Fortran LAPACK documentation for DSYEVD::

 DSYEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 Because of large use of BLAS of level 3, DSYEVD needs N**2 more
 workspace than DSYEVX.

 */
extern proc LAPACK_dsyevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, w : [] c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cheevd

Original Fortran LAPACK documentation for CHEEVD::

 CHEEVD computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_cheevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, w : [] c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zheevd

Original Fortran LAPACK documentation for ZHEEVD::

 ZHEEVD computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_zheevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, w : [] c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssyevx

Original Fortran LAPACK documentation for SSYEVX::

 SSYEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

 */
extern proc LAPACK_ssyevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsyevx

Original Fortran LAPACK documentation for DSYEVX::

 DSYEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

 */
extern proc LAPACK_dsyevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cheevx

Original Fortran LAPACK documentation for CHEEVX::

 CHEEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACK_cheevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zheevx

Original Fortran LAPACK documentation for ZHEEVX::

 ZHEEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACK_zheevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssyevr

Original Fortran LAPACK documentation for SSYEVR::

 SSYEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 SSYEVR first reduces the matrix A to tridiagonal form T with a call
 to SSYTRD. Then, whenever possible, SSYEVR calls SSTEMR to compute
 the eigenspectrum using Relatively Robust Representations. SSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see SSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : SSYEVR calls SSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 SSYEVR calls SSTEBZ and SSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of SSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACK_ssyevr(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, isuppz : [] c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsyevr

Original Fortran LAPACK documentation for DSYEVR::

 DSYEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 DSYEVR first reduces the matrix A to tridiagonal form T with a call
 to DSYTRD. Then, whenever possible, DSYEVR calls DSTEMR to compute
 the eigenspectrum using Relatively Robust Representations. DSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see DSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : DSYEVR calls DSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 DSYEVR calls DSTEBZ and SSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of DSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACK_dsyevr(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, isuppz : [] c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cheevr

Original Fortran LAPACK documentation for CHEEVR::

 CHEEVR computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 CHEEVR first reduces the matrix A to tridiagonal form T with a call
 to CHETRD. Then, whenever possible, CHEEVR calls CSTEMR to compute
 the eigenspectrum using Relatively Robust Representations. CSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see DSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : CHEEVR calls CSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 CHEEVR calls SSTEBZ and CSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of CSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACK_cheevr(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, isuppz : [] c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zheevr

Original Fortran LAPACK documentation for ZHEEVR::

 ZHEEVR computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 ZHEEVR first reduces the matrix A to tridiagonal form T with a call
 to ZHETRD. Then, whenever possible, ZHEEVR calls ZSTEMR to compute
 eigenspectrum using Relatively Robust Representations. ZSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see DSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : ZHEEVR calls ZSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 ZHEEVR calls DSTEBZ and ZSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of ZSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACK_zheevr(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, isuppz : [] c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspev

Original Fortran LAPACK documentation for SSPEV::

 SSPEV computes all the eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A in packed storage.

 */
extern proc LAPACK_sspev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspev

Original Fortran LAPACK documentation for DSPEV::

 DSPEV computes all the eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A in packed storage.

 */
extern proc LAPACK_dspev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpev

Original Fortran LAPACK documentation for CHPEV::

 CHPEV computes all the eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix in packed storage.

 */
extern proc LAPACK_chpev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpev

Original Fortran LAPACK documentation for ZHPEV::

 ZHPEV computes all the eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix in packed storage.

 */
extern proc LAPACK_zhpev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspevd

Original Fortran LAPACK documentation for SSPEVD::

 SSPEVD computes all the eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_sspevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspevd

Original Fortran LAPACK documentation for DSPEVD::

 DSPEVD computes all the eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_dspevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpevd

Original Fortran LAPACK documentation for CHPEVD::

 CHPEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_chpevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpevd

Original Fortran LAPACK documentation for ZHPEVD::

 ZHPEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_zhpevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspevx

Original Fortran LAPACK documentation for SSPEVX::

 SSPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. Eigenvalues/vectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACK_sspevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_float, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspevx

Original Fortran LAPACK documentation for DSPEVX::

 DSPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. Eigenvalues/vectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACK_dspevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_double, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpevx

Original Fortran LAPACK documentation for CHPEVX::

 CHPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A in packed storage.
 Eigenvalues/vectors can be selected by specifying either a range of
 values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_chpevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(64), ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpevx

Original Fortran LAPACK documentation for ZHPEVX::

 ZHPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A in packed storage.
 Eigenvalues/vectors can be selected by specifying either a range of
 values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_zhpevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(128), ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssbev

Original Fortran LAPACK documentation for SSBEV::

 SSBEV computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A.

 */
extern proc LAPACK_ssbev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_float, ref ldab : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsbev

Original Fortran LAPACK documentation for DSBEV::

 DSBEV computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A.

 */
extern proc LAPACK_dsbev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_double, ref ldab : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chbev

Original Fortran LAPACK documentation for CHBEV::

 CHBEV computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A.

 */
extern proc LAPACK_chbev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(64), ref ldab : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhbev

Original Fortran LAPACK documentation for ZHBEV::

 ZHBEV computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A.

 */
extern proc LAPACK_zhbev(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(128), ref ldab : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssbevd

Original Fortran LAPACK documentation for SSBEVD::

 SSBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A. If eigenvectors are desired, it uses
 a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_ssbevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_float, ref ldab : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsbevd

Original Fortran LAPACK documentation for DSBEVD::

 DSBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A. If eigenvectors are desired, it uses
 a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_dsbevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_double, ref ldab : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chbevd

Original Fortran LAPACK documentation for CHBEVD::

 CHBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_chbevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(64), ref ldab : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhbevd

Original Fortran LAPACK documentation for ZHBEVD::

 ZHBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_zhbevd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(128), ref ldab : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssbevx

Original Fortran LAPACK documentation for SSBEVX::

 SSBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric band matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACK_ssbevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_float, ref ldab : c_int, q : [] c_float, ref ldq : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsbevx

Original Fortran LAPACK documentation for DSBEVX::

 DSBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric band matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACK_dsbevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] c_double, ref ldab : c_int, q : [] c_double, ref ldq : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chbevx

Original Fortran LAPACK documentation for CHBEVX::

 CHBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian band matrix A. Eigenvalues and eigenvectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACK_chbevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(64), ref ldab : c_int, q : [] complex(64), ref ldq : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhbevx

Original Fortran LAPACK documentation for ZHBEVX::

 ZHBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian band matrix A. Eigenvalues and eigenvectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 */
extern proc LAPACK_zhbevx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ref kd : c_int, ab : [] complex(128), ref ldab : c_int, q : [] complex(128), ref ldq : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sstev

Original Fortran LAPACK documentation for SSTEV::

 SSTEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix A.

 */
extern proc LAPACK_sstev(ref jobz : c_char, ref n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dstev

Original Fortran LAPACK documentation for DSTEV::

 DSTEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix A.

 */
extern proc LAPACK_dstev(ref jobz : c_char, ref n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sstevd

Original Fortran LAPACK documentation for SSTEVD::

 SSTEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_sstevd(ref jobz : c_char, ref n : c_int, d : [] c_float, e : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dstevd

Original Fortran LAPACK documentation for DSTEVD::

 DSTEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_dstevd(ref jobz : c_char, ref n : c_int, d : [] c_double, e : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sstevx

Original Fortran LAPACK documentation for SSTEVX::

 SSTEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix A. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_sstevx(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_float, e : [] c_float, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dstevx

Original Fortran LAPACK documentation for DSTEVX::

 DSTEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix A. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_dstevx(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_double, e : [] c_double, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sstevr

Original Fortran LAPACK documentation for SSTEVR::

 SSTEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

 Whenever possible, SSTEVR calls SSTEMR to compute the
 eigenspectrum using Relatively Robust Representations. SSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows. For the i-th
 unreduced block of T,
 (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
 is a relatively robust representation,
 (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
 relative accuracy by the dqds algorithm,
 (c) If there is a cluster of close eigenvalues, "choose" sigma_i
 close to the cluster, and go to step (a),
 (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
 compute the corresponding eigenvector by forming a
 rank-revealing twisted factorization.
 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
 Computer Science Division Technical Report No. UCB//CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : SSTEVR calls SSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 SSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of SSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACK_sstevr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_float, e : [] c_float, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, isuppz : [] c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dstevr

Original Fortran LAPACK documentation for DSTEVR::

 DSTEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

 Whenever possible, DSTEVR calls DSTEMR to compute the
 eigenspectrum using Relatively Robust Representations. DSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows. For the i-th
 unreduced block of T,
 (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
 is a relatively robust representation,
 (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
 relative accuracy by the dqds algorithm,
 (c) If there is a cluster of close eigenvalues, "choose" sigma_i
 close to the cluster, and go to step (a),
 (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
 compute the corresponding eigenvector by forming a
 rank-revealing twisted factorization.
 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
 Computer Science Division Technical Report No. UCB//CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : DSTEVR calls DSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 DSTEVR calls DSTEBZ and DSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of DSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

 */
extern proc LAPACK_dstevr(ref jobz : c_char, ref range : c_char, ref n : c_int, d : [] c_double, e : [] c_double, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, isuppz : [] c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgees

Original Fortran LAPACK documentation for SGEES::

 SGEES computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left.
 The leading columns of Z then form an orthonormal basis for the
 invariant subspace corresponding to the selected eigenvalues.

 A matrix is in real Schur form if it is upper quasi-triangular with
 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
 form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

 */
extern proc LAPACK_sgees(ref jobvs : c_char, ref sort : c_char, chlapack_select : LAPACK_S_SELECT2, ref n : c_int, a : [] c_float, ref lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ref ldvs : c_int, work : [] c_float, ref lwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgees

Original Fortran LAPACK documentation for DGEES::

 DGEES computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left.
 The leading columns of Z then form an orthonormal basis for the
 invariant subspace corresponding to the selected eigenvalues.

 A matrix is in real Schur form if it is upper quasi-triangular with
 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
 form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

 */
extern proc LAPACK_dgees(ref jobvs : c_char, ref sort : c_char, chlapack_select : LAPACK_D_SELECT2, ref n : c_int, a : [] c_double, ref lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ref ldvs : c_int, work : [] c_double, ref lwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgees

Original Fortran LAPACK documentation for CGEES::

 CGEES computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues, the Schur form T, and, optionally, the matrix of Schur
 vectors Z. This gives the Schur factorization A = Z*T*(Z**H).

 Optionally, it also orders the eigenvalues on the diagonal of the
 Schur form so that selected eigenvalues are at the top left.
 The leading columns of Z then form an orthonormal basis for the
 invariant subspace corresponding to the selected eigenvalues.

 A complex matrix is in Schur form if it is upper triangular.

 */
extern proc LAPACK_cgees(ref jobvs : c_char, ref sort : c_char, chlapack_select : LAPACK_C_SELECT1, ref n : c_int, a : [] complex(64), ref lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ref ldvs : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgees

Original Fortran LAPACK documentation for ZGEES::

 ZGEES computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues, the Schur form T, and, optionally, the matrix of Schur
 vectors Z. This gives the Schur factorization A = Z*T*(Z**H).

 Optionally, it also orders the eigenvalues on the diagonal of the
 Schur form so that selected eigenvalues are at the top left.
 The leading columns of Z then form an orthonormal basis for the
 invariant subspace corresponding to the selected eigenvalues.

 A complex matrix is in Schur form if it is upper triangular.

 */
extern proc LAPACK_zgees(ref jobvs : c_char, ref sort : c_char, chlapack_select : LAPACK_Z_SELECT1, ref n : c_int, a : [] complex(128), ref lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ref ldvs : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeesx

Original Fortran LAPACK documentation for SGEESX::

 SGEESX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left;
 computes a reciprocal condition number for the average of the
 selected eigenvalues (RCONDE); and computes a reciprocal condition
 number for the right invariant subspace corresponding to the
 selected eigenvalues (RCONDV). The leading columns of Z form an
 orthonormal basis for this invariant subspace.

 For further explanation of the reciprocal condition numbers RCONDE
 and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
 these quantities are called s and sep respectively).

 A real matrix is in real Schur form if it is upper quasi-triangular
 with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
 the form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

 */
extern proc LAPACK_sgeesx(ref jobvs : c_char, ref sort : c_char, chlapack_select : LAPACK_S_SELECT2, ref sense : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ref ldvs : c_int, ref rconde : c_float, ref rcondv : c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeesx

Original Fortran LAPACK documentation for DGEESX::

 DGEESX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left;
 computes a reciprocal condition number for the average of the
 selected eigenvalues (RCONDE); and computes a reciprocal condition
 number for the right invariant subspace corresponding to the
 selected eigenvalues (RCONDV). The leading columns of Z form an
 orthonormal basis for this invariant subspace.

 For further explanation of the reciprocal condition numbers RCONDE
 and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
 these quantities are called s and sep respectively).

 A real matrix is in real Schur form if it is upper quasi-triangular
 with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
 the form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

 */
extern proc LAPACK_dgeesx(ref jobvs : c_char, ref sort : c_char, chlapack_select : LAPACK_D_SELECT2, ref sense : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ref ldvs : c_int, ref rconde : c_double, ref rcondv : c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeesx

Original Fortran LAPACK documentation for CGEESX::

 CGEESX computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues, the Schur form T, and, optionally, the matrix of Schur
 vectors Z. This gives the Schur factorization A = Z*T*(Z**H).

 Optionally, it also orders the eigenvalues on the diagonal of the
 Schur form so that selected eigenvalues are at the top left;
 computes a reciprocal condition number for the average of the
 selected eigenvalues (RCONDE); and computes a reciprocal condition
 number for the right invariant subspace corresponding to the
 selected eigenvalues (RCONDV). The leading columns of Z form an
 orthonormal basis for this invariant subspace.

 For further explanation of the reciprocal condition numbers RCONDE
 and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
 these quantities are called s and sep respectively).

 A complex matrix is in Schur form if it is upper triangular.

 */
extern proc LAPACK_cgeesx(ref jobvs : c_char, ref sort : c_char, chlapack_select : LAPACK_C_SELECT1, ref sense : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ref ldvs : c_int, ref rconde : c_float, ref rcondv : c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeesx

Original Fortran LAPACK documentation for ZGEESX::

 ZGEESX computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues, the Schur form T, and, optionally, the matrix of Schur
 vectors Z. This gives the Schur factorization A = Z*T*(Z**H).

 Optionally, it also orders the eigenvalues on the diagonal of the
 Schur form so that selected eigenvalues are at the top left;
 computes a reciprocal condition number for the average of the
 selected eigenvalues (RCONDE); and computes a reciprocal condition
 number for the right invariant subspace corresponding to the
 selected eigenvalues (RCONDV). The leading columns of Z form an
 orthonormal basis for this invariant subspace.

 For further explanation of the reciprocal condition numbers RCONDE
 and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
 these quantities are called s and sep respectively).

 A complex matrix is in Schur form if it is upper triangular.

 */
extern proc LAPACK_zgeesx(ref jobvs : c_char, ref sort : c_char, chlapack_select : LAPACK_Z_SELECT1, ref sense : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ref ldvs : c_int, ref rconde : c_double, ref rcondv : c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeev

Original Fortran LAPACK documentation for SGEEV::

 SGEEV computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 */
extern proc LAPACK_sgeev(ref jobvl : c_char, ref jobvr : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ref ldvl : c_int, vr : [] c_float, ref ldvr : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeev

Original Fortran LAPACK documentation for DGEEV::

 DGEEV computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 */
extern proc LAPACK_dgeev(ref jobvl : c_char, ref jobvr : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ref ldvl : c_int, vr : [] c_double, ref ldvr : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeev

Original Fortran LAPACK documentation for CGEEV::

 CGEEV computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 */
extern proc LAPACK_cgeev(ref jobvl : c_char, ref jobvr : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, w : [] complex(64), vl : [] complex(64), ref ldvl : c_int, vr : [] complex(64), ref ldvr : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeev

Original Fortran LAPACK documentation for ZGEEV::

 ZGEEV computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 */
extern proc LAPACK_zgeev(ref jobvl : c_char, ref jobvr : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, w : [] complex(128), vl : [] complex(128), ref ldvl : c_int, vr : [] complex(128), ref ldvr : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeevx

Original Fortran LAPACK documentation for SGEEVX::

 SGEEVX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
 (RCONDE), and reciprocal condition numbers for the right
 eigenvectors (RCONDV).

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 Balancing a matrix means permuting the rows and columns to make it
 more nearly upper triangular, and applying a diagonal similarity
 transformation D * A * D**(-1), where D is a diagonal matrix, to
 make its rows and columns closer in norm and the condition numbers
 of its eigenvalues and eigenvectors smaller. The computed
 reciprocal condition numbers correspond to the balanced matrix.
 Permuting rows and columns will not change the condition numbers
 (in exact arithmetic) but diagonal scaling will. For further
 explanation of balancing, see section 4.10.2 of the LAPACK
 Users' Guide.

 */
extern proc LAPACK_sgeevx(ref balanc : c_char, ref jobvl : c_char, ref jobvr : c_char, ref sense : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, wr : [] c_float, wi : [] c_float, vl : [] c_float, ref ldvl : c_int, vr : [] c_float, ref ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeevx

Original Fortran LAPACK documentation for DGEEVX::

 DGEEVX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
 (RCONDE), and reciprocal condition numbers for the right
 eigenvectors (RCONDV).

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 Balancing a matrix means permuting the rows and columns to make it
 more nearly upper triangular, and applying a diagonal similarity
 transformation D * A * D**(-1), where D is a diagonal matrix, to
 make its rows and columns closer in norm and the condition numbers
 of its eigenvalues and eigenvectors smaller. The computed
 reciprocal condition numbers correspond to the balanced matrix.
 Permuting rows and columns will not change the condition numbers
 (in exact arithmetic) but diagonal scaling will. For further
 explanation of balancing, see section 4.10.2 of the LAPACK
 Users' Guide.

 */
extern proc LAPACK_dgeevx(ref balanc : c_char, ref jobvl : c_char, ref jobvr : c_char, ref sense : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, wr : [] c_double, wi : [] c_double, vl : [] c_double, ref ldvl : c_int, vr : [] c_double, ref ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeevx

Original Fortran LAPACK documentation for CGEEVX::

 CGEEVX computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
 (RCONDE), and reciprocal condition numbers for the right
 eigenvectors (RCONDV).

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 Balancing a matrix means permuting the rows and columns to make it
 more nearly upper triangular, and applying a diagonal similarity
 transformation D * A * D**(-1), where D is a diagonal matrix, to
 make its rows and columns closer in norm and the condition numbers
 of its eigenvalues and eigenvectors smaller. The computed
 reciprocal condition numbers correspond to the balanced matrix.
 Permuting rows and columns will not change the condition numbers
 (in exact arithmetic) but diagonal scaling will. For further
 explanation of balancing, see section 4.10.2 of the LAPACK
 Users' Guide.

 */
extern proc LAPACK_cgeevx(ref balanc : c_char, ref jobvl : c_char, ref jobvr : c_char, ref sense : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, w : [] complex(64), vl : [] complex(64), ref ldvl : c_int, vr : [] complex(64), ref ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeevx

Original Fortran LAPACK documentation for ZGEEVX::

 ZGEEVX computes for an N-by-N complex nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
 (RCONDE), and reciprocal condition numbers for the right
 eigenvectors (RCONDV).

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 Balancing a matrix means permuting the rows and columns to make it
 more nearly upper triangular, and applying a diagonal similarity
 transformation D * A * D**(-1), where D is a diagonal matrix, to
 make its rows and columns closer in norm and the condition numbers
 of its eigenvalues and eigenvectors smaller. The computed
 reciprocal condition numbers correspond to the balanced matrix.
 Permuting rows and columns will not change the condition numbers
 (in exact arithmetic) but diagonal scaling will. For further
 explanation of balancing, see section 4.10.2 of the LAPACK
 Users' Guide.

 */
extern proc LAPACK_zgeevx(ref balanc : c_char, ref jobvl : c_char, ref jobvr : c_char, ref sense : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, w : [] complex(128), vl : [] complex(128), ref ldvl : c_int, vr : [] complex(128), ref ldvr : c_int, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgesvd

Original Fortran LAPACK documentation for SGESVD::

 SGESVD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors. The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns V**T, not V.

 */
extern proc LAPACK_sgesvd(ref jobu : c_char, ref jobvt : c_char, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, s : [] c_float, u : [] c_float, ref ldu : c_int, vt : [] c_float, ref ldvt : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgesvd

Original Fortran LAPACK documentation for DGESVD::

 DGESVD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors. The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns V**T, not V.

 */
extern proc LAPACK_dgesvd(ref jobu : c_char, ref jobvt : c_char, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, s : [] c_double, u : [] c_double, ref ldu : c_int, vt : [] c_double, ref ldvt : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgesvd

Original Fortran LAPACK documentation for CGESVD::

 CGESVD computes the singular value decomposition (SVD) of a complex
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors. The SVD is written

 A = U * SIGMA * conjugate-transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
 V is an N-by-N unitary matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns V**H, not V.

 */
extern proc LAPACK_cgesvd(ref jobu : c_char, ref jobvt : c_char, ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, s : [] c_float, u : [] complex(64), ref ldu : c_int, vt : [] complex(64), ref ldvt : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgesvd

Original Fortran LAPACK documentation for ZGESVD::

 ZGESVD computes the singular value decomposition (SVD) of a complex
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors. The SVD is written

 A = U * SIGMA * conjugate-transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
 V is an N-by-N unitary matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns V**H, not V.

 */
extern proc LAPACK_zgesvd(ref jobu : c_char, ref jobvt : c_char, ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, s : [] c_double, u : [] complex(128), ref ldu : c_int, vt : [] complex(128), ref ldvt : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgesdd

Original Fortran LAPACK documentation for SGESDD::

 SGESDD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and right singular
 vectors. If singular vectors are desired, it uses a
 divide-and-conquer algorithm.

 The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns VT = V**T, not V.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_sgesdd(ref jobz : c_char, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, s : [] c_float, u : [] c_float, ref ldu : c_int, vt : [] c_float, ref ldvt : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgesdd

Original Fortran LAPACK documentation for DGESDD::

 DGESDD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and right singular
 vectors. If singular vectors are desired, it uses a
 divide-and-conquer algorithm.

 The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns VT = V**T, not V.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_dgesdd(ref jobz : c_char, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, s : [] c_double, u : [] c_double, ref ldu : c_int, vt : [] c_double, ref ldvt : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgesdd

Original Fortran LAPACK documentation for CGESDD::

 CGESDD computes the singular value decomposition (SVD) of a complex
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors, by using divide-and-conquer method. The SVD is written

 A = U * SIGMA * conjugate-transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
 V is an N-by-N unitary matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns VT = V**H, not V.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_cgesdd(ref jobz : c_char, ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, s : [] c_float, u : [] complex(64), ref ldu : c_int, vt : [] complex(64), ref ldvt : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgesdd

Original Fortran LAPACK documentation for ZGESDD::

 ZGESDD computes the singular value decomposition (SVD) of a complex
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors, by using divide-and-conquer method. The SVD is written

 A = U * SIGMA * conjugate-transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
 V is an N-by-N unitary matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns VT = V**H, not V.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_zgesdd(ref jobz : c_char, ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, s : [] c_double, u : [] complex(128), ref ldu : c_int, vt : [] complex(128), ref ldvt : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgejsv

Original Fortran LAPACK documentation for DGEJSV::

 DGEJSV computes the singular value decomposition (SVD) of a real M-by-N
 matrix [A], where M >= N. The SVD of [A] is written as

 [A] = [U] * [SIGMA] * [V]^t,

 where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
 diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
 [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
 the singular values of [A]. The columns of [U] and [V] are the left and
 the right singular vectors of [A], respectively. The matrices [U] and [V]
 are computed and stored in the arrays U and V, respectively. The diagonal
 of [SIGMA] is computed and stored in the array SVA.

 */
extern proc LAPACK_dgejsv(ref joba : c_char, ref jobu : c_char, ref jobv : c_char, ref jobr : c_char, ref jobt : c_char, ref jobp : c_char, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, sva : [] c_double, u : [] c_double, ref ldu : c_int, v : [] c_double, ref ldv : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgejsv

Original Fortran LAPACK documentation for SGEJSV::

 SGEJSV computes the singular value decomposition (SVD) of a real M-by-N
 matrix [A], where M >= N. The SVD of [A] is written as

 [A] = [U] * [SIGMA] * [V]^t,

 where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
 diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
 [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
 the singular values of [A]. The columns of [U] and [V] are the left and
 the right singular vectors of [A], respectively. The matrices [U] and [V]
 are computed and stored in the arrays U and V, respectively. The diagonal
 of [SIGMA] is computed and stored in the array SVA.

 */
extern proc LAPACK_sgejsv(ref joba : c_char, ref jobu : c_char, ref jobv : c_char, ref jobr : c_char, ref jobt : c_char, ref jobp : c_char, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, sva : [] c_float, u : [] c_float, ref ldu : c_int, v : [] c_float, ref ldv : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgesvj

Original Fortran LAPACK documentation for DGESVJ::

 DGESVJ computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, where M >= N. The SVD of A is written as
 [++] [xx] [x0] [xx]
 A = U * SIGMA * V^t, [++] = [xx] * [ox] * [xx]
 [++] [xx]
 where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
 matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
 of SIGMA are the singular values of A. The columns of U and V are the
 left and the right singular vectors of A, respectively.

 */
extern proc LAPACK_dgesvj(ref joba : c_char, ref jobu : c_char, ref jobv : c_char, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, sva : [] c_double, ref mv : c_int, v : [] c_double, ref ldv : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgesvj

Original Fortran LAPACK documentation for SGESVJ::

 SGESVJ computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, where M >= N. The SVD of A is written as
 [++] [xx] [x0] [xx]
 A = U * SIGMA * V^t, [++] = [xx] * [ox] * [xx]
 [++] [xx]
 where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
 matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
 of SIGMA are the singular values of A. The columns of U and V are the
 left and the right singular vectors of A, respectively.

 */
extern proc LAPACK_sgesvj(ref joba : c_char, ref jobu : c_char, ref jobv : c_char, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, sva : [] c_float, ref mv : c_int, v : [] c_float, ref ldv : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggsvd

Original Fortran LAPACK documentation for SGGSVD::

 SGGSVD computes the generalized singular value decomposition (GSVD)
 of an M-by-N real matrix A and P-by-N real matrix B:

 U**T*A*Q = D1*( 0 R ), V**T*B*Q = D2*( 0 R )

 where U, V and Q are orthogonal matrices.
 Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,
 then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
 D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
 following structures, respectively:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 )
 L ( 0 0 R22 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The routine computes C, S, R, and optionally the orthogonal
 transformation matrices U, V and Q.

 In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
 A and B implicitly gives the SVD of A*inv(B):
 A*inv(B) = U*(D1*inv(D2))*V**T.
 If ( A**T,B**T)**T has orthonormal columns, then the GSVD of A and B is
 also equal to the CS decomposition of A and B. Furthermore, the GSVD
 can be used to derive the solution of the eigenvalue problem:
 A**T*A x = lambda* B**T*B x.
 In some literature, the GSVD of A and B is presented in the form
 U**T*A*X = ( 0 D1 ), V**T*B*X = ( 0 D2 )
 where U and V are orthogonal and X is nonsingular, D1 and D2 are
 ``diagonal''. The former GSVD form can be converted to the latter
 form by taking the nonsingular matrix X as

 X = Q*( I 0 )
 ( 0 inv(R) ).

 */
extern proc LAPACK_sggsvd(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref n : c_int, ref p : c_int, ref k : c_int, ref l : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] c_float, ref ldu : c_int, v : [] c_float, ref ldv : c_int, q : [] c_float, ref ldq : c_int, work : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggsvd

Original Fortran LAPACK documentation for DGGSVD::

 DGGSVD computes the generalized singular value decomposition (GSVD)
 of an M-by-N real matrix A and P-by-N real matrix B:

 U**T*A*Q = D1*( 0 R ), V**T*B*Q = D2*( 0 R )

 where U, V and Q are orthogonal matrices.
 Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,
 then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
 D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
 following structures, respectively:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 )
 L ( 0 0 R22 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The routine computes C, S, R, and optionally the orthogonal
 transformation matrices U, V and Q.

 In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
 A and B implicitly gives the SVD of A*inv(B):
 A*inv(B) = U*(D1*inv(D2))*V**T.
 If ( A**T,B**T)**T has orthonormal columns, then the GSVD of A and B is
 also equal to the CS decomposition of A and B. Furthermore, the GSVD
 can be used to derive the solution of the eigenvalue problem:
 A**T*A x = lambda* B**T*B x.
 In some literature, the GSVD of A and B is presented in the form
 U**T*A*X = ( 0 D1 ), V**T*B*X = ( 0 D2 )
 where U and V are orthogonal and X is nonsingular, D1 and D2 are
 ``diagonal''. The former GSVD form can be converted to the latter
 form by taking the nonsingular matrix X as

 X = Q*( I 0 )
 ( 0 inv(R) ).

 */
extern proc LAPACK_dggsvd(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref n : c_int, ref p : c_int, ref k : c_int, ref l : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] c_double, ref ldu : c_int, v : [] c_double, ref ldv : c_int, q : [] c_double, ref ldq : c_int, work : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggsvd

Original Fortran LAPACK documentation for CGGSVD::

 CGGSVD computes the generalized singular value decomposition (GSVD)
 of an M-by-N complex matrix A and P-by-N complex matrix B:

 U**H*A*Q = D1*( 0 R ), V**H*B*Q = D2*( 0 R )

 where U, V and Q are unitary matrices.
 Let K+L = the effective numerical rank of the
 matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
 triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
 matrices and of the following structures, respectively:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 )
 L ( 0 0 R22 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The routine computes C, S, R, and optionally the unitary
 transformation matrices U, V and Q.

 In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
 A and B implicitly gives the SVD of A*inv(B):
 A*inv(B) = U*(D1*inv(D2))*V**H.
 If ( A**H,B**H)**H has orthnormal columns, then the GSVD of A and B is also
 equal to the CS decomposition of A and B. Furthermore, the GSVD can
 be used to derive the solution of the eigenvalue problem:
 A**H*A x = lambda* B**H*B x.
 In some literature, the GSVD of A and B is presented in the form
 U**H*A*X = ( 0 D1 ), V**H*B*X = ( 0 D2 )
 where U and V are orthogonal and X is nonsingular, and D1 and D2 are
 ``diagonal''. The former GSVD form can be converted to the latter
 form by taking the nonsingular matrix X as

 X = Q*( I 0 )
 ( 0 inv(R) )

 */
extern proc LAPACK_cggsvd(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref n : c_int, ref p : c_int, ref k : c_int, ref l : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, alpha : [] c_float, beta : [] c_float, u : [] complex(64), ref ldu : c_int, v : [] complex(64), ref ldv : c_int, q : [] complex(64), ref ldq : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggsvd

Original Fortran LAPACK documentation for ZGGSVD::

 ZGGSVD computes the generalized singular value decomposition (GSVD)
 of an M-by-N complex matrix A and P-by-N complex matrix B:

 U**H*A*Q = D1*( 0 R ), V**H*B*Q = D2*( 0 R )

 where U, V and Q are unitary matrices.
 Let K+L = the effective numerical rank of the
 matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
 triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
 matrices and of the following structures, respectively:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 )
 L ( 0 0 R22 )
 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The routine computes C, S, R, and optionally the unitary
 transformation matrices U, V and Q.

 In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
 A and B implicitly gives the SVD of A*inv(B):
 A*inv(B) = U*(D1*inv(D2))*V**H.
 If ( A**H,B**H)**H has orthnormal columns, then the GSVD of A and B is also
 equal to the CS decomposition of A and B. Furthermore, the GSVD can
 be used to derive the solution of the eigenvalue problem:
 A**H*A x = lambda* B**H*B x.
 In some literature, the GSVD of A and B is presented in the form
 U**H*A*X = ( 0 D1 ), V**H*B*X = ( 0 D2 )
 where U and V are orthogonal and X is nonsingular, and D1 and D2 are
 ``diagonal''. The former GSVD form can be converted to the latter
 form by taking the nonsingular matrix X as

 X = Q*( I 0 )
 ( 0 inv(R) )

 */
extern proc LAPACK_zggsvd(ref jobu : c_char, ref jobv : c_char, ref jobq : c_char, ref m : c_int, ref n : c_int, ref p : c_int, ref k : c_int, ref l : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, alpha : [] c_double, beta : [] c_double, u : [] complex(128), ref ldu : c_int, v : [] complex(128), ref ldv : c_int, q : [] complex(128), ref ldq : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssygv

Original Fortran LAPACK documentation for SSYGV::

 SSYGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric and B is also
 positive definite.

 */
extern proc LAPACK_ssygv(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, w : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsygv

Original Fortran LAPACK documentation for DSYGV::

 DSYGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric and B is also
 positive definite.

 */
extern proc LAPACK_dsygv(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, w : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chegv

Original Fortran LAPACK documentation for CHEGV::

 CHEGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian and B is also
 positive definite.

 */
extern proc LAPACK_chegv(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, w : [] c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhegv

Original Fortran LAPACK documentation for ZHEGV::

 ZHEGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian and B is also
 positive definite.

 */
extern proc LAPACK_zhegv(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, w : [] c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssygvd

Original Fortran LAPACK documentation for SSYGVD::

 SSYGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_ssygvd(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, w : [] c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsygvd

Original Fortran LAPACK documentation for DSYGVD::

 DSYGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_dsygvd(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, w : [] c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chegvd

Original Fortran LAPACK documentation for CHEGVD::

 CHEGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_chegvd(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, w : [] c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhegvd

Original Fortran LAPACK documentation for ZHEGVD::

 ZHEGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_zhegvd(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, w : [] c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssygvx

Original Fortran LAPACK documentation for SSYGVX::

 SSYGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_ssygvx(ref itype : c_int, ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsygvx

Original Fortran LAPACK documentation for DSYGVX::

 DSYGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_dsygvx(ref itype : c_int, ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chegvx

Original Fortran LAPACK documentation for CHEGVX::

 CHEGVX computes selected eigenvalues, and optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_chegvx(ref itype : c_int, ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhegvx

Original Fortran LAPACK documentation for ZHEGVX::

 ZHEGVX computes selected eigenvalues, and optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_zhegvx(ref itype : c_int, ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspgv

Original Fortran LAPACK documentation for SSPGV::

 SSPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric, stored in packed format,
 and B is also positive definite.

 */
extern proc LAPACK_sspgv(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspgv

Original Fortran LAPACK documentation for DSPGV::

 DSPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric, stored in packed format,
 and B is also positive definite.

 */
extern proc LAPACK_dspgv(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpgv

Original Fortran LAPACK documentation for CHPGV::

 CHPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian, stored in packed format,
 and B is also positive definite.

 */
extern proc LAPACK_chpgv(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpgv

Original Fortran LAPACK documentation for ZHPGV::

 ZHPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian, stored in packed format,
 and B is also positive definite.

 */
extern proc LAPACK_zhpgv(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspgvd

Original Fortran LAPACK documentation for SSPGVD::

 SSPGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_sspgvd(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspgvd

Original Fortran LAPACK documentation for DSPGVD::

 DSPGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_dspgvd(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpgvd

Original Fortran LAPACK documentation for CHPGVD::

 CHPGVD computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_chpgvd(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpgvd

Original Fortran LAPACK documentation for ZHPGVD::

 ZHPGVD computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_zhpgvd(ref itype : c_int, ref jobz : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sspgvx

Original Fortran LAPACK documentation for SSPGVX::

 SSPGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric, stored in packed storage, and B
 is also positive definite. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

 */
extern proc LAPACK_sspgvx(ref itype : c_int, ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_float, bp : [] c_float, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dspgvx

Original Fortran LAPACK documentation for DSPGVX::

 DSPGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric, stored in packed storage, and B
 is also positive definite. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

 */
extern proc LAPACK_dspgvx(ref itype : c_int, ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_double, bp : [] c_double, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chpgvx

Original Fortran LAPACK documentation for CHPGVX::

 CHPGVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite. Eigenvalues and eigenvectors can be selected by
 specifying either a range of values or a range of indices for the
 desired eigenvalues.

 */
extern proc LAPACK_chpgvx(ref itype : c_int, ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(64), bp : [] complex(64), ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhpgvx

Original Fortran LAPACK documentation for ZHPGVX::

 ZHPGVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite. Eigenvalues and eigenvectors can be selected by
 specifying either a range of values or a range of indices for the
 desired eigenvalues.

 */
extern proc LAPACK_zhpgvx(ref itype : c_int, ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(128), bp : [] complex(128), ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssbgv

Original Fortran LAPACK documentation for SSBGV::

 SSBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite.

 */
extern proc LAPACK_ssbgv(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] c_float, ref ldab : c_int, bb : [] c_float, ref ldbb : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsbgv

Original Fortran LAPACK documentation for DSBGV::

 DSBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite.

 */
extern proc LAPACK_dsbgv(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] c_double, ref ldab : c_int, bb : [] c_double, ref ldbb : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chbgv

Original Fortran LAPACK documentation for CHBGV::

 CHBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite.

 */
extern proc LAPACK_chbgv(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] complex(64), ref ldab : c_int, bb : [] complex(64), ref ldbb : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhbgv

Original Fortran LAPACK documentation for ZHBGV::

 ZHBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite.

 */
extern proc LAPACK_zhbgv(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] complex(128), ref ldab : c_int, bb : [] complex(128), ref ldbb : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssbgvd

Original Fortran LAPACK documentation for SSBGVD::

 SSBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of the
 form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and
 banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_ssbgvd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] c_float, ref ldab : c_int, bb : [] c_float, ref ldbb : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsbgvd

Original Fortran LAPACK documentation for DSBGVD::

 DSBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of the
 form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and
 banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_dsbgvd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] c_double, ref ldab : c_int, bb : [] c_double, ref ldbb : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chbgvd

Original Fortran LAPACK documentation for CHBGVD::

 CHBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_chbgvd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] complex(64), ref ldab : c_int, bb : [] complex(64), ref ldbb : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhbgvd

Original Fortran LAPACK documentation for ZHBGVD::

 ZHBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 */
extern proc LAPACK_zhbgvd(ref jobz : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] complex(128), ref ldab : c_int, bb : [] complex(128), ref ldbb : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref lrwork : c_int, iwork : [] c_int, ref liwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssbgvx

Original Fortran LAPACK documentation for SSBGVX::

 SSBGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_ssbgvx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] c_float, ref ldab : c_int, bb : [] c_float, ref ldbb : c_int, q : [] c_float, ref ldq : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ref ldz : c_int, work : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsbgvx

Original Fortran LAPACK documentation for DSBGVX::

 DSBGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_dsbgvx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] c_double, ref ldab : c_int, bb : [] c_double, ref ldbb : c_int, q : [] c_double, ref ldq : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ref ldz : c_int, work : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chbgvx

Original Fortran LAPACK documentation for CHBGVX::

 CHBGVX computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_chbgvx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] complex(64), ref ldab : c_int, bb : [] complex(64), ref ldbb : c_int, q : [] complex(64), ref ldq : c_int, ref vl : c_float, ref vu : c_float, ref il : c_int, ref iu : c_int, ref abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ref ldz : c_int, work : [] complex(64), rwork : [] c_float, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhbgvx

Original Fortran LAPACK documentation for ZHBGVX::

 ZHBGVX computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

 */
extern proc LAPACK_zhbgvx(ref jobz : c_char, ref range : c_char, ref uplo : c_char, ref n : c_int, ref ka : c_int, ref kb : c_int, ab : [] complex(128), ref ldab : c_int, bb : [] complex(128), ref ldbb : c_int, q : [] complex(128), ref ldq : c_int, ref vl : c_double, ref vu : c_double, ref il : c_int, ref iu : c_int, ref abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ref ldz : c_int, work : [] complex(128), rwork : [] c_double, iwork : [] c_int, ifail : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgges

Original Fortran LAPACK documentation for SGGES::

 SGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
 the generalized eigenvalues, the generalized real Schur form (S,T),
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T.The
 leading columns of VSL and VSR then form an orthonormal basis for the
 corresponding left and right eigenspaces (deflating subspaces).

 (If only the generalized eigenvalues are needed, use the driver
 SGGEV instead, which is faster.)

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

 */
extern proc LAPACK_sgges(ref jobvsl : c_char, ref jobvsr : c_char, ref sort : c_char, selctg : LAPACK_S_SELECT3, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ref ldvsl : c_int, vsr : [] c_float, ref ldvsr : c_int, work : [] c_float, ref lwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgges

Original Fortran LAPACK documentation for DGGES::

 DGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
 the generalized eigenvalues, the generalized real Schur form (S,T),
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T.The
 leading columns of VSL and VSR then form an orthonormal basis for the
 corresponding left and right eigenspaces (deflating subspaces).

 (If only the generalized eigenvalues are needed, use the driver
 DGGEV instead, which is faster.)

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

 */
extern proc LAPACK_dgges(ref jobvsl : c_char, ref jobvsr : c_char, ref sort : c_char, selctg : LAPACK_D_SELECT3, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ref ldvsl : c_int, vsr : [] c_double, ref ldvsr : c_int, work : [] c_double, ref lwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgges

Original Fortran LAPACK documentation for CGGES::

 CGGES computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, the generalized complex Schur
 form (S, T), and optionally left and/or right Schur vectors (VSL
 and VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )

 where (VSR)**H is the conjugate-transpose of VSR.

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 triangular matrix S and the upper triangular matrix T. The leading
 columns of VSL and VSR then form an unitary basis for the
 corresponding left and right eigenspaces (deflating subspaces).

 (If only the generalized eigenvalues are needed, use the driver
 CGGEV instead, which is faster.)

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0, and even for both being zero.

 A pair of matrices (S,T) is in generalized complex Schur form if S
 and T are upper triangular and, in addition, the diagonal elements
 of T are non-negative real numbers.

 */
extern proc LAPACK_cgges(ref jobvsl : c_char, ref jobvsr : c_char, ref sort : c_char, selctg : LAPACK_C_SELECT2, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ref ldvsl : c_int, vsr : [] complex(64), ref ldvsr : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgges

Original Fortran LAPACK documentation for ZGGES::

 ZGGES computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, the generalized complex Schur
 form (S, T), and optionally left and/or right Schur vectors (VSL
 and VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )

 where (VSR)**H is the conjugate-transpose of VSR.

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 triangular matrix S and the upper triangular matrix T. The leading
 columns of VSL and VSR then form an unitary basis for the
 corresponding left and right eigenspaces (deflating subspaces).

 (If only the generalized eigenvalues are needed, use the driver
 ZGGEV instead, which is faster.)

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0, and even for both being zero.

 A pair of matrices (S,T) is in generalized complex Schur form if S
 and T are upper triangular and, in addition, the diagonal elements
 of T are non-negative real numbers.

 */
extern proc LAPACK_zgges(ref jobvsl : c_char, ref jobvsr : c_char, ref sort : c_char, selctg : LAPACK_Z_SELECT2, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ref ldvsl : c_int, vsr : [] complex(128), ref ldvsr : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggesx

Original Fortran LAPACK documentation for SGGESX::

 SGGESX computes for a pair of N-by-N real nonsymmetric matrices
 (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T; computes
 a reciprocal condition number for the average of the selected
 eigenvalues (RCONDE); and computes a reciprocal condition number for
 the right and left deflating subspaces corresponding to the selected
 eigenvalues (RCONDV). The leading columns of VSL and VSR then form
 an orthonormal basis for the corresponding left and right eigenspaces
 (deflating subspaces).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or for both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

 */
extern proc LAPACK_sggesx(ref jobvsl : c_char, ref jobvsr : c_char, ref sort : c_char, selctg : LAPACK_S_SELECT3, ref sense : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, ref ldvsl : c_int, vsr : [] c_float, ref ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggesx

Original Fortran LAPACK documentation for DGGESX::

 DGGESX computes for a pair of N-by-N real nonsymmetric matrices
 (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T; computes
 a reciprocal condition number for the average of the selected
 eigenvalues (RCONDE); and computes a reciprocal condition number for
 the right and left deflating subspaces corresponding to the selected
 eigenvalues (RCONDV). The leading columns of VSL and VSR then form
 an orthonormal basis for the corresponding left and right eigenspaces
 (deflating subspaces).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or for both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

 */
extern proc LAPACK_dggesx(ref jobvsl : c_char, ref jobvsr : c_char, ref sort : c_char, selctg : LAPACK_D_SELECT3, ref sense : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, ref ldvsl : c_int, vsr : [] c_double, ref ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref liwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggesx

Original Fortran LAPACK documentation for CGGESX::

 CGGESX computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, the complex Schur form (S,T),
 and, optionally, the left and/or right matrices of Schur vectors (VSL
 and VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )

 where (VSR)**H is the conjugate-transpose of VSR.

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 triangular matrix S and the upper triangular matrix T; computes
 a reciprocal condition number for the average of the selected
 eigenvalues (RCONDE); and computes a reciprocal condition number for
 the right and left deflating subspaces corresponding to the selected
 eigenvalues (RCONDV). The leading columns of VSL and VSR then form
 an orthonormal basis for the corresponding left and right eigenspaces
 (deflating subspaces).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or for both being zero.

 A pair of matrices (S,T) is in generalized complex Schur form if T is
 upper triangular with non-negative diagonal and S is upper
 triangular.

 */
extern proc LAPACK_cggesx(ref jobvsl : c_char, ref jobvsr : c_char, ref sort : c_char, selctg : LAPACK_C_SELECT2, ref sense : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), ref ldvsl : c_int, vsr : [] complex(64), ref ldvsr : c_int, rconde : [] c_float, rcondv : [] c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, iwork : [] c_int, ref liwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggesx

Original Fortran LAPACK documentation for ZGGESX::

 ZGGESX computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, the complex Schur form (S,T),
 and, optionally, the left and/or right matrices of Schur vectors (VSL
 and VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )

 where (VSR)**H is the conjugate-transpose of VSR.

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 triangular matrix S and the upper triangular matrix T; computes
 a reciprocal condition number for the average of the selected
 eigenvalues (RCONDE); and computes a reciprocal condition number for
 the right and left deflating subspaces corresponding to the selected
 eigenvalues (RCONDV). The leading columns of VSL and VSR then form
 an orthonormal basis for the corresponding left and right eigenspaces
 (deflating subspaces).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or for both being zero.

 A pair of matrices (S,T) is in generalized complex Schur form if T is
 upper triangular with non-negative diagonal and S is upper
 triangular.

 */
extern proc LAPACK_zggesx(ref jobvsl : c_char, ref jobvsr : c_char, ref sort : c_char, selctg : LAPACK_Z_SELECT2, ref sense : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), ref ldvsl : c_int, vsr : [] complex(128), ref ldvsr : c_int, rconde : [] c_double, rcondv : [] c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, iwork : [] c_int, ref liwork : c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggev

Original Fortran LAPACK documentation for SGGEV::

 SGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j).

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B .

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACK_sggev(ref jobvl : c_char, ref jobvr : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ref ldvl : c_int, vr : [] c_float, ref ldvr : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggev

Original Fortran LAPACK documentation for DGGEV::

 DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j).

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B .

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACK_dggev(ref jobvl : c_char, ref jobvr : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ref ldvl : c_int, vr : [] c_double, ref ldvr : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggev

Original Fortran LAPACK documentation for CGGEV::

 CGGEV computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, and optionally, the left and/or
 right generalized eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right generalized eigenvector v(j) corresponding to the
 generalized eigenvalue lambda(j) of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j).

 The left generalized eigenvector u(j) corresponding to the
 generalized eigenvalues lambda(j) of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACK_cggev(ref jobvl : c_char, ref jobvr : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ref ldvl : c_int, vr : [] complex(64), ref ldvr : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggev

Original Fortran LAPACK documentation for ZGGEV::

 ZGGEV computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B), the generalized eigenvalues, and optionally, the left and/or
 right generalized eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right generalized eigenvector v(j) corresponding to the
 generalized eigenvalue lambda(j) of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j).

 The left generalized eigenvector u(j) corresponding to the
 generalized eigenvalues lambda(j) of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACK_zggev(ref jobvl : c_char, ref jobvr : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ref ldvl : c_int, vr : [] complex(128), ref ldvr : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sggevx

Original Fortran LAPACK documentation for SGGEVX::

 SGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j) .

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B.

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACK_sggevx(ref balanc : c_char, ref jobvl : c_char, ref jobvr : c_char, ref sense : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, ref ldvl : c_int, vr : [] c_float, ref ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] c_float, ref lwork : c_int, iwork : [] c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dggevx

Original Fortran LAPACK documentation for DGGEVX::

 DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j) .

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B.

 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACK_dggevx(ref balanc : c_char, ref jobvl : c_char, ref jobvr : c_char, ref sense : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, ref ldvl : c_int, vr : [] c_double, ref ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] c_double, ref lwork : c_int, iwork : [] c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cggevx

Original Fortran LAPACK documentation for CGGEVX::

 CGGEVX computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B) the generalized eigenvalues, and optionally, the left and/or
 right generalized eigenvectors.

 Optionally, it also computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies
 A * v(j) = lambda(j) * B * v(j) .
 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies
 u(j)**H * A = lambda(j) * u(j)**H * B.
 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACK_cggevx(ref balanc : c_char, ref jobvl : c_char, ref jobvr : c_char, ref sense : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), ref ldvl : c_int, vr : [] complex(64), ref ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, iwork : [] c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zggevx

Original Fortran LAPACK documentation for ZGGEVX::

 ZGGEVX computes for a pair of N-by-N complex nonsymmetric matrices
 (A,B) the generalized eigenvalues, and optionally, the left and/or
 right generalized eigenvectors.

 Optionally, it also computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies
 A * v(j) = lambda(j) * B * v(j) .
 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies
 u(j)**H * A = lambda(j) * u(j)**H * B.
 where u(j)**H is the conjugate-transpose of u(j).

 */
extern proc LAPACK_zggevx(ref balanc : c_char, ref jobvl : c_char, ref jobvr : c_char, ref sense : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), ref ldvl : c_int, vr : [] complex(128), ref ldvr : c_int, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, iwork : [] c_int, bwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsfrk

Original Fortran LAPACK documentation for DSFRK::

 Level 3 BLAS like routine for C in RFP Format.

 DSFRK performs one of the symmetric rank--k operations

 C := alpha*A*A**T + beta*C,

 or

 C := alpha*A**T*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n symmetric
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

 */
extern proc LAPACK_dsfrk(ref transr : c_char, ref uplo : c_char, ref trans : c_char, ref n : c_int, ref k : c_int, ref alpha : c_double, a : [] c_double, ref lda : c_int, ref beta : c_double, c : [] c_double) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssfrk

Original Fortran LAPACK documentation for SSFRK::

 Level 3 BLAS like routine for C in RFP Format.

 SSFRK performs one of the symmetric rank--k operations

 C := alpha*A*A**T + beta*C,

 or

 C := alpha*A**T*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n symmetric
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

 */
extern proc LAPACK_ssfrk(ref transr : c_char, ref uplo : c_char, ref trans : c_char, ref n : c_int, ref k : c_int, ref alpha : c_float, a : [] c_float, ref lda : c_int, ref beta : c_float, c : [] c_float) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhfrk

Original Fortran LAPACK documentation for ZHFRK::

 Level 3 BLAS like routine for C in RFP Format.

 ZHFRK performs one of the Hermitian rank--k operations

 C := alpha*A*A**H + beta*C,

 or

 C := alpha*A**H*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n Hermitian
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

 */
extern proc LAPACK_zhfrk(ref transr : c_char, ref uplo : c_char, ref trans : c_char, ref n : c_int, ref k : c_int, ref alpha : c_double, a : [] complex(128), ref lda : c_int, ref beta : c_double, c : [] complex(128)) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chfrk

Original Fortran LAPACK documentation for CHFRK::

 Level 3 BLAS like routine for C in RFP Format.

 CHFRK performs one of the Hermitian rank--k operations

 C := alpha*A*A**H + beta*C,

 or

 C := alpha*A**H*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n Hermitian
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

 */
extern proc LAPACK_chfrk(ref transr : c_char, ref uplo : c_char, ref trans : c_char, ref n : c_int, ref k : c_int, ref alpha : c_float, a : [] complex(64), ref lda : c_int, ref beta : c_float, c : [] complex(64)) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtfsm

Original Fortran LAPACK documentation for DTFSM::

 Level 3 BLAS like routine for A in RFP Format.

 DTFSM solves the matrix equation

 op( A )*X = alpha*B or X*op( A ) = alpha*B

 where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 non-unit, upper or lower triangular matrix and op( A ) is one of

 op( A ) = A or op( A ) = A**T.

 A is in Rectangular Full Packed (RFP) Format.

 The matrix X is overwritten on B.

 */
extern proc LAPACK_dtfsm(ref transr : c_char, ref side : c_char, ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref m : c_int, ref n : c_int, ref alpha : c_double, a : [] c_double, b : [] c_double, ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stfsm

Original Fortran LAPACK documentation for STFSM::

 Level 3 BLAS like routine for A in RFP Format.

 STFSM solves the matrix equation

 op( A )*X = alpha*B or X*op( A ) = alpha*B

 where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 non-unit, upper or lower triangular matrix and op( A ) is one of

 op( A ) = A or op( A ) = A**T.

 A is in Rectangular Full Packed (RFP) Format.

 The matrix X is overwritten on B.

 */
extern proc LAPACK_stfsm(ref transr : c_char, ref side : c_char, ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref m : c_int, ref n : c_int, ref alpha : c_float, a : [] c_float, b : [] c_float, ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztfsm

Original Fortran LAPACK documentation for ZTFSM::

 Level 3 BLAS like routine for A in RFP Format.

 ZTFSM solves the matrix equation

 op( A )*X = alpha*B or X*op( A ) = alpha*B

 where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 non-unit, upper or lower triangular matrix and op( A ) is one of

 op( A ) = A or op( A ) = A**H.

 A is in Rectangular Full Packed (RFP) Format.

 The matrix X is overwritten on B.

 */
extern proc LAPACK_ztfsm(ref transr : c_char, ref side : c_char, ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref m : c_int, ref n : c_int, ref alpha : complex(128), a : [] complex(128), b : [] complex(128), ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctfsm

Original Fortran LAPACK documentation for CTFSM::

 Level 3 BLAS like routine for A in RFP Format.

 CTFSM solves the matrix equation

 op( A )*X = alpha*B or X*op( A ) = alpha*B

 where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 non-unit, upper or lower triangular matrix and op( A ) is one of

 op( A ) = A or op( A ) = A**H.

 A is in Rectangular Full Packed (RFP) Format.

 The matrix X is overwritten on B.

 */
extern proc LAPACK_ctfsm(ref transr : c_char, ref side : c_char, ref uplo : c_char, ref trans : c_char, ref diag : c_char, ref m : c_int, ref n : c_int, ref alpha : complex(64), a : [] complex(64), b : [] complex(64), ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtfttp

Original Fortran LAPACK documentation for DTFTTP::

 DTFTTP copies a triangular matrix A from rectangular full packed
 format (TF) to standard packed format (TP).

 */
extern proc LAPACK_dtfttp(ref transr : c_char, ref uplo : c_char, ref n : c_int, arf : [] c_double, ap : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stfttp

Original Fortran LAPACK documentation for STFTTP::

 STFTTP copies a triangular matrix A from rectangular full packed
 format (TF) to standard packed format (TP).

 */
extern proc LAPACK_stfttp(ref transr : c_char, ref uplo : c_char, ref n : c_int, arf : [] c_float, ap : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztfttp

Original Fortran LAPACK documentation for ZTFTTP::

 ZTFTTP copies a triangular matrix A from rectangular full packed
 format (TF) to standard packed format (TP).

 */
extern proc LAPACK_ztfttp(ref transr : c_char, ref uplo : c_char, ref n : c_int, arf : [] complex(128), ap : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctfttp

Original Fortran LAPACK documentation for CTFTTP::

 CTFTTP copies a triangular matrix A from rectangular full packed
 format (TF) to standard packed format (TP).

 */
extern proc LAPACK_ctfttp(ref transr : c_char, ref uplo : c_char, ref n : c_int, arf : [] complex(64), ap : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtfttr

Original Fortran LAPACK documentation for DTFTTR::

 DTFTTR copies a triangular matrix A from rectangular full packed
 format (TF) to standard full format (TR).

 */
extern proc LAPACK_dtfttr(ref transr : c_char, ref uplo : c_char, ref n : c_int, arf : [] c_double, a : [] c_double, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stfttr

Original Fortran LAPACK documentation for STFTTR::

 STFTTR copies a triangular matrix A from rectangular full packed
 format (TF) to standard full format (TR).

 */
extern proc LAPACK_stfttr(ref transr : c_char, ref uplo : c_char, ref n : c_int, arf : [] c_float, a : [] c_float, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztfttr

Original Fortran LAPACK documentation for ZTFTTR::

 ZTFTTR copies a triangular matrix A from rectangular full packed
 format (TF) to standard full format (TR).

 */
extern proc LAPACK_ztfttr(ref transr : c_char, ref uplo : c_char, ref n : c_int, arf : [] complex(128), a : [] complex(128), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctfttr

Original Fortran LAPACK documentation for CTFTTR::

 CTFTTR copies a triangular matrix A from rectangular full packed
 format (TF) to standard full format (TR).

 */
extern proc LAPACK_ctfttr(ref transr : c_char, ref uplo : c_char, ref n : c_int, arf : [] complex(64), a : [] complex(64), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtpttf

Original Fortran LAPACK documentation for DTPTTF::

 DTPTTF copies a triangular matrix A from standard packed format (TP)
 to rectangular full packed format (TF).

 */
extern proc LAPACK_dtpttf(ref transr : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_double, arf : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stpttf

Original Fortran LAPACK documentation for STPTTF::

 STPTTF copies a triangular matrix A from standard packed format (TP)
 to rectangular full packed format (TF).

 */
extern proc LAPACK_stpttf(ref transr : c_char, ref uplo : c_char, ref n : c_int, ap : [] c_float, arf : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztpttf

Original Fortran LAPACK documentation for ZTPTTF::

 ZTPTTF copies a triangular matrix A from standard packed format (TP)
 to rectangular full packed format (TF).

 */
extern proc LAPACK_ztpttf(ref transr : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(128), arf : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctpttf

Original Fortran LAPACK documentation for CTPTTF::

 CTPTTF copies a triangular matrix A from standard packed format (TP)
 to rectangular full packed format (TF).

 */
extern proc LAPACK_ctpttf(ref transr : c_char, ref uplo : c_char, ref n : c_int, ap : [] complex(64), arf : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtpttr

Original Fortran LAPACK documentation for DTPTTR::

 DTPTTR copies a triangular matrix A from standard packed format (TP)
 to standard full format (TR).

 */
extern proc LAPACK_dtpttr(ref uplo : c_char, ref n : c_int, ap : [] c_double, a : [] c_double, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stpttr

Original Fortran LAPACK documentation for STPTTR::

 STPTTR copies a triangular matrix A from standard packed format (TP)
 to standard full format (TR).

 */
extern proc LAPACK_stpttr(ref uplo : c_char, ref n : c_int, ap : [] c_float, a : [] c_float, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztpttr

Original Fortran LAPACK documentation for ZTPTTR::

 ZTPTTR copies a triangular matrix A from standard packed format (TP)
 to standard full format (TR).

 */
extern proc LAPACK_ztpttr(ref uplo : c_char, ref n : c_int, ap : [] complex(128), a : [] complex(128), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctpttr

Original Fortran LAPACK documentation for CTPTTR::

 CTPTTR copies a triangular matrix A from standard packed format (TP)
 to standard full format (TR).

 */
extern proc LAPACK_ctpttr(ref uplo : c_char, ref n : c_int, ap : [] complex(64), a : [] complex(64), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrttf

Original Fortran LAPACK documentation for DTRTTF::

 DTRTTF copies a triangular matrix A from standard full format (TR)
 to rectangular full packed format (TF) .

 */
extern proc LAPACK_dtrttf(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, arf : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strttf

Original Fortran LAPACK documentation for STRTTF::

 STRTTF copies a triangular matrix A from standard full format (TR)
 to rectangular full packed format (TF) .

 */
extern proc LAPACK_strttf(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, arf : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrttf

Original Fortran LAPACK documentation for ZTRTTF::

 ZTRTTF copies a triangular matrix A from standard full format (TR)
 to rectangular full packed format (TF) .

 */
extern proc LAPACK_ztrttf(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, arf : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrttf

Original Fortran LAPACK documentation for CTRTTF::

 CTRTTF copies a triangular matrix A from standard full format (TR)
 to rectangular full packed format (TF) .

 */
extern proc LAPACK_ctrttf(ref transr : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, arf : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtrttp

Original Fortran LAPACK documentation for DTRTTP::

 DTRTTP copies a triangular matrix A from full format (TR) to standard
 packed format (TP).

 */
extern proc LAPACK_dtrttp(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ap : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_strttp

Original Fortran LAPACK documentation for STRTTP::

 STRTTP copies a triangular matrix A from full format (TR) to standard
 packed format (TP).

 */
extern proc LAPACK_strttp(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ap : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztrttp

Original Fortran LAPACK documentation for ZTRTTP::

 ZTRTTP copies a triangular matrix A from full format (TR) to standard
 packed format (TP).

 */
extern proc LAPACK_ztrttp(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ap : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctrttp

Original Fortran LAPACK documentation for CTRTTP::

 CTRTTP copies a triangular matrix A from full format (TR) to standard
 packed format (TP).

 */
extern proc LAPACK_ctrttp(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ap : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeqrfp

Original Fortran LAPACK documentation for SGEQRFP::

 SGEQRFP computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACK_sgeqrfp(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeqrfp

Original Fortran LAPACK documentation for DGEQRFP::

 DGEQRFP computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACK_dgeqrfp(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeqrfp

Original Fortran LAPACK documentation for CGEQRFP::

 CGEQRFP computes a QR factorization of a complex M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACK_cgeqrfp(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeqrfp

Original Fortran LAPACK documentation for ZGEQRFP::

 ZGEQRFP computes a QR factorization of a complex M-by-N matrix A:
 A = Q * R.

 */
extern proc LAPACK_zgeqrfp(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clacgv

Original Fortran LAPACK documentation for CLACGV::

 CLACGV conjugates a complex vector of length N.

 */
extern proc LAPACK_clacgv(ref n : c_int, x : [] complex(64), ref incx : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlacgv

Original Fortran LAPACK documentation for ZLACGV::

 ZLACGV conjugates a complex vector of length N.

 */
extern proc LAPACK_zlacgv(ref n : c_int, x : [] complex(128), ref incx : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slarnv

Original Fortran LAPACK documentation for SLARNV::

 SLARNV returns a vector of n random real numbers from a uniform or
 normal distribution.

 */
extern proc LAPACK_slarnv(ref idist : c_int, iseed : [] c_int, ref n : c_int, x : [] c_float) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlarnv

Original Fortran LAPACK documentation for DLARNV::

 DLARNV returns a vector of n random real numbers from a uniform or
 normal distribution.

 */
extern proc LAPACK_dlarnv(ref idist : c_int, iseed : [] c_int, ref n : c_int, x : [] c_double) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clarnv

Original Fortran LAPACK documentation for CLARNV::

 CLARNV returns a vector of n random complex numbers from a uniform or
 normal distribution.

 */
extern proc LAPACK_clarnv(ref idist : c_int, iseed : [] c_int, ref n : c_int, x : [] complex(64)) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlarnv

Original Fortran LAPACK documentation for ZLARNV::

 ZLARNV returns a vector of n random complex numbers from a uniform or
 normal distribution.

 */
extern proc LAPACK_zlarnv(ref idist : c_int, iseed : [] c_int, ref n : c_int, x : [] complex(128)) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeqr2

Original Fortran LAPACK documentation for SGEQR2::

 SGEQR2 computes a QR factorization of a real m by n matrix A:
 A = Q * R.

 */
extern proc LAPACK_sgeqr2(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeqr2

Original Fortran LAPACK documentation for DGEQR2::

 DGEQR2 computes a QR factorization of a real m by n matrix A:
 A = Q * R.

 */
extern proc LAPACK_dgeqr2(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeqr2

Original Fortran LAPACK documentation for CGEQR2::

 CGEQR2 computes a QR factorization of a complex m by n matrix A:
 A = Q * R.

 */
extern proc LAPACK_cgeqr2(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeqr2

Original Fortran LAPACK documentation for ZGEQR2::

 ZGEQR2 computes a QR factorization of a complex m by n matrix A:
 A = Q * R.

 */
extern proc LAPACK_zgeqr2(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slacn2

Original Fortran LAPACK documentation for SLACN2::

 SLACN2 estimates the 1-norm of a square, real matrix A.
 Reverse communication is used for evaluating matrix-vector products.

 */
extern proc LAPACK_slacn2(ref n : c_int, v : [] c_float, x : [] c_float, isgn : [] c_int, ref est : c_float, ref kase : c_int, isave : [] c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlacn2

Original Fortran LAPACK documentation for DLACN2::

 DLACN2 estimates the 1-norm of a square, real matrix A.
 Reverse communication is used for evaluating matrix-vector products.

 */
extern proc LAPACK_dlacn2(ref n : c_int, v : [] c_double, x : [] c_double, isgn : [] c_int, ref est : c_double, ref kase : c_int, isave : [] c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clacn2

Original Fortran LAPACK documentation for CLACN2::

 CLACN2 estimates the 1-norm of a square, complex matrix A.
 Reverse communication is used for evaluating matrix-vector products.

 */
extern proc LAPACK_clacn2(ref n : c_int, v : [] complex(64), x : [] complex(64), ref est : c_float, ref kase : c_int, isave : [] c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlacn2

Original Fortran LAPACK documentation for ZLACN2::

 ZLACN2 estimates the 1-norm of a square, complex matrix A.
 Reverse communication is used for evaluating matrix-vector products.

 */
extern proc LAPACK_zlacn2(ref n : c_int, v : [] complex(128), x : [] complex(128), ref est : c_double, ref kase : c_int, isave : [] c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slacpy

Original Fortran LAPACK documentation for SLACPY::

 SLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.

 */
extern proc LAPACK_slacpy(ref uplo : c_char, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlacpy

Original Fortran LAPACK documentation for DLACPY::

 DLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.

 */
extern proc LAPACK_dlacpy(ref uplo : c_char, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clacpy

Original Fortran LAPACK documentation for CLACPY::

 CLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.

 */
extern proc LAPACK_clacpy(ref uplo : c_char, ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlacpy

Original Fortran LAPACK documentation for ZLACPY::

 ZLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.

 */
extern proc LAPACK_zlacpy(ref uplo : c_char, ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clacp2

Original Fortran LAPACK documentation for CLACP2::

 CLACP2 copies all or part of a real two-dimensional matrix A to a
 complex matrix B.

 */
extern proc LAPACK_clacp2(ref uplo : c_char, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, b : [] complex(64), ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlacp2

Original Fortran LAPACK documentation for ZLACP2::

 ZLACP2 copies all or part of a real two-dimensional matrix A to a
 complex matrix B.

 */
extern proc LAPACK_zlacp2(ref uplo : c_char, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, b : [] complex(128), ref ldb : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgetf2

Original Fortran LAPACK documentation for SGETF2::

 SGETF2 computes an LU factorization of a general m-by-n matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 2 BLAS version of the algorithm.

 */
extern proc LAPACK_sgetf2(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgetf2

Original Fortran LAPACK documentation for DGETF2::

 DGETF2 computes an LU factorization of a general m-by-n matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 2 BLAS version of the algorithm.

 */
extern proc LAPACK_dgetf2(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgetf2

Original Fortran LAPACK documentation for CGETF2::

 CGETF2 computes an LU factorization of a general m-by-n matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 2 BLAS version of the algorithm.

 */
extern proc LAPACK_cgetf2(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgetf2

Original Fortran LAPACK documentation for ZGETF2::

 ZGETF2 computes an LU factorization of a general m-by-n matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 2 BLAS version of the algorithm.

 */
extern proc LAPACK_zgetf2(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slaswp

Original Fortran LAPACK documentation for SLASWP::

 SLASWP performs a series of row interchanges on the matrix A.
 One row interchange is initiated for each of rows K1 through K2 of A.

 */
extern proc LAPACK_slaswp(ref n : c_int, a : [] c_float, ref lda : c_int, ref k1 : c_int, ref k2 : c_int, ipiv : [] c_int, ref incx : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlaswp

Original Fortran LAPACK documentation for DLASWP::

 DLASWP performs a series of row interchanges on the matrix A.
 One row interchange is initiated for each of rows K1 through K2 of A.

 */
extern proc LAPACK_dlaswp(ref n : c_int, a : [] c_double, ref lda : c_int, ref k1 : c_int, ref k2 : c_int, ipiv : [] c_int, ref incx : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_claswp

Original Fortran LAPACK documentation for CLASWP::

 CLASWP performs a series of row interchanges on the matrix A.
 One row interchange is initiated for each of rows K1 through K2 of A.

 */
extern proc LAPACK_claswp(ref n : c_int, a : [] complex(64), ref lda : c_int, ref k1 : c_int, ref k2 : c_int, ipiv : [] c_int, ref incx : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlaswp

Original Fortran LAPACK documentation for ZLASWP::

 ZLASWP performs a series of row interchanges on the matrix A.
 One row interchange is initiated for each of rows K1 through K2 of A.

 */
extern proc LAPACK_zlaswp(ref n : c_int, a : [] complex(128), ref lda : c_int, ref k1 : c_int, ref k2 : c_int, ipiv : [] c_int, ref incx : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slange

Original Fortran LAPACK documentation for SLANGE::

 SLANGE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real matrix A.

 */
extern proc LAPACK_slange(ref norm : c_char, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_dlange

Original Fortran LAPACK documentation for DLANGE::

 DLANGE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real matrix A.

 */
extern proc LAPACK_dlange(ref norm : c_char, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_clange

Original Fortran LAPACK documentation for CLANGE::

 CLANGE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex matrix A.

 */
extern proc LAPACK_clange(ref norm : c_char, ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_zlange

Original Fortran LAPACK documentation for ZLANGE::

 ZLANGE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex matrix A.

 */
extern proc LAPACK_zlange(ref norm : c_char, ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_clanhe

Original Fortran LAPACK documentation for CLANHE::

 CLANHE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex hermitian matrix A.

 */
extern proc LAPACK_clanhe(ref norm : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_zlanhe

Original Fortran LAPACK documentation for ZLANHE::

 ZLANHE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex hermitian matrix A.

 */
extern proc LAPACK_zlanhe(ref norm : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_slansy

Original Fortran LAPACK documentation for SLANSY::

 SLANSY returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real symmetric matrix A.

 */
extern proc LAPACK_slansy(ref norm : c_char, ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_dlansy

Original Fortran LAPACK documentation for DLANSY::

 DLANSY returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real symmetric matrix A.

 */
extern proc LAPACK_dlansy(ref norm : c_char, ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_clansy

Original Fortran LAPACK documentation for CLANSY::

 CLANSY returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex symmetric matrix A.

 */
extern proc LAPACK_clansy(ref norm : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_zlansy

Original Fortran LAPACK documentation for ZLANSY::

 ZLANSY returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex symmetric matrix A.

 */
extern proc LAPACK_zlansy(ref norm : c_char, ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_slantr

Original Fortran LAPACK documentation for SLANTR::

 SLANTR returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 trapezoidal or triangular matrix A.

 */
extern proc LAPACK_slantr(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_dlantr

Original Fortran LAPACK documentation for DLANTR::

 DLANTR returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 trapezoidal or triangular matrix A.

 */
extern proc LAPACK_dlantr(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_clantr

Original Fortran LAPACK documentation for CLANTR::

 CLANTR returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 trapezoidal or triangular matrix A.

 */
extern proc LAPACK_clantr(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, work : [] c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_zlantr

Original Fortran LAPACK documentation for ZLANTR::

 ZLANTR returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 trapezoidal or triangular matrix A.

 */
extern proc LAPACK_zlantr(ref norm : c_char, ref uplo : c_char, ref diag : c_char, ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, work : [] c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_slamch
 */
extern proc LAPACK_slamch(ref cmach : c_char) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_dlamch
 */
extern proc LAPACK_dlamch(ref cmach : c_char) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_sgelq2

Original Fortran LAPACK documentation for SGELQ2::

 SGELQ2 computes an LQ factorization of a real m by n matrix A:
 A = L * Q.

 */
extern proc LAPACK_sgelq2(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, tau : [] c_float, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgelq2

Original Fortran LAPACK documentation for DGELQ2::

 DGELQ2 computes an LQ factorization of a real m by n matrix A:
 A = L * Q.

 */
extern proc LAPACK_dgelq2(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, tau : [] c_double, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgelq2

Original Fortran LAPACK documentation for CGELQ2::

 CGELQ2 computes an LQ factorization of a complex m by n matrix A:
 A = L * Q.

 */
extern proc LAPACK_cgelq2(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, tau : [] complex(64), work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgelq2

Original Fortran LAPACK documentation for ZGELQ2::

 ZGELQ2 computes an LQ factorization of a complex m by n matrix A:
 A = L * Q.

 */
extern proc LAPACK_zgelq2(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, tau : [] complex(128), work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slarfb

Original Fortran LAPACK documentation for SLARFB::

 SLARFB applies a real block reflector H or its transpose H**T to a
 real m by n matrix C, from either the left or the right.

 */
extern proc LAPACK_slarfb(ref side : c_char, ref trans : c_char, ref direct : c_char, ref storev : c_char, ref m : c_int, ref n : c_int, ref k : c_int, v : [] c_float, ref ldv : c_int, t : [] c_float, ref ldt : c_int, c : [] c_float, ref ldc : c_int, work : [] c_float, ref ldwork : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlarfb

Original Fortran LAPACK documentation for DLARFB::

 DLARFB applies a real block reflector H or its transpose H**T to a
 real m by n matrix C, from either the left or the right.

 */
extern proc LAPACK_dlarfb(ref side : c_char, ref trans : c_char, ref direct : c_char, ref storev : c_char, ref m : c_int, ref n : c_int, ref k : c_int, v : [] c_double, ref ldv : c_int, t : [] c_double, ref ldt : c_int, c : [] c_double, ref ldc : c_int, work : [] c_double, ref ldwork : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clarfb

Original Fortran LAPACK documentation for CLARFB::

 CLARFB applies a complex block reflector H or its transpose H**H to a
 complex M-by-N matrix C, from either the left or the right.

 */
extern proc LAPACK_clarfb(ref side : c_char, ref trans : c_char, ref direct : c_char, ref storev : c_char, ref m : c_int, ref n : c_int, ref k : c_int, v : [] complex(64), ref ldv : c_int, t : [] complex(64), ref ldt : c_int, c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref ldwork : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlarfb

Original Fortran LAPACK documentation for ZLARFB::

 ZLARFB applies a complex block reflector H or its transpose H**H to a
 complex M-by-N matrix C, from either the left or the right.

 */
extern proc LAPACK_zlarfb(ref side : c_char, ref trans : c_char, ref direct : c_char, ref storev : c_char, ref m : c_int, ref n : c_int, ref k : c_int, v : [] complex(128), ref ldv : c_int, t : [] complex(128), ref ldt : c_int, c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref ldwork : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slarfg

Original Fortran LAPACK documentation for SLARFG::

 SLARFG generates a real elementary reflector H of order n, such
 that

 H * ( alpha ) = ( beta ), H**T * H = I.
 ( x ) ( 0 )

 where alpha and beta are scalars, and x is an (n-1)-element real
 vector. H is represented in the form

 H = I - tau * ( 1 ) * ( 1 v**T ) ,
 ( v )

 where tau is a real scalar and v is a real (n-1)-element
 vector.

 If the elements of x are all zero, then tau = 0 and H is taken to be
 the unit matrix.

 Otherwise 1 <= tau <= 2.

 */
extern proc LAPACK_slarfg(ref n : c_int, ref alpha : c_float, x : [] c_float, ref incx : c_int, ref tau : c_float) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlarfg

Original Fortran LAPACK documentation for DLARFG::

 DLARFG generates a real elementary reflector H of order n, such
 that

 H * ( alpha ) = ( beta ), H**T * H = I.
 ( x ) ( 0 )

 where alpha and beta are scalars, and x is an (n-1)-element real
 vector. H is represented in the form

 H = I - tau * ( 1 ) * ( 1 v**T ) ,
 ( v )

 where tau is a real scalar and v is a real (n-1)-element
 vector.

 If the elements of x are all zero, then tau = 0 and H is taken to be
 the unit matrix.

 Otherwise 1 <= tau <= 2.

 */
extern proc LAPACK_dlarfg(ref n : c_int, ref alpha : c_double, x : [] c_double, ref incx : c_int, ref tau : c_double) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clarfg

Original Fortran LAPACK documentation for CLARFG::

 CLARFG generates a complex elementary reflector H of order n, such
 that

 H**H * ( alpha ) = ( beta ), H**H * H = I.
 ( x ) ( 0 )

 where alpha and beta are scalars, with beta real, and x is an
 (n-1)-element complex vector. H is represented in the form

 H = I - tau * ( 1 ) * ( 1 v**H ) ,
 ( v )

 where tau is a complex scalar and v is a complex (n-1)-element
 vector. Note that H is not hermitian.

 If the elements of x are all zero and alpha is real, then tau = 0
 and H is taken to be the unit matrix.

 Otherwise 1 <= real(tau) <= 2 and abs(tau-1) <= 1 .

 */
extern proc LAPACK_clarfg(ref n : c_int, ref alpha : complex(64), x : [] complex(64), ref incx : c_int, ref tau : complex(64)) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlarfg

Original Fortran LAPACK documentation for ZLARFG::

 ZLARFG generates a complex elementary reflector H of order n, such
 that

 H**H * ( alpha ) = ( beta ), H**H * H = I.
 ( x ) ( 0 )

 where alpha and beta are scalars, with beta real, and x is an
 (n-1)-element complex vector. H is represented in the form

 H = I - tau * ( 1 ) * ( 1 v**H ) ,
 ( v )

 where tau is a complex scalar and v is a complex (n-1)-element
 vector. Note that H is not hermitian.

 If the elements of x are all zero and alpha is real, then tau = 0
 and H is taken to be the unit matrix.

 Otherwise 1 <= real(tau) <= 2 and abs(tau-1) <= 1 .

 */
extern proc LAPACK_zlarfg(ref n : c_int, ref alpha : complex(128), x : [] complex(128), ref incx : c_int, ref tau : complex(128)) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slarft

Original Fortran LAPACK documentation for SLARFT::

 SLARFT forms the triangular factor T of a real block reflector H
 of order n, which is defined as a product of k elementary reflectors.

 If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

 If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

 If STOREV = 'C', the vector which defines the elementary reflector
 H(i) is stored in the i-th column of the array V, and

 H = I - V * T * V**T

 If STOREV = 'R', the vector which defines the elementary reflector
 H(i) is stored in the i-th row of the array V, and

 H = I - V**T * T * V

 */
extern proc LAPACK_slarft(ref direct : c_char, ref storev : c_char, ref n : c_int, ref k : c_int, v : [] c_float, ref ldv : c_int, tau : [] c_float, t : [] c_float, ref ldt : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlarft

Original Fortran LAPACK documentation for DLARFT::

 DLARFT forms the triangular factor T of a real block reflector H
 of order n, which is defined as a product of k elementary reflectors.

 If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

 If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

 If STOREV = 'C', the vector which defines the elementary reflector
 H(i) is stored in the i-th column of the array V, and

 H = I - V * T * V**T

 If STOREV = 'R', the vector which defines the elementary reflector
 H(i) is stored in the i-th row of the array V, and

 H = I - V**T * T * V

 */
extern proc LAPACK_dlarft(ref direct : c_char, ref storev : c_char, ref n : c_int, ref k : c_int, v : [] c_double, ref ldv : c_int, tau : [] c_double, t : [] c_double, ref ldt : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clarft

Original Fortran LAPACK documentation for CLARFT::

 CLARFT forms the triangular factor T of a complex block reflector H
 of order n, which is defined as a product of k elementary reflectors.

 If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

 If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

 If STOREV = 'C', the vector which defines the elementary reflector
 H(i) is stored in the i-th column of the array V, and

 H = I - V * T * V**H

 If STOREV = 'R', the vector which defines the elementary reflector
 H(i) is stored in the i-th row of the array V, and

 H = I - V**H * T * V

 */
extern proc LAPACK_clarft(ref direct : c_char, ref storev : c_char, ref n : c_int, ref k : c_int, v : [] complex(64), ref ldv : c_int, tau : [] complex(64), t : [] complex(64), ref ldt : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlarft

Original Fortran LAPACK documentation for ZLARFT::

 ZLARFT forms the triangular factor T of a complex block reflector H
 of order n, which is defined as a product of k elementary reflectors.

 If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

 If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

 If STOREV = 'C', the vector which defines the elementary reflector
 H(i) is stored in the i-th column of the array V, and

 H = I - V * T * V**H

 If STOREV = 'R', the vector which defines the elementary reflector
 H(i) is stored in the i-th row of the array V, and

 H = I - V**H * T * V

 */
extern proc LAPACK_zlarft(ref direct : c_char, ref storev : c_char, ref n : c_int, ref k : c_int, v : [] complex(128), ref ldv : c_int, tau : [] complex(128), t : [] complex(128), ref ldt : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slarfx

Original Fortran LAPACK documentation for SLARFX::

 SLARFX applies a real elementary reflector H to a real m by n
 matrix C, from either the left or the right. H is represented in the
 form

 H = I - tau * v * v**T

 where tau is a real scalar and v is a real vector.

 If tau = 0, then H is taken to be the unit matrix

 This version uses inline code if H has order < 11.

 */
extern proc LAPACK_slarfx(ref side : c_char, ref m : c_int, ref n : c_int, v : [] c_float, ref tau : c_float, c : [] c_float, ref ldc : c_int, work : [] c_float) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlarfx

Original Fortran LAPACK documentation for DLARFX::

 DLARFX applies a real elementary reflector H to a real m by n
 matrix C, from either the left or the right. H is represented in the
 form

 H = I - tau * v * v**T

 where tau is a real scalar and v is a real vector.

 If tau = 0, then H is taken to be the unit matrix

 This version uses inline code if H has order < 11.

 */
extern proc LAPACK_dlarfx(ref side : c_char, ref m : c_int, ref n : c_int, v : [] c_double, ref tau : c_double, c : [] c_double, ref ldc : c_int, work : [] c_double) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clarfx

Original Fortran LAPACK documentation for CLARFX::

 CLARFX applies a complex elementary reflector H to a complex m by n
 matrix C, from either the left or the right. H is represented in the
 form

 H = I - tau * v * v**H

 where tau is a complex scalar and v is a complex vector.

 If tau = 0, then H is taken to be the unit matrix

 This version uses inline code if H has order < 11.

 */
extern proc LAPACK_clarfx(ref side : c_char, ref m : c_int, ref n : c_int, v : [] complex(64), ref tau : complex(64), c : [] complex(64), ref ldc : c_int, work : [] complex(64)) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlarfx

Original Fortran LAPACK documentation for ZLARFX::

 ZLARFX applies a complex elementary reflector H to a complex m by n
 matrix C, from either the left or the right. H is represented in the
 form

 H = I - tau * v * v**H

 where tau is a complex scalar and v is a complex vector.

 If tau = 0, then H is taken to be the unit matrix

 This version uses inline code if H has order < 11.

 */
extern proc LAPACK_zlarfx(ref side : c_char, ref m : c_int, ref n : c_int, v : [] complex(128), ref tau : complex(128), c : [] complex(128), ref ldc : c_int, work : [] complex(128)) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slatms

Original Fortran LAPACK documentation for SLATMS::

 SLATMS generates random matrices with specified singular values
 (or symmetric/hermitian with specified eigenvalues)
 for testing LAPACK programs.

 SLATMS operates by applying the following sequence of
 operations:

 Set the diagonal to D, where D may be input or
 computed according to MODE, COND, DMAX, and SYM
 as described below.

 Generate a matrix with the appropriate band structure, by one
 of two methods:

 Method A:
 Generate a dense M x N matrix by multiplying D on the left
 and the right by random unitary matrices, then:

 Reduce the bandwidth according to KL and KU, using
 Householder transformations.

 Method B:
 Convert the bandwidth-0 (i.e., diagonal) matrix to a
 bandwidth-1 matrix using Givens rotations, "chasing"
 out-of-band elements back, much as in QR; then
 convert the bandwidth-1 to a bandwidth-2 matrix, etc.
 Note that for reasonably small bandwidths (relative to
 M and N) this requires less storage, as a dense matrix
 is not generated. Also, for symmetric matrices, only
 one triangle is generated.

 Method A is chosen if the bandwidth is a large fraction of the
 order of the matrix, and LDA is at least M (so a dense
 matrix can be stored.) Method B is chosen if the bandwidth
 is small (< 1/2 N for symmetric, < .3 N+M for
 non-symmetric), or LDA is less than M and not less than the
 bandwidth.

 Pack the matrix if desired. Options specified by PACK are:
 no packing
 zero out upper half (if symmetric)
 zero out lower half (if symmetric)
 store the upper half columnwise (if symmetric or upper
 triangular)
 store the lower half columnwise (if symmetric or lower
 triangular)
 store the lower triangle in banded format (if symmetric
 or lower triangular)
 store the upper triangle in banded format (if symmetric
 or upper triangular)
 store the entire matrix in banded format
 If Method B is chosen, and band format is specified, then the
 matrix will be generated in the band format, so no repacking
 will be necessary.

 */
extern proc LAPACK_slatms(ref m : c_int, ref n : c_int, ref dist : c_char, iseed : [] c_int, ref sym : c_char, d : [] c_float, ref mode : c_int, ref cond : c_float, ref dmax : c_float, ref kl : c_int, ref ku : c_int, ref pack : c_char, a : [] c_float, ref lda : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlatms

Original Fortran LAPACK documentation for DLATMS::

 DLATMS generates random matrices with specified singular values
 (or symmetric/hermitian with specified eigenvalues)
 for testing LAPACK programs.

 DLATMS operates by applying the following sequence of
 operations:

 Set the diagonal to D, where D may be input or
 computed according to MODE, COND, DMAX, and SYM
 as described below.

 Generate a matrix with the appropriate band structure, by one
 of two methods:

 Method A:
 Generate a dense M x N matrix by multiplying D on the left
 and the right by random unitary matrices, then:

 Reduce the bandwidth according to KL and KU, using
 Householder transformations.

 Method B:
 Convert the bandwidth-0 (i.e., diagonal) matrix to a
 bandwidth-1 matrix using Givens rotations, "chasing"
 out-of-band elements back, much as in QR; then
 convert the bandwidth-1 to a bandwidth-2 matrix, etc.
 Note that for reasonably small bandwidths (relative to
 M and N) this requires less storage, as a dense matrix
 is not generated. Also, for symmetric matrices, only
 one triangle is generated.

 Method A is chosen if the bandwidth is a large fraction of the
 order of the matrix, and LDA is at least M (so a dense
 matrix can be stored.) Method B is chosen if the bandwidth
 is small (< 1/2 N for symmetric, < .3 N+M for
 non-symmetric), or LDA is less than M and not less than the
 bandwidth.

 Pack the matrix if desired. Options specified by PACK are:
 no packing
 zero out upper half (if symmetric)
 zero out lower half (if symmetric)
 store the upper half columnwise (if symmetric or upper
 triangular)
 store the lower half columnwise (if symmetric or lower
 triangular)
 store the lower triangle in banded format (if symmetric
 or lower triangular)
 store the upper triangle in banded format (if symmetric
 or upper triangular)
 store the entire matrix in banded format
 If Method B is chosen, and band format is specified, then the
 matrix will be generated in the band format, so no repacking
 will be necessary.

 */
extern proc LAPACK_dlatms(ref m : c_int, ref n : c_int, ref dist : c_char, iseed : [] c_int, ref sym : c_char, d : [] c_double, ref mode : c_int, ref cond : c_double, ref dmax : c_double, ref kl : c_int, ref ku : c_int, ref pack : c_char, a : [] c_double, ref lda : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clatms

Original Fortran LAPACK documentation for CLATMS::

 CLATMS generates random matrices with specified singular values
 (or hermitian with specified eigenvalues)
 for testing LAPACK programs.

 CLATMS operates by applying the following sequence of
 operations:

 Set the diagonal to D, where D may be input or
 computed according to MODE, COND, DMAX, and SYM
 as described below.

 Generate a matrix with the appropriate band structure, by one
 of two methods:

 Method A:
 Generate a dense M x N matrix by multiplying D on the left
 and the right by random unitary matrices, then:

 Reduce the bandwidth according to KL and KU, using
 Householder transformations.

 Method B:
 Convert the bandwidth-0 (i.e., diagonal) matrix to a
 bandwidth-1 matrix using Givens rotations, "chasing"
 out-of-band elements back, much as in QR; then convert
 the bandwidth-1 to a bandwidth-2 matrix, etc. Note
 that for reasonably small bandwidths (relative to M and
 N) this requires less storage, as a dense matrix is not
 generated. Also, for hermitian or symmetric matrices,
 only one triangle is generated.

 Method A is chosen if the bandwidth is a large fraction of the
 order of the matrix, and LDA is at least M (so a dense
 matrix can be stored.) Method B is chosen if the bandwidth
 is small (< 1/2 N for hermitian or symmetric, < .3 N+M for
 non-symmetric), or LDA is less than M and not less than the
 bandwidth.

 Pack the matrix if desired. Options specified by PACK are:
 no packing
 zero out upper half (if hermitian)
 zero out lower half (if hermitian)
 store the upper half columnwise (if hermitian or upper
 triangular)
 store the lower half columnwise (if hermitian or lower
 triangular)
 store the lower triangle in banded format (if hermitian or
 lower triangular)
 store the upper triangle in banded format (if hermitian or
 upper triangular)
 store the entire matrix in banded format
 If Method B is chosen, and band format is specified, then the
 matrix will be generated in the band format, so no repacking
 will be necessary.

 */
extern proc LAPACK_clatms(ref m : c_int, ref n : c_int, ref dist : c_char, iseed : [] c_int, ref sym : c_char, d : [] c_float, ref mode : c_int, ref cond : c_float, ref dmax : c_float, ref kl : c_int, ref ku : c_int, ref pack : c_char, a : [] complex(64), ref lda : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlatms

Original Fortran LAPACK documentation for ZLATMS::

 ZLATMS generates random matrices with specified singular values
 (or hermitian with specified eigenvalues)
 for testing LAPACK programs.

 ZLATMS operates by applying the following sequence of
 operations:

 Set the diagonal to D, where D may be input or
 computed according to MODE, COND, DMAX, and SYM
 as described below.

 Generate a matrix with the appropriate band structure, by one
 of two methods:

 Method A:
 Generate a dense M x N matrix by multiplying D on the left
 and the right by random unitary matrices, then:

 Reduce the bandwidth according to KL and KU, using
 Householder transformations.

 Method B:
 Convert the bandwidth-0 (i.e., diagonal) matrix to a
 bandwidth-1 matrix using Givens rotations, "chasing"
 out-of-band elements back, much as in QR; then convert
 the bandwidth-1 to a bandwidth-2 matrix, etc. Note
 that for reasonably small bandwidths (relative to M and
 N) this requires less storage, as a dense matrix is not
 generated. Also, for hermitian or symmetric matrices,
 only one triangle is generated.

 Method A is chosen if the bandwidth is a large fraction of the
 order of the matrix, and LDA is at least M (so a dense
 matrix can be stored.) Method B is chosen if the bandwidth
 is small (< 1/2 N for hermitian or symmetric, < .3 N+M for
 non-symmetric), or LDA is less than M and not less than the
 bandwidth.

 Pack the matrix if desired. Options specified by PACK are:
 no packing
 zero out upper half (if hermitian)
 zero out lower half (if hermitian)
 store the upper half columnwise (if hermitian or upper
 triangular)
 store the lower half columnwise (if hermitian or lower
 triangular)
 store the lower triangle in banded format (if hermitian or
 lower triangular)
 store the upper triangle in banded format (if hermitian or
 upper triangular)
 store the entire matrix in banded format
 If Method B is chosen, and band format is specified, then the
 matrix will be generated in the band format, so no repacking
 will be necessary.

 */
extern proc LAPACK_zlatms(ref m : c_int, ref n : c_int, ref dist : c_char, iseed : [] c_int, ref sym : c_char, d : [] c_double, ref mode : c_int, ref cond : c_double, ref dmax : c_double, ref kl : c_int, ref ku : c_int, ref pack : c_char, a : [] complex(128), ref lda : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slag2d

Original Fortran LAPACK documentation for SLAG2D::

 SLAG2D converts a SINGLE PRECISION matrix, SA, to a DOUBLE
 PRECISION matrix, A.

 Note that while it is possible to overflow while converting
 from double to single, it is not possible to overflow when
 converting from single to double.

 This is an auxiliary routine so there is no argument checking.

 */
extern proc LAPACK_slag2d(ref m : c_int, ref n : c_int, sa : [] c_float, ref ldsa : c_int, a : [] c_double, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlag2s

Original Fortran LAPACK documentation for DLAG2S::

 DLAG2S converts a DOUBLE PRECISION matrix, SA, to a SINGLE
 PRECISION matrix, A.

 RMAX is the overflow for the SINGLE PRECISION arithmetic
 DLAG2S checks that all the entries of A are between -RMAX and
 RMAX. If not the convertion is aborted and a flag is raised.

 This is an auxiliary routine so there is no argument checking.

 */
extern proc LAPACK_dlag2s(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, sa : [] c_float, ref ldsa : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clag2z

Original Fortran LAPACK documentation for CLAG2Z::

 CLAG2Z converts a COMPLEX matrix, SA, to a COMPLEX*16 matrix, A.

 Note that while it is possible to overflow while converting
 from double to single, it is not possible to overflow when
 converting from single to double.

 This is an auxiliary routine so there is no argument checking.

 */
extern proc LAPACK_clag2z(ref m : c_int, ref n : c_int, sa : [] complex(64), ref ldsa : c_int, a : [] complex(128), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlag2c

Original Fortran LAPACK documentation for ZLAG2C::

 ZLAG2C converts a COMPLEX*16 matrix, SA, to a COMPLEX matrix, A.

 RMAX is the overflow for the SINGLE PRECISION arithmetic
 ZLAG2C checks that all the entries of A are between -RMAX and
 RMAX. If not the convertion is aborted and a flag is raised.

 This is an auxiliary routine so there is no argument checking.

 */
extern proc LAPACK_zlag2c(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, sa : [] complex(64), ref ldsa : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slauum

Original Fortran LAPACK documentation for SLAUUM::

 SLAUUM computes the product U * U**T or L**T * L, where the triangular
 factor U or L is stored in the upper or lower triangular part of
 the array A.

 If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
 overwriting the factor U in A.
 If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
 overwriting the factor L in A.

 This is the blocked form of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_slauum(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlauum

Original Fortran LAPACK documentation for DLAUUM::

 DLAUUM computes the product U * U**T or L**T * L, where the triangular
 factor U or L is stored in the upper or lower triangular part of
 the array A.

 If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
 overwriting the factor U in A.
 If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
 overwriting the factor L in A.

 This is the blocked form of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_dlauum(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clauum

Original Fortran LAPACK documentation for CLAUUM::

 CLAUUM computes the product U * U**H or L**H * L, where the triangular
 factor U or L is stored in the upper or lower triangular part of
 the array A.

 If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
 overwriting the factor U in A.
 If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
 overwriting the factor L in A.

 This is the blocked form of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_clauum(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlauum

Original Fortran LAPACK documentation for ZLAUUM::

 ZLAUUM computes the product U * U**H or L**H * L, where the triangular
 factor U or L is stored in the upper or lower triangular part of
 the array A.

 If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
 overwriting the factor U in A.
 If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
 overwriting the factor L in A.

 This is the blocked form of the algorithm, calling Level 3 BLAS.

 */
extern proc LAPACK_zlauum(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slagge

Original Fortran LAPACK documentation for SLAGGE::

 SLAGGE generates a real general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random orthogonal matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional orthogonal transformations.

 */
extern proc LAPACK_slagge(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, d : [] c_float, a : [] c_float, ref lda : c_int, iseed : [] c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlagge

Original Fortran LAPACK documentation for DLAGGE::

 DLAGGE generates a real general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random orthogonal matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional orthogonal transformations.

 */
extern proc LAPACK_dlagge(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, d : [] c_double, a : [] c_double, ref lda : c_int, iseed : [] c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clagge

Original Fortran LAPACK documentation for CLAGGE::

 CLAGGE generates a complex general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random unitary matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional unitary transformations.

 */
extern proc LAPACK_clagge(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, d : [] c_float, a : [] complex(64), ref lda : c_int, iseed : [] c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlagge

Original Fortran LAPACK documentation for ZLAGGE::

 ZLAGGE generates a complex general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random unitary matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional unitary transformations.

 */
extern proc LAPACK_zlagge(ref m : c_int, ref n : c_int, ref kl : c_int, ref ku : c_int, d : [] c_double, a : [] complex(128), ref lda : c_int, iseed : [] c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slaset

Original Fortran LAPACK documentation for SLASET::

 SLASET initializes an m-by-n matrix A to BETA on the diagonal and
 ALPHA on the offdiagonals.

 */
extern proc LAPACK_slaset(ref uplo : c_char, ref m : c_int, ref n : c_int, ref alpha : c_float, ref beta : c_float, a : [] c_float, ref lda : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlaset

Original Fortran LAPACK documentation for DLASET::

 DLASET initializes an m-by-n matrix A to BETA on the diagonal and
 ALPHA on the offdiagonals.

 */
extern proc LAPACK_dlaset(ref uplo : c_char, ref m : c_int, ref n : c_int, ref alpha : c_double, ref beta : c_double, a : [] c_double, ref lda : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_claset

Original Fortran LAPACK documentation for CLASET::

 CLASET initializes a 2-D array A to BETA on the diagonal and
 ALPHA on the offdiagonals.

 */
extern proc LAPACK_claset(ref uplo : c_char, ref m : c_int, ref n : c_int, ref alpha : complex(64), ref beta : complex(64), a : [] complex(64), ref lda : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlaset

Original Fortran LAPACK documentation for ZLASET::

 ZLASET initializes a 2-D array A to BETA on the diagonal and
 ALPHA on the offdiagonals.

 */
extern proc LAPACK_zlaset(ref uplo : c_char, ref m : c_int, ref n : c_int, ref alpha : complex(128), ref beta : complex(128), a : [] complex(128), ref lda : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slasrt

Original Fortran LAPACK documentation for SLASRT::

 Sort the numbers in D in increasing order (if ID = 'I') or
 in decreasing order (if ID = 'D' ).

 Use Quick Sort, reverting to Insertion sort on arrays of
 size <= 20. Dimension of STACK limits N to about 2**32.

 */
extern proc LAPACK_slasrt(ref id : c_char, ref n : c_int, d : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlasrt

Original Fortran LAPACK documentation for DLASRT::

 Sort the numbers in D in increasing order (if ID = 'I') or
 in decreasing order (if ID = 'D' ).

 Use Quick Sort, reverting to Insertion sort on arrays of
 size <= 20. Dimension of STACK limits N to about 2**32.

 */
extern proc LAPACK_dlasrt(ref id : c_char, ref n : c_int, d : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_claghe

Original Fortran LAPACK documentation for CLAGHE::

 CLAGHE generates a complex hermitian matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 unitary transformations.

 */
extern proc LAPACK_claghe(ref n : c_int, ref k : c_int, d : [] c_float, a : [] complex(64), ref lda : c_int, iseed : [] c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlaghe

Original Fortran LAPACK documentation for ZLAGHE::

 ZLAGHE generates a complex hermitian matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 unitary transformations.

 */
extern proc LAPACK_zlaghe(ref n : c_int, ref k : c_int, d : [] c_double, a : [] complex(128), ref lda : c_int, iseed : [] c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slagsy

Original Fortran LAPACK documentation for SLAGSY::

 SLAGSY generates a real symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random orthogonal matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 orthogonal transformations.

 */
extern proc LAPACK_slagsy(ref n : c_int, ref k : c_int, d : [] c_float, a : [] c_float, ref lda : c_int, iseed : [] c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlagsy

Original Fortran LAPACK documentation for DLAGSY::

 DLAGSY generates a real symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random orthogonal matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 orthogonal transformations.

 */
extern proc LAPACK_dlagsy(ref n : c_int, ref k : c_int, d : [] c_double, a : [] c_double, ref lda : c_int, iseed : [] c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clagsy

Original Fortran LAPACK documentation for CLAGSY::

 CLAGSY generates a complex symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U**T. The semi-bandwidth may then be reduced to k by
 additional unitary transformations.

 */
extern proc LAPACK_clagsy(ref n : c_int, ref k : c_int, d : [] c_float, a : [] complex(64), ref lda : c_int, iseed : [] c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlagsy

Original Fortran LAPACK documentation for ZLAGSY::

 ZLAGSY generates a complex symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U**T. The semi-bandwidth may then be reduced to k by
 additional unitary transformations.

 */
extern proc LAPACK_zlagsy(ref n : c_int, ref k : c_int, d : [] c_double, a : [] complex(128), ref lda : c_int, iseed : [] c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slapmr

Original Fortran LAPACK documentation for SLAPMR::

 SLAPMR rearranges the rows of the M by N matrix X as specified
 by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
 If FORWRD = .TRUE., forward permutation:

 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

 If FORWRD = .FALSE., backward permutation:

 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

 */
extern proc LAPACK_slapmr(ref forwrd : c_int, ref m : c_int, ref n : c_int, x : [] c_float, ref ldx : c_int, k : [] c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlapmr

Original Fortran LAPACK documentation for DLAPMR::

 DLAPMR rearranges the rows of the M by N matrix X as specified
 by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
 If FORWRD = .TRUE., forward permutation:

 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

 If FORWRD = .FALSE., backward permutation:

 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

 */
extern proc LAPACK_dlapmr(ref forwrd : c_int, ref m : c_int, ref n : c_int, x : [] c_double, ref ldx : c_int, k : [] c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_clapmr

Original Fortran LAPACK documentation for CLAPMR::

 CLAPMR rearranges the rows of the M by N matrix X as specified
 by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
 If FORWRD = .TRUE., forward permutation:

 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

 If FORWRD = .FALSE., backward permutation:

 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

 */
extern proc LAPACK_clapmr(ref forwrd : c_int, ref m : c_int, ref n : c_int, x : [] complex(64), ref ldx : c_int, k : [] c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zlapmr

Original Fortran LAPACK documentation for ZLAPMR::

 ZLAPMR rearranges the rows of the M by N matrix X as specified
 by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
 If FORWRD = .TRUE., forward permutation:

 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

 If FORWRD = .FALSE., backward permutation:

 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

 */
extern proc LAPACK_zlapmr(ref forwrd : c_int, ref m : c_int, ref n : c_int, x : [] complex(128), ref ldx : c_int, k : [] c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slapy2

Original Fortran LAPACK documentation for SLAPY2::

 SLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
 overflow.

 */
extern proc LAPACK_slapy2(ref x : c_float, ref y : c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_dlapy2

Original Fortran LAPACK documentation for DLAPY2::

 DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
 overflow.

 */
extern proc LAPACK_dlapy2(ref x : c_double, ref y : c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_slapy3

Original Fortran LAPACK documentation for SLAPY3::

 SLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
 unnecessary overflow.

 */
extern proc LAPACK_slapy3(ref x : c_float, ref y : c_float, ref z : c_float) : c_float;

pragma"no doc"
/* 
External Procedure to LAPACK_dlapy3

Original Fortran LAPACK documentation for DLAPY3::

 DLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
 unnecessary overflow.

 */
extern proc LAPACK_dlapy3(ref x : c_double, ref y : c_double, ref z : c_double) : c_double;

pragma"no doc"
/* 
External Procedure to LAPACK_slartgp

Original Fortran LAPACK documentation for SLARTGP::

 SLARTGP generates a plane rotation so that

 [ CS SN ] . [ F ] = [ R ] where CS**2 + SN**2 = 1.
 [ -SN CS ] [ G ] [ 0 ]

 This is a slower, more accurate version of the Level 1 BLAS routine SROTG,
 with the following other differences:
 F and G are unchanged on return.
 If G=0, then CS=(+/-)1 and SN=0.
 If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.

 The sign is chosen so that R >= 0.

 */
extern proc LAPACK_slartgp(ref f : c_float, ref g : c_float, ref cs : c_float, ref sn : c_float, ref r : c_float) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlartgp

Original Fortran LAPACK documentation for DLARTGP::

 DLARTGP generates a plane rotation so that

 [ CS SN ] . [ F ] = [ R ] where CS**2 + SN**2 = 1.
 [ -SN CS ] [ G ] [ 0 ]

 This is a slower, more accurate version of the Level 1 BLAS routine DROTG,
 with the following other differences:
 F and G are unchanged on return.
 If G=0, then CS=(+/-)1 and SN=0.
 If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.

 The sign is chosen so that R >= 0.

 */
extern proc LAPACK_dlartgp(ref f : c_double, ref g : c_double, ref cs : c_double, ref sn : c_double, ref r : c_double) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_slartgs

Original Fortran LAPACK documentation for SLARTGS::

 SLARTGS generates a plane rotation designed to introduce a bulge in
 Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
 problem. X and Y are the top-row entries, and SIGMA is the shift.
 The computed CS and SN define a plane rotation satisfying

 [ CS SN ] . [ X^2 - SIGMA ] = [ R ],
 [ -SN CS ] [ X * Y ] [ 0 ]

 with R nonnegative. If X^2 - SIGMA and X * Y are 0, then the
 rotation is by PI/2.

 */
extern proc LAPACK_slartgs(ref x : c_float, ref y : c_float, ref sigma : c_float, ref cs : c_float, ref sn : c_float) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dlartgs

Original Fortran LAPACK documentation for DLARTGS::

 DLARTGS generates a plane rotation designed to introduce a bulge in
 Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
 problem. X and Y are the top-row entries, and SIGMA is the shift.
 The computed CS and SN define a plane rotation satisfying

 [ CS SN ] . [ X^2 - SIGMA ] = [ R ],
 [ -SN CS ] [ X * Y ] [ 0 ]

 with R nonnegative. If X^2 - SIGMA and X * Y are 0, then the
 rotation is by PI/2.

 */
extern proc LAPACK_dlartgs(ref x : c_double, ref y : c_double, ref sigma : c_double, ref cs : c_double, ref sn : c_double) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cbbcsd

Original Fortran LAPACK documentation for CBBCSD::

 CBBCSD computes the CS decomposition of a unitary matrix in
 bidiagonal-block form,


 [ B11 | B12 0 0 ]
 [ 0 | 0 -I 0 ]
 X = [----------------]
 [ B21 | B22 0 0 ]
 [ 0 | 0 0 I ]

 [ C | -S 0 0 ]
 [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**H
 = [---------] [---------------] [---------] .
 [ | U2 ] [ S | C 0 0 ] [ | V2 ]
 [ 0 | 0 0 I ]

 X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
 than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
 transposed and/or permuted. This can be done in constant time using
 the TRANS and SIGNS options. See CUNCSD for details.)

 The bidiagonal matrices B11, B12, B21, and B22 are represented
 implicitly by angles THETA(1:Q) and PHI(1:Q-1).

 The unitary matrices U1, U2, V1T, and V2T are input/output.
 The input matrices are pre- or post-multiplied by the appropriate
 singular vector matrices.

 */
extern proc LAPACK_cbbcsd(ref jobu1 : c_char, ref jobu2 : c_char, ref jobv1t : c_char, ref jobv2t : c_char, ref trans : c_char, ref m : c_int, ref p : c_int, ref q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] complex(64), ref ldu1 : c_int, u2 : [] complex(64), ref ldu2 : c_int, v1t : [] complex(64), ref ldv1t : c_int, v2t : [] complex(64), ref ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float, rwork : [] c_float, ref lrwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cheswapr

Original Fortran LAPACK documentation for CHESWAPR::

 CHESWAPR applies an elementary permutation on the rows and the columns of
 a hermitian matrix.

 */
extern proc LAPACK_cheswapr(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref i1 : c_int, ref i2 : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chetri2

Original Fortran LAPACK documentation for CHETRI2::

 CHETRI2 computes the inverse of a COMPLEX hermitian indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CHETRF. CHETRI2 set the LEADING DIMENSION of the workspace
 before calling CHETRI2X that actually computes the inverse.

 */
extern proc LAPACK_chetri2(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chetri2x

Original Fortran LAPACK documentation for CHETRI2X::

 CHETRI2X computes the inverse of a complex Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 CHETRF.

 */
extern proc LAPACK_chetri2x(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref nb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_chetrs2

Original Fortran LAPACK documentation for CHETRS2::

 CHETRS2 solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHETRF and converted by CSYCONV.

 */
extern proc LAPACK_chetrs2(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csyconv

Original Fortran LAPACK documentation for CSYCONV::

 CSYCONV convert A given by TRF into L and D and vice-versa.
 Get Non-diag elements of D (returned in workspace) and 
 apply or reverse permutation done in TRF.

 */
extern proc LAPACK_csyconv(ref uplo : c_char, ref way : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csyswapr

Original Fortran LAPACK documentation for CSYSWAPR::

 CSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.

 */
extern proc LAPACK_csyswapr(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref i1 : c_int, ref i2 : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csytri2

Original Fortran LAPACK documentation for CSYTRI2::

 CSYTRI2 computes the inverse of a COMPLEX symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CSYTRF. CSYTRI2 sets the LEADING DIMENSION of the workspace
 before calling CSYTRI2X that actually computes the inverse.

 */
extern proc LAPACK_csytri2(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csytri2x

Original Fortran LAPACK documentation for CSYTRI2X::

 CSYTRI2X computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CSYTRF.

 */
extern proc LAPACK_csytri2x(ref uplo : c_char, ref n : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref nb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csytrs2

Original Fortran LAPACK documentation for CSYTRS2::

 CSYTRS2 solves a system of linear equations A*X = B with a COMPLEX
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by CSYTRF and converted by CSYCONV.

 */
extern proc LAPACK_csytrs2(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cunbdb

Original Fortran LAPACK documentation for CUNBDB::

 CUNBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned unitary matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**H
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See CUNCSD
 for details.)

 The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

 */
extern proc LAPACK_cunbdb(ref trans : c_char, ref signs : c_char, ref m : c_int, ref p : c_int, ref q : c_int, x11 : [] complex(64), ref ldx11 : c_int, x12 : [] complex(64), ref ldx12 : c_int, x21 : [] complex(64), ref ldx21 : c_int, x22 : [] complex(64), ref ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] complex(64), taup2 : [] complex(64), tauq1 : [] complex(64), tauq2 : [] complex(64), work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cuncsd

Original Fortran LAPACK documentation for CUNCSD::

 CUNCSD computes the CS decomposition of an M-by-M partitioned
 unitary matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**H
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

 */
extern proc LAPACK_cuncsd(ref jobu1 : c_char, ref jobu2 : c_char, ref jobv1t : c_char, ref jobv2t : c_char, ref trans : c_char, ref signs : c_char, ref m : c_int, ref p : c_int, ref q : c_int, x11 : [] complex(64), ref ldx11 : c_int, x12 : [] complex(64), ref ldx12 : c_int, x21 : [] complex(64), ref ldx21 : c_int, x22 : [] complex(64), ref ldx22 : c_int, theta : [] c_float, u1 : [] complex(64), ref ldu1 : c_int, u2 : [] complex(64), ref ldu2 : c_int, v1t : [] complex(64), ref ldv1t : c_int, v2t : [] complex(64), ref ldv2t : c_int, work : [] complex(64), ref lwork : c_int, rwork : [] c_float, ref lrwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dbbcsd

Original Fortran LAPACK documentation for DBBCSD::

 DBBCSD computes the CS decomposition of an orthogonal matrix in
 bidiagonal-block form,


 [ B11 | B12 0 0 ]
 [ 0 | 0 -I 0 ]
 X = [----------------]
 [ B21 | B22 0 0 ]
 [ 0 | 0 0 I ]

 [ C | -S 0 0 ]
 [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**T
 = [---------] [---------------] [---------] .
 [ | U2 ] [ S | C 0 0 ] [ | V2 ]
 [ 0 | 0 0 I ]

 X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
 than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
 transposed and/or permuted. This can be done in constant time using
 the TRANS and SIGNS options. See DORCSD for details.)

 The bidiagonal matrices B11, B12, B21, and B22 are represented
 implicitly by angles THETA(1:Q) and PHI(1:Q-1).

 The orthogonal matrices U1, U2, V1T, and V2T are input/output.
 The input matrices are pre- or post-multiplied by the appropriate
 singular vector matrices.

 */
extern proc LAPACK_dbbcsd(ref jobu1 : c_char, ref jobu2 : c_char, ref jobv1t : c_char, ref jobv2t : c_char, ref trans : c_char, ref m : c_int, ref p : c_int, ref q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] c_double, ref ldu1 : c_int, u2 : [] c_double, ref ldu2 : c_int, v1t : [] c_double, ref ldv1t : c_int, v2t : [] c_double, ref ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dorbdb

Original Fortran LAPACK documentation for DORBDB::

 DORBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned orthogonal matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**T
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See DORCSD
 for details.)

 The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

 */
extern proc LAPACK_dorbdb(ref trans : c_char, ref signs : c_char, ref m : c_int, ref p : c_int, ref q : c_int, x11 : [] c_double, ref ldx11 : c_int, x12 : [] c_double, ref ldx12 : c_int, x21 : [] c_double, ref ldx21 : c_int, x22 : [] c_double, ref ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] c_double, taup2 : [] c_double, tauq1 : [] c_double, tauq2 : [] c_double, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dorcsd

Original Fortran LAPACK documentation for DORCSD::

 DORCSD computes the CS decomposition of an M-by-M partitioned
 orthogonal matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**T
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

 */
extern proc LAPACK_dorcsd(ref jobu1 : c_char, ref jobu2 : c_char, ref jobv1t : c_char, ref jobv2t : c_char, ref trans : c_char, ref signs : c_char, ref m : c_int, ref p : c_int, ref q : c_int, x11 : [] c_double, ref ldx11 : c_int, x12 : [] c_double, ref ldx12 : c_int, x21 : [] c_double, ref ldx21 : c_int, x22 : [] c_double, ref ldx22 : c_int, theta : [] c_double, u1 : [] c_double, ref ldu1 : c_int, u2 : [] c_double, ref ldu2 : c_int, v1t : [] c_double, ref ldv1t : c_int, v2t : [] c_double, ref ldv2t : c_int, work : [] c_double, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsyconv

Original Fortran LAPACK documentation for DSYCONV::

 DSYCONV convert A given by TRF into L and D and vice-versa.
 Get Non-diag elements of D (returned in workspace) and 
 apply or reverse permutation done in TRF.

 */
extern proc LAPACK_dsyconv(ref uplo : c_char, ref way : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsyswapr

Original Fortran LAPACK documentation for DSYSWAPR::

 DSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.

 */
extern proc LAPACK_dsyswapr(ref uplo : c_char, ref n : c_int, a : [] c_double, ref i1 : c_int, ref i2 : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsytri2

Original Fortran LAPACK documentation for DSYTRI2::

 DSYTRI2 computes the inverse of a DOUBLE PRECISION symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 DSYTRF. DSYTRI2 sets the LEADING DIMENSION of the workspace
 before calling DSYTRI2X that actually computes the inverse.

 */
extern proc LAPACK_dsytri2(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsytri2x

Original Fortran LAPACK documentation for DSYTRI2X::

 DSYTRI2X computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 DSYTRF.

 */
extern proc LAPACK_dsytri2x(ref uplo : c_char, ref n : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, work : [] c_double, ref nb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsytrs2

Original Fortran LAPACK documentation for DSYTRS2::

 DSYTRS2 solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by DSYTRF and converted by DSYCONV.

 */
extern proc LAPACK_dsytrs2(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sbbcsd

Original Fortran LAPACK documentation for SBBCSD::

 SBBCSD computes the CS decomposition of an orthogonal matrix in
 bidiagonal-block form,


 [ B11 | B12 0 0 ]
 [ 0 | 0 -I 0 ]
 X = [----------------]
 [ B21 | B22 0 0 ]
 [ 0 | 0 0 I ]

 [ C | -S 0 0 ]
 [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**T
 = [---------] [---------------] [---------] .
 [ | U2 ] [ S | C 0 0 ] [ | V2 ]
 [ 0 | 0 0 I ]

 X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
 than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
 transposed and/or permuted. This can be done in constant time using
 the TRANS and SIGNS options. See SORCSD for details.)

 The bidiagonal matrices B11, B12, B21, and B22 are represented
 implicitly by angles THETA(1:Q) and PHI(1:Q-1).

 The orthogonal matrices U1, U2, V1T, and V2T are input/output.
 The input matrices are pre- or post-multiplied by the appropriate
 singular vector matrices.

 */
extern proc LAPACK_sbbcsd(ref jobu1 : c_char, ref jobu2 : c_char, ref jobv1t : c_char, ref jobv2t : c_char, ref trans : c_char, ref m : c_int, ref p : c_int, ref q : c_int, theta : [] c_float, phi : [] c_float, u1 : [] c_float, ref ldu1 : c_int, u2 : [] c_float, ref ldu2 : c_int, v1t : [] c_float, ref ldv1t : c_int, v2t : [] c_float, ref ldv2t : c_int, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sorbdb

Original Fortran LAPACK documentation for SORBDB::

 SORBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned orthogonal matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**T
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See SORCSD
 for details.)

 The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

 */
extern proc LAPACK_sorbdb(ref trans : c_char, ref signs : c_char, ref m : c_int, ref p : c_int, ref q : c_int, x11 : [] c_float, ref ldx11 : c_int, x12 : [] c_float, ref ldx12 : c_int, x21 : [] c_float, ref ldx21 : c_int, x22 : [] c_float, ref ldx22 : c_int, theta : [] c_float, phi : [] c_float, taup1 : [] c_float, taup2 : [] c_float, tauq1 : [] c_float, tauq2 : [] c_float, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sorcsd

Original Fortran LAPACK documentation for SORCSD::

 SORCSD computes the CS decomposition of an M-by-M partitioned
 orthogonal matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**T
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

 */
extern proc LAPACK_sorcsd(ref jobu1 : c_char, ref jobu2 : c_char, ref jobv1t : c_char, ref jobv2t : c_char, ref trans : c_char, ref signs : c_char, ref m : c_int, ref p : c_int, ref q : c_int, x11 : [] c_float, ref ldx11 : c_int, x12 : [] c_float, ref ldx12 : c_int, x21 : [] c_float, ref ldx21 : c_int, x22 : [] c_float, ref ldx22 : c_int, theta : [] c_float, u1 : [] c_float, ref ldu1 : c_int, u2 : [] c_float, ref ldu2 : c_int, v1t : [] c_float, ref ldv1t : c_int, v2t : [] c_float, ref ldv2t : c_int, work : [] c_float, ref lwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssyconv

Original Fortran LAPACK documentation for SSYCONV::

 SSYCONV convert A given by TRF into L and D and vice-versa.
 Get Non-diag elements of D (returned in workspace) and 
 apply or reverse permutation done in TRF.

 */
extern proc LAPACK_ssyconv(ref uplo : c_char, ref way : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssyswapr

Original Fortran LAPACK documentation for SSYSWAPR::

 SSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.

 */
extern proc LAPACK_ssyswapr(ref uplo : c_char, ref n : c_int, a : [] c_float, ref i1 : c_int, ref i2 : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssytri2

Original Fortran LAPACK documentation for SSYTRI2::

 SSYTRI2 computes the inverse of a REAL symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 SSYTRF. SSYTRI2 sets the LEADING DIMENSION of the workspace
 before calling SSYTRI2X that actually computes the inverse.

 */
extern proc LAPACK_ssytri2(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssytri2x

Original Fortran LAPACK documentation for SSYTRI2X::

 SSYTRI2X computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 SSYTRF.

 */
extern proc LAPACK_ssytri2x(ref uplo : c_char, ref n : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, work : [] c_float, ref nb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssytrs2

Original Fortran LAPACK documentation for SSYTRS2::

 SSYTRS2 solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by SSYTRF and converted by SSYCONV.

 */
extern proc LAPACK_ssytrs2(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zbbcsd

Original Fortran LAPACK documentation for ZBBCSD::

 ZBBCSD computes the CS decomposition of a unitary matrix in
 bidiagonal-block form,


 [ B11 | B12 0 0 ]
 [ 0 | 0 -I 0 ]
 X = [----------------]
 [ B21 | B22 0 0 ]
 [ 0 | 0 0 I ]

 [ C | -S 0 0 ]
 [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**H
 = [---------] [---------------] [---------] .
 [ | U2 ] [ S | C 0 0 ] [ | V2 ]
 [ 0 | 0 0 I ]

 X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
 than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
 transposed and/or permuted. This can be done in constant time using
 the TRANS and SIGNS options. See ZUNCSD for details.)

 The bidiagonal matrices B11, B12, B21, and B22 are represented
 implicitly by angles THETA(1:Q) and PHI(1:Q-1).

 The unitary matrices U1, U2, V1T, and V2T are input/output.
 The input matrices are pre- or post-multiplied by the appropriate
 singular vector matrices.

 */
extern proc LAPACK_zbbcsd(ref jobu1 : c_char, ref jobu2 : c_char, ref jobv1t : c_char, ref jobv2t : c_char, ref trans : c_char, ref m : c_int, ref p : c_int, ref q : c_int, theta : [] c_double, phi : [] c_double, u1 : [] complex(128), ref ldu1 : c_int, u2 : [] complex(128), ref ldu2 : c_int, v1t : [] complex(128), ref ldv1t : c_int, v2t : [] complex(128), ref ldv2t : c_int, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double, rwork : [] c_double, ref lrwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zheswapr

Original Fortran LAPACK documentation for ZHESWAPR::

 ZHESWAPR applies an elementary permutation on the rows and the columns of
 a hermitian matrix.

 */
extern proc LAPACK_zheswapr(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref i1 : c_int, ref i2 : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhetri2

Original Fortran LAPACK documentation for ZHETRI2::

 ZHETRI2 computes the inverse of a COMPLEX*16 hermitian indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 ZHETRF. ZHETRI2 set the LEADING DIMENSION of the workspace
 before calling ZHETRI2X that actually computes the inverse.

 */
extern proc LAPACK_zhetri2(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhetri2x

Original Fortran LAPACK documentation for ZHETRI2X::

 ZHETRI2X computes the inverse of a COMPLEX*16 Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 ZHETRF.

 */
extern proc LAPACK_zhetri2x(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref nb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zhetrs2

Original Fortran LAPACK documentation for ZHETRS2::

 ZHETRS2 solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by ZHETRF and converted by ZSYCONV.

 */
extern proc LAPACK_zhetrs2(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsyconv

Original Fortran LAPACK documentation for ZSYCONV::

 ZSYCONV converts A given by ZHETRF into L and D or vice-versa.
 Get nondiagonal elements of D (returned in workspace) and 
 apply or reverse permutation done in TRF.

 */
extern proc LAPACK_zsyconv(ref uplo : c_char, ref way : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsyswapr

Original Fortran LAPACK documentation for ZSYSWAPR::

 ZSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.

 */
extern proc LAPACK_zsyswapr(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref i1 : c_int, ref i2 : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsytri2

Original Fortran LAPACK documentation for ZSYTRI2::

 ZSYTRI2 computes the inverse of a COMPLEX*16 symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 ZSYTRF. ZSYTRI2 sets the LEADING DIMENSION of the workspace
 before calling ZSYTRI2X that actually computes the inverse.

 */
extern proc LAPACK_zsytri2(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsytri2x

Original Fortran LAPACK documentation for ZSYTRI2X::

 ZSYTRI2X computes the inverse of a complex symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 ZSYTRF.

 */
extern proc LAPACK_zsytri2x(ref uplo : c_char, ref n : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, work : [] complex(128), ref nb : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsytrs2

Original Fortran LAPACK documentation for ZSYTRS2::

 ZSYTRS2 solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by ZSYTRF and converted by ZSYCONV.

 */
extern proc LAPACK_zsytrs2(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zunbdb

Original Fortran LAPACK documentation for ZUNBDB::

 ZUNBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned unitary matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**H
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See ZUNCSD
 for details.)

 The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

 */
extern proc LAPACK_zunbdb(ref trans : c_char, ref signs : c_char, ref m : c_int, ref p : c_int, ref q : c_int, x11 : [] complex(128), ref ldx11 : c_int, x12 : [] complex(128), ref ldx12 : c_int, x21 : [] complex(128), ref ldx21 : c_int, x22 : [] complex(128), ref ldx22 : c_int, theta : [] c_double, phi : [] c_double, taup1 : [] complex(128), taup2 : [] complex(128), tauq1 : [] complex(128), tauq2 : [] complex(128), work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zuncsd

Original Fortran LAPACK documentation for ZUNCSD::

 ZUNCSD computes the CS decomposition of an M-by-M partitioned
 unitary matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**H
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

 */
extern proc LAPACK_zuncsd(ref jobu1 : c_char, ref jobu2 : c_char, ref jobv1t : c_char, ref jobv2t : c_char, ref trans : c_char, ref signs : c_char, ref m : c_int, ref p : c_int, ref q : c_int, x11 : [] complex(128), ref ldx11 : c_int, x12 : [] complex(128), ref ldx12 : c_int, x21 : [] complex(128), ref ldx21 : c_int, x22 : [] complex(128), ref ldx22 : c_int, theta : [] c_double, u1 : [] complex(128), ref ldu1 : c_int, u2 : [] complex(128), ref ldu2 : c_int, v1t : [] complex(128), ref ldv1t : c_int, v2t : [] complex(128), ref ldv2t : c_int, work : [] complex(128), ref lwork : c_int, rwork : [] c_double, ref lrwork : c_int, iwork : [] c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgemqrt

Original Fortran LAPACK documentation for SGEMQRT::

 SGEMQRT overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q C C Q
 TRANS = 'T': Q**T C C Q**T

 where Q is a real orthogonal matrix defined as the product of K
 elementary reflectors:

 Q = H(1) H(2) . . . H(K) = I - V T V**T

 generated using the compact WY representation as returned by SGEQRT. 

 Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.

 */
extern proc LAPACK_sgemqrt(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref nb : c_int, v : [] c_float, ref ldv : c_int, t : [] c_float, ref ldt : c_int, c : [] c_float, ref ldc : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgemqrt

Original Fortran LAPACK documentation for DGEMQRT::

 DGEMQRT overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q C C Q
 TRANS = 'T': Q**T C C Q**T

 where Q is a real orthogonal matrix defined as the product of K
 elementary reflectors:

 Q = H(1) H(2) . . . H(K) = I - V T V**T

 generated using the compact WY representation as returned by DGEQRT. 

 Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.

 */
extern proc LAPACK_dgemqrt(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref nb : c_int, v : [] c_double, ref ldv : c_int, t : [] c_double, ref ldt : c_int, c : [] c_double, ref ldc : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgemqrt

Original Fortran LAPACK documentation for CGEMQRT::

 CGEMQRT overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q C C Q
 TRANS = 'C': Q**H C C Q**H

 where Q is a complex orthogonal matrix defined as the product of K
 elementary reflectors:

 Q = H(1) H(2) . . . H(K) = I - V T V**H

 generated using the compact WY representation as returned by CGEQRT. 

 Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.

 */
extern proc LAPACK_cgemqrt(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref nb : c_int, v : [] complex(64), ref ldv : c_int, t : [] complex(64), ref ldt : c_int, c : [] complex(64), ref ldc : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgemqrt

Original Fortran LAPACK documentation for ZGEMQRT::

 ZGEMQRT overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q C C Q
 TRANS = 'C': Q**H C C Q**H

 where Q is a complex orthogonal matrix defined as the product of K
 elementary reflectors:

 Q = H(1) H(2) . . . H(K) = I - V T V**H

 generated using the compact WY representation as returned by ZGEQRT. 

 Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.

 */
extern proc LAPACK_zgemqrt(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref nb : c_int, v : [] complex(128), ref ldv : c_int, t : [] complex(128), ref ldt : c_int, c : [] complex(128), ref ldc : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeqrt

Original Fortran LAPACK documentation for SGEQRT::

 SGEQRT computes a blocked QR factorization of a real M-by-N matrix A
 using the compact WY representation of Q.

 */
extern proc LAPACK_sgeqrt(ref m : c_int, ref n : c_int, ref nb : c_int, a : [] c_float, ref lda : c_int, t : [] c_float, ref ldt : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeqrt

Original Fortran LAPACK documentation for DGEQRT::

 DGEQRT computes a blocked QR factorization of a real M-by-N matrix A
 using the compact WY representation of Q.

 */
extern proc LAPACK_dgeqrt(ref m : c_int, ref n : c_int, ref nb : c_int, a : [] c_double, ref lda : c_int, t : [] c_double, ref ldt : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeqrt

Original Fortran LAPACK documentation for CGEQRT::

 CGEQRT computes a blocked QR factorization of a complex M-by-N matrix A
 using the compact WY representation of Q.

 */
extern proc LAPACK_cgeqrt(ref m : c_int, ref n : c_int, ref nb : c_int, a : [] complex(64), ref lda : c_int, t : [] complex(64), ref ldt : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeqrt

Original Fortran LAPACK documentation for ZGEQRT::

 ZGEQRT computes a blocked QR factorization of a complex M-by-N matrix A
 using the compact WY representation of Q.

 */
extern proc LAPACK_zgeqrt(ref m : c_int, ref n : c_int, ref nb : c_int, a : [] complex(128), ref lda : c_int, t : [] complex(128), ref ldt : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeqrt2

Original Fortran LAPACK documentation for SGEQRT2::

 SGEQRT2 computes a QR factorization of a real M-by-N matrix A, 
 using the compact WY representation of Q.

 */
extern proc LAPACK_sgeqrt2(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, t : [] c_float, ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeqrt2

Original Fortran LAPACK documentation for DGEQRT2::

 DGEQRT2 computes a QR factorization of a real M-by-N matrix A, 
 using the compact WY representation of Q.

 */
extern proc LAPACK_dgeqrt2(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, t : [] c_double, ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeqrt2

Original Fortran LAPACK documentation for CGEQRT2::

 CGEQRT2 computes a QR factorization of a complex M-by-N matrix A, 
 using the compact WY representation of Q.

 */
extern proc LAPACK_cgeqrt2(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, t : [] complex(64), ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeqrt2

Original Fortran LAPACK documentation for ZGEQRT2::

 ZGEQRT2 computes a QR factorization of a complex M-by-N matrix A, 
 using the compact WY representation of Q.

 */
extern proc LAPACK_zgeqrt2(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, t : [] complex(128), ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_sgeqrt3

Original Fortran LAPACK documentation for SGEQRT3::

 SGEQRT3 recursively computes a QR factorization of a real M-by-N 
 matrix A, using the compact WY representation of Q. 

 Based on the algorithm of Elmroth and Gustavson, 
 IBM J. Res. Develop. Vol 44 No. 4 July 2000.

 */
extern proc LAPACK_sgeqrt3(ref m : c_int, ref n : c_int, a : [] c_float, ref lda : c_int, t : [] c_float, ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dgeqrt3

Original Fortran LAPACK documentation for DGEQRT3::

 DGEQRT3 recursively computes a QR factorization of a real M-by-N 
 matrix A, using the compact WY representation of Q. 

 Based on the algorithm of Elmroth and Gustavson, 
 IBM J. Res. Develop. Vol 44 No. 4 July 2000.

 */
extern proc LAPACK_dgeqrt3(ref m : c_int, ref n : c_int, a : [] c_double, ref lda : c_int, t : [] c_double, ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_cgeqrt3

Original Fortran LAPACK documentation for CGEQRT3::

 CGEQRT3 recursively computes a QR factorization of a complex M-by-N matrix A, 
 using the compact WY representation of Q. 

 Based on the algorithm of Elmroth and Gustavson, 
 IBM J. Res. Develop. Vol 44 No. 4 July 2000.

 */
extern proc LAPACK_cgeqrt3(ref m : c_int, ref n : c_int, a : [] complex(64), ref lda : c_int, t : [] complex(64), ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zgeqrt3

Original Fortran LAPACK documentation for ZGEQRT3::

 ZGEQRT3 recursively computes a QR factorization of a complex M-by-N 
 matrix A, using the compact WY representation of Q. 

 Based on the algorithm of Elmroth and Gustavson, 
 IBM J. Res. Develop. Vol 44 No. 4 July 2000.

 */
extern proc LAPACK_zgeqrt3(ref m : c_int, ref n : c_int, a : [] complex(128), ref lda : c_int, t : [] complex(128), ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stpmqrt

Original Fortran LAPACK documentation for STPMQRT::

 STPMQRT applies a real orthogonal matrix Q obtained from a 
 "triangular-pentagonal" real block reflector H to a general
 real matrix C, which consists of two blocks A and B.

 */
extern proc LAPACK_stpmqrt(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, ref nb : c_int, v : [] c_float, ref ldv : c_int, t : [] c_float, ref ldt : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, work : [] c_float, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtpmqrt

Original Fortran LAPACK documentation for DTPMQRT::

 DTPMQRT applies a real orthogonal matrix Q obtained from a 
 "triangular-pentagonal" real block reflector H to a general
 real matrix C, which consists of two blocks A and B.

 */
extern proc LAPACK_dtpmqrt(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, ref nb : c_int, v : [] c_double, ref ldv : c_int, t : [] c_double, ref ldt : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctpmqrt

Original Fortran LAPACK documentation for CTPMQRT::

 CTPMQRT applies a complex orthogonal matrix Q obtained from a 
 "triangular-pentagonal" complex block reflector H to a general
 complex matrix C, which consists of two blocks A and B.

 */
extern proc LAPACK_ctpmqrt(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, ref nb : c_int, v : [] complex(64), ref ldv : c_int, t : [] complex(64), ref ldt : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztpmqrt

Original Fortran LAPACK documentation for ZTPMQRT::

 ZTPMQRT applies a complex orthogonal matrix Q obtained from a 
 "triangular-pentagonal" complex block reflector H to a general
 complex matrix C, which consists of two blocks A and B.

 */
extern proc LAPACK_ztpmqrt(ref side : c_char, ref trans : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, ref nb : c_int, v : [] complex(128), ref ldv : c_int, t : [] complex(128), ref ldt : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtpqrt

Original Fortran LAPACK documentation for DTPQRT::

 DTPQRT computes a blocked QR factorization of a real 
 "triangular-pentagonal" matrix C, which is composed of a 
 triangular block A and pentagonal block B, using the compact 
 WY representation for Q.

 */
extern proc LAPACK_dtpqrt(ref m : c_int, ref n : c_int, ref l : c_int, ref nb : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, t : [] c_double, ref ldt : c_int, work : [] c_double, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctpqrt

Original Fortran LAPACK documentation for CTPQRT::

 CTPQRT computes a blocked QR factorization of a complex 
 "triangular-pentagonal" matrix C, which is composed of a 
 triangular block A and pentagonal block B, using the compact 
 WY representation for Q.

 */
extern proc LAPACK_ctpqrt(ref m : c_int, ref n : c_int, ref l : c_int, ref nb : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, t : [] complex(64), ref ldt : c_int, work : [] complex(64), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztpqrt

Original Fortran LAPACK documentation for ZTPQRT::

 ZTPQRT computes a blocked QR factorization of a complex 
 "triangular-pentagonal" matrix C, which is composed of a 
 triangular block A and pentagonal block B, using the compact 
 WY representation for Q.

 */
extern proc LAPACK_ztpqrt(ref m : c_int, ref n : c_int, ref l : c_int, ref nb : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, t : [] complex(128), ref ldt : c_int, work : [] complex(128), ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stpqrt2

Original Fortran LAPACK documentation for STPQRT2::

 STPQRT2 computes a QR factorization of a real "triangular-pentagonal"
 matrix C, which is composed of a triangular block A and pentagonal block B, 
 using the compact WY representation for Q.

 */
extern proc LAPACK_stpqrt2(ref m : c_int, ref n : c_int, ref l : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, t : [] c_float, ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtpqrt2

Original Fortran LAPACK documentation for DTPQRT2::

 DTPQRT2 computes a QR factorization of a real "triangular-pentagonal"
 matrix C, which is composed of a triangular block A and pentagonal block B, 
 using the compact WY representation for Q.

 */
extern proc LAPACK_dtpqrt2(ref m : c_int, ref n : c_int, ref l : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, t : [] c_double, ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctpqrt2

Original Fortran LAPACK documentation for CTPQRT2::

 CTPQRT2 computes a QR factorization of a complex "triangular-pentagonal"
 matrix C, which is composed of a triangular block A and pentagonal block B, 
 using the compact WY representation for Q.

 */
extern proc LAPACK_ctpqrt2(ref m : c_int, ref n : c_int, ref l : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, t : [] complex(64), ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztpqrt2

Original Fortran LAPACK documentation for ZTPQRT2::

 ZTPQRT2 computes a QR factorization of a complex "triangular-pentagonal"
 matrix C, which is composed of a triangular block A and pentagonal block B, 
 using the compact WY representation for Q.

 */
extern proc LAPACK_ztpqrt2(ref m : c_int, ref n : c_int, ref l : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, t : [] complex(128), ref ldt : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_stprfb

Original Fortran LAPACK documentation for STPRFB::

 STPRFB applies a real "triangular-pentagonal" block reflector H or its 
 conjugate transpose H^H to a real matrix C, which is composed of two 
 blocks A and B, either from the left or right.

 */
extern proc LAPACK_stprfb(ref side : c_char, ref trans : c_char, ref direct : c_char, ref storev : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, v : [] c_float, ref ldv : c_int, t : [] c_float, ref ldt : c_int, a : [] c_float, ref lda : c_int, b : [] c_float, ref ldb : c_int, work : [] c_float, ref ldwork : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dtprfb

Original Fortran LAPACK documentation for DTPRFB::

 DTPRFB applies a real "triangular-pentagonal" block reflector H or its 
 transpose H**T to a real matrix C, which is composed of two 
 blocks A and B, either from the left or right.

 */
extern proc LAPACK_dtprfb(ref side : c_char, ref trans : c_char, ref direct : c_char, ref storev : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, v : [] c_double, ref ldv : c_int, t : [] c_double, ref ldt : c_int, a : [] c_double, ref lda : c_int, b : [] c_double, ref ldb : c_int, work : [] c_double, ref ldwork : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ctprfb

Original Fortran LAPACK documentation for CTPRFB::

 CTPRFB applies a complex "triangular-pentagonal" block reflector H or its 
 conjugate transpose H**H to a complex matrix C, which is composed of two 
 blocks A and B, either from the left or right.

 */
extern proc LAPACK_ctprfb(ref side : c_char, ref trans : c_char, ref direct : c_char, ref storev : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, v : [] complex(64), ref ldv : c_int, t : [] complex(64), ref ldt : c_int, a : [] complex(64), ref lda : c_int, b : [] complex(64), ref ldb : c_int, work : [] c_float, ref ldwork : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ztprfb

Original Fortran LAPACK documentation for ZTPRFB::

 ZTPRFB applies a complex "triangular-pentagonal" block reflector H or its 
 conjugate transpose H**H to a complex matrix C, which is composed of two 
 blocks A and B, either from the left or right.

 */
extern proc LAPACK_ztprfb(ref side : c_char, ref trans : c_char, ref direct : c_char, ref storev : c_char, ref m : c_int, ref n : c_int, ref k : c_int, ref l : c_int, v : [] complex(128), ref ldv : c_int, t : [] complex(128), ref ldt : c_int, a : [] complex(128), ref lda : c_int, b : [] complex(128), ref ldb : c_int, work : [] c_double, ref ldwork : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ssysv_rook

Original Fortran LAPACK documentation for SSYSV_ROOK::

 SSYSV_ROOK computes the solution to a real system of linear
 equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 SSYTRF_ROOK is called to compute the factorization of a real
 symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
 pivoting method.

 The factored form of A is then used to solve the system 
 of equations A * X = B by calling SSYTRS_ROOK.

 */
extern proc LAPACK_ssysv_rook(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_float, ref lda : c_int, ipiv : [] c_int, b : [] c_float, ref ldb : c_int, work : [] c_float, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_dsysv_rook

Original Fortran LAPACK documentation for DSYSV_ROOK::

 DSYSV_ROOK computes the solution to a real system of linear
 equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 DSYTRF_ROOK is called to compute the factorization of a real
 symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
 pivoting method.

 The factored form of A is then used to solve the system 
 of equations A * X = B by calling DSYTRS_ROOK.

 */
extern proc LAPACK_dsysv_rook(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] c_double, ref lda : c_int, ipiv : [] c_int, b : [] c_double, ref ldb : c_int, work : [] c_double, ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csysv_rook

Original Fortran LAPACK documentation for CSYSV_ROOK::

 CSYSV_ROOK computes the solution to a complex system of linear
 equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. 

 CSYTRF_ROOK is called to compute the factorization of a complex
 symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
 pivoting method.

 The factored form of A is then used to solve the system 
 of equations A * X = B by calling CSYTRS_ROOK.

 */
extern proc LAPACK_csysv_rook(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(64), ref lda : c_int, ipiv : [] c_int, b : [] complex(64), ref ldb : c_int, work : [] complex(64), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsysv_rook

Original Fortran LAPACK documentation for ZSYSV_ROOK::

 ZSYSV_ROOK computes the solution to a complex system of linear
 equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. 

 ZSYTRF_ROOK is called to compute the factorization of a complex
 symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
 pivoting method.

 The factored form of A is then used to solve the system 
 of equations A * X = B by calling ZSYTRS_ROOK.

 */
extern proc LAPACK_zsysv_rook(ref uplo : c_char, ref n : c_int, ref nrhs : c_int, a : [] complex(128), ref lda : c_int, ipiv : [] c_int, b : [] complex(128), ref ldb : c_int, work : [] complex(128), ref lwork : c_int, ref info : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_csyr

Original Fortran LAPACK documentation for CSYR::

 CSYR performs the symmetric rank 1 operation

 A := alpha*x*x**H + A,

 where alpha is a complex scalar, x is an n element vector and A is an
 n by n symmetric matrix.

 */
extern proc LAPACK_csyr(ref uplo : c_char, ref n : c_int, ref alpha : complex(64), x : [] complex(64), ref incx : c_int, a : [] complex(64), ref lda : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_zsyr

Original Fortran LAPACK documentation for ZSYR::

 ZSYR performs the symmetric rank 1 operation

 A := alpha*x*x**H + A,

 where alpha is a complex scalar, x is an n element vector and A is an
 n by n symmetric matrix.

 */
extern proc LAPACK_zsyr(ref uplo : c_char, ref n : c_int, ref alpha : complex(128), x : [] complex(128), ref incx : c_int, a : [] complex(128), ref lda : c_int) : c_void_ptr;

pragma"no doc"
/* 
External Procedure to LAPACK_ilaver

Original Fortran LAPACK documentation for ILAVER::

 This subroutine returns the LAPACK version.

 */
extern proc LAPACK_ilaver(ref vers_major : c_int, ref vers_minor : c_int, ref vers_patch : c_int) : c_void_ptr;

} // LAPACK 
