/*

Chapel idiomatic wrappers for the LAPACK library.

Consult the :mod:`LAPACK` module, which defines all the types and enumerations that this module uses, and demonstrates compiling with LAPACK binaries.
Also consult the :mod:`LAPACK` module for details pertaining to the pure LAPACK procedures that it provides.

Differences from LAPACK
-----------------------

The `XYYZZZ <http://www.netlib.org/lapack/individualroutines.html>`_ naming convention for procedures has been only slightly modified with the removal of the type identifier in the procedure name,
creating a set of polymorphic procedures under the name YYZZZ.

Procedure arguments have been simplified. 
Using the original Fortran documentation, groupings of arguments pertaining to matrices and arrays were found, and encapsulated by Chapel arrays.

For example, instead of 

.. code-block:: chapel

  LAPACKE_sgesv(matrix_order : lapack_memory_order, n : c_int, nrhs : c_int, a : [] c_float, lda : c_int, ipiv : [] c_int, b : [] c_float, ldb : c_int) : c_int;

the arguments n, nrhs, lda, and ldb can be encapsulated by properties of Chapel arrays and their domains, giving the ChaLAPACK procedure:

.. code-block:: chapel

  gesv(matrix_order : lapack_memory_order, a : [] c_float, ipiv : [] c_int, b : [] c_float): c_int;

This requires that your matrices are stored in a two dimensional form.

ChaLAPACK Procedures
--------------------

*/
module ChaLAPACK {
use "lapacke.h";
use SysCTypes;

use LAPACK;
/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sbdsdc for the type c_float.

Original Fortran LAPACK purpose documentation for SBDSDC::

 SBDSDC computes the singular value decomposition (SVD) of a real
 N-by-N (upper or lower) bidiagonal matrix B: B = U * S * VT,
 using a divide and conquer method, where S is a diagonal matrix
 with non-negative diagonal elements (the singular values of B), and
 U and VT are orthogonal matrices of left and right singular vectors,
 respectively. SBDSDC can be used to compute all singular values,
 and optionally, singular vectors or singular vectors in compact form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See SLASD3 for details.

 The code currently calls SLASDQ if singular values only are desired.
 However, it can be slightly modified to compute singular values
 using the divide and conquer method.

Original Fortran LAPACK argument documentation for SBDSDC::

 UPLO is CHARACTER*1
  = 'U': B is upper bidiagonal.
  = 'L': B is lower bidiagonal.

 COMPQ is CHARACTER*1
  Specifies whether singular vectors are to be computed
  as follows:
  = 'N': Compute singular values only;
  = 'P': Compute singular values and compute singular
  vectors in compact form;
  = 'I': Compute singular values and singular vectors.

 N is INTEGER
  The order of the matrix B. N >= 0.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the bidiagonal matrix B.
  On exit, if INFO=0, the singular values of B.

 E is REAL array, dimension (N-1)
  On entry, the elements of E contain the offdiagonal
  elements of the bidiagonal matrix whose SVD is desired.
  On exit, E has been destroyed.

 U is REAL array, dimension (LDU,N)
  If COMPQ = 'I', then:
  On exit, if INFO = 0, U contains the left singular vectors
  of the bidiagonal matrix.
  For other values of COMPQ, U is not referenced.

 VT is REAL array, dimension (LDVT,N)
  If COMPQ = 'I', then:
  On exit, if INFO = 0, VT**T contains the right singular
  vectors of the bidiagonal matrix.
  For other values of COMPQ, VT is not referenced.

 Q is REAL array, dimension (LDQ)
  If COMPQ = 'P', then:
  On exit, if INFO = 0, Q and IQ contain the left
  and right singular vectors in a compact form,
  requiring O(N log N) space instead of 2*N**2.
  In particular, Q contains all the REAL data in
  LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
  words of memory, where SMLSIZ is returned by ILAENV and
  is equal to the maximum size of the subproblems at the
  bottom of the computation tree (usually about 25).
  For other values of COMPQ, Q is not referenced.

 IQ is INTEGER array, dimension (LDIQ)
  If COMPQ = 'P', then:
  On exit, if INFO = 0, Q and IQ contain the left
  and right singular vectors in a compact form,
  requiring O(N log N) space instead of 2*N**2.
  In particular, IQ contains all INTEGER data in
  LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
  words of memory, where SMLSIZ is returned by ILAENV and
  is equal to the maximum size of the subproblems at the
  bottom of the computation tree (usually about 25).
  For other values of COMPQ, IQ is not referenced.

 */
inline proc bdsdc(matrix_order : lapack_memory_order, uplo : string, compq : string, n : c_int, d : [] c_float, e : [] c_float, u : [] c_float, vt : [] c_float, q : [] c_float, iq : [] c_int): c_int{
  return LAPACKE_sbdsdc(matrix_order, ascii(uplo) : c_char, ascii(compq) : c_char, n, d, e, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int, q, iq);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dbdsdc for the type c_double.

For more information, see the documentation for :proc:`bdsdc`, or consult the Netlibs or Intel documentation.
 */
inline proc bdsdc(matrix_order : lapack_memory_order, uplo : string, compq : string, n : c_int, d : [] c_double, e : [] c_double, u : [] c_double, vt : [] c_double, q : [] c_double, iq : [] c_int): c_int{
  return LAPACKE_dbdsdc(matrix_order, ascii(uplo) : c_char, ascii(compq) : c_char, n, d, e, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int, q, iq);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sbdsqr for the type c_float.

Original Fortran LAPACK purpose documentation for SBDSQR::

 SBDSQR computes the singular values and, optionally, the right and/or
 left singular vectors from the singular value decomposition (SVD) of
 a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
 zero-shift QR algorithm. The SVD of B has the form
 
 B = Q * S * P**T
 
 where S is the diagonal matrix of singular values, Q is an orthogonal
 matrix of left singular vectors, and P is an orthogonal matrix of
 right singular vectors. If left singular vectors are requested, this
 subroutine actually returns U*Q instead of Q, and, if right singular
 vectors are requested, this subroutine returns P**T*VT instead of
 P**T, for given real input matrices U and VT. When U and VT are the
 orthogonal matrices that reduce a general matrix A to bidiagonal
 form: A = U*B*VT, as computed by SGEBRD, then
 
 A = (U*Q) * S * (P**T*VT)
 
 is the SVD of A. Optionally, the subroutine may also compute Q**T*C
 for a given real input matrix C.

 See "Computing Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
 no. 5, pp. 873-912, Sept 1990) and
 "Accurate singular values and differential qd algorithms," by
 B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
 Department, University of California at Berkeley, July 1992
 for a detailed description of the algorithm.

Original Fortran LAPACK argument documentation for SBDSQR::

 UPLO is CHARACTER*1
  = 'U': B is upper bidiagonal;
  = 'L': B is lower bidiagonal.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the bidiagonal matrix B.
  On exit, if INFO=0, the singular values of B in decreasing
  order.

 E is REAL array, dimension (N-1)
  On entry, the N-1 offdiagonal elements of the bidiagonal
  matrix B.
  On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
  will contain the diagonal and superdiagonal elements of a
  bidiagonal matrix orthogonally equivalent to the one given
  as input.

 VT is REAL array, dimension (LDVT, NCVT)
  On entry, an N-by-NCVT matrix VT.
  On exit, VT is overwritten by P**T * VT.
  Not referenced if NCVT = 0.

 U is REAL array, dimension (LDU, N)
  On entry, an NRU-by-N matrix U.
  On exit, U is overwritten by U * Q.
  Not referenced if NRU = 0.

 C is REAL array, dimension (LDC, NCC)
  On entry, an N-by-NCC matrix C.
  On exit, C is overwritten by Q**T * C.
  Not referenced if NCC = 0.

 */
inline proc bdsqr(matrix_order : lapack_memory_order, uplo : string, d : [] c_float, e : [] c_float, vt : [] c_float, u : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sbdsqr(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then vt.domain.dim(2).size else vt.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then u.domain.dim(1).size else u.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, d, e, vt, (vt.domain.dim(2).size) : c_int, u, (u.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dbdsqr for the type c_double.

For more information, see the documentation for :proc:`bdsqr`, or consult the Netlibs or Intel documentation.
 */
inline proc bdsqr(matrix_order : lapack_memory_order, uplo : string, d : [] c_double, e : [] c_double, vt : [] c_double, u : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dbdsqr(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then vt.domain.dim(2).size else vt.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then u.domain.dim(1).size else u.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, d, e, vt, (vt.domain.dim(2).size) : c_int, u, (u.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cbdsqr for the type lapack_complex_float.

For more information, see the documentation for :proc:`bdsqr`, or consult the Netlibs or Intel documentation.
 */
inline proc bdsqr(matrix_order : lapack_memory_order, uplo : string, d : [] c_float, e : [] c_float, vt : [] complex(64), u : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cbdsqr(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then vt.domain.dim(2).size else vt.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then u.domain.dim(1).size else u.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, d, e, vt, (vt.domain.dim(2).size) : c_int, u, (u.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zbdsqr for the type lapack_complex_double.

For more information, see the documentation for :proc:`bdsqr`, or consult the Netlibs or Intel documentation.
 */
inline proc bdsqr(matrix_order : lapack_memory_order, uplo : string, d : [] c_double, e : [] c_double, vt : [] complex(128), u : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zbdsqr(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then vt.domain.dim(2).size else vt.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then u.domain.dim(1).size else u.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, d, e, vt, (vt.domain.dim(2).size) : c_int, u, (u.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sdisna for the type c_float.

Original Fortran LAPACK purpose documentation for SDISNA::

 SDISNA computes the reciprocal condition numbers for the eigenvectors
 of a real symmetric or complex Hermitian matrix or for the left or
 right singular vectors of a general m-by-n matrix. The reciprocal
 condition number is the 'gap' between the corresponding eigenvalue or
 singular value and the nearest other one.

 The bound on the error, measured by angle in radians, in the I-th
 computed vector is given by

 SLAMCH( 'E' ) * ( ANORM / SEP( I ) )

 where ANORM = 2-norm(A) = max( abs( D(j) ) ). SEP(I) is not allowed
 to be smaller than SLAMCH( 'E' )*ANORM in order to limit the size of
 the error bound.

 SDISNA may also be used to compute error bounds for eigenvectors of
 the generalized symmetric definite eigenproblem.

Original Fortran LAPACK argument documentation for SDISNA::

 JOB is CHARACTER*1
  Specifies for which problem the reciprocal condition numbers
  should be computed:
  = 'E': the eigenvectors of a symmetric/Hermitian matrix;
  = 'L': the left singular vectors of a general matrix;
  = 'R': the right singular vectors of a general matrix.

 M is INTEGER
  The number of rows of the matrix. M >= 0.

 N is INTEGER
  If JOB = 'L' or 'R', the number of columns of the matrix,
  in which case N >= 0. Ignored if JOB = 'E'.

 D is REAL array, dimension (M) if JOB = 'E'
  dimension (min(M,N)) if JOB = 'L' or 'R'
  The eigenvalues (if JOB = 'E') or singular values (if JOB =
  'L' or 'R') of the matrix, in either increasing or decreasing
  order. If singular values, they must be non-negative.

 SEP is REAL array, dimension (M) if JOB = 'E'
  dimension (min(M,N)) if JOB = 'L' or 'R'
  The reciprocal condition numbers of the vectors.

 */
inline proc disna(job : string, m : c_int, n : c_int, d : [] c_float, sep : [] c_float): c_int{
  return LAPACKE_sdisna(ascii(job) : c_char, m, n, d, sep);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ddisna for the type c_double.

For more information, see the documentation for :proc:`disna`, or consult the Netlibs or Intel documentation.
 */
inline proc disna(job : string, m : c_int, n : c_int, d : [] c_double, sep : [] c_double): c_int{
  return LAPACKE_ddisna(ascii(job) : c_char, m, n, d, sep);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbbrd for the type c_float.

Original Fortran LAPACK purpose documentation for SGBBRD::

 SGBBRD reduces a real general m-by-n band matrix A to upper
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 The routine computes B, and optionally forms Q or P**T, or computes
 Q**T*C for a given matrix C.

Original Fortran LAPACK argument documentation for SGBBRD::

 VECT is CHARACTER*1
  Specifies whether or not the matrices Q and P**T are to be
  formed.
  = 'N': do not form Q or P**T;
  = 'Q': form Q only;
  = 'P': form P**T only;
  = 'B': form both.

 N is INTEGER
  The number of columns of the matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals of the matrix A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals of the matrix A. KU >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the m-by-n band matrix A, stored in rows 1 to
  KL+KU+1. The j-th column of A is stored in the j-th column of
  the array AB as follows:
  AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
  On exit, A is overwritten by values generated during the
  reduction.

 D is REAL array, dimension (min(M,N))
  The diagonal elements of the bidiagonal matrix B.

 E is REAL array, dimension (min(M,N)-1)
  The superdiagonal elements of the bidiagonal matrix B.

 Q is REAL array, dimension (LDQ,M)
  If VECT = 'Q' or 'B', the m-by-m orthogonal matrix Q.
  If VECT = 'N' or 'P', the array Q is not referenced.

 PT is REAL array, dimension (LDPT,N)
  If VECT = 'P' or 'B', the n-by-n orthogonal matrix P'.
  If VECT = 'N' or 'Q', the array PT is not referenced.

 C is REAL array, dimension (LDC,NCC)
  On entry, an m-by-ncc matrix C.
  On exit, C is overwritten by Q**T*C.
  C is not referenced if NCC = 0.

 */
inline proc gbbrd(matrix_order : lapack_memory_order, vect : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, d : [] c_float, e : [] c_float, q : [] c_float, pt : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sgbbrd(matrix_order, ascii(vect) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, n, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, kl, ku, ab, (ab.domain.dim(2).size) : c_int, d, e, q, (q.domain.dim(2).size) : c_int, pt, (pt.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbbrd for the type c_double.

For more information, see the documentation for :proc:`gbbrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gbbrd(matrix_order : lapack_memory_order, vect : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, d : [] c_double, e : [] c_double, q : [] c_double, pt : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dgbbrd(matrix_order, ascii(vect) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, n, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, kl, ku, ab, (ab.domain.dim(2).size) : c_int, d, e, q, (q.domain.dim(2).size) : c_int, pt, (pt.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbbrd for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbbrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gbbrd(matrix_order : lapack_memory_order, vect : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), d : [] c_float, e : [] c_float, q : [] complex(64), pt : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cgbbrd(matrix_order, ascii(vect) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, n, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, kl, ku, ab, (ab.domain.dim(2).size) : c_int, d, e, q, (q.domain.dim(2).size) : c_int, pt, (pt.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbbrd for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbbrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gbbrd(matrix_order : lapack_memory_order, vect : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), d : [] c_double, e : [] c_double, q : [] complex(128), pt : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zgbbrd(matrix_order, ascii(vect) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, n, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, kl, ku, ab, (ab.domain.dim(2).size) : c_int, d, e, q, (q.domain.dim(2).size) : c_int, pt, (pt.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbcon for the type c_float.

Original Fortran LAPACK purpose documentation for SGBCON::

 SGBCON estimates the reciprocal of the condition number of a real
 general band matrix A, in either the 1-norm or the infinity-norm,
 using the LU factorization computed by SGBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

Original Fortran LAPACK argument documentation for SGBCON::

 NORM is CHARACTER*1
  Specifies whether the 1-norm condition number or the
  infinity-norm condition number is required:
  = '1' or 'O': 1-norm;
  = 'I': Infinity-norm.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is REAL array, dimension (LDAB,N)
  Details of the LU factorization of the band matrix A, as
  computed by SGBTRF. U is stored as an upper triangular band
  matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
  the multipliers used during the factorization are stored in
  rows KL+KU+2 to 2*KL+KU+1.

 IPIV is INTEGER array, dimension (N)
  The pivot indices; for 1 <= i <= N, row i of the matrix was
  interchanged with row IPIV(i).

 ANORM is REAL
  If NORM = '1' or 'O', the 1-norm of the original matrix A.
  If NORM = 'I', the infinity-norm of the original matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(norm(A) * norm(inv(A))).

 */
inline proc gbcon(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_sgbcon(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbcon for the type c_double.

For more information, see the documentation for :proc:`gbcon`, or consult the Netlibs or Intel documentation.
 */
inline proc gbcon(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_dgbcon(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbcon for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbcon`, or consult the Netlibs or Intel documentation.
 */
inline proc gbcon(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_cgbcon(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbcon`, or consult the Netlibs or Intel documentation.
 */
inline proc gbcon(matrix_order : lapack_memory_order, norm : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zgbcon(matrix_order, ascii(norm) : c_char, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbequ for the type c_float.

Original Fortran LAPACK purpose documentation for SGBEQU::

 SGBEQU computes row and column scalings intended to equilibrate an
 M-by-N band matrix A and reduce its condition number. R returns the
 row scale factors and C the column scale factors, chosen to try to
 make the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

Original Fortran LAPACK argument documentation for SGBEQU::

 M is INTEGER
  The number of rows of the matrix A. M >= 0.

 N is INTEGER
  The number of columns of the matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is REAL array, dimension (LDAB,N)
  The band matrix A, stored in rows 1 to KL+KU+1. The j-th
  column of A is stored in the j-th column of the array AB as
  follows:
  AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).

 R is REAL array, dimension (M)
  If INFO = 0, or INFO > M, R contains the row scale factors
  for A.

 C is REAL array, dimension (N)
  If INFO = 0, C contains the column scale factors for A.

 ROWCND is REAL
  If INFO = 0 or INFO > M, ROWCND contains the ratio of the
  smallest R(i) to the largest R(i). If ROWCND >= 0.1 and
  AMAX is neither too large nor too small, it is not worth
  scaling by R.

 COLCND is REAL
  If INFO = 0, COLCND contains the ratio of the smallest
  C(i) to the largest C(i). If COLCND >= 0.1, it is not
  worth scaling by C.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc gbequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float): c_int{
  return LAPACKE_sgbequ(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbequ for the type c_double.

For more information, see the documentation for :proc:`gbequ`, or consult the Netlibs or Intel documentation.
 */
inline proc gbequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double): c_int{
  return LAPACKE_dgbequ(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbequ for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbequ`, or consult the Netlibs or Intel documentation.
 */
inline proc gbequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float): c_int{
  return LAPACKE_cgbequ(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbequ for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbequ`, or consult the Netlibs or Intel documentation.
 */
inline proc gbequ(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double): c_int{
  return LAPACKE_zgbequ(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbequb for the type c_float.

Original Fortran LAPACK purpose documentation for SGBEQUB::

 SGBEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from SGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

Original Fortran LAPACK argument documentation for SGBEQUB::

 M is INTEGER
  The number of rows of the matrix A. M >= 0.

 N is INTEGER
  The number of columns of the matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is DOUBLE PRECISION array, dimension (LDAB,N)
  On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
  The j-th column of A is stored in the j-th column of the
  array AB as follows:
  AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)

 R is REAL array, dimension (M)
  If INFO = 0 or INFO > M, R contains the row scale factors
  for A.

 C is REAL array, dimension (N)
  If INFO = 0, C contains the column scale factors for A.

 ROWCND is REAL
  If INFO = 0 or INFO > M, ROWCND contains the ratio of the
  smallest R(i) to the largest R(i). If ROWCND >= 0.1 and
  AMAX is neither too large nor too small, it is not worth
  scaling by R.

 COLCND is REAL
  If INFO = 0, COLCND contains the ratio of the smallest
  C(i) to the largest C(i). If COLCND >= 0.1, it is not
  worth scaling by C.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc gbequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float): c_int{
  return LAPACKE_sgbequb(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbequb for the type c_double.

For more information, see the documentation for :proc:`gbequb`, or consult the Netlibs or Intel documentation.
 */
inline proc gbequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double): c_int{
  return LAPACKE_dgbequb(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbequb for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbequb`, or consult the Netlibs or Intel documentation.
 */
inline proc gbequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float): c_int{
  return LAPACKE_cgbequb(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbequb for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbequb`, or consult the Netlibs or Intel documentation.
 */
inline proc gbequb(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double): c_int{
  return LAPACKE_zgbequb(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbrfs for the type c_float.

Original Fortran LAPACK purpose documentation for SGBRFS::

 SGBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is banded, and provides
 error bounds and backward error estimates for the solution.

Original Fortran LAPACK argument documentation for SGBRFS::

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 N is INTEGER
  The order of the matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is REAL array, dimension (LDAB,N)
  The original band matrix A, stored in rows 1 to KL+KU+1.
  The j-th column of A is stored in the j-th column of the
  array AB as follows:
  AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).

 AFB is REAL array, dimension (LDAFB,N)
  Details of the LU factorization of the band matrix A, as
  computed by SGBTRF. U is stored as an upper triangular band
  matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
  the multipliers used during the factorization are stored in
  rows KL+KU+2 to 2*KL+KU+1.

 IPIV is INTEGER array, dimension (N)
  The pivot indices from SGBTRF; for 1<=i<=N, row i of the
  matrix was interchanged with row IPIV(i).

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SGBTRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc gbrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, afb : [] c_float, ipiv : [] c_int, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sgbrfs(matrix_order, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbrfs for the type c_double.

For more information, see the documentation for :proc:`gbrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc gbrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, afb : [] c_double, ipiv : [] c_int, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dgbrfs(matrix_order, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbrfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc gbrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), afb : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cgbrfs(matrix_order, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbrfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc gbrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), afb : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zgbrfs(matrix_order, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbrfsx for the type c_float.

Original Fortran LAPACK purpose documentation for SGBRFSX::

 SGBRFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

Original Fortran LAPACK argument documentation for SGBRFSX::

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done to A
  before calling this routine. This is needed to compute
  the solution and error bounds correctly.
  = 'N': No equilibration
  = 'R': Row equilibration, i.e., A has been premultiplied by
  diag(R).
  = 'C': Column equilibration, i.e., A has been postmultiplied
  by diag(C).
  = 'B': Both row and column equilibration, i.e., A has been
  replaced by diag(R) * A * diag(C).
  The right hand side B has been changed accordingly.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is DOUBLE PRECISION array, dimension (LDAB,N)
  The original band matrix A, stored in rows 1 to KL+KU+1.
  The j-th column of A is stored in the j-th column of the
  array AB as follows:
  AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).

 AFB is DOUBLE PRECISION array, dimension (LDAFB,N)
  Details of the LU factorization of the band matrix A, as
  computed by DGBTRF. U is stored as an upper triangular band
  matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
  the multipliers used during the factorization are stored in
  rows KL+KU+2 to 2*KL+KU+1.

 IPIV is INTEGER array, dimension (N)
  The pivot indices from SGETRF; for 1<=i<=N, row i of the
  matrix was interchanged with row IPIV(i).

 R is REAL array, dimension (N)
  The row scale factors for A. If EQUED = 'R' or 'B', A is
  multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
  is not accessed. R is an input argument if FACT = 'F';
  otherwise, R is an output argument. If FACT = 'F' and
  EQUED = 'R' or 'B', each element of R must be positive.
  If R is output, each element of R is a power of the radix.
  If R is input, each element of R should be a power of the radix
  to ensure a reliable solution and error estimates. Scaling by
  powers of the radix does not cause rounding errors unless the
  result underflows or overflows. Rounding errors during scaling
  lead to refining with a matrix that is not equivalent to the
  input matrix, producing error estimates that may not be
  reliable.

 C is REAL array, dimension (N)
  The column scale factors for A. If EQUED = 'C' or 'B', A is
  multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
  is not accessed. C is an input argument if FACT = 'F';
  otherwise, C is an output argument. If FACT = 'F' and
  EQUED = 'C' or 'B', each element of C must be positive.
  If C is output, each element of C is a power of the radix.
  If C is input, each element of C should be a power of the radix
  to ensure a reliable solution and error estimates. Scaling by
  powers of the radix does not cause rounding errors unless the
  result underflows or overflows. Rounding errors during scaling
  lead to refining with a matrix that is not equivalent to the
  input matrix, producing error estimates that may not be
  reliable.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SGETRS.
  On exit, the improved solution matrix X.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc gbrfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, afb : [] c_float, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_sgbrfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbrfsx for the type c_double.

For more information, see the documentation for :proc:`gbrfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc gbrfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, afb : [] c_double, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_dgbrfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbrfsx for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbrfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc gbrfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), afb : [] complex(64), ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_cgbrfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbrfsx for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbrfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc gbrfsx(matrix_order : lapack_memory_order, trans : string, equed : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), afb : [] complex(128), ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zgbrfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbsv for the type c_float.

Original Fortran LAPACK purpose documentation for SGBSV::

 SGBSV computes the solution to a real system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals. The factored form of A
 is then used to solve the system of equations A * X = B.

Original Fortran LAPACK argument documentation for SGBSV::

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the matrix A in band storage, in rows KL+1 to
  2*KL+KU+1; rows 1 to KL of the array need not be set.
  The j-th column of A is stored in the j-th column of the
  array AB as follows:
  AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)
  On exit, details of the factorization: U is stored as an
  upper triangular band matrix with KL+KU superdiagonals in
  rows 1 to KL+KU+1, and the multipliers used during the
  factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
  See below for further details.

 IPIV is INTEGER array, dimension (N)
  The pivot indices that define the permutation matrix P;
  row i of the matrix was interchanged with row IPIV(i).

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc gbsv(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_sgbsv(matrix_order, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbsv for the type c_double.

For more information, see the documentation for :proc:`gbsv`, or consult the Netlibs or Intel documentation.
 */
inline proc gbsv(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dgbsv(matrix_order, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbsv for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbsv`, or consult the Netlibs or Intel documentation.
 */
inline proc gbsv(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_cgbsv(matrix_order, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbsv for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbsv`, or consult the Netlibs or Intel documentation.
 */
inline proc gbsv(matrix_order : lapack_memory_order, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zgbsv(matrix_order, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbsvx for the type c_float.

Original Fortran LAPACK purpose documentation for SGBSVX::

 SGBSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
 where A is a band matrix of order N with KL subdiagonals and KU
 superdiagonals, and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for SGBSVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AFB and IPIV contain the factored form of
  A. If EQUED is not 'N', the matrix A has been
  equilibrated with scaling factors given by R and C.
  AB, AFB, and IPIV are not modified.
  = 'N': The matrix A will be copied to AFB and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AFB and factored.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations.
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Transpose)

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
  The j-th column of A is stored in the j-th column of the
  array AB as follows:
  AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)
 
  If FACT = 'F' and EQUED is not 'N', then A must have been
  equilibrated by the scaling factors in R and/or C. AB is not
  modified if FACT = 'F' or 'N', or if FACT = 'E' and
  EQUED = 'N' on exit.
 
  On exit, if EQUED .ne. 'N', A is scaled as follows:
  EQUED = 'R': A := diag(R) * A
  EQUED = 'C': A := A * diag(C)
  EQUED = 'B': A := diag(R) * A * diag(C).

 AFB is REAL array, dimension (LDAFB,N)
  If FACT = 'F', then AFB is an input argument and on entry
  contains details of the LU factorization of the band matrix
  A, as computed by SGBTRF. U is stored as an upper triangular
  band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
  and the multipliers used during the factorization are stored
  in rows KL+KU+2 to 2*KL+KU+1. If EQUED .ne. 'N', then AFB is
  the factored form of the equilibrated matrix A.
 
  If FACT = 'N', then AFB is an output argument and on exit
  returns details of the LU factorization of A.
 
  If FACT = 'E', then AFB is an output argument and on exit
  returns details of the LU factorization of the equilibrated
  matrix A (see the description of AB for the form of the
  equilibrated matrix).

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains the pivot indices from the factorization A = L*U
  as computed by SGBTRF; row i of the matrix was interchanged
  with row IPIV(i).
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains the pivot indices from the factorization A = L*U
  of the original matrix A.
 
  If FACT = 'E', then IPIV is an output argument and on exit
  contains the pivot indices from the factorization A = L*U
  of the equilibrated matrix A.

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'R': Row equilibration, i.e., A has been premultiplied by
  diag(R).
  = 'C': Column equilibration, i.e., A has been postmultiplied
  by diag(C).
  = 'B': Both row and column equilibration, i.e., A has been
  replaced by diag(R) * A * diag(C).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 R is REAL array, dimension (N)
  The row scale factors for A. If EQUED = 'R' or 'B', A is
  multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
  is not accessed. R is an input argument if FACT = 'F';
  otherwise, R is an output argument. If FACT = 'F' and
  EQUED = 'R' or 'B', each element of R must be positive.

 C is REAL array, dimension (N)
  The column scale factors for A. If EQUED = 'C' or 'B', A is
  multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
  is not accessed. C is an input argument if FACT = 'F';
  otherwise, C is an output argument. If FACT = 'F' and
  EQUED = 'C' or 'B', each element of C must be positive.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit,
  if EQUED = 'N', B is not modified;
  if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
  diag(R)*B;
  if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
  overwritten by diag(C)*B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
  to the original system of equations. Note that A and B are
  modified on exit if EQUED .ne. 'N', and the solution to the
  equilibrated system is inv(diag(C))*X if TRANS = 'N' and
  EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
  and EQUED = 'R' or 'B'.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A after equilibration (if done). If RCOND is less than the
  machine precision (in particular, if RCOND = 0), the matrix
  is singular to working precision. This condition is
  indicated by a return code of INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc gbsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, afb : [] c_float, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float): c_int{
  return LAPACKE_sgbsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr, rpivot);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbsvx for the type c_double.

For more information, see the documentation for :proc:`gbsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc gbsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, afb : [] c_double, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double): c_int{
  return LAPACKE_dgbsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr, rpivot);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbsvx for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc gbsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), afb : [] complex(64), ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float): c_int{
  return LAPACKE_cgbsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr, rpivot);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbsvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc gbsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), afb : [] complex(128), ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double): c_int{
  return LAPACKE_zgbsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr, rpivot);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbsvxx for the type c_float.

Original Fortran LAPACK purpose documentation for SGBSVXX::

 SGBSVXX uses the LU factorization to compute the solution to a
 real system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SGBSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SGBSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SGBSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SGBSVXX would itself produce.

Original Fortran LAPACK argument documentation for SGBSVXX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AF and IPIV contain the factored form of A.
  If EQUED is not 'N', the matrix A has been
  equilibrated with scaling factors given by R and C.
  A, AF, and IPIV are not modified.
  = 'N': The matrix A will be copied to AF and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AF and factored.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate Transpose = Transpose)

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
  The j-th column of A is stored in the j-th column of the
  array AB as follows:
  AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)
 
  If FACT = 'F' and EQUED is not 'N', then AB must have been
  equilibrated by the scaling factors in R and/or C. AB is not
  modified if FACT = 'F' or 'N', or if FACT = 'E' and
  EQUED = 'N' on exit.
 
  On exit, if EQUED .ne. 'N', A is scaled as follows:
  EQUED = 'R': A := diag(R) * A
  EQUED = 'C': A := A * diag(C)
  EQUED = 'B': A := diag(R) * A * diag(C).

 AFB is REAL array, dimension (LDAFB,N)
  If FACT = 'F', then AFB is an input argument and on entry
  contains details of the LU factorization of the band matrix
  A, as computed by SGBTRF. U is stored as an upper triangular
  band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
  and the multipliers used during the factorization are stored
  in rows KL+KU+2 to 2*KL+KU+1. If EQUED .ne. 'N', then AFB is
  the factored form of the equilibrated matrix A.
 
  If FACT = 'N', then AF is an output argument and on exit
  returns the factors L and U from the factorization A = P*L*U
  of the original matrix A.
 
  If FACT = 'E', then AF is an output argument and on exit
  returns the factors L and U from the factorization A = P*L*U
  of the equilibrated matrix A (see the description of A for
  the form of the equilibrated matrix).

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains the pivot indices from the factorization A = P*L*U
  as computed by SGETRF; row i of the matrix was interchanged
  with row IPIV(i).
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains the pivot indices from the factorization A = P*L*U
  of the original matrix A.
 
  If FACT = 'E', then IPIV is an output argument and on exit
  contains the pivot indices from the factorization A = P*L*U
  of the equilibrated matrix A.

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'R': Row equilibration, i.e., A has been premultiplied by
  diag(R).
  = 'C': Column equilibration, i.e., A has been postmultiplied
  by diag(C).
  = 'B': Both row and column equilibration, i.e., A has been
  replaced by diag(R) * A * diag(C).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 R is REAL array, dimension (N)
  The row scale factors for A. If EQUED = 'R' or 'B', A is
  multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
  is not accessed. R is an input argument if FACT = 'F';
  otherwise, R is an output argument. If FACT = 'F' and
  EQUED = 'R' or 'B', each element of R must be positive.
  If R is output, each element of R is a power of the radix.
  If R is input, each element of R should be a power of the radix
  to ensure a reliable solution and error estimates. Scaling by
  powers of the radix does not cause rounding errors unless the
  result underflows or overflows. Rounding errors during scaling
  lead to refining with a matrix that is not equivalent to the
  input matrix, producing error estimates that may not be
  reliable.

 C is REAL array, dimension (N)
  The column scale factors for A. If EQUED = 'C' or 'B', A is
  multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
  is not accessed. C is an input argument if FACT = 'F';
  otherwise, C is an output argument. If FACT = 'F' and
  EQUED = 'C' or 'B', each element of C must be positive.
  If C is output, each element of C is a power of the radix.
  If C is input, each element of C should be a power of the radix
  to ensure a reliable solution and error estimates. Scaling by
  powers of the radix does not cause rounding errors unless the
  result underflows or overflows. Rounding errors during scaling
  lead to refining with a matrix that is not equivalent to the
  input matrix, producing error estimates that may not be
  reliable.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit,
  if EQUED = 'N', B is not modified;
  if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
  diag(R)*B;
  if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
  overwritten by diag(C)*B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0, the N-by-NRHS solution matrix X to the original
  system of equations. Note that A and B are modified on exit
  if EQUED .ne. 'N', and the solution to the equilibrated system is
  inv(diag(C))*X if TRANS = 'N' and EQUED = 'C' or 'B', or
  inv(diag(R))*X if TRANS = 'T' or 'C' and EQUED = 'R' or 'B'.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 RPVGRW is REAL
  Reciprocal pivot growth. On exit, this contains the reciprocal
  pivot growth factor norm(A)/norm(U). The "max absolute element"
  norm is used. If this is much less than 1, then the stability of
  the LU factorization of the (equilibrated) matrix A could be poor.
  This also means that the solution X, estimated condition numbers,
  and error bounds could be unreliable. If factorization fails with
  0<INFO<=N, then this contains the reciprocal pivot growth factor
  for the leading INFO columns of A. In SGESVX, this quantity is
  returned in WORK(1).

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc gbsvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, afb : [] c_float, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_sgbsvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbsvxx for the type c_double.

For more information, see the documentation for :proc:`gbsvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc gbsvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, afb : [] c_double, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_dgbsvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbsvxx for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbsvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc gbsvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), afb : [] complex(64), ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_cgbsvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbsvxx for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbsvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc gbsvxx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), afb : [] complex(128), ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zgbsvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbtrf for the type c_float.

Original Fortran LAPACK purpose documentation for SGBTRF::

 SGBTRF computes an LU factorization of a real m-by-n band matrix A
 using partial pivoting with row interchanges.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

Original Fortran LAPACK argument documentation for SGBTRF::

 M is INTEGER
  The number of rows of the matrix A. M >= 0.

 N is INTEGER
  The number of columns of the matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the matrix A in band storage, in rows KL+1 to
  2*KL+KU+1; rows 1 to KL of the array need not be set.
  The j-th column of A is stored in the j-th column of the
  array AB as follows:
  AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
 
  On exit, details of the factorization: U is stored as an
  upper triangular band matrix with KL+KU superdiagonals in
  rows 1 to KL+KU+1, and the multipliers used during the
  factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
  See below for further details.

 IPIV is INTEGER array, dimension (min(M,N))
  The pivot indices; for 1 <= i <= min(M,N), row i of the
  matrix was interchanged with row IPIV(i).

 */
inline proc gbtrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_sgbtrf(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbtrf for the type c_double.

For more information, see the documentation for :proc:`gbtrf`, or consult the Netlibs or Intel documentation.
 */
inline proc gbtrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dgbtrf(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbtrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbtrf`, or consult the Netlibs or Intel documentation.
 */
inline proc gbtrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_cgbtrf(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbtrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbtrf`, or consult the Netlibs or Intel documentation.
 */
inline proc gbtrf(matrix_order : lapack_memory_order, m : c_int, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zgbtrf(matrix_order, m, n, kl, ku, ab, (ab.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgbtrs for the type c_float.

Original Fortran LAPACK purpose documentation for SGBTRS::

 SGBTRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general band matrix A using the LU factorization computed
 by SGBTRF.

Original Fortran LAPACK argument documentation for SGBTRS::

 TRANS is CHARACTER*1
  Specifies the form of the system of equations.
  = 'N': A * X = B (No transpose)
  = 'T': A**T* X = B (Transpose)
  = 'C': A**T* X = B (Conjugate transpose = Transpose)

 N is INTEGER
  The order of the matrix A. N >= 0.

 KL is INTEGER
  The number of subdiagonals within the band of A. KL >= 0.

 KU is INTEGER
  The number of superdiagonals within the band of A. KU >= 0.

 AB is REAL array, dimension (LDAB,N)
  Details of the LU factorization of the band matrix A, as
  computed by SGBTRF. U is stored as an upper triangular band
  matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
  the multipliers used during the factorization are stored in
  rows KL+KU+2 to 2*KL+KU+1.

 IPIV is INTEGER array, dimension (N)
  The pivot indices; for 1 <= i <= N, row i of the matrix was
  interchanged with row IPIV(i).

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc gbtrs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_sgbtrs(matrix_order, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgbtrs for the type c_double.

For more information, see the documentation for :proc:`gbtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc gbtrs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dgbtrs(matrix_order, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgbtrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`gbtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc gbtrs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_cgbtrs(matrix_order, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgbtrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`gbtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc gbtrs(matrix_order : lapack_memory_order, trans : string, n : c_int, kl : c_int, ku : c_int, ab : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zgbtrs(matrix_order, ascii(trans) : c_char, n, kl, ku, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgebak for the type c_float.

Original Fortran LAPACK purpose documentation for SGEBAK::

 SGEBAK forms the right or left eigenvectors of a real general matrix
 by backward transformation on the computed eigenvectors of the
 balanced matrix output by SGEBAL.

Original Fortran LAPACK argument documentation for SGEBAK::

 JOB is CHARACTER*1
  Specifies the type of backward transformation required:
  = 'N', do nothing, return immediately;
  = 'P', do backward transformation for permutation only;
  = 'S', do backward transformation for scaling only;
  = 'B', do backward transformations for both permutation and
  scaling.
  JOB must be the same as the argument JOB supplied to SGEBAL.

 SIDE is CHARACTER*1
  = 'R': V contains right eigenvectors;
  = 'L': V contains left eigenvectors.

 ILO is INTEGER

 IHI is INTEGER
  The integers ILO and IHI determined by SGEBAL.
  1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

 SCALE is REAL array, dimension (N)
  Details of the permutation and scaling factors, as returned
  by SGEBAL.

 V is REAL array, dimension (LDV,M)
  On entry, the matrix of right or left eigenvectors to be
  transformed, as returned by SHSEIN or STREVC.
  On exit, V is overwritten by the transformed eigenvectors.

 */
inline proc gebak(matrix_order : lapack_memory_order, job : string, side : string, ilo : c_int, ihi : c_int, scale : [] c_float, v : [] c_float): c_int{
  return LAPACKE_sgebak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(1).size else v.domain.dim(2).size) : c_int, ilo, ihi, scale, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(2).size else v.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgebak for the type c_double.

For more information, see the documentation for :proc:`gebak`, or consult the Netlibs or Intel documentation.
 */
inline proc gebak(matrix_order : lapack_memory_order, job : string, side : string, ilo : c_int, ihi : c_int, scale : [] c_double, v : [] c_double): c_int{
  return LAPACKE_dgebak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(1).size else v.domain.dim(2).size) : c_int, ilo, ihi, scale, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(2).size else v.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgebak for the type lapack_complex_float.

For more information, see the documentation for :proc:`gebak`, or consult the Netlibs or Intel documentation.
 */
inline proc gebak(matrix_order : lapack_memory_order, job : string, side : string, ilo : c_int, ihi : c_int, scale : [] c_float, v : [] complex(64)): c_int{
  return LAPACKE_cgebak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(1).size else v.domain.dim(2).size) : c_int, ilo, ihi, scale, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(2).size else v.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgebak for the type lapack_complex_double.

For more information, see the documentation for :proc:`gebak`, or consult the Netlibs or Intel documentation.
 */
inline proc gebak(matrix_order : lapack_memory_order, job : string, side : string, ilo : c_int, ihi : c_int, scale : [] c_double, v : [] complex(128)): c_int{
  return LAPACKE_zgebak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(1).size else v.domain.dim(2).size) : c_int, ilo, ihi, scale, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(2).size else v.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgebal for the type c_float.

Original Fortran LAPACK purpose documentation for SGEBAL::

 SGEBAL balances a general real matrix A. This involves, first,
 permuting A by a similarity transformation to isolate eigenvalues
 in the first 1 to ILO-1 and last IHI+1 to N elements on the
 diagonal; and second, applying a diagonal similarity transformation
 to rows and columns ILO to IHI to make the rows and columns as
 close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrix, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors.

Original Fortran LAPACK argument documentation for SGEBAL::

 JOB is CHARACTER*1
  Specifies the operations to be performed on A:
  = 'N': none: simply set ILO = 1, IHI = N, SCALE(I) = 1.0
  for i = 1,...,N;
  = 'P': permute only;
  = 'S': scale only;
  = 'B': both permute and scale.

 A is REAL array, dimension (LDA,N)
  On entry, the input matrix A.
  On exit, A is overwritten by the balanced matrix.
  If JOB = 'N', A is not referenced.
  See Further Details.

 ILO is INTEGER

 IHI is INTEGER
  ILO and IHI are set to integers such that on exit
  A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
  If JOB = 'N' or 'S', ILO = 1 and IHI = N.

 SCALE is REAL array, dimension (N)
  Details of the permutations and scaling factors applied to
  A. If P(j) is the index of the row and column interchanged
  with row and column j and D(j) is the scaling factor
  applied to row and column j, then
  SCALE(j) = P(j) for j = 1,...,ILO-1
  = D(j) for j = ILO,...,IHI
  = P(j) for j = IHI+1,...,N.
  The order in which the interchanges are made is N to IHI+1,
  then 1 to ILO-1.

 */
inline proc gebal(matrix_order : lapack_memory_order, job : string, a : [] c_float, ref ilo : c_int, ref ihi : c_int, scale : [] c_float): c_int{
  return LAPACKE_sgebal(matrix_order, ascii(job) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ilo, ihi, scale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgebal for the type c_double.

For more information, see the documentation for :proc:`gebal`, or consult the Netlibs or Intel documentation.
 */
inline proc gebal(matrix_order : lapack_memory_order, job : string, a : [] c_double, ref ilo : c_int, ref ihi : c_int, scale : [] c_double): c_int{
  return LAPACKE_dgebal(matrix_order, ascii(job) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ilo, ihi, scale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgebal for the type lapack_complex_float.

For more information, see the documentation for :proc:`gebal`, or consult the Netlibs or Intel documentation.
 */
inline proc gebal(matrix_order : lapack_memory_order, job : string, a : [] complex(64), ref ilo : c_int, ref ihi : c_int, scale : [] c_float): c_int{
  return LAPACKE_cgebal(matrix_order, ascii(job) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ilo, ihi, scale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgebal for the type lapack_complex_double.

For more information, see the documentation for :proc:`gebal`, or consult the Netlibs or Intel documentation.
 */
inline proc gebal(matrix_order : lapack_memory_order, job : string, a : [] complex(128), ref ilo : c_int, ref ihi : c_int, scale : [] c_double): c_int{
  return LAPACKE_zgebal(matrix_order, ascii(job) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ilo, ihi, scale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgebrd for the type c_float.

Original Fortran LAPACK purpose documentation for SGEBRD::

 SGEBRD reduces a general real M-by-N matrix A to upper or lower
 bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

 If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

Original Fortran LAPACK argument documentation for SGEBRD::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N general matrix to be reduced.
  On exit,
  if m >= n, the diagonal and the first superdiagonal are
  overwritten with the upper bidiagonal matrix B; the
  elements below the diagonal, with the array TAUQ, represent
  the orthogonal matrix Q as a product of elementary
  reflectors, and the elements above the first superdiagonal,
  with the array TAUP, represent the orthogonal matrix P as
  a product of elementary reflectors;
  if m < n, the diagonal and the first subdiagonal are
  overwritten with the lower bidiagonal matrix B; the
  elements below the first subdiagonal, with the array TAUQ,
  represent the orthogonal matrix Q as a product of
  elementary reflectors, and the elements above the diagonal,
  with the array TAUP, represent the orthogonal matrix P as
  a product of elementary reflectors.
  See Further Details.

 D is REAL array, dimension (min(M,N))
  The diagonal elements of the bidiagonal matrix B:
  D(i) = A(i,i).

 E is REAL array, dimension (min(M,N)-1)
  The off-diagonal elements of the bidiagonal matrix B:
  if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
  if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.

 TAUQ is REAL array dimension (min(M,N))
  The scalar factors of the elementary reflectors which
  represent the orthogonal matrix Q. See Further Details.

 TAUP is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors which
  represent the orthogonal matrix P. See Further Details.

 */
inline proc gebrd(matrix_order : lapack_memory_order, a : [] c_float, d : [] c_float, e : [] c_float, tauq : [] c_float, taup : [] c_float): c_int{
  return LAPACKE_sgebrd(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, d, e, tauq, taup);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgebrd for the type c_double.

For more information, see the documentation for :proc:`gebrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gebrd(matrix_order : lapack_memory_order, a : [] c_double, d : [] c_double, e : [] c_double, tauq : [] c_double, taup : [] c_double): c_int{
  return LAPACKE_dgebrd(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, d, e, tauq, taup);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgebrd for the type lapack_complex_float.

For more information, see the documentation for :proc:`gebrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gebrd(matrix_order : lapack_memory_order, a : [] complex(64), d : [] c_float, e : [] c_float, tauq : [] complex(64), taup : [] complex(64)): c_int{
  return LAPACKE_cgebrd(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, d, e, tauq, taup);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgebrd for the type lapack_complex_double.

For more information, see the documentation for :proc:`gebrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gebrd(matrix_order : lapack_memory_order, a : [] complex(128), d : [] c_double, e : [] c_double, tauq : [] complex(128), taup : [] complex(128)): c_int{
  return LAPACKE_zgebrd(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, d, e, tauq, taup);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgecon for the type c_float.

Original Fortran LAPACK purpose documentation for SGECON::

 SGECON estimates the reciprocal of the condition number of a general
 real matrix A, in either the 1-norm or the infinity-norm, using
 the LU factorization computed by SGETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

Original Fortran LAPACK argument documentation for SGECON::

 NORM is CHARACTER*1
  Specifies whether the 1-norm condition number or the
  infinity-norm condition number is required:
  = '1' or 'O': 1-norm;
  = 'I': Infinity-norm.

 A is REAL array, dimension (LDA,N)
  The factors L and U from the factorization A = P*L*U
  as computed by SGETRF.

 ANORM is REAL
  If NORM = '1' or 'O', the 1-norm of the original matrix A.
  If NORM = 'I', the infinity-norm of the original matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(norm(A) * norm(inv(A))).

 */
inline proc gecon(matrix_order : lapack_memory_order, norm : string, a : [] c_float, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_sgecon(matrix_order, ascii(norm) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgecon for the type c_double.

For more information, see the documentation for :proc:`gecon`, or consult the Netlibs or Intel documentation.
 */
inline proc gecon(matrix_order : lapack_memory_order, norm : string, a : [] c_double, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_dgecon(matrix_order, ascii(norm) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgecon for the type lapack_complex_float.

For more information, see the documentation for :proc:`gecon`, or consult the Netlibs or Intel documentation.
 */
inline proc gecon(matrix_order : lapack_memory_order, norm : string, a : [] complex(64), anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_cgecon(matrix_order, ascii(norm) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgecon for the type lapack_complex_double.

For more information, see the documentation for :proc:`gecon`, or consult the Netlibs or Intel documentation.
 */
inline proc gecon(matrix_order : lapack_memory_order, norm : string, a : [] complex(128), anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zgecon(matrix_order, ascii(norm) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeequ for the type c_float.

Original Fortran LAPACK purpose documentation for SGEEQU::

 SGEEQU computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.

 R(i) and C(j) are restricted to be between SMLNUM = smallest safe
 number and BIGNUM = largest safe number. Use of these scaling
 factors is not guaranteed to reduce the condition number of A but
 works well in practice.

Original Fortran LAPACK argument documentation for SGEEQU::

 A is REAL array, dimension (LDA,N)
  The M-by-N matrix whose equilibration factors are
  to be computed.

 R is REAL array, dimension (M)
  If INFO = 0 or INFO > M, R contains the row scale factors
  for A.

 C is REAL array, dimension (N)
  If INFO = 0, C contains the column scale factors for A.

 ROWCND is REAL
  If INFO = 0 or INFO > M, ROWCND contains the ratio of the
  smallest R(i) to the largest R(i). If ROWCND >= 0.1 and
  AMAX is neither too large nor too small, it is not worth
  scaling by R.

 COLCND is REAL
  If INFO = 0, COLCND contains the ratio of the smallest
  C(i) to the largest C(i). If COLCND >= 0.1, it is not
  worth scaling by C.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc geequ(matrix_order : lapack_memory_order, a : [] c_float, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float): c_int{
  return LAPACKE_sgeequ(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeequ for the type c_double.

For more information, see the documentation for :proc:`geequ`, or consult the Netlibs or Intel documentation.
 */
inline proc geequ(matrix_order : lapack_memory_order, a : [] c_double, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double): c_int{
  return LAPACKE_dgeequ(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeequ for the type lapack_complex_float.

For more information, see the documentation for :proc:`geequ`, or consult the Netlibs or Intel documentation.
 */
inline proc geequ(matrix_order : lapack_memory_order, a : [] complex(64), r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float): c_int{
  return LAPACKE_cgeequ(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeequ for the type lapack_complex_double.

For more information, see the documentation for :proc:`geequ`, or consult the Netlibs or Intel documentation.
 */
inline proc geequ(matrix_order : lapack_memory_order, a : [] complex(128), r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double): c_int{
  return LAPACKE_zgeequ(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeequb for the type c_float.

Original Fortran LAPACK purpose documentation for SGEEQUB::

 SGEEQUB computes row and column scalings intended to equilibrate an
 M-by-N matrix A and reduce its condition number. R returns the row
 scale factors and C the column scale factors, chosen to try to make
 the largest element in each row and column of the matrix B with
 elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
 the radix.

 R(i) and C(j) are restricted to be a power of the radix between
 SMLNUM = smallest safe number and BIGNUM = largest safe number. Use
 of these scaling factors is not guaranteed to reduce the condition
 number of A but works well in practice.

 This routine differs from SGEEQU by restricting the scaling factors
 to a power of the radix. Baring over- and underflow, scaling by
 these factors introduces no additional rounding errors. However, the
 scaled entries' magnitured are no longer approximately 1 but lie
 between sqrt(radix) and 1/sqrt(radix).

Original Fortran LAPACK argument documentation for SGEEQUB::

 A is REAL array, dimension (LDA,N)
  The M-by-N matrix whose equilibration factors are
  to be computed.

 R is REAL array, dimension (M)
  If INFO = 0 or INFO > M, R contains the row scale factors
  for A.

 C is REAL array, dimension (N)
  If INFO = 0, C contains the column scale factors for A.

 ROWCND is REAL
  If INFO = 0 or INFO > M, ROWCND contains the ratio of the
  smallest R(i) to the largest R(i). If ROWCND >= 0.1 and
  AMAX is neither too large nor too small, it is not worth
  scaling by R.

 COLCND is REAL
  If INFO = 0, COLCND contains the ratio of the smallest
  C(i) to the largest C(i). If COLCND >= 0.1, it is not
  worth scaling by C.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc geequb(matrix_order : lapack_memory_order, a : [] c_float, r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float): c_int{
  return LAPACKE_sgeequb(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeequb for the type c_double.

For more information, see the documentation for :proc:`geequb`, or consult the Netlibs or Intel documentation.
 */
inline proc geequb(matrix_order : lapack_memory_order, a : [] c_double, r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double): c_int{
  return LAPACKE_dgeequb(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeequb for the type lapack_complex_float.

For more information, see the documentation for :proc:`geequb`, or consult the Netlibs or Intel documentation.
 */
inline proc geequb(matrix_order : lapack_memory_order, a : [] complex(64), r : [] c_float, c : [] c_float, ref rowcnd : c_float, ref colcnd : c_float, ref amax : c_float): c_int{
  return LAPACKE_cgeequb(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeequb for the type lapack_complex_double.

For more information, see the documentation for :proc:`geequb`, or consult the Netlibs or Intel documentation.
 */
inline proc geequb(matrix_order : lapack_memory_order, a : [] complex(128), r : [] c_double, c : [] c_double, ref rowcnd : c_double, ref colcnd : c_double, ref amax : c_double): c_int{
  return LAPACKE_zgeequb(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, r, c, rowcnd, colcnd, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgees for the type c_float.

Original Fortran LAPACK purpose documentation for SGEES::

 SGEES computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left.
 The leading columns of Z then form an orthonormal basis for the
 invariant subspace corresponding to the selected eigenvalues.

 A matrix is in real Schur form if it is upper quasi-triangular with
 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
 form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

Original Fortran LAPACK argument documentation for SGEES::

 JOBVS is CHARACTER*1
  = 'N': Schur vectors are not computed;
  = 'V': Schur vectors are computed.

 SORT is CHARACTER*1
  Specifies whether or not to order the eigenvalues on the
  diagonal of the Schur form.
  = 'N': Eigenvalues are not ordered;
  = 'S': Eigenvalues are ordered (see SELECT).

 A is REAL array, dimension (LDA,N)
  On entry, the N-by-N matrix A.
  On exit, A has been overwritten by its real Schur form T.

 SDIM is INTEGER
  If SORT = 'N', SDIM = 0.
  If SORT = 'S', SDIM = number of eigenvalues (after sorting)
  for which SELECT is true. (Complex conjugate
  pairs for which SELECT is true for either
  eigenvalue count as 2.)

 WR is REAL array, dimension (N)

 WI is REAL array, dimension (N)
  WR and WI contain the real and imaginary parts,
  respectively, of the computed eigenvalues in the same order
  that they appear on the diagonal of the output Schur form T.
  Complex conjugate pairs of eigenvalues will appear
  consecutively with the eigenvalue having the positive
  imaginary part first.

 VS is REAL array, dimension (LDVS,N)
  If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
  vectors.
  If JOBVS = 'N', VS is not referenced.

 */
inline proc gees(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_S_SELECT2, a : [] c_float, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float): c_int{
  return LAPACKE_sgees(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sdim, wr, wi, vs, (vs.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgees for the type c_double.

For more information, see the documentation for :proc:`gees`, or consult the Netlibs or Intel documentation.
 */
inline proc gees(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_D_SELECT2, a : [] c_double, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double): c_int{
  return LAPACKE_dgees(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sdim, wr, wi, vs, (vs.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgees for the type lapack_complex_float.

For more information, see the documentation for :proc:`gees`, or consult the Netlibs or Intel documentation.
 */
inline proc gees(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_C_SELECT1, a : [] complex(64), ref sdim : c_int, w : [] complex(64), vs : [] complex(64)): c_int{
  return LAPACKE_cgees(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sdim, w, vs, (vs.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgees for the type lapack_complex_double.

For more information, see the documentation for :proc:`gees`, or consult the Netlibs or Intel documentation.
 */
inline proc gees(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_Z_SELECT1, a : [] complex(128), ref sdim : c_int, w : [] complex(128), vs : [] complex(128)): c_int{
  return LAPACKE_zgees(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sdim, w, vs, (vs.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeesx for the type c_float.

Original Fortran LAPACK purpose documentation for SGEESX::

 SGEESX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues, the real Schur form T, and, optionally, the matrix of
 Schur vectors Z. This gives the Schur factorization A = Z*T*(Z**T).

 Optionally, it also orders the eigenvalues on the diagonal of the
 real Schur form so that selected eigenvalues are at the top left;
 computes a reciprocal condition number for the average of the
 selected eigenvalues (RCONDE); and computes a reciprocal condition
 number for the right invariant subspace corresponding to the
 selected eigenvalues (RCONDV). The leading columns of Z form an
 orthonormal basis for this invariant subspace.

 For further explanation of the reciprocal condition numbers RCONDE
 and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
 these quantities are called s and sep respectively).

 A real matrix is in real Schur form if it is upper quasi-triangular
 with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
 the form
 [ a b ]
 [ c a ]

 where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

Original Fortran LAPACK argument documentation for SGEESX::

 JOBVS is CHARACTER*1
  = 'N': Schur vectors are not computed;
  = 'V': Schur vectors are computed.

 SORT is CHARACTER*1
  Specifies whether or not to order the eigenvalues on the
  diagonal of the Schur form.
  = 'N': Eigenvalues are not ordered;
  = 'S': Eigenvalues are ordered (see SELECT).

 SENSE is CHARACTER*1
  Determines which reciprocal condition numbers are computed.
  = 'N': None are computed;
  = 'E': Computed for average of selected eigenvalues only;
  = 'V': Computed for selected right invariant subspace only;
  = 'B': Computed for both.
  If SENSE = 'E', 'V' or 'B', SORT must equal 'S'.

 A is REAL array, dimension (LDA, N)
  On entry, the N-by-N matrix A.
  On exit, A is overwritten by its real Schur form T.

 SDIM is INTEGER
  If SORT = 'N', SDIM = 0.
  If SORT = 'S', SDIM = number of eigenvalues (after sorting)
  for which SELECT is true. (Complex conjugate
  pairs for which SELECT is true for either
  eigenvalue count as 2.)

 WR is REAL array, dimension (N)

 WI is REAL array, dimension (N)
  WR and WI contain the real and imaginary parts, respectively,
  of the computed eigenvalues, in the same order that they
  appear on the diagonal of the output Schur form T. Complex
  conjugate pairs of eigenvalues appear consecutively with the
  eigenvalue having the positive imaginary part first.

 VS is REAL array, dimension (LDVS,N)
  If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
  vectors.
  If JOBVS = 'N', VS is not referenced.

 RCONDE is REAL
  If SENSE = 'E' or 'B', RCONDE contains the reciprocal
  condition number for the average of the selected eigenvalues.
  Not referenced if SENSE = 'N' or 'V'.

 RCONDV is REAL
  If SENSE = 'V' or 'B', RCONDV contains the reciprocal
  condition number for the selected right invariant subspace.
  Not referenced if SENSE = 'N' or 'E'.

 */
inline proc geesx(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_S_SELECT2, sense : string, a : [] c_float, ref sdim : c_int, wr : [] c_float, wi : [] c_float, vs : [] c_float, ref rconde : c_float, ref rcondv : c_float): c_int{
  return LAPACKE_sgeesx(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sdim, wr, wi, vs, (vs.domain.dim(2).size) : c_int, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeesx for the type c_double.

For more information, see the documentation for :proc:`geesx`, or consult the Netlibs or Intel documentation.
 */
inline proc geesx(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_D_SELECT2, sense : string, a : [] c_double, ref sdim : c_int, wr : [] c_double, wi : [] c_double, vs : [] c_double, ref rconde : c_double, ref rcondv : c_double): c_int{
  return LAPACKE_dgeesx(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sdim, wr, wi, vs, (vs.domain.dim(2).size) : c_int, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeesx for the type lapack_complex_float.

For more information, see the documentation for :proc:`geesx`, or consult the Netlibs or Intel documentation.
 */
inline proc geesx(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_C_SELECT1, sense : string, a : [] complex(64), ref sdim : c_int, w : [] complex(64), vs : [] complex(64), ref rconde : c_float, ref rcondv : c_float): c_int{
  return LAPACKE_cgeesx(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sdim, w, vs, (vs.domain.dim(2).size) : c_int, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeesx for the type lapack_complex_double.

For more information, see the documentation for :proc:`geesx`, or consult the Netlibs or Intel documentation.
 */
inline proc geesx(matrix_order : lapack_memory_order, jobvs : string, sort : string, chlapack_select : LAPACK_Z_SELECT1, sense : string, a : [] complex(128), ref sdim : c_int, w : [] complex(128), vs : [] complex(128), ref rconde : c_double, ref rcondv : c_double): c_int{
  return LAPACKE_zgeesx(matrix_order, ascii(jobvs) : c_char, ascii(sort) : c_char, chlapack_select, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sdim, w, vs, (vs.domain.dim(2).size) : c_int, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeev for the type c_float.

Original Fortran LAPACK purpose documentation for SGEEV::

 SGEEV computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

Original Fortran LAPACK argument documentation for SGEEV::

 JOBVL is CHARACTER*1
  = 'N': left eigenvectors of A are not computed;
  = 'V': left eigenvectors of A are computed.

 JOBVR is CHARACTER*1
  = 'N': right eigenvectors of A are not computed;
  = 'V': right eigenvectors of A are computed.

 A is REAL array, dimension (LDA,N)
  On entry, the N-by-N matrix A.
  On exit, A has been overwritten.

 WR is REAL array, dimension (N)

 WI is REAL array, dimension (N)
  WR and WI contain the real and imaginary parts,
  respectively, of the computed eigenvalues. Complex
  conjugate pairs of eigenvalues appear consecutively
  with the eigenvalue having the positive imaginary part
  first.

 VL is REAL array, dimension (LDVL,N)
  If JOBVL = 'V', the left eigenvectors u(j) are stored one
  after another in the columns of VL, in the same order
  as their eigenvalues.
  If JOBVL = 'N', VL is not referenced.
  If the j-th eigenvalue is real, then u(j) = VL(:,j),
  the j-th column of VL.
  If the j-th and (j+1)-st eigenvalues form a complex
  conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
  u(j+1) = VL(:,j) - i*VL(:,j+1).

 VR is REAL array, dimension (LDVR,N)
  If JOBVR = 'V', the right eigenvectors v(j) are stored one
  after another in the columns of VR, in the same order
  as their eigenvalues.
  If JOBVR = 'N', VR is not referenced.
  If the j-th eigenvalue is real, then v(j) = VR(:,j),
  the j-th column of VR.
  If the j-th and (j+1)-st eigenvalues form a complex
  conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
  v(j+1) = VR(:,j) - i*VR(:,j+1).

 */
inline proc geev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, a : [] c_float, wr : [] c_float, wi : [] c_float, vl : [] c_float, vr : [] c_float): c_int{
  return LAPACKE_sgeev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, wr, wi, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeev for the type c_double.

For more information, see the documentation for :proc:`geev`, or consult the Netlibs or Intel documentation.
 */
inline proc geev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, a : [] c_double, wr : [] c_double, wi : [] c_double, vl : [] c_double, vr : [] c_double): c_int{
  return LAPACKE_dgeev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, wr, wi, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeev for the type lapack_complex_float.

For more information, see the documentation for :proc:`geev`, or consult the Netlibs or Intel documentation.
 */
inline proc geev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, a : [] complex(64), w : [] complex(64), vl : [] complex(64), vr : [] complex(64)): c_int{
  return LAPACKE_cgeev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeev for the type lapack_complex_double.

For more information, see the documentation for :proc:`geev`, or consult the Netlibs or Intel documentation.
 */
inline proc geev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, a : [] complex(128), w : [] complex(128), vl : [] complex(128), vr : [] complex(128)): c_int{
  return LAPACKE_zgeev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeevx for the type c_float.

Original Fortran LAPACK purpose documentation for SGEEVX::

 SGEEVX computes for an N-by-N real nonsymmetric matrix A, the
 eigenvalues and, optionally, the left and/or right eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
 (RCONDE), and reciprocal condition numbers for the right
 eigenvectors (RCONDV).

 The right eigenvector v(j) of A satisfies
 A * v(j) = lambda(j) * v(j)
 where lambda(j) is its eigenvalue.
 The left eigenvector u(j) of A satisfies
 u(j)**H * A = lambda(j) * u(j)**H
 where u(j)**H denotes the conjugate-transpose of u(j).

 The computed eigenvectors are normalized to have Euclidean norm
 equal to 1 and largest component real.

 Balancing a matrix means permuting the rows and columns to make it
 more nearly upper triangular, and applying a diagonal similarity
 transformation D * A * D**(-1), where D is a diagonal matrix, to
 make its rows and columns closer in norm and the condition numbers
 of its eigenvalues and eigenvectors smaller. The computed
 reciprocal condition numbers correspond to the balanced matrix.
 Permuting rows and columns will not change the condition numbers
 (in exact arithmetic) but diagonal scaling will. For further
 explanation of balancing, see section 4.10.2 of the LAPACK
 Users' Guide.

Original Fortran LAPACK argument documentation for SGEEVX::

 BALANC is CHARACTER*1
  Indicates how the input matrix should be diagonally scaled
  and/or permuted to improve the conditioning of its
  eigenvalues.
  = 'N': Do not diagonally scale or permute;
  = 'P': Perform permutations to make the matrix more nearly
  upper triangular. Do not diagonally scale;
  = 'S': Diagonally scale the matrix, i.e. replace A by
  D*A*D**(-1), where D is a diagonal matrix chosen
  to make the rows and columns of A more equal in
  norm. Do not permute;
  = 'B': Both diagonally scale and permute A.
 
  Computed reciprocal condition numbers will be for the matrix
  after balancing and/or permuting. Permuting does not change
  condition numbers (in exact arithmetic), but balancing does.

 JOBVL is CHARACTER*1
  = 'N': left eigenvectors of A are not computed;
  = 'V': left eigenvectors of A are computed.
  If SENSE = 'E' or 'B', JOBVL must = 'V'.

 JOBVR is CHARACTER*1
  = 'N': right eigenvectors of A are not computed;
  = 'V': right eigenvectors of A are computed.
  If SENSE = 'E' or 'B', JOBVR must = 'V'.

 SENSE is CHARACTER*1
  Determines which reciprocal condition numbers are computed.
  = 'N': None are computed;
  = 'E': Computed for eigenvalues only;
  = 'V': Computed for right eigenvectors only;
  = 'B': Computed for eigenvalues and right eigenvectors.
 
  If SENSE = 'E' or 'B', both left and right eigenvectors
  must also be computed (JOBVL = 'V' and JOBVR = 'V').

 A is REAL array, dimension (LDA,N)
  On entry, the N-by-N matrix A.
  On exit, A has been overwritten. If JOBVL = 'V' or
  JOBVR = 'V', A contains the real Schur form of the balanced
  version of the input matrix A.

 WR is REAL array, dimension (N)

 WI is REAL array, dimension (N)
  WR and WI contain the real and imaginary parts,
  respectively, of the computed eigenvalues. Complex
  conjugate pairs of eigenvalues will appear consecutively
  with the eigenvalue having the positive imaginary part
  first.

 VL is REAL array, dimension (LDVL,N)
  If JOBVL = 'V', the left eigenvectors u(j) are stored one
  after another in the columns of VL, in the same order
  as their eigenvalues.
  If JOBVL = 'N', VL is not referenced.
  If the j-th eigenvalue is real, then u(j) = VL(:,j),
  the j-th column of VL.
  If the j-th and (j+1)-st eigenvalues form a complex
  conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
  u(j+1) = VL(:,j) - i*VL(:,j+1).

 VR is REAL array, dimension (LDVR,N)
  If JOBVR = 'V', the right eigenvectors v(j) are stored one
  after another in the columns of VR, in the same order
  as their eigenvalues.
  If JOBVR = 'N', VR is not referenced.
  If the j-th eigenvalue is real, then v(j) = VR(:,j),
  the j-th column of VR.
  If the j-th and (j+1)-st eigenvalues form a complex
  conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
  v(j+1) = VR(:,j) - i*VR(:,j+1).

 ILO is INTEGER

 IHI is INTEGER
  ILO and IHI are integer values determined when A was
  balanced. The balanced A(i,j) = 0 if I > J and 
  J = 1,...,ILO-1 or I = IHI+1,...,N.

 SCALE is REAL array, dimension (N)
  Details of the permutations and scaling factors applied
  when balancing A. If P(j) is the index of the row and column
  interchanged with row and column j, and D(j) is the scaling
  factor applied to row and column j, then
  SCALE(J) = P(J), for J = 1,...,ILO-1
  = D(J), for J = ILO,...,IHI
  = P(J) for J = IHI+1,...,N.
  The order in which the interchanges are made is N to IHI+1,
  then 1 to ILO-1.

 ABNRM is REAL
  The one-norm of the balanced matrix (the maximum
  of the sum of absolute values of elements of any column).

 RCONDE is REAL array, dimension (N)
  RCONDE(j) is the reciprocal condition number of the j-th
  eigenvalue.

 RCONDV is REAL array, dimension (N)
  RCONDV(j) is the reciprocal condition number of the j-th
  right eigenvector.

 */
inline proc geevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, a : [] c_float, wr : [] c_float, wi : [] c_float, vl : [] c_float, vr : [] c_float, ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float): c_int{
  return LAPACKE_sgeevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, wr, wi, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, ilo, ihi, scale, abnrm, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeevx for the type c_double.

For more information, see the documentation for :proc:`geevx`, or consult the Netlibs or Intel documentation.
 */
inline proc geevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, a : [] c_double, wr : [] c_double, wi : [] c_double, vl : [] c_double, vr : [] c_double, ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double): c_int{
  return LAPACKE_dgeevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, wr, wi, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, ilo, ihi, scale, abnrm, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeevx for the type lapack_complex_float.

For more information, see the documentation for :proc:`geevx`, or consult the Netlibs or Intel documentation.
 */
inline proc geevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, a : [] complex(64), w : [] complex(64), vl : [] complex(64), vr : [] complex(64), ref ilo : c_int, ref ihi : c_int, scale : [] c_float, ref abnrm : c_float, rconde : [] c_float, rcondv : [] c_float): c_int{
  return LAPACKE_cgeevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, ilo, ihi, scale, abnrm, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeevx for the type lapack_complex_double.

For more information, see the documentation for :proc:`geevx`, or consult the Netlibs or Intel documentation.
 */
inline proc geevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, a : [] complex(128), w : [] complex(128), vl : [] complex(128), vr : [] complex(128), ref ilo : c_int, ref ihi : c_int, scale : [] c_double, ref abnrm : c_double, rconde : [] c_double, rcondv : [] c_double): c_int{
  return LAPACKE_zgeevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, ilo, ihi, scale, abnrm, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgehrd for the type c_float.

Original Fortran LAPACK purpose documentation for SGEHRD::

 SGEHRD reduces a real general matrix A to upper Hessenberg form H by
 an orthogonal similarity transformation: Q**T * A * Q = H .

Original Fortran LAPACK argument documentation for SGEHRD::

 ILO is INTEGER

 IHI is INTEGER
 
  It is assumed that A is already upper triangular in rows
  and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
  set by a previous call to SGEBAL; otherwise they should be
  set to 1 and N respectively. See Further Details.
  1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

 A is REAL array, dimension (LDA,N)
  On entry, the N-by-N general matrix to be reduced.
  On exit, the upper triangle and the first subdiagonal of A
  are overwritten with the upper Hessenberg matrix H, and the
  elements below the first subdiagonal, with the array TAU,
  represent the orthogonal matrix Q as a product of elementary
  reflectors. See Further Details.

 TAU is REAL array, dimension (N-1)
  The scalar factors of the elementary reflectors (see Further
  Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
  zero.

 */
inline proc gehrd(matrix_order : lapack_memory_order, ilo : c_int, ihi : c_int, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sgehrd(matrix_order, (a.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgehrd for the type c_double.

For more information, see the documentation for :proc:`gehrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gehrd(matrix_order : lapack_memory_order, ilo : c_int, ihi : c_int, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dgehrd(matrix_order, (a.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgehrd for the type lapack_complex_float.

For more information, see the documentation for :proc:`gehrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gehrd(matrix_order : lapack_memory_order, ilo : c_int, ihi : c_int, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cgehrd(matrix_order, (a.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgehrd for the type lapack_complex_double.

For more information, see the documentation for :proc:`gehrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gehrd(matrix_order : lapack_memory_order, ilo : c_int, ihi : c_int, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zgehrd(matrix_order, (a.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgejsv for the type c_float.

Original Fortran LAPACK purpose documentation for SGEJSV::

 SGEJSV computes the singular value decomposition (SVD) of a real M-by-N
 matrix [A], where M >= N. The SVD of [A] is written as

 [A] = [U] * [SIGMA] * [V]^t,

 where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
 diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
 [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
 the singular values of [A]. The columns of [U] and [V] are the left and
 the right singular vectors of [A], respectively. The matrices [U] and [V]
 are computed and stored in the arrays U and V, respectively. The diagonal
 of [SIGMA] is computed and stored in the array SVA.

Original Fortran LAPACK argument documentation for SGEJSV::

 JOBA is CHARACTER*1
  Specifies the level of accuracy:
  = 'C': This option works well (high relative accuracy) if A = B * D,
  with well-conditioned B and arbitrary diagonal matrix D.
  The accuracy cannot be spoiled by COLUMN scaling. The
  accuracy of the computed output depends on the condition of
  B, and the procedure aims at the best theoretical accuracy.
  The relative error max_{i=1:N}|d sigma_i| / sigma_i is
  bounded by f(M,N)*epsilon* cond(B), independent of D.
  The input matrix is preprocessed with the QRF with column
  pivoting. This initial preprocessing and preconditioning by
  a rank revealing QR factorization is common for all values of
  JOBA. Additional actions are specified as follows:
  = 'E': Computation as with 'C' with an additional estimate of the
  condition number of B. It provides a realistic error bound.
  = 'F': If A = D1 * C * D2 with ill-conditioned diagonal scalings
  D1, D2, and well-conditioned matrix C, this option gives
  higher accuracy than the 'C' option. If the structure of the
  input matrix is not known, and relative accuracy is
  desirable, then this option is advisable. The input matrix A
  is preprocessed with QR factorization with FULL (row and
  column) pivoting.
  = 'G' Computation as with 'F' with an additional estimate of the
  condition number of B, where A=D*B. If A has heavily weighted
  rows, then using this condition number gives too pessimistic
  error bound.
  = 'A': Small singular values are the noise and the matrix is treated
  as numerically rank defficient. The error in the computed
  singular values is bounded by f(m,n)*epsilon*||A||.
  The computed SVD A = U * S * V^t restores A up to
  f(m,n)*epsilon*||A||.
  This gives the procedure the licence to discard (set to zero)
  all singular values below N*epsilon*||A||.
  = 'R': Similar as in 'A'. Rank revealing property of the initial
  QR factorization is used do reveal (using triangular factor)
  a gap sigma_{r+1} < epsilon * sigma_r in which case the
  numerical RANK is declared to be r. The SVD is computed with
  absolute error bounds, but more accurately than with 'A'.

 JOBU is CHARACTER*1
  Specifies whether to compute the columns of U:
  = 'U': N columns of U are returned in the array U.
  = 'F': full set of M left sing. vectors is returned in the array U.
  = 'W': U may be used as workspace of length M*N. See the description
  of U.
  = 'N': U is not computed.

 JOBV is CHARACTER*1
  Specifies whether to compute the matrix V:
  = 'V': N columns of V are returned in the array V; Jacobi rotations
  are not explicitly accumulated.
  = 'J': N columns of V are returned in the array V, but they are
  computed as the product of Jacobi rotations. This option is
  allowed only if JOBU .NE. 'N', i.e. in computing the full SVD.
  = 'W': V may be used as workspace of length N*N. See the description
  of V.
  = 'N': V is not computed.

 JOBR is CHARACTER*1
  Specifies the RANGE for the singular values. Issues the licence to
  set to zero small positive singular values if they are outside
  specified range. If A .NE. 0 is scaled so that the largest singular
  value of c*A is around SQRT(BIG), BIG=SLAMCH('O'), then JOBR issues
  the licence to kill columns of A whose norm in c*A is less than
  SQRT(SFMIN) (for JOBR.EQ.'R'), or less than SMALL=SFMIN/EPSLN,
  where SFMIN=SLAMCH('S'), EPSLN=SLAMCH('E').
  = 'N': Do not kill small columns of c*A. This option assumes that
  BLAS and QR factorizations and triangular solvers are
  implemented to work in that range. If the condition of A
  is greater than BIG, use SGESVJ.
  = 'R': RESTRICTED range for sigma(c*A) is [SQRT(SFMIN), SQRT(BIG)]
  (roughly, as described above). This option is recommended.
  ===========================
  For computing the singular values in the FULL range [SFMIN,BIG]
  use SGESVJ.

 JOBT is CHARACTER*1
  If the matrix is square then the procedure may determine to use
  transposed A if A^t seems to be better with respect to convergence.
  If the matrix is not square, JOBT is ignored. This is subject to
  changes in the future.
  The decision is based on two values of entropy over the adjoint
  orbit of A^t * A. See the descriptions of WORK(6) and WORK(7).
  = 'T': transpose if entropy test indicates possibly faster
  convergence of Jacobi process if A^t is taken as input. If A is
  replaced with A^t, then the row pivoting is included automatically.
  = 'N': do not speculate.
  This option can be used to compute only the singular values, or the
  full SVD (U, SIGMA and V). For only one set of singular vectors
  (U or V), the caller should provide both U and V, as one of the
  matrices is used as workspace if the matrix A is transposed.
  The implementer can easily remove this constraint and make the
  code more complicated. See the descriptions of U and V.

 JOBP is CHARACTER*1
  Issues the licence to introduce structured perturbations to drown
  denormalized numbers. This licence should be active if the
  denormals are poorly implemented, causing slow computation,
  especially in cases of fast convergence (!). For details see [1,2].
  For the sake of simplicity, this perturbations are included only
  when the full SVD or only the singular values are requested. The
  implementer/user can easily add the perturbation for the cases of
  computing one set of singular vectors.
  = 'P': introduce perturbation
  = 'N': do not perturb

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.

 SVA is REAL array, dimension (N)
  On exit,
  - For WORK(1)/WORK(2) = ONE: The singular values of A. During the
  computation SVA contains Euclidean column norms of the
  iterated matrices in the array A.
  - For WORK(1) .NE. WORK(2): The singular values of A are
  (WORK(1)/WORK(2)) * SVA(1:N). This factored form is used if
  sigma_max(A) overflows or if small singular values have been
  saved from underflow by scaling the input matrix A.
  - If JOBR='R' then some of the singular values may be returned
  as exact zeros obtained by "set to zero" because they are
  below the numerical rank threshold or are denormalized numbers.

 U is REAL array, dimension ( LDU, N )
  If JOBU = 'U', then U contains on exit the M-by-N matrix of
  the left singular vectors.
  If JOBU = 'F', then U contains on exit the M-by-M matrix of
  the left singular vectors, including an ONB
  of the orthogonal complement of the Range(A).
  If JOBU = 'W' .AND. (JOBV.EQ.'V' .AND. JOBT.EQ.'T' .AND. M.EQ.N),
  then U is used as workspace if the procedure
  replaces A with A^t. In that case, [V] is computed
  in U as left singular vectors of A^t and then
  copied back to the V array. This 'W' option is just
  a reminder to the caller that in this case U is
  reserved as workspace of length N*N.
  If JOBU = 'N' U is not referenced.

 V is REAL array, dimension ( LDV, N )
  If JOBV = 'V', 'J' then V contains on exit the N-by-N matrix of
  the right singular vectors;
  If JOBV = 'W', AND (JOBU.EQ.'U' AND JOBT.EQ.'T' AND M.EQ.N),
  then V is used as workspace if the pprocedure
  replaces A with A^t. In that case, [U] is computed
  in V as right singular vectors of A^t and then
  copied back to the U array. This 'W' option is just
  a reminder to the caller that in this case V is
  reserved as workspace of length N*N.
  If JOBV = 'N' V is not referenced.

 */
inline proc gejsv(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, jobr : string, jobt : string, jobp : string, a : [] c_float, sva : [] c_float, u : [] c_float, v : [] c_float, stat : [] c_float, istat : [] c_int): c_int{
  return LAPACKE_sgejsv(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobr) : c_char, ascii(jobt) : c_char, ascii(jobp) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sva, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, stat, istat);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgejsv for the type c_double.

For more information, see the documentation for :proc:`gejsv`, or consult the Netlibs or Intel documentation.
 */
inline proc gejsv(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, jobr : string, jobt : string, jobp : string, a : [] c_double, sva : [] c_double, u : [] c_double, v : [] c_double, stat : [] c_double, istat : [] c_int): c_int{
  return LAPACKE_dgejsv(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobr) : c_char, ascii(jobt) : c_char, ascii(jobp) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sva, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, stat, istat);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgelq2 for the type c_float.

Original Fortran LAPACK purpose documentation for SGELQ2::

 SGELQ2 computes an LQ factorization of a real m by n matrix A:
 A = L * Q.

Original Fortran LAPACK argument documentation for SGELQ2::

 A is REAL array, dimension (LDA,N)
  On entry, the m by n matrix A.
  On exit, the elements on and below the diagonal of the array
  contain the m by min(m,n) lower trapezoidal matrix L (L is
  lower triangular if m <= n); the elements above the diagonal,
  with the array TAU, represent the orthogonal matrix Q as a
  product of elementary reflectors (see Further Details).

 TAU is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc gelq2(matrix_order : lapack_memory_order, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sgelq2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgelq2 for the type c_double.

For more information, see the documentation for :proc:`gelq2`, or consult the Netlibs or Intel documentation.
 */
inline proc gelq2(matrix_order : lapack_memory_order, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dgelq2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgelq2 for the type lapack_complex_float.

For more information, see the documentation for :proc:`gelq2`, or consult the Netlibs or Intel documentation.
 */
inline proc gelq2(matrix_order : lapack_memory_order, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cgelq2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgelq2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`gelq2`, or consult the Netlibs or Intel documentation.
 */
inline proc gelq2(matrix_order : lapack_memory_order, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zgelq2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgelqf for the type c_float.

Original Fortran LAPACK purpose documentation for SGELQF::

 SGELQF computes an LQ factorization of a real M-by-N matrix A:
 A = L * Q.

Original Fortran LAPACK argument documentation for SGELQF::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, the elements on and below the diagonal of the array
  contain the m-by-min(m,n) lower trapezoidal matrix L (L is
  lower triangular if m <= n); the elements above the diagonal,
  with the array TAU, represent the orthogonal matrix Q as a
  product of elementary reflectors (see Further Details).

 TAU is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc gelqf(matrix_order : lapack_memory_order, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sgelqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgelqf for the type c_double.

For more information, see the documentation for :proc:`gelqf`, or consult the Netlibs or Intel documentation.
 */
inline proc gelqf(matrix_order : lapack_memory_order, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dgelqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgelqf for the type lapack_complex_float.

For more information, see the documentation for :proc:`gelqf`, or consult the Netlibs or Intel documentation.
 */
inline proc gelqf(matrix_order : lapack_memory_order, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cgelqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgelqf for the type lapack_complex_double.

For more information, see the documentation for :proc:`gelqf`, or consult the Netlibs or Intel documentation.
 */
inline proc gelqf(matrix_order : lapack_memory_order, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zgelqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgels for the type c_float.

Original Fortran LAPACK purpose documentation for SGELS::

 SGELS solves overdetermined or underdetermined real linear systems
 involving an M-by-N matrix A, or its transpose, using a QR or LQ
 factorization of A. It is assumed that A has full rank.

 The following options are provided: 

 1. If TRANS = 'N' and m >= n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A*X ||.

 2. If TRANS = 'N' and m < n: find the minimum norm solution of
 an underdetermined system A * X = B.

 3. If TRANS = 'T' and m >= n: find the minimum norm solution of
 an undetermined system A**T * X = B.

 4. If TRANS = 'T' and m < n: find the least squares solution of
 an overdetermined system, i.e., solve the least squares problem
 minimize || B - A**T * X ||.

 Several right hand side vectors b and solution vectors x can be 
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution 
 matrix X.

Original Fortran LAPACK argument documentation for SGELS::

 TRANS is CHARACTER*1
  = 'N': the linear system involves A;
  = 'T': the linear system involves A**T.

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit,
  if M >= N, A is overwritten by details of its QR
  factorization as returned by SGEQRF;
  if M < N, A is overwritten by details of its LQ
  factorization as returned by SGELQF.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the matrix B of right hand side vectors, stored
  columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
  if TRANS = 'T'. 
  On exit, if INFO = 0, B is overwritten by the solution
  vectors, stored columnwise:
  if TRANS = 'N' and m >= n, rows 1 to n of B contain the least
  squares solution vectors; the residual sum of squares for the
  solution in each column is given by the sum of squares of
  elements N+1 to M in that column;
  if TRANS = 'N' and m < n, rows 1 to N of B contain the
  minimum norm solution vectors;
  if TRANS = 'T' and m >= n, rows 1 to M of B contain the
  minimum norm solution vectors;
  if TRANS = 'T' and m < n, rows 1 to M of B contain the
  least squares solution vectors; the residual sum of squares
  for the solution in each column is given by the sum of
  squares of elements M+1 to N in that column.

 */
inline proc gels(matrix_order : lapack_memory_order, trans : string, a : [] c_float, b : [] c_float): c_int{
  return LAPACKE_sgels(matrix_order, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgels for the type c_double.

For more information, see the documentation for :proc:`gels`, or consult the Netlibs or Intel documentation.
 */
inline proc gels(matrix_order : lapack_memory_order, trans : string, a : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dgels(matrix_order, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgels for the type lapack_complex_float.

For more information, see the documentation for :proc:`gels`, or consult the Netlibs or Intel documentation.
 */
inline proc gels(matrix_order : lapack_memory_order, trans : string, a : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cgels(matrix_order, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgels for the type lapack_complex_double.

For more information, see the documentation for :proc:`gels`, or consult the Netlibs or Intel documentation.
 */
inline proc gels(matrix_order : lapack_memory_order, trans : string, a : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zgels(matrix_order, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgelsd for the type c_float.

Original Fortran LAPACK purpose documentation for SGELSD::

 SGELSD computes the minimum-norm solution to a real linear least
 squares problem:
 minimize 2-norm(| b - A*x |)
 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The problem is solved in three steps:
 (1) Reduce the coefficient matrix A to bidiagonal form with
 Householder transformations, reducing the original problem
 into a "bidiagonal least squares problem" (BLS)
 (2) Solve the BLS using a divide and conquer approach.
 (3) Apply back all the Householder tranformations to solve
 the original least squares problem.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for SGELSD::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, A has been destroyed.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the M-by-NRHS right hand side matrix B.
  On exit, B is overwritten by the N-by-NRHS solution
  matrix X. If m >= n and RANK = n, the residual
  sum-of-squares for the solution in the i-th column is given
  by the sum of squares of elements n+1:m in that column.

 S is REAL array, dimension (min(M,N))
  The singular values of A in decreasing order.
  The condition number of A in the 2-norm = S(1)/S(min(m,n)).

 RCOND is REAL
  RCOND is used to determine the effective rank of A.
  Singular values S(i) <= RCOND*S(1) are treated as zero.
  If RCOND < 0, machine precision is used instead.

 */
inline proc gelsd(matrix_order : lapack_memory_order, a : [] c_float, b : [] c_float, s : [] c_float, rcond : c_float): c_int{
  return LAPACKE_sgelsd(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, s, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgelsd for the type c_double.

For more information, see the documentation for :proc:`gelsd`, or consult the Netlibs or Intel documentation.
 */
inline proc gelsd(matrix_order : lapack_memory_order, a : [] c_double, b : [] c_double, s : [] c_double, rcond : c_double): c_int{
  return LAPACKE_dgelsd(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, s, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgelsd for the type lapack_complex_float.

For more information, see the documentation for :proc:`gelsd`, or consult the Netlibs or Intel documentation.
 */
inline proc gelsd(matrix_order : lapack_memory_order, a : [] complex(64), b : [] complex(64), s : [] c_float, rcond : c_float): c_int{
  return LAPACKE_cgelsd(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, s, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgelsd for the type lapack_complex_double.

For more information, see the documentation for :proc:`gelsd`, or consult the Netlibs or Intel documentation.
 */
inline proc gelsd(matrix_order : lapack_memory_order, a : [] complex(128), b : [] complex(128), s : [] c_double, rcond : c_double): c_int{
  return LAPACKE_zgelsd(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, s, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgelss for the type c_float.

Original Fortran LAPACK purpose documentation for SGELSS::

 SGELSS computes the minimum norm solution to a real linear least
 squares problem:

 Minimize 2-norm(| b - A*x |).

 using the singular value decomposition (SVD) of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
 X.

 The effective rank of A is determined by treating as zero those
 singular values which are less than RCOND times the largest singular
 value.

Original Fortran LAPACK argument documentation for SGELSS::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, the first min(m,n) rows of A are overwritten with
  its right singular vectors, stored rowwise.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the M-by-NRHS right hand side matrix B.
  On exit, B is overwritten by the N-by-NRHS solution
  matrix X. If m >= n and RANK = n, the residual
  sum-of-squares for the solution in the i-th column is given
  by the sum of squares of elements n+1:m in that column.

 S is REAL array, dimension (min(M,N))
  The singular values of A in decreasing order.
  The condition number of A in the 2-norm = S(1)/S(min(m,n)).

 RCOND is REAL
  RCOND is used to determine the effective rank of A.
  Singular values S(i) <= RCOND*S(1) are treated as zero.
  If RCOND < 0, machine precision is used instead.

 */
inline proc gelss(matrix_order : lapack_memory_order, a : [] c_float, b : [] c_float, s : [] c_float, rcond : c_float): c_int{
  return LAPACKE_sgelss(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, s, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgelss for the type c_double.

For more information, see the documentation for :proc:`gelss`, or consult the Netlibs or Intel documentation.
 */
inline proc gelss(matrix_order : lapack_memory_order, a : [] c_double, b : [] c_double, s : [] c_double, rcond : c_double): c_int{
  return LAPACKE_dgelss(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, s, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgelss for the type lapack_complex_float.

For more information, see the documentation for :proc:`gelss`, or consult the Netlibs or Intel documentation.
 */
inline proc gelss(matrix_order : lapack_memory_order, a : [] complex(64), b : [] complex(64), s : [] c_float, rcond : c_float): c_int{
  return LAPACKE_cgelss(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, s, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgelss for the type lapack_complex_double.

For more information, see the documentation for :proc:`gelss`, or consult the Netlibs or Intel documentation.
 */
inline proc gelss(matrix_order : lapack_memory_order, a : [] complex(128), b : [] complex(128), s : [] c_double, rcond : c_double): c_int{
  return LAPACKE_zgelss(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, s, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgelsy for the type c_float.

Original Fortran LAPACK purpose documentation for SGELSY::

 SGELSY computes the minimum-norm solution to a real linear least
 squares problem:
 minimize || A * X - B ||
 using a complete orthogonal factorization of A. A is an M-by-N
 matrix which may be rank-deficient.

 Several right hand side vectors b and solution vectors x can be
 handled in a single call; they are stored as the columns of the
 M-by-NRHS right hand side matrix B and the N-by-NRHS solution
 matrix X.

 The routine first computes a QR factorization with column pivoting:
 A * P = Q * [ R11 R12 ]
 [ 0 R22 ]
 with R11 defined as the largest leading submatrix whose estimated
 condition number is less than 1/RCOND. The order of R11, RANK,
 is the effective rank of A.

 Then, R22 is considered to be negligible, and R12 is annihilated
 by orthogonal transformations from the right, arriving at the
 complete orthogonal factorization:
 A * P = Q * [ T11 0 ] * Z
 [ 0 0 ]
 The minimum-norm solution is then
 X = P * Z**T [ inv(T11)*Q1**T*B ]
 [ 0 ]
 where Q1 consists of the first RANK columns of Q.

 This routine is basically identical to the original xGELSX except
 three differences:
 o The call to the subroutine xGEQPF has been substituted by the
 the call to the subroutine xGEQP3. This subroutine is a Blas-3
 version of the QR factorization with column pivoting.
 o Matrix B (the right hand side) is updated with Blas-3.
 o The permutation of matrix B (the right hand side) is faster and
 more simple.

Original Fortran LAPACK argument documentation for SGELSY::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, A has been overwritten by details of its
  complete orthogonal factorization.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the M-by-NRHS right hand side matrix B.
  On exit, the N-by-NRHS solution matrix X.

 JPVT is INTEGER array, dimension (N)
  On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
  to the front of AP, otherwise column i is a free column.
  On exit, if JPVT(i) = k, then the i-th column of AP
  was the k-th column of A.

 RCOND is REAL
  RCOND is used to determine the effective rank of A, which
  is defined as the order of the largest leading triangular
  submatrix R11 in the QR factorization with pivoting of A,
  whose estimated condition number < 1/RCOND.

 */
inline proc gelsy(matrix_order : lapack_memory_order, a : [] c_float, b : [] c_float, jpvt : [] c_int, rcond : c_float): c_int{
  return LAPACKE_sgelsy(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, jpvt, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgelsy for the type c_double.

For more information, see the documentation for :proc:`gelsy`, or consult the Netlibs or Intel documentation.
 */
inline proc gelsy(matrix_order : lapack_memory_order, a : [] c_double, b : [] c_double, jpvt : [] c_int, rcond : c_double): c_int{
  return LAPACKE_dgelsy(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, jpvt, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgelsy for the type lapack_complex_float.

For more information, see the documentation for :proc:`gelsy`, or consult the Netlibs or Intel documentation.
 */
inline proc gelsy(matrix_order : lapack_memory_order, a : [] complex(64), b : [] complex(64), jpvt : [] c_int, rcond : c_float): c_int{
  return LAPACKE_cgelsy(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, jpvt, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgelsy for the type lapack_complex_double.

For more information, see the documentation for :proc:`gelsy`, or consult the Netlibs or Intel documentation.
 */
inline proc gelsy(matrix_order : lapack_memory_order, a : [] complex(128), b : [] complex(128), jpvt : [] c_int, rcond : c_double): c_int{
  return LAPACKE_zgelsy(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, jpvt, rcond, (a.domain.dim(1).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeqlf for the type c_float.

Original Fortran LAPACK purpose documentation for SGEQLF::

 SGEQLF computes a QL factorization of a real M-by-N matrix A:
 A = Q * L.

Original Fortran LAPACK argument documentation for SGEQLF::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit,
  if m >= n, the lower triangle of the subarray
  A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
  if m <= n, the elements on and below the (n-m)-th
  superdiagonal contain the M-by-N lower trapezoidal matrix L;
  the remaining elements, with the array TAU, represent the
  orthogonal matrix Q as a product of elementary reflectors
  (see Further Details).

 TAU is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc geqlf(matrix_order : lapack_memory_order, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sgeqlf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeqlf for the type c_double.

For more information, see the documentation for :proc:`geqlf`, or consult the Netlibs or Intel documentation.
 */
inline proc geqlf(matrix_order : lapack_memory_order, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dgeqlf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeqlf for the type lapack_complex_float.

For more information, see the documentation for :proc:`geqlf`, or consult the Netlibs or Intel documentation.
 */
inline proc geqlf(matrix_order : lapack_memory_order, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cgeqlf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeqlf for the type lapack_complex_double.

For more information, see the documentation for :proc:`geqlf`, or consult the Netlibs or Intel documentation.
 */
inline proc geqlf(matrix_order : lapack_memory_order, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zgeqlf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeqp3 for the type c_float.

Original Fortran LAPACK purpose documentation for SGEQP3::

 SGEQP3 computes a QR factorization with column pivoting of a
 matrix A: A*P = Q*R using Level 3 BLAS.

Original Fortran LAPACK argument documentation for SGEQP3::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, the upper triangle of the array contains the
  min(M,N)-by-N upper trapezoidal matrix R; the elements below
  the diagonal, together with the array TAU, represent the
  orthogonal matrix Q as a product of min(M,N) elementary
  reflectors.

 JPVT is INTEGER array, dimension (N)
  On entry, if JPVT(J).ne.0, the J-th column of A is permuted
  to the front of A*P (a leading column); if JPVT(J)=0,
  the J-th column of A is a free column.
  On exit, if JPVT(J)=K, then the J-th column of A*P was the
  the K-th column of A.

 TAU is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors.

 */
inline proc geqp3(matrix_order : lapack_memory_order, a : [] c_float, jpvt : [] c_int, tau : [] c_float): c_int{
  return LAPACKE_sgeqp3(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, jpvt, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeqp3 for the type c_double.

For more information, see the documentation for :proc:`geqp3`, or consult the Netlibs or Intel documentation.
 */
inline proc geqp3(matrix_order : lapack_memory_order, a : [] c_double, jpvt : [] c_int, tau : [] c_double): c_int{
  return LAPACKE_dgeqp3(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, jpvt, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeqp3 for the type lapack_complex_float.

For more information, see the documentation for :proc:`geqp3`, or consult the Netlibs or Intel documentation.
 */
inline proc geqp3(matrix_order : lapack_memory_order, a : [] complex(64), jpvt : [] c_int, tau : [] complex(64)): c_int{
  return LAPACKE_cgeqp3(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, jpvt, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeqp3 for the type lapack_complex_double.

For more information, see the documentation for :proc:`geqp3`, or consult the Netlibs or Intel documentation.
 */
inline proc geqp3(matrix_order : lapack_memory_order, a : [] complex(128), jpvt : [] c_int, tau : [] complex(128)): c_int{
  return LAPACKE_zgeqp3(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, jpvt, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeqpf for the type c_float.

Original Fortran LAPACK purpose documentation for SGEQPF::

 This routine is deprecated and has been replaced by routine SGEQP3.

 SGEQPF computes a QR factorization with column pivoting of a
 real M-by-N matrix A: A*P = Q*R.

Original Fortran LAPACK argument documentation for SGEQPF::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, the upper triangle of the array contains the
  min(M,N)-by-N upper triangular matrix R; the elements
  below the diagonal, together with the array TAU,
  represent the orthogonal matrix Q as a product of
  min(m,n) elementary reflectors.

 JPVT is INTEGER array, dimension (N)
  On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
  to the front of A*P (a leading column); if JPVT(i) = 0,
  the i-th column of A is a free column.
  On exit, if JPVT(i) = k, then the i-th column of A*P
  was the k-th column of A.

 TAU is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors.

 */
inline proc geqpf(matrix_order : lapack_memory_order, a : [] c_float, jpvt : [] c_int, tau : [] c_float): c_int{
  return LAPACKE_sgeqpf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, jpvt, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeqpf for the type c_double.

For more information, see the documentation for :proc:`geqpf`, or consult the Netlibs or Intel documentation.
 */
inline proc geqpf(matrix_order : lapack_memory_order, a : [] c_double, jpvt : [] c_int, tau : [] c_double): c_int{
  return LAPACKE_dgeqpf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, jpvt, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeqpf for the type lapack_complex_float.

For more information, see the documentation for :proc:`geqpf`, or consult the Netlibs or Intel documentation.
 */
inline proc geqpf(matrix_order : lapack_memory_order, a : [] complex(64), jpvt : [] c_int, tau : [] complex(64)): c_int{
  return LAPACKE_cgeqpf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, jpvt, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeqpf for the type lapack_complex_double.

For more information, see the documentation for :proc:`geqpf`, or consult the Netlibs or Intel documentation.
 */
inline proc geqpf(matrix_order : lapack_memory_order, a : [] complex(128), jpvt : [] c_int, tau : [] complex(128)): c_int{
  return LAPACKE_zgeqpf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, jpvt, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeqr2 for the type c_float.

Original Fortran LAPACK purpose documentation for SGEQR2::

 SGEQR2 computes a QR factorization of a real m by n matrix A:
 A = Q * R.

Original Fortran LAPACK argument documentation for SGEQR2::

 A is REAL array, dimension (LDA,N)
  On entry, the m by n matrix A.
  On exit, the elements on and above the diagonal of the array
  contain the min(m,n) by n upper trapezoidal matrix R (R is
  upper triangular if m >= n); the elements below the diagonal,
  with the array TAU, represent the orthogonal matrix Q as a
  product of elementary reflectors (see Further Details).

 TAU is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc geqr2(matrix_order : lapack_memory_order, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sgeqr2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeqr2 for the type c_double.

For more information, see the documentation for :proc:`geqr2`, or consult the Netlibs or Intel documentation.
 */
inline proc geqr2(matrix_order : lapack_memory_order, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dgeqr2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeqr2 for the type lapack_complex_float.

For more information, see the documentation for :proc:`geqr2`, or consult the Netlibs or Intel documentation.
 */
inline proc geqr2(matrix_order : lapack_memory_order, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cgeqr2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeqr2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`geqr2`, or consult the Netlibs or Intel documentation.
 */
inline proc geqr2(matrix_order : lapack_memory_order, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zgeqr2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeqrf for the type c_float.

Original Fortran LAPACK purpose documentation for SGEQRF::

 SGEQRF computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

Original Fortran LAPACK argument documentation for SGEQRF::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, the elements on and above the diagonal of the array
  contain the min(M,N)-by-N upper trapezoidal matrix R (R is
  upper triangular if m >= n); the elements below the diagonal,
  with the array TAU, represent the orthogonal matrix Q as a
  product of min(m,n) elementary reflectors (see Further
  Details).

 TAU is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc geqrf(matrix_order : lapack_memory_order, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sgeqrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeqrf for the type c_double.

For more information, see the documentation for :proc:`geqrf`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrf(matrix_order : lapack_memory_order, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dgeqrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeqrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`geqrf`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrf(matrix_order : lapack_memory_order, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cgeqrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeqrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`geqrf`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrf(matrix_order : lapack_memory_order, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zgeqrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeqrfp for the type c_float.

Original Fortran LAPACK purpose documentation for SGEQRFP::

 SGEQRFP computes a QR factorization of a real M-by-N matrix A:
 A = Q * R.

Original Fortran LAPACK argument documentation for SGEQRFP::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, the elements on and above the diagonal of the array
  contain the min(M,N)-by-N upper trapezoidal matrix R (R is
  upper triangular if m >= n); the elements below the diagonal,
  with the array TAU, represent the orthogonal matrix Q as a
  product of min(m,n) elementary reflectors (see Further
  Details).

 TAU is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc geqrfp(matrix_order : lapack_memory_order, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sgeqrfp(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeqrfp for the type c_double.

For more information, see the documentation for :proc:`geqrfp`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrfp(matrix_order : lapack_memory_order, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dgeqrfp(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeqrfp for the type lapack_complex_float.

For more information, see the documentation for :proc:`geqrfp`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrfp(matrix_order : lapack_memory_order, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cgeqrfp(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeqrfp for the type lapack_complex_double.

For more information, see the documentation for :proc:`geqrfp`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrfp(matrix_order : lapack_memory_order, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zgeqrfp(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgerfs for the type c_float.

Original Fortran LAPACK purpose documentation for SGERFS::

 SGERFS improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates for
 the solution.

Original Fortran LAPACK argument documentation for SGERFS::

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 A is REAL array, dimension (LDA,N)
  The original N-by-N matrix A.

 AF is REAL array, dimension (LDAF,N)
  The factors L and U from the factorization A = P*L*U
  as computed by SGETRF.

 IPIV is INTEGER array, dimension (N)
  The pivot indices from SGETRF; for 1<=i<=N, row i of the
  matrix was interchanged with row IPIV(i).

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SGETRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc gerfs(matrix_order : lapack_memory_order, trans : string, a : [] c_float, af : [] c_float, ipiv : [] c_int, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sgerfs(matrix_order, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgerfs for the type c_double.

For more information, see the documentation for :proc:`gerfs`, or consult the Netlibs or Intel documentation.
 */
inline proc gerfs(matrix_order : lapack_memory_order, trans : string, a : [] c_double, af : [] c_double, ipiv : [] c_int, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dgerfs(matrix_order, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgerfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`gerfs`, or consult the Netlibs or Intel documentation.
 */
inline proc gerfs(matrix_order : lapack_memory_order, trans : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cgerfs(matrix_order, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgerfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`gerfs`, or consult the Netlibs or Intel documentation.
 */
inline proc gerfs(matrix_order : lapack_memory_order, trans : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zgerfs(matrix_order, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgerfsx for the type c_float.

Original Fortran LAPACK purpose documentation for SGERFSX::

 SGERFSX improves the computed solution to a system of linear
 equations and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED, R
 and C below. In this case, the solution and error bounds returned
 are for the original unequilibrated system.

Original Fortran LAPACK argument documentation for SGERFSX::

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done to A
  before calling this routine. This is needed to compute
  the solution and error bounds correctly.
  = 'N': No equilibration
  = 'R': Row equilibration, i.e., A has been premultiplied by
  diag(R).
  = 'C': Column equilibration, i.e., A has been postmultiplied
  by diag(C).
  = 'B': Both row and column equilibration, i.e., A has been
  replaced by diag(R) * A * diag(C).
  The right hand side B has been changed accordingly.

 A is REAL array, dimension (LDA,N)
  The original N-by-N matrix A.

 AF is REAL array, dimension (LDAF,N)
  The factors L and U from the factorization A = P*L*U
  as computed by SGETRF.

 IPIV is INTEGER array, dimension (N)
  The pivot indices from SGETRF; for 1<=i<=N, row i of the
  matrix was interchanged with row IPIV(i).

 R is REAL array, dimension (N)
  The row scale factors for A. If EQUED = 'R' or 'B', A is
  multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
  is not accessed. 
  If R is accessed, each element of R should be a power of the radix
  to ensure a reliable solution and error estimates. Scaling by
  powers of the radix does not cause rounding errors unless the
  result underflows or overflows. Rounding errors during scaling
  lead to refining with a matrix that is not equivalent to the
  input matrix, producing error estimates that may not be
  reliable.

 C is REAL array, dimension (N)
  The column scale factors for A. If EQUED = 'C' or 'B', A is
  multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
  is not accessed. 
  If C is accessed, each element of C should be a power of the radix
  to ensure a reliable solution and error estimates. Scaling by
  powers of the radix does not cause rounding errors unless the
  result underflows or overflows. Rounding errors during scaling
  lead to refining with a matrix that is not equivalent to the
  input matrix, producing error estimates that may not be
  reliable.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SGETRS.
  On exit, the improved solution matrix X.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc gerfsx(matrix_order : lapack_memory_order, trans : string, equed : string, a : [] c_float, af : [] c_float, ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_sgerfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgerfsx for the type c_double.

For more information, see the documentation for :proc:`gerfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc gerfsx(matrix_order : lapack_memory_order, trans : string, equed : string, a : [] c_double, af : [] c_double, ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_dgerfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgerfsx for the type lapack_complex_float.

For more information, see the documentation for :proc:`gerfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc gerfsx(matrix_order : lapack_memory_order, trans : string, equed : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, r : [] c_float, c : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_cgerfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgerfsx for the type lapack_complex_double.

For more information, see the documentation for :proc:`gerfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc gerfsx(matrix_order : lapack_memory_order, trans : string, equed : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, r : [] c_double, c : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zgerfsx(matrix_order, ascii(trans) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgerqf for the type c_float.

Original Fortran LAPACK purpose documentation for SGERQF::

 SGERQF computes an RQ factorization of a real M-by-N matrix A:
 A = R * Q.

Original Fortran LAPACK argument documentation for SGERQF::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit,
  if m <= n, the upper triangle of the subarray
  A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
  if m >= n, the elements on and above the (m-n)-th subdiagonal
  contain the M-by-N upper trapezoidal matrix R;
  the remaining elements, with the array TAU, represent the
  orthogonal matrix Q as a product of min(m,n) elementary
  reflectors (see Further Details).

 TAU is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc gerqf(matrix_order : lapack_memory_order, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sgerqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgerqf for the type c_double.

For more information, see the documentation for :proc:`gerqf`, or consult the Netlibs or Intel documentation.
 */
inline proc gerqf(matrix_order : lapack_memory_order, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dgerqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgerqf for the type lapack_complex_float.

For more information, see the documentation for :proc:`gerqf`, or consult the Netlibs or Intel documentation.
 */
inline proc gerqf(matrix_order : lapack_memory_order, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cgerqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgerqf for the type lapack_complex_double.

For more information, see the documentation for :proc:`gerqf`, or consult the Netlibs or Intel documentation.
 */
inline proc gerqf(matrix_order : lapack_memory_order, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zgerqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgesdd for the type c_float.

Original Fortran LAPACK purpose documentation for SGESDD::

 SGESDD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and right singular
 vectors. If singular vectors are desired, it uses a
 divide-and-conquer algorithm.

 The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns VT = V**T, not V.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for SGESDD::

 JOBZ is CHARACTER*1
  Specifies options for computing all or part of the matrix U:
  = 'A': all M columns of U and all N rows of V**T are
  returned in the arrays U and VT;
  = 'S': the first min(M,N) columns of U and the first
  min(M,N) rows of V**T are returned in the arrays U
  and VT;
  = 'O': If M >= N, the first N columns of U are overwritten
  on the array A and all rows of V**T are returned in
  the array VT;
  otherwise, all columns of U are returned in the
  array U and the first M rows of V**T are overwritten
  in the array A;
  = 'N': no columns of U or rows of V**T are computed.

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit,
  if JOBZ = 'O', A is overwritten with the first N columns
  of U (the left singular vectors, stored
  columnwise) if M >= N;
  A is overwritten with the first M rows
  of V**T (the right singular vectors, stored
  rowwise) otherwise.
  if JOBZ .ne. 'O', the contents of A are destroyed.

 S is REAL array, dimension (min(M,N))
  The singular values of A, sorted so that S(i) >= S(i+1).

 U is REAL array, dimension (LDU,UCOL)
  UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
  UCOL = min(M,N) if JOBZ = 'S'.
  If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
  orthogonal matrix U;
  if JOBZ = 'S', U contains the first min(M,N) columns of U
  (the left singular vectors, stored columnwise);
  if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.

 VT is REAL array, dimension (LDVT,N)
  If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
  N-by-N orthogonal matrix V**T;
  if JOBZ = 'S', VT contains the first min(M,N) rows of
  V**T (the right singular vectors, stored rowwise);
  if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.

 */
inline proc gesdd(matrix_order : lapack_memory_order, jobz : string, a : [] c_float, s : [] c_float, u : [] c_float, vt : [] c_float): c_int{
  return LAPACKE_sgesdd(matrix_order, ascii(jobz) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgesdd for the type c_double.

For more information, see the documentation for :proc:`gesdd`, or consult the Netlibs or Intel documentation.
 */
inline proc gesdd(matrix_order : lapack_memory_order, jobz : string, a : [] c_double, s : [] c_double, u : [] c_double, vt : [] c_double): c_int{
  return LAPACKE_dgesdd(matrix_order, ascii(jobz) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgesdd for the type lapack_complex_float.

For more information, see the documentation for :proc:`gesdd`, or consult the Netlibs or Intel documentation.
 */
inline proc gesdd(matrix_order : lapack_memory_order, jobz : string, a : [] complex(64), s : [] c_float, u : [] complex(64), vt : [] complex(64)): c_int{
  return LAPACKE_cgesdd(matrix_order, ascii(jobz) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgesdd for the type lapack_complex_double.

For more information, see the documentation for :proc:`gesdd`, or consult the Netlibs or Intel documentation.
 */
inline proc gesdd(matrix_order : lapack_memory_order, jobz : string, a : [] complex(128), s : [] c_double, u : [] complex(128), vt : [] complex(128)): c_int{
  return LAPACKE_zgesdd(matrix_order, ascii(jobz) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgesv for the type c_float.

Original Fortran LAPACK purpose documentation for SGESV::

 SGESV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as
 A = P * L * U,
 where P is a permutation matrix, L is unit lower triangular, and U is
 upper triangular. The factored form of A is then used to solve the
 system of equations A * X = B.

Original Fortran LAPACK argument documentation for SGESV::

 A is REAL array, dimension (LDA,N)
  On entry, the N-by-N coefficient matrix A.
  On exit, the factors L and U from the factorization
  A = P*L*U; the unit diagonal elements of L are not stored.

 IPIV is INTEGER array, dimension (N)
  The pivot indices that define the permutation matrix P;
  row i of the matrix was interchanged with row IPIV(i).

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS matrix of right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc gesv(matrix_order : lapack_memory_order, a : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_sgesv(matrix_order, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgesv for the type c_double.

For more information, see the documentation for :proc:`gesv`, or consult the Netlibs or Intel documentation.
 */
inline proc gesv(matrix_order : lapack_memory_order, a : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dgesv(matrix_order, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgesv for the type lapack_complex_float.

For more information, see the documentation for :proc:`gesv`, or consult the Netlibs or Intel documentation.
 */
inline proc gesv(matrix_order : lapack_memory_order, a : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_cgesv(matrix_order, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgesv for the type lapack_complex_double.

For more information, see the documentation for :proc:`gesv`, or consult the Netlibs or Intel documentation.
 */
inline proc gesv(matrix_order : lapack_memory_order, a : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zgesv(matrix_order, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsgesv for the type c_double.

Original Fortran LAPACK purpose documentation for DSGESV::

 DSGESV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 DSGESV first attempts to factorize the matrix in SINGLE PRECISION
 and use this factorization within an iterative refinement procedure
 to produce a solution with DOUBLE PRECISION normwise backward error
 quality (see below). If the approach fails the method switches to a
 DOUBLE PRECISION factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio SINGLE PRECISION performance over DOUBLE PRECISION
 performance is too small. A reasonable strategy should take the
 number of right-hand sides and the size of the matrix into account.
 This might be done with a call to ILAENV in the future. Up to now, we
 always try iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

Original Fortran LAPACK argument documentation for DSGESV::

 A is DOUBLE PRECISION array,
  dimension (LDA,N)
  On entry, the N-by-N coefficient matrix A.
  On exit, if iterative refinement has been successfully used
  (INFO.EQ.0 and ITER.GE.0, see description below), then A is
  unchanged, if double precision factorization has been used
  (INFO.EQ.0 and ITER.LT.0, see description below), then the
  array A contains the factors L and U from the factorization
  A = P*L*U; the unit diagonal elements of L are not stored.

 IPIV is INTEGER array, dimension (N)
  The pivot indices that define the permutation matrix P;
  row i of the matrix was interchanged with row IPIV(i).
  Corresponds either to the single precision factorization
  (if INFO.EQ.0 and ITER.GE.0) or the double precision
  factorization (if INFO.EQ.0 and ITER.LT.0).

 B is DOUBLE PRECISION array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is DOUBLE PRECISION array, dimension (LDX,NRHS)
  If INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc sgesv(matrix_order : lapack_memory_order, a : [] c_double, ipiv : [] c_int, b : [] c_double, x : [] c_double, ref chlapack_iter : c_int): c_int{
  return LAPACKE_dsgesv(matrix_order, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, chlapack_iter);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zcgesv for the type lapack_complex_double.

Original Fortran LAPACK purpose documentation for ZCGESV::

 ZCGESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 ZCGESV first attempts to factorize the matrix in COMPLEX and use this
 factorization within an iterative refinement procedure to produce a
 solution with COMPLEX*16 normwise backward error quality (see below).
 If the approach fails the method switches to a COMPLEX*16
 factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio COMPLEX performance over COMPLEX*16 performance is too
 small. A reasonable strategy should take the number of right-hand
 sides and the size of the matrix into account. This might be done
 with a call to ILAENV in the future. Up to now, we always try
 iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

Original Fortran LAPACK argument documentation for ZCGESV::

 A is COMPLEX*16 array,
  dimension (LDA,N)
  On entry, the N-by-N coefficient matrix A.
  On exit, if iterative refinement has been successfully used
  (INFO.EQ.0 and ITER.GE.0, see description below), then A is
  unchanged, if double precision factorization has been used
  (INFO.EQ.0 and ITER.LT.0, see description below), then the
  array A contains the factors L and U from the factorization
  A = P*L*U; the unit diagonal elements of L are not stored.

 IPIV is INTEGER array, dimension (N)
  The pivot indices that define the permutation matrix P;
  row i of the matrix was interchanged with row IPIV(i).
  Corresponds either to the single precision factorization
  (if INFO.EQ.0 and ITER.GE.0) or the double precision
  factorization (if INFO.EQ.0 and ITER.LT.0).

 B is COMPLEX*16 array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is COMPLEX*16 array, dimension (LDX,NRHS)
  If INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc cgesv(matrix_order : lapack_memory_order, a : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ref chlapack_iter : c_int): c_int{
  return LAPACKE_zcgesv(matrix_order, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, chlapack_iter);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgesvd for the type c_float.

Original Fortran LAPACK purpose documentation for SGESVD::

 SGESVD computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, optionally computing the left and/or right singular
 vectors. The SVD is written

 A = U * SIGMA * transpose(V)

 where SIGMA is an M-by-N matrix which is zero except for its
 min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA
 are the singular values of A; they are real and non-negative, and
 are returned in descending order. The first min(m,n) columns of
 U and V are the left and right singular vectors of A.

 Note that the routine returns V**T, not V.

Original Fortran LAPACK argument documentation for SGESVD::

 JOBU is CHARACTER*1
  Specifies options for computing all or part of the matrix U:
  = 'A': all M columns of U are returned in array U:
  = 'S': the first min(m,n) columns of U (the left singular
  vectors) are returned in the array U;
  = 'O': the first min(m,n) columns of U (the left singular
  vectors) are overwritten on the array A;
  = 'N': no columns of U (no left singular vectors) are
  computed.

 JOBVT is CHARACTER*1
  Specifies options for computing all or part of the matrix
  V**T:
  = 'A': all N rows of V**T are returned in the array VT;
  = 'S': the first min(m,n) rows of V**T (the right singular
  vectors) are returned in the array VT;
  = 'O': the first min(m,n) rows of V**T (the right singular
  vectors) are overwritten on the array A;
  = 'N': no rows of V**T (no right singular vectors) are
  computed.
 
  JOBVT and JOBU cannot both be 'O'.

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit,
  if JOBU = 'O', A is overwritten with the first min(m,n)
  columns of U (the left singular vectors,
  stored columnwise);
  if JOBVT = 'O', A is overwritten with the first min(m,n)
  rows of V**T (the right singular vectors,
  stored rowwise);
  if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
  are destroyed.

 S is REAL array, dimension (min(M,N))
  The singular values of A, sorted so that S(i) >= S(i+1).

 U is REAL array, dimension (LDU,UCOL)
  (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
  If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
  if JOBU = 'S', U contains the first min(m,n) columns of U
  (the left singular vectors, stored columnwise);
  if JOBU = 'N' or 'O', U is not referenced.

 VT is REAL array, dimension (LDVT,N)
  If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
  V**T;
  if JOBVT = 'S', VT contains the first min(m,n) rows of
  V**T (the right singular vectors, stored rowwise);
  if JOBVT = 'N' or 'O', VT is not referenced.

 */
inline proc gesvd(matrix_order : lapack_memory_order, jobu : string, jobvt : string, a : [] c_float, s : [] c_float, u : [] c_float, vt : [] c_float, superb : [] c_float): c_int{
  return LAPACKE_sgesvd(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int, superb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgesvd for the type c_double.

For more information, see the documentation for :proc:`gesvd`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvd(matrix_order : lapack_memory_order, jobu : string, jobvt : string, a : [] c_double, s : [] c_double, u : [] c_double, vt : [] c_double, superb : [] c_double): c_int{
  return LAPACKE_dgesvd(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int, superb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgesvd for the type lapack_complex_float.

For more information, see the documentation for :proc:`gesvd`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvd(matrix_order : lapack_memory_order, jobu : string, jobvt : string, a : [] complex(64), s : [] c_float, u : [] complex(64), vt : [] complex(64), superb : [] c_float): c_int{
  return LAPACKE_cgesvd(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int, superb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgesvd for the type lapack_complex_double.

For more information, see the documentation for :proc:`gesvd`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvd(matrix_order : lapack_memory_order, jobu : string, jobvt : string, a : [] complex(128), s : [] c_double, u : [] complex(128), vt : [] complex(128), superb : [] c_double): c_int{
  return LAPACKE_zgesvd(matrix_order, ascii(jobu) : c_char, ascii(jobvt) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, u, (u.domain.dim(2).size) : c_int, vt, (vt.domain.dim(2).size) : c_int, superb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgesvj for the type c_float.

Original Fortran LAPACK purpose documentation for SGESVJ::

 SGESVJ computes the singular value decomposition (SVD) of a real
 M-by-N matrix A, where M >= N. The SVD of A is written as
 [++] [xx] [x0] [xx]
 A = U * SIGMA * V^t, [++] = [xx] * [ox] * [xx]
 [++] [xx]
 where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
 matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
 of SIGMA are the singular values of A. The columns of U and V are the
 left and the right singular vectors of A, respectively.

Original Fortran LAPACK argument documentation for SGESVJ::

 JOBA is CHARACTER* 1
  Specifies the structure of A.
  = 'L': The input matrix A is lower triangular;
  = 'U': The input matrix A is upper triangular;
  = 'G': The input matrix A is general M-by-N matrix, M >= N.

 JOBU is CHARACTER*1
  Specifies whether to compute the left singular vectors
  (columns of U):
  = 'U': The left singular vectors corresponding to the nonzero
  singular values are computed and returned in the leading
  columns of A. See more details in the description of A.
  The default numerical orthogonality threshold is set to
  approximately TOL=CTOL*EPS, CTOL=SQRT(M), EPS=SLAMCH('E').
  = 'C': Analogous to JOBU='U', except that user can control the
  level of numerical orthogonality of the computed left
  singular vectors. TOL can be set to TOL = CTOL*EPS, where
  CTOL is given on input in the array WORK.
  No CTOL smaller than ONE is allowed. CTOL greater
  than 1 / EPS is meaningless. The option 'C'
  can be used if M*EPS is satisfactory orthogonality
  of the computed left singular vectors, so CTOL=M could
  save few sweeps of Jacobi rotations.
  See the descriptions of A and WORK(1).
  = 'N': The matrix U is not computed. However, see the
  description of A.

 JOBV is CHARACTER*1
  Specifies whether to compute the right singular vectors, that
  is, the matrix V:
  = 'V' : the matrix V is computed and returned in the array V
  = 'A' : the Jacobi rotations are applied to the MV-by-N
  array V. In other words, the right singular vector
  matrix V is not computed explicitly; instead it is
  applied to an MV-by-N matrix initially stored in the
  first MV rows of V.
  = 'N' : the matrix V is not computed and the array V is not
  referenced

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit,
  If JOBU .EQ. 'U' .OR. JOBU .EQ. 'C':
  If INFO .EQ. 0 :
  RANKA orthonormal columns of U are returned in the
  leading RANKA columns of the array A. Here RANKA <= N
  is the number of computed singular values of A that are
  above the underflow threshold SLAMCH('S'). The singular
  vectors corresponding to underflowed or zero singular
  values are not computed. The value of RANKA is returned
  in the array WORK as RANKA=NINT(WORK(2)). Also see the
  descriptions of SVA and WORK. The computed columns of U
  are mutually numerically orthogonal up to approximately
  TOL=SQRT(M)*EPS (default); or TOL=CTOL*EPS (JOBU.EQ.'C'),
  see the description of JOBU.
  If INFO .GT. 0,
  the procedure SGESVJ did not converge in the given number
  of iterations (sweeps). In that case, the computed
  columns of U may not be orthogonal up to TOL. The output
  U (stored in A), SIGMA (given by the computed singular
  values in SVA(1:N)) and V is still a decomposition of the
  input matrix A in the sense that the residual
  ||A-SCALE*U*SIGMA*V^T||_2 / ||A||_2 is small.
  If JOBU .EQ. 'N':
  If INFO .EQ. 0 :
  Note that the left singular vectors are 'for free' in the
  one-sided Jacobi SVD algorithm. However, if only the
  singular values are needed, the level of numerical
  orthogonality of U is not an issue and iterations are
  stopped when the columns of the iterated matrix are
  numerically orthogonal up to approximately M*EPS. Thus,
  on exit, A contains the columns of U scaled with the
  corresponding singular values.
  If INFO .GT. 0 :
  the procedure SGESVJ did not converge in the given number
  of iterations (sweeps).

 SVA is REAL array, dimension (N)
  On exit,
  If INFO .EQ. 0 :
  depending on the value SCALE = WORK(1), we have:
  If SCALE .EQ. ONE:
  SVA(1:N) contains the computed singular values of A.
  During the computation SVA contains the Euclidean column
  norms of the iterated matrices in the array A.
  If SCALE .NE. ONE:
  The singular values of A are SCALE*SVA(1:N), and this
  factored representation is due to the fact that some of the
  singular values of A might underflow or overflow.
 
  If INFO .GT. 0 :
  the procedure SGESVJ did not converge in the given number of
  iterations (sweeps) and SCALE*SVA(1:N) may not be accurate.

 MV is INTEGER
  If JOBV .EQ. 'A', then the product of Jacobi rotations in SGESVJ
  is applied to the first MV rows of V. See the description of JOBV.

 V is REAL array, dimension (LDV,N)
  If JOBV = 'V', then V contains on exit the N-by-N matrix of
  the right singular vectors;
  If JOBV = 'A', then V contains the product of the computed right
  singular vector matrix and the initial matrix in
  the array V.
  If JOBV = 'N', then V is not referenced.

 */
inline proc gesvj(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, a : [] c_float, sva : [] c_float, mv : c_int, v : [] c_float, stat : [] c_float): c_int{
  return LAPACKE_sgesvj(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sva, mv, v, (v.domain.dim(2).size) : c_int, stat);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgesvj for the type c_double.

For more information, see the documentation for :proc:`gesvj`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvj(matrix_order : lapack_memory_order, joba : string, jobu : string, jobv : string, a : [] c_double, sva : [] c_double, mv : c_int, v : [] c_double, stat : [] c_double): c_int{
  return LAPACKE_dgesvj(matrix_order, ascii(joba) : c_char, ascii(jobu) : c_char, ascii(jobv) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sva, mv, v, (v.domain.dim(2).size) : c_int, stat);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgesvx for the type c_float.

Original Fortran LAPACK purpose documentation for SGESVX::

 SGESVX uses the LU factorization to compute the solution to a real
 system of linear equations
 A * X = B,
 where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for SGESVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AF and IPIV contain the factored form of A.
  If EQUED is not 'N', the matrix A has been
  equilibrated with scaling factors given by R and C.
  A, AF, and IPIV are not modified.
  = 'N': The matrix A will be copied to AF and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AF and factored.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Transpose)

 A is REAL array, dimension (LDA,N)
  On entry, the N-by-N matrix A. If FACT = 'F' and EQUED is
  not 'N', then A must have been equilibrated by the scaling
  factors in R and/or C. A is not modified if FACT = 'F' or
  'N', or if FACT = 'E' and EQUED = 'N' on exit.
 
  On exit, if EQUED .ne. 'N', A is scaled as follows:
  EQUED = 'R': A := diag(R) * A
  EQUED = 'C': A := A * diag(C)
  EQUED = 'B': A := diag(R) * A * diag(C).

 AF is REAL array, dimension (LDAF,N)
  If FACT = 'F', then AF is an input argument and on entry
  contains the factors L and U from the factorization
  A = P*L*U as computed by SGETRF. If EQUED .ne. 'N', then
  AF is the factored form of the equilibrated matrix A.
 
  If FACT = 'N', then AF is an output argument and on exit
  returns the factors L and U from the factorization A = P*L*U
  of the original matrix A.
 
  If FACT = 'E', then AF is an output argument and on exit
  returns the factors L and U from the factorization A = P*L*U
  of the equilibrated matrix A (see the description of A for
  the form of the equilibrated matrix).

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains the pivot indices from the factorization A = P*L*U
  as computed by SGETRF; row i of the matrix was interchanged
  with row IPIV(i).
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains the pivot indices from the factorization A = P*L*U
  of the original matrix A.
 
  If FACT = 'E', then IPIV is an output argument and on exit
  contains the pivot indices from the factorization A = P*L*U
  of the equilibrated matrix A.

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'R': Row equilibration, i.e., A has been premultiplied by
  diag(R).
  = 'C': Column equilibration, i.e., A has been postmultiplied
  by diag(C).
  = 'B': Both row and column equilibration, i.e., A has been
  replaced by diag(R) * A * diag(C).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 R is REAL array, dimension (N)
  The row scale factors for A. If EQUED = 'R' or 'B', A is
  multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
  is not accessed. R is an input argument if FACT = 'F';
  otherwise, R is an output argument. If FACT = 'F' and
  EQUED = 'R' or 'B', each element of R must be positive.

 C is REAL array, dimension (N)
  The column scale factors for A. If EQUED = 'C' or 'B', A is
  multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
  is not accessed. C is an input argument if FACT = 'F';
  otherwise, C is an output argument. If FACT = 'F' and
  EQUED = 'C' or 'B', each element of C must be positive.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit,
  if EQUED = 'N', B is not modified;
  if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
  diag(R)*B;
  if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
  overwritten by diag(C)*B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
  to the original system of equations. Note that A and B are
  modified on exit if EQUED .ne. 'N', and the solution to the
  equilibrated system is inv(diag(C))*X if TRANS = 'N' and
  EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
  and EQUED = 'R' or 'B'.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A after equilibration (if done). If RCOND is less than the
  machine precision (in particular, if RCOND = 0), the matrix
  is singular to working precision. This condition is
  indicated by a return code of INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc gesvx(matrix_order : lapack_memory_order, fact : string, trans : string, a : [] c_float, af : [] c_float, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float): c_int{
  return LAPACKE_sgesvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr, rpivot);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgesvx for the type c_double.

For more information, see the documentation for :proc:`gesvx`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvx(matrix_order : lapack_memory_order, fact : string, trans : string, a : [] c_double, af : [] c_double, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double): c_int{
  return LAPACKE_dgesvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr, rpivot);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgesvx for the type lapack_complex_float.

For more information, see the documentation for :proc:`gesvx`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvx(matrix_order : lapack_memory_order, fact : string, trans : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float, rpivot : [] c_float): c_int{
  return LAPACKE_cgesvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr, rpivot);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgesvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`gesvx`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvx(matrix_order : lapack_memory_order, fact : string, trans : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double, rpivot : [] c_double): c_int{
  return LAPACKE_zgesvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr, rpivot);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgesvxx for the type c_float.

Original Fortran LAPACK purpose documentation for SGESVXX::

 SGESVXX uses the LU factorization to compute the solution to a
 real system of linear equations A * X = B, where A is an
 N-by-N matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SGESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SGESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SGESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SGESVXX would itself produce.

Original Fortran LAPACK argument documentation for SGESVXX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AF and IPIV contain the factored form of A.
  If EQUED is not 'N', the matrix A has been
  equilibrated with scaling factors given by R and C.
  A, AF, and IPIV are not modified.
  = 'N': The matrix A will be copied to AF and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AF and factored.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate Transpose = Transpose)

 A is REAL array, dimension (LDA,N)
  On entry, the N-by-N matrix A. If FACT = 'F' and EQUED is
  not 'N', then A must have been equilibrated by the scaling
  factors in R and/or C. A is not modified if FACT = 'F' or
  'N', or if FACT = 'E' and EQUED = 'N' on exit.
 
  On exit, if EQUED .ne. 'N', A is scaled as follows:
  EQUED = 'R': A := diag(R) * A
  EQUED = 'C': A := A * diag(C)
  EQUED = 'B': A := diag(R) * A * diag(C).

 AF is REAL array, dimension (LDAF,N)
  If FACT = 'F', then AF is an input argument and on entry
  contains the factors L and U from the factorization
  A = P*L*U as computed by SGETRF. If EQUED .ne. 'N', then
  AF is the factored form of the equilibrated matrix A.
 
  If FACT = 'N', then AF is an output argument and on exit
  returns the factors L and U from the factorization A = P*L*U
  of the original matrix A.
 
  If FACT = 'E', then AF is an output argument and on exit
  returns the factors L and U from the factorization A = P*L*U
  of the equilibrated matrix A (see the description of A for
  the form of the equilibrated matrix).

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains the pivot indices from the factorization A = P*L*U
  as computed by SGETRF; row i of the matrix was interchanged
  with row IPIV(i).
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains the pivot indices from the factorization A = P*L*U
  of the original matrix A.
 
  If FACT = 'E', then IPIV is an output argument and on exit
  contains the pivot indices from the factorization A = P*L*U
  of the equilibrated matrix A.

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'R': Row equilibration, i.e., A has been premultiplied by
  diag(R).
  = 'C': Column equilibration, i.e., A has been postmultiplied
  by diag(C).
  = 'B': Both row and column equilibration, i.e., A has been
  replaced by diag(R) * A * diag(C).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 R is REAL array, dimension (N)
  The row scale factors for A. If EQUED = 'R' or 'B', A is
  multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
  is not accessed. R is an input argument if FACT = 'F';
  otherwise, R is an output argument. If FACT = 'F' and
  EQUED = 'R' or 'B', each element of R must be positive.
  If R is output, each element of R is a power of the radix.
  If R is input, each element of R should be a power of the radix
  to ensure a reliable solution and error estimates. Scaling by
  powers of the radix does not cause rounding errors unless the
  result underflows or overflows. Rounding errors during scaling
  lead to refining with a matrix that is not equivalent to the
  input matrix, producing error estimates that may not be
  reliable.

 C is REAL array, dimension (N)
  The column scale factors for A. If EQUED = 'C' or 'B', A is
  multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
  is not accessed. C is an input argument if FACT = 'F';
  otherwise, C is an output argument. If FACT = 'F' and
  EQUED = 'C' or 'B', each element of C must be positive.
  If C is output, each element of C is a power of the radix.
  If C is input, each element of C should be a power of the radix
  to ensure a reliable solution and error estimates. Scaling by
  powers of the radix does not cause rounding errors unless the
  result underflows or overflows. Rounding errors during scaling
  lead to refining with a matrix that is not equivalent to the
  input matrix, producing error estimates that may not be
  reliable.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit,
  if EQUED = 'N', B is not modified;
  if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
  diag(R)*B;
  if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
  overwritten by diag(C)*B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0, the N-by-NRHS solution matrix X to the original
  system of equations. Note that A and B are modified on exit
  if EQUED .ne. 'N', and the solution to the equilibrated system is
  inv(diag(C))*X if TRANS = 'N' and EQUED = 'C' or 'B', or
  inv(diag(R))*X if TRANS = 'T' or 'C' and EQUED = 'R' or 'B'.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 RPVGRW is REAL
  Reciprocal pivot growth. On exit, this contains the reciprocal
  pivot growth factor norm(A)/norm(U). The "max absolute element"
  norm is used. If this is much less than 1, then the stability of
  the LU factorization of the (equilibrated) matrix A could be poor.
  This also means that the solution X, estimated condition numbers,
  and error bounds could be unreliable. If factorization fails with
  0<INFO<=N, then this contains the reciprocal pivot growth factor
  for the leading INFO columns of A. In SGESVX, this quantity is
  returned in WORK(1).

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc gesvxx(matrix_order : lapack_memory_order, fact : string, trans : string, a : [] c_float, af : [] c_float, ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_sgesvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgesvxx for the type c_double.

For more information, see the documentation for :proc:`gesvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvxx(matrix_order : lapack_memory_order, fact : string, trans : string, a : [] c_double, af : [] c_double, ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_dgesvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgesvxx for the type lapack_complex_float.

For more information, see the documentation for :proc:`gesvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvxx(matrix_order : lapack_memory_order, fact : string, trans : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, ref equed : string, r : [] c_float, c : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_cgesvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgesvxx for the type lapack_complex_double.

For more information, see the documentation for :proc:`gesvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc gesvxx(matrix_order : lapack_memory_order, fact : string, trans : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, ref equed : string, r : [] c_double, c : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zgesvxx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, r, c, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgetf2 for the type c_float.

Original Fortran LAPACK purpose documentation for SGETF2::

 SGETF2 computes an LU factorization of a general m-by-n matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 2 BLAS version of the algorithm.

Original Fortran LAPACK argument documentation for SGETF2::

 A is REAL array, dimension (LDA,N)
  On entry, the m by n matrix to be factored.
  On exit, the factors L and U from the factorization
  A = P*L*U; the unit diagonal elements of L are not stored.

 IPIV is INTEGER array, dimension (min(M,N))
  The pivot indices; for 1 <= i <= min(M,N), row i of the
  matrix was interchanged with row IPIV(i).

 */
inline proc getf2(matrix_order : lapack_memory_order, a : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_sgetf2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgetf2 for the type c_double.

For more information, see the documentation for :proc:`getf2`, or consult the Netlibs or Intel documentation.
 */
inline proc getf2(matrix_order : lapack_memory_order, a : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dgetf2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgetf2 for the type lapack_complex_float.

For more information, see the documentation for :proc:`getf2`, or consult the Netlibs or Intel documentation.
 */
inline proc getf2(matrix_order : lapack_memory_order, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_cgetf2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgetf2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`getf2`, or consult the Netlibs or Intel documentation.
 */
inline proc getf2(matrix_order : lapack_memory_order, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zgetf2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgetrf for the type c_float.

Original Fortran LAPACK purpose documentation for SGETRF::

 SGETRF computes an LU factorization of a general M-by-N matrix A
 using partial pivoting with row interchanges.

 The factorization has the form
 A = P * L * U
 where P is a permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if m > n), and U is upper
 triangular (upper trapezoidal if m < n).

 This is the right-looking Level 3 BLAS version of the algorithm.

Original Fortran LAPACK argument documentation for SGETRF::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix to be factored.
  On exit, the factors L and U from the factorization
  A = P*L*U; the unit diagonal elements of L are not stored.

 IPIV is INTEGER array, dimension (min(M,N))
  The pivot indices; for 1 <= i <= min(M,N), row i of the
  matrix was interchanged with row IPIV(i).

 */
inline proc getrf(matrix_order : lapack_memory_order, a : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_sgetrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgetrf for the type c_double.

For more information, see the documentation for :proc:`getrf`, or consult the Netlibs or Intel documentation.
 */
inline proc getrf(matrix_order : lapack_memory_order, a : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dgetrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgetrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`getrf`, or consult the Netlibs or Intel documentation.
 */
inline proc getrf(matrix_order : lapack_memory_order, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_cgetrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgetrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`getrf`, or consult the Netlibs or Intel documentation.
 */
inline proc getrf(matrix_order : lapack_memory_order, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zgetrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgetri for the type c_float.

Original Fortran LAPACK purpose documentation for SGETRI::

 SGETRI computes the inverse of a matrix using the LU factorization
 computed by SGETRF.

 This method inverts U and then computes inv(A) by solving the system
 inv(A)*L = inv(U) for inv(A).

Original Fortran LAPACK argument documentation for SGETRI::

 A is REAL array, dimension (LDA,N)
  On entry, the factors L and U from the factorization
  A = P*L*U as computed by SGETRF.
  On exit, if INFO = 0, the inverse of the original matrix A.

 IPIV is INTEGER array, dimension (N)
  The pivot indices from SGETRF; for 1<=i<=N, row i of the
  matrix was interchanged with row IPIV(i).

 */
inline proc getri(matrix_order : lapack_memory_order, a : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_sgetri(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgetri for the type c_double.

For more information, see the documentation for :proc:`getri`, or consult the Netlibs or Intel documentation.
 */
inline proc getri(matrix_order : lapack_memory_order, a : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dgetri(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgetri for the type lapack_complex_float.

For more information, see the documentation for :proc:`getri`, or consult the Netlibs or Intel documentation.
 */
inline proc getri(matrix_order : lapack_memory_order, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_cgetri(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgetri for the type lapack_complex_double.

For more information, see the documentation for :proc:`getri`, or consult the Netlibs or Intel documentation.
 */
inline proc getri(matrix_order : lapack_memory_order, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zgetri(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgetrs for the type c_float.

Original Fortran LAPACK purpose documentation for SGETRS::

 SGETRS solves a system of linear equations
 A * X = B or A**T * X = B
 with a general N-by-N matrix A using the LU factorization computed
 by SGETRF.

Original Fortran LAPACK argument documentation for SGETRS::

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T* X = B (Transpose)
  = 'C': A**T* X = B (Conjugate transpose = Transpose)

 A is REAL array, dimension (LDA,N)
  The factors L and U from the factorization A = P*L*U
  as computed by SGETRF.

 IPIV is INTEGER array, dimension (N)
  The pivot indices from SGETRF; for 1<=i<=N, row i of the
  matrix was interchanged with row IPIV(i).

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc getrs(matrix_order : lapack_memory_order, trans : string, a : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_sgetrs(matrix_order, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgetrs for the type c_double.

For more information, see the documentation for :proc:`getrs`, or consult the Netlibs or Intel documentation.
 */
inline proc getrs(matrix_order : lapack_memory_order, trans : string, a : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dgetrs(matrix_order, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgetrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`getrs`, or consult the Netlibs or Intel documentation.
 */
inline proc getrs(matrix_order : lapack_memory_order, trans : string, a : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_cgetrs(matrix_order, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgetrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`getrs`, or consult the Netlibs or Intel documentation.
 */
inline proc getrs(matrix_order : lapack_memory_order, trans : string, a : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zgetrs(matrix_order, ascii(trans) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggbak for the type c_float.

Original Fortran LAPACK purpose documentation for SGGBAK::

 SGGBAK forms the right or left eigenvectors of a real generalized
 eigenvalue problem A*x = lambda*B*x, by backward transformation on
 the computed eigenvectors of the balanced pair of matrices output by
 SGGBAL.

Original Fortran LAPACK argument documentation for SGGBAK::

 JOB is CHARACTER*1
  Specifies the type of backward transformation required:
  = 'N': do nothing, return immediately;
  = 'P': do backward transformation for permutation only;
  = 'S': do backward transformation for scaling only;
  = 'B': do backward transformations for both permutation and
  scaling.
  JOB must be the same as the argument JOB supplied to SGGBAL.

 SIDE is CHARACTER*1
  = 'R': V contains right eigenvectors;
  = 'L': V contains left eigenvectors.

 ILO is INTEGER

 IHI is INTEGER
  The integers ILO and IHI determined by SGGBAL.
  1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

 LSCALE is REAL array, dimension (N)
  Details of the permutations and/or scaling factors applied
  to the left side of A and B, as returned by SGGBAL.

 RSCALE is REAL array, dimension (N)
  Details of the permutations and/or scaling factors applied
  to the right side of A and B, as returned by SGGBAL.

 V is REAL array, dimension (LDV,M)
  On entry, the matrix of right or left eigenvectors to be
  transformed, as returned by STGEVC.
  On exit, V is overwritten by the transformed eigenvectors.

 */
inline proc ggbak(matrix_order : lapack_memory_order, job : string, side : string, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, v : [] c_float): c_int{
  return LAPACKE_sggbak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(1).size else v.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(2).size else v.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggbak for the type c_double.

For more information, see the documentation for :proc:`ggbak`, or consult the Netlibs or Intel documentation.
 */
inline proc ggbak(matrix_order : lapack_memory_order, job : string, side : string, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, v : [] c_double): c_int{
  return LAPACKE_dggbak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(1).size else v.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(2).size else v.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggbak for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggbak`, or consult the Netlibs or Intel documentation.
 */
inline proc ggbak(matrix_order : lapack_memory_order, job : string, side : string, ilo : c_int, ihi : c_int, lscale : [] c_float, rscale : [] c_float, v : [] complex(64)): c_int{
  return LAPACKE_cggbak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(1).size else v.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(2).size else v.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggbak for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggbak`, or consult the Netlibs or Intel documentation.
 */
inline proc ggbak(matrix_order : lapack_memory_order, job : string, side : string, ilo : c_int, ihi : c_int, lscale : [] c_double, rscale : [] c_double, v : [] complex(128)): c_int{
  return LAPACKE_zggbak(matrix_order, ascii(job) : c_char, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(1).size else v.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale, (if matrix_order == lapack_memory_order.row_major then v.domain.dim(2).size else v.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggbal for the type c_float.

Original Fortran LAPACK purpose documentation for SGGBAL::

 SGGBAL balances a pair of general real matrices (A,B). This
 involves, first, permuting A and B by similarity transformations to
 isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
 elements on the diagonal; and second, applying a diagonal similarity
 transformation to rows and columns ILO to IHI to make the rows
 and columns as close in norm as possible. Both steps are optional.

 Balancing may reduce the 1-norm of the matrices, and improve the
 accuracy of the computed eigenvalues and/or eigenvectors in the
 generalized eigenvalue problem A*x = lambda*B*x.

Original Fortran LAPACK argument documentation for SGGBAL::

 JOB is CHARACTER*1
  Specifies the operations to be performed on A and B:
  = 'N': none: simply set ILO = 1, IHI = N, LSCALE(I) = 1.0
  and RSCALE(I) = 1.0 for i = 1,...,N.
  = 'P': permute only;
  = 'S': scale only;
  = 'B': both permute and scale.

 A is REAL array, dimension (LDA,N)
  On entry, the input matrix A.
  On exit, A is overwritten by the balanced matrix.
  If JOB = 'N', A is not referenced.

 B is REAL array, dimension (LDB,N)
  On entry, the input matrix B.
  On exit, B is overwritten by the balanced matrix.
  If JOB = 'N', B is not referenced.

 ILO is INTEGER

 IHI is INTEGER
  ILO and IHI are set to integers such that on exit
  A(i,j) = 0 and B(i,j) = 0 if i > j and
  j = 1,...,ILO-1 or i = IHI+1,...,N.
  If JOB = 'N' or 'S', ILO = 1 and IHI = N.

 LSCALE is REAL array, dimension (N)
  Details of the permutations and scaling factors applied
  to the left side of A and B. If P(j) is the index of the
  row interchanged with row j, and D(j)
  is the scaling factor applied to row j, then
  LSCALE(j) = P(j) for J = 1,...,ILO-1
  = D(j) for J = ILO,...,IHI
  = P(j) for J = IHI+1,...,N.
  The order in which the interchanges are made is N to IHI+1,
  then 1 to ILO-1.

 RSCALE is REAL array, dimension (N)
  Details of the permutations and scaling factors applied
  to the right side of A and B. If P(j) is the index of the
  column interchanged with column j, and D(j)
  is the scaling factor applied to column j, then
  LSCALE(j) = P(j) for J = 1,...,ILO-1
  = D(j) for J = ILO,...,IHI
  = P(j) for J = IHI+1,...,N.
  The order in which the interchanges are made is N to IHI+1,
  then 1 to ILO-1.

 */
inline proc ggbal(matrix_order : lapack_memory_order, job : string, a : [] c_float, b : [] c_float, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float): c_int{
  return LAPACKE_sggbal(matrix_order, ascii(job) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggbal for the type c_double.

For more information, see the documentation for :proc:`ggbal`, or consult the Netlibs or Intel documentation.
 */
inline proc ggbal(matrix_order : lapack_memory_order, job : string, a : [] c_double, b : [] c_double, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double): c_int{
  return LAPACKE_dggbal(matrix_order, ascii(job) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggbal for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggbal`, or consult the Netlibs or Intel documentation.
 */
inline proc ggbal(matrix_order : lapack_memory_order, job : string, a : [] complex(64), b : [] complex(64), ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float): c_int{
  return LAPACKE_cggbal(matrix_order, ascii(job) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggbal for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggbal`, or consult the Netlibs or Intel documentation.
 */
inline proc ggbal(matrix_order : lapack_memory_order, job : string, a : [] complex(128), b : [] complex(128), ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double): c_int{
  return LAPACKE_zggbal(matrix_order, ascii(job) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgges for the type c_float.

Original Fortran LAPACK purpose documentation for SGGES::

 SGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
 the generalized eigenvalues, the generalized real Schur form (S,T),
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T.The
 leading columns of VSL and VSR then form an orthonormal basis for the
 corresponding left and right eigenspaces (deflating subspaces).

 (If only the generalized eigenvalues are needed, use the driver
 SGGEV instead, which is faster.)

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

Original Fortran LAPACK argument documentation for SGGES::

 JOBVSL is CHARACTER*1
  = 'N': do not compute the left Schur vectors;
  = 'V': compute the left Schur vectors.

 JOBVSR is CHARACTER*1
  = 'N': do not compute the right Schur vectors;
  = 'V': compute the right Schur vectors.

 SORT is CHARACTER*1
  Specifies whether or not to order the eigenvalues on the
  diagonal of the generalized Schur form.
  = 'N': Eigenvalues are not ordered;
  = 'S': Eigenvalues are ordered (see SELCTG);

 SELCTG is a LOGICAL FUNCTION of three REAL arguments
  SELCTG must be declared EXTERNAL in the calling subroutine.
  If SORT = 'N', SELCTG is not referenced.
  If SORT = 'S', SELCTG is used to select eigenvalues to sort
  to the top left of the Schur form.
  An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
  SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
  one of a complex conjugate pair of eigenvalues is selected,
  then both complex eigenvalues are selected.
 
  Note that in the ill-conditioned case, a selected complex
  eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j),
  BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2
  in this case.

 A is REAL array, dimension (LDA, N)
  On entry, the first of the pair of matrices.
  On exit, A has been overwritten by its generalized Schur
  form S.

 B is REAL array, dimension (LDB, N)
  On entry, the second of the pair of matrices.
  On exit, B has been overwritten by its generalized Schur
  form T.

 SDIM is INTEGER
  If SORT = 'N', SDIM = 0.
  If SORT = 'S', SDIM = number of eigenvalues (after sorting)
  for which SELCTG is true. (Complex conjugate pairs for which
  SELCTG is true for either eigenvalue count as 2.)

 ALPHAR is REAL array, dimension (N)

 ALPHAI is REAL array, dimension (N)

 BETA is REAL array, dimension (N)
  On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
  be the generalized eigenvalues. ALPHAR(j) + ALPHAI(j)*i,
  and BETA(j),j=1,...,N are the diagonals of the complex Schur
  form (S,T) that would result if the 2-by-2 diagonal blocks of
  the real Schur form of (A,B) were further reduced to
  triangular form using 2-by-2 complex unitary transformations.
  If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
  positive, then the j-th and (j+1)-st eigenvalues are a
  complex conjugate pair, with ALPHAI(j+1) negative.
 
  Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
  may easily over- or underflow, and BETA(j) may even be zero.
  Thus, the user should avoid naively computing the ratio.
  However, ALPHAR and ALPHAI will be always less than and
  usually comparable with norm(A) in magnitude, and BETA always
  less than and usually comparable with norm(B).

 VSL is REAL array, dimension (LDVSL,N)
  If JOBVSL = 'V', VSL will contain the left Schur vectors.
  Not referenced if JOBVSL = 'N'.

 VSR is REAL array, dimension (LDVSR,N)
  If JOBVSR = 'V', VSR will contain the right Schur vectors.
  Not referenced if JOBVSR = 'N'.

 */
inline proc gges(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_S_SELECT3, a : [] c_float, b : [] c_float, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, vsr : [] c_float): c_int{
  return LAPACKE_sgges(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, sdim, alphar, alphai, beta, vsl, (vsl.domain.dim(2).size) : c_int, vsr, (vsr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgges for the type c_double.

For more information, see the documentation for :proc:`gges`, or consult the Netlibs or Intel documentation.
 */
inline proc gges(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_D_SELECT3, a : [] c_double, b : [] c_double, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, vsr : [] c_double): c_int{
  return LAPACKE_dgges(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, sdim, alphar, alphai, beta, vsl, (vsl.domain.dim(2).size) : c_int, vsr, (vsr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgges for the type lapack_complex_float.

For more information, see the documentation for :proc:`gges`, or consult the Netlibs or Intel documentation.
 */
inline proc gges(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_C_SELECT2, a : [] complex(64), b : [] complex(64), ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), vsr : [] complex(64)): c_int{
  return LAPACKE_cgges(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, sdim, alpha, beta, vsl, (vsl.domain.dim(2).size) : c_int, vsr, (vsr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgges for the type lapack_complex_double.

For more information, see the documentation for :proc:`gges`, or consult the Netlibs or Intel documentation.
 */
inline proc gges(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_Z_SELECT2, a : [] complex(128), b : [] complex(128), ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), vsr : [] complex(128)): c_int{
  return LAPACKE_zgges(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, sdim, alpha, beta, vsl, (vsl.domain.dim(2).size) : c_int, vsr, (vsr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggesx for the type c_float.

Original Fortran LAPACK purpose documentation for SGGESX::

 SGGESX computes for a pair of N-by-N real nonsymmetric matrices
 (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
 optionally, the left and/or right matrices of Schur vectors (VSL and
 VSR). This gives the generalized Schur factorization

 (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )

 Optionally, it also orders the eigenvalues so that a selected cluster
 of eigenvalues appears in the leading diagonal blocks of the upper
 quasi-triangular matrix S and the upper triangular matrix T; computes
 a reciprocal condition number for the average of the selected
 eigenvalues (RCONDE); and computes a reciprocal condition number for
 the right and left deflating subspaces corresponding to the selected
 eigenvalues (RCONDV). The leading columns of VSL and VSR then form
 an orthonormal basis for the corresponding left and right eigenspaces
 (deflating subspaces).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio alpha/beta = w, such that A - w*B is singular. It is
 usually represented as the pair (alpha,beta), as there is a
 reasonable interpretation for beta=0 or for both being zero.

 A pair of matrices (S,T) is in generalized real Schur form if T is
 upper triangular with non-negative diagonal and S is block upper
 triangular with 1-by-1 and 2-by-2 blocks. 1-by-1 blocks correspond
 to real generalized eigenvalues, while 2-by-2 blocks of S will be
 "standardized" by making the corresponding elements of T have the
 form:
 [ a 0 ]
 [ 0 b ]

 and the pair of corresponding 2-by-2 blocks in S and T will have a
 complex conjugate pair of generalized eigenvalues.

Original Fortran LAPACK argument documentation for SGGESX::

 JOBVSL is CHARACTER*1
  = 'N': do not compute the left Schur vectors;
  = 'V': compute the left Schur vectors.

 JOBVSR is CHARACTER*1
  = 'N': do not compute the right Schur vectors;
  = 'V': compute the right Schur vectors.

 SORT is CHARACTER*1
  Specifies whether or not to order the eigenvalues on the
  diagonal of the generalized Schur form.
  = 'N': Eigenvalues are not ordered;
  = 'S': Eigenvalues are ordered (see SELCTG).

 SELCTG is procedure) LOGICAL FUNCTION of three REAL arguments
  SELCTG must be declared EXTERNAL in the calling subroutine.
  If SORT = 'N', SELCTG is not referenced.
  If SORT = 'S', SELCTG is used to select eigenvalues to sort
  to the top left of the Schur form.
  An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
  SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
  one of a complex conjugate pair of eigenvalues is selected,
  then both complex eigenvalues are selected.
  Note that a selected complex eigenvalue may no longer satisfy
  SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) = .TRUE. after ordering,
  since ordering may change the value of complex eigenvalues
  (especially if the eigenvalue is ill-conditioned), in this
  case INFO is set to N+3.

 SENSE is CHARACTER*1
  Determines which reciprocal condition numbers are computed.
  = 'N' : None are computed;
  = 'E' : Computed for average of selected eigenvalues only;
  = 'V' : Computed for selected deflating subspaces only;
  = 'B' : Computed for both.
  If SENSE = 'E', 'V', or 'B', SORT must equal 'S'.

 A is REAL array, dimension (LDA, N)
  On entry, the first of the pair of matrices.
  On exit, A has been overwritten by its generalized Schur
  form S.

 B is REAL array, dimension (LDB, N)
  On entry, the second of the pair of matrices.
  On exit, B has been overwritten by its generalized Schur
  form T.

 SDIM is INTEGER
  If SORT = 'N', SDIM = 0.
  If SORT = 'S', SDIM = number of eigenvalues (after sorting)
  for which SELCTG is true. (Complex conjugate pairs for which
  SELCTG is true for either eigenvalue count as 2.)

 ALPHAR is REAL array, dimension (N)

 ALPHAI is REAL array, dimension (N)

 BETA is REAL array, dimension (N)
  On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
  be the generalized eigenvalues. ALPHAR(j) + ALPHAI(j)*i
  and BETA(j),j=1,...,N are the diagonals of the complex Schur
  form (S,T) that would result if the 2-by-2 diagonal blocks of
  the real Schur form of (A,B) were further reduced to
  triangular form using 2-by-2 complex unitary transformations.
  If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
  positive, then the j-th and (j+1)-st eigenvalues are a
  complex conjugate pair, with ALPHAI(j+1) negative.
 
  Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
  may easily over- or underflow, and BETA(j) may even be zero.
  Thus, the user should avoid naively computing the ratio.
  However, ALPHAR and ALPHAI will be always less than and
  usually comparable with norm(A) in magnitude, and BETA always
  less than and usually comparable with norm(B).

 VSL is REAL array, dimension (LDVSL,N)
  If JOBVSL = 'V', VSL will contain the left Schur vectors.
  Not referenced if JOBVSL = 'N'.

 VSR is REAL array, dimension (LDVSR,N)
  If JOBVSR = 'V', VSR will contain the right Schur vectors.
  Not referenced if JOBVSR = 'N'.

 RCONDE is REAL array, dimension ( 2 )
  If SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the
  reciprocal condition numbers for the average of the selected
  eigenvalues.
  Not referenced if SENSE = 'N' or 'V'.

 RCONDV is REAL array, dimension ( 2 )
  If SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the
  reciprocal condition numbers for the selected deflating
  subspaces.
  Not referenced if SENSE = 'N' or 'E'.

 */
inline proc ggesx(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_S_SELECT3, sense : string, a : [] c_float, b : [] c_float, ref sdim : c_int, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vsl : [] c_float, vsr : [] c_float, rconde : [] c_float, rcondv : [] c_float): c_int{
  return LAPACKE_sggesx(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, sdim, alphar, alphai, beta, vsl, (vsl.domain.dim(2).size) : c_int, vsr, (vsr.domain.dim(2).size) : c_int, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggesx for the type c_double.

For more information, see the documentation for :proc:`ggesx`, or consult the Netlibs or Intel documentation.
 */
inline proc ggesx(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_D_SELECT3, sense : string, a : [] c_double, b : [] c_double, ref sdim : c_int, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vsl : [] c_double, vsr : [] c_double, rconde : [] c_double, rcondv : [] c_double): c_int{
  return LAPACKE_dggesx(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, sdim, alphar, alphai, beta, vsl, (vsl.domain.dim(2).size) : c_int, vsr, (vsr.domain.dim(2).size) : c_int, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggesx for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggesx`, or consult the Netlibs or Intel documentation.
 */
inline proc ggesx(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_C_SELECT2, sense : string, a : [] complex(64), b : [] complex(64), ref sdim : c_int, alpha : [] complex(64), beta : [] complex(64), vsl : [] complex(64), vsr : [] complex(64), rconde : [] c_float, rcondv : [] c_float): c_int{
  return LAPACKE_cggesx(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, sdim, alpha, beta, vsl, (vsl.domain.dim(2).size) : c_int, vsr, (vsr.domain.dim(2).size) : c_int, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggesx for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggesx`, or consult the Netlibs or Intel documentation.
 */
inline proc ggesx(matrix_order : lapack_memory_order, jobvsl : string, jobvsr : string, sort : string, selctg : LAPACK_Z_SELECT2, sense : string, a : [] complex(128), b : [] complex(128), ref sdim : c_int, alpha : [] complex(128), beta : [] complex(128), vsl : [] complex(128), vsr : [] complex(128), rconde : [] c_double, rcondv : [] c_double): c_int{
  return LAPACKE_zggesx(matrix_order, ascii(jobvsl) : c_char, ascii(jobvsr) : c_char, ascii(sort) : c_char, selctg, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, sdim, alpha, beta, vsl, (vsl.domain.dim(2).size) : c_int, vsr, (vsr.domain.dim(2).size) : c_int, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggev for the type c_float.

Original Fortran LAPACK purpose documentation for SGGEV::

 SGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j).

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B .

 where u(j)**H is the conjugate-transpose of u(j).

Original Fortran LAPACK argument documentation for SGGEV::

 JOBVL is CHARACTER*1
  = 'N': do not compute the left generalized eigenvectors;
  = 'V': compute the left generalized eigenvectors.

 JOBVR is CHARACTER*1
  = 'N': do not compute the right generalized eigenvectors;
  = 'V': compute the right generalized eigenvectors.

 A is REAL array, dimension (LDA, N)
  On entry, the matrix A in the pair (A,B).
  On exit, A has been overwritten.

 B is REAL array, dimension (LDB, N)
  On entry, the matrix B in the pair (A,B).
  On exit, B has been overwritten.

 ALPHAR is REAL array, dimension (N)

 ALPHAI is REAL array, dimension (N)

 BETA is REAL array, dimension (N)
  On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
  be the generalized eigenvalues. If ALPHAI(j) is zero, then
  the j-th eigenvalue is real; if positive, then the j-th and
  (j+1)-st eigenvalues are a complex conjugate pair, with
  ALPHAI(j+1) negative.
 
  Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
  may easily over- or underflow, and BETA(j) may even be zero.
  Thus, the user should avoid naively computing the ratio
  alpha/beta. However, ALPHAR and ALPHAI will be always less
  than and usually comparable with norm(A) in magnitude, and
  BETA always less than and usually comparable with norm(B).

 VL is REAL array, dimension (LDVL,N)
  If JOBVL = 'V', the left eigenvectors u(j) are stored one
  after another in the columns of VL, in the same order as
  their eigenvalues. If the j-th eigenvalue is real, then
  u(j) = VL(:,j), the j-th column of VL. If the j-th and
  (j+1)-th eigenvalues form a complex conjugate pair, then
  u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
  Each eigenvector is scaled so the largest component has
  abs(real part)+abs(imag. part)=1.
  Not referenced if JOBVL = 'N'.

 VR is REAL array, dimension (LDVR,N)
  If JOBVR = 'V', the right eigenvectors v(j) are stored one
  after another in the columns of VR, in the same order as
  their eigenvalues. If the j-th eigenvalue is real, then
  v(j) = VR(:,j), the j-th column of VR. If the j-th and
  (j+1)-th eigenvalues form a complex conjugate pair, then
  v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
  Each eigenvector is scaled so the largest component has
  abs(real part)+abs(imag. part)=1.
  Not referenced if JOBVR = 'N'.

 */
inline proc ggev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, a : [] c_float, b : [] c_float, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, vr : [] c_float): c_int{
  return LAPACKE_sggev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alphar, alphai, beta, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggev for the type c_double.

For more information, see the documentation for :proc:`ggev`, or consult the Netlibs or Intel documentation.
 */
inline proc ggev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, a : [] c_double, b : [] c_double, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, vr : [] c_double): c_int{
  return LAPACKE_dggev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alphar, alphai, beta, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggev for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggev`, or consult the Netlibs or Intel documentation.
 */
inline proc ggev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, a : [] complex(64), b : [] complex(64), alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), vr : [] complex(64)): c_int{
  return LAPACKE_cggev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggev for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggev`, or consult the Netlibs or Intel documentation.
 */
inline proc ggev(matrix_order : lapack_memory_order, jobvl : string, jobvr : string, a : [] complex(128), b : [] complex(128), alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), vr : [] complex(128)): c_int{
  return LAPACKE_zggev(matrix_order, ascii(jobvl) : c_char, ascii(jobvr) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggevx for the type c_float.

Original Fortran LAPACK purpose documentation for SGGEVX::

 SGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 A * v(j) = lambda(j) * B * v(j) .

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

 u(j)**H * A = lambda(j) * u(j)**H * B.

 where u(j)**H is the conjugate-transpose of u(j).

Original Fortran LAPACK argument documentation for SGGEVX::

 BALANC is CHARACTER*1
  Specifies the balance option to be performed.
  = 'N': do not diagonally scale or permute;
  = 'P': permute only;
  = 'S': scale only;
  = 'B': both permute and scale.
  Computed reciprocal condition numbers will be for the
  matrices after permuting and/or balancing. Permuting does
  not change condition numbers (in exact arithmetic), but
  balancing does.

 JOBVL is CHARACTER*1
  = 'N': do not compute the left generalized eigenvectors;
  = 'V': compute the left generalized eigenvectors.

 JOBVR is CHARACTER*1
  = 'N': do not compute the right generalized eigenvectors;
  = 'V': compute the right generalized eigenvectors.

 SENSE is CHARACTER*1
  Determines which reciprocal condition numbers are computed.
  = 'N': none are computed;
  = 'E': computed for eigenvalues only;
  = 'V': computed for eigenvectors only;
  = 'B': computed for eigenvalues and eigenvectors.

 A is REAL array, dimension (LDA, N)
  On entry, the matrix A in the pair (A,B).
  On exit, A has been overwritten. If JOBVL='V' or JOBVR='V'
  or both, then A contains the first part of the real Schur
  form of the "balanced" versions of the input A and B.

 B is REAL array, dimension (LDB, N)
  On entry, the matrix B in the pair (A,B).
  On exit, B has been overwritten. If JOBVL='V' or JOBVR='V'
  or both, then B contains the second part of the real Schur
  form of the "balanced" versions of the input A and B.

 ALPHAR is REAL array, dimension (N)

 ALPHAI is REAL array, dimension (N)

 BETA is REAL array, dimension (N)
  On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
  be the generalized eigenvalues. If ALPHAI(j) is zero, then
  the j-th eigenvalue is real; if positive, then the j-th and
  (j+1)-st eigenvalues are a complex conjugate pair, with
  ALPHAI(j+1) negative.
 
  Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
  may easily over- or underflow, and BETA(j) may even be zero.
  Thus, the user should avoid naively computing the ratio
  ALPHA/BETA. However, ALPHAR and ALPHAI will be always less
  than and usually comparable with norm(A) in magnitude, and
  BETA always less than and usually comparable with norm(B).

 VL is REAL array, dimension (LDVL,N)
  If JOBVL = 'V', the left eigenvectors u(j) are stored one
  after another in the columns of VL, in the same order as
  their eigenvalues. If the j-th eigenvalue is real, then
  u(j) = VL(:,j), the j-th column of VL. If the j-th and
  (j+1)-th eigenvalues form a complex conjugate pair, then
  u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
  Each eigenvector will be scaled so the largest component have
  abs(real part) + abs(imag. part) = 1.
  Not referenced if JOBVL = 'N'.

 VR is REAL array, dimension (LDVR,N)
  If JOBVR = 'V', the right eigenvectors v(j) are stored one
  after another in the columns of VR, in the same order as
  their eigenvalues. If the j-th eigenvalue is real, then
  v(j) = VR(:,j), the j-th column of VR. If the j-th and
  (j+1)-th eigenvalues form a complex conjugate pair, then
  v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
  Each eigenvector will be scaled so the largest component have
  abs(real part) + abs(imag. part) = 1.
  Not referenced if JOBVR = 'N'.

 ILO is INTEGER

 IHI is INTEGER
  ILO and IHI are integer values such that on exit
  A(i,j) = 0 and B(i,j) = 0 if i > j and
  j = 1,...,ILO-1 or i = IHI+1,...,N.
  If BALANC = 'N' or 'S', ILO = 1 and IHI = N.

 LSCALE is REAL array, dimension (N)
  Details of the permutations and scaling factors applied
  to the left side of A and B. If PL(j) is the index of the
  row interchanged with row j, and DL(j) is the scaling
  factor applied to row j, then
  LSCALE(j) = PL(j) for j = 1,...,ILO-1
  = DL(j) for j = ILO,...,IHI
  = PL(j) for j = IHI+1,...,N.
  The order in which the interchanges are made is N to IHI+1,
  then 1 to ILO-1.

 RSCALE is REAL array, dimension (N)
  Details of the permutations and scaling factors applied
  to the right side of A and B. If PR(j) is the index of the
  column interchanged with column j, and DR(j) is the scaling
  factor applied to column j, then
  RSCALE(j) = PR(j) for j = 1,...,ILO-1
  = DR(j) for j = ILO,...,IHI
  = PR(j) for j = IHI+1,...,N
  The order in which the interchanges are made is N to IHI+1,
  then 1 to ILO-1.

 ABNRM is REAL
  The one-norm of the balanced matrix A.

 BBNRM is REAL
  The one-norm of the balanced matrix B.

 RCONDE is REAL array, dimension (N)
  If SENSE = 'E' or 'B', the reciprocal condition numbers of
  the eigenvalues, stored in consecutive elements of the array.
  For a complex conjugate pair of eigenvalues two consecutive
  elements of RCONDE are set to the same value. Thus RCONDE(j),
  RCONDV(j), and the j-th columns of VL and VR all correspond
  to the j-th eigenpair.
  If SENSE = 'N' or 'V', RCONDE is not referenced.

 RCONDV is REAL array, dimension (N)
  If SENSE = 'V' or 'B', the estimated reciprocal condition
  numbers of the eigenvectors, stored in consecutive elements
  of the array. For a complex eigenvector two consecutive
  elements of RCONDV are set to the same value. If the
  eigenvalues cannot be reordered to compute RCONDV(j),
  RCONDV(j) is set to 0; this can only occur when the true
  value would be very small anyway.
  If SENSE = 'N' or 'E', RCONDV is not referenced.

 */
inline proc ggevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, a : [] c_float, b : [] c_float, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, vl : [] c_float, vr : [] c_float, ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float): c_int{
  return LAPACKE_sggevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alphar, alphai, beta, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggevx for the type c_double.

For more information, see the documentation for :proc:`ggevx`, or consult the Netlibs or Intel documentation.
 */
inline proc ggevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, a : [] c_double, b : [] c_double, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, vl : [] c_double, vr : [] c_double, ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double): c_int{
  return LAPACKE_dggevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alphar, alphai, beta, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggevx for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggevx`, or consult the Netlibs or Intel documentation.
 */
inline proc ggevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, a : [] complex(64), b : [] complex(64), alpha : [] complex(64), beta : [] complex(64), vl : [] complex(64), vr : [] complex(64), ref ilo : c_int, ref ihi : c_int, lscale : [] c_float, rscale : [] c_float, ref abnrm : c_float, ref bbnrm : c_float, rconde : [] c_float, rcondv : [] c_float): c_int{
  return LAPACKE_cggevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggevx for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggevx`, or consult the Netlibs or Intel documentation.
 */
inline proc ggevx(matrix_order : lapack_memory_order, balanc : string, jobvl : string, jobvr : string, sense : string, a : [] complex(128), b : [] complex(128), alpha : [] complex(128), beta : [] complex(128), vl : [] complex(128), vr : [] complex(128), ref ilo : c_int, ref ihi : c_int, lscale : [] c_double, rscale : [] c_double, ref abnrm : c_double, ref bbnrm : c_double, rconde : [] c_double, rcondv : [] c_double): c_int{
  return LAPACKE_zggevx(matrix_order, ascii(balanc) : c_char, ascii(jobvl) : c_char, ascii(jobvr) : c_char, ascii(sense) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggglm for the type c_float.

Original Fortran LAPACK purpose documentation for SGGGLM::

 SGGGLM solves a general Gauss-Markov linear model (GLM) problem:

 minimize || y ||_2 subject to d = A*x + B*y
 x

 where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
 given N-vector. It is assumed that M <= N <= M+P, and

 rank(A) = M and rank( A B ) = N.

 Under these assumptions, the constrained equation is always
 consistent, and there is a unique solution x and a minimal 2-norm
 solution y, which is obtained using a generalized QR factorization
 of the matrices (A, B) given by

 A = Q*(R), B = Q*T*Z.
 (0)

 In particular, if matrix B is square nonsingular, then the problem
 GLM is equivalent to the following weighted linear least squares
 problem

 minimize || inv(B)*(d-A*x) ||_2
 x

 where inv(B) denotes the inverse of B.

Original Fortran LAPACK argument documentation for SGGGLM::

 A is REAL array, dimension (LDA,M)
  On entry, the N-by-M matrix A.
  On exit, the upper triangular part of the array A contains
  the M-by-M upper triangular matrix R.

 B is REAL array, dimension (LDB,P)
  On entry, the N-by-P matrix B.
  On exit, if N <= P, the upper triangle of the subarray
  B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
  if N > P, the elements on and above the (N-P)th subdiagonal
  contain the N-by-P upper trapezoidal matrix T.

 D is REAL array, dimension (N)
  On entry, D is the left hand side of the GLM equation.
  On exit, D is destroyed.

 X is REAL array, dimension (M)

 Y is REAL array, dimension (P)
 
  On exit, X and Y are the solutions of the GLM problem.

 */
inline proc ggglm(matrix_order : lapack_memory_order, a : [] c_float, b : [] c_float, d : [] c_float, x : [] c_float, y : [] c_float): c_int{
  return LAPACKE_sggglm(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, d, x, y);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggglm for the type c_double.

For more information, see the documentation for :proc:`ggglm`, or consult the Netlibs or Intel documentation.
 */
inline proc ggglm(matrix_order : lapack_memory_order, a : [] c_double, b : [] c_double, d : [] c_double, x : [] c_double, y : [] c_double): c_int{
  return LAPACKE_dggglm(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, d, x, y);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggglm for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggglm`, or consult the Netlibs or Intel documentation.
 */
inline proc ggglm(matrix_order : lapack_memory_order, a : [] complex(64), b : [] complex(64), d : [] complex(64), x : [] complex(64), y : [] complex(64)): c_int{
  return LAPACKE_cggglm(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, d, x, y);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggglm for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggglm`, or consult the Netlibs or Intel documentation.
 */
inline proc ggglm(matrix_order : lapack_memory_order, a : [] complex(128), b : [] complex(128), d : [] complex(128), x : [] complex(128), y : [] complex(128)): c_int{
  return LAPACKE_zggglm(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, d, x, y);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgghrd for the type c_float.

Original Fortran LAPACK purpose documentation for SGGHRD::

 SGGHRD reduces a pair of real matrices (A,B) to generalized upper
 Hessenberg form using orthogonal transformations, where A is a
 general matrix and B is upper triangular. The form of the
 generalized eigenvalue problem is
 A*x = lambda*B*x,
 and B is typically made upper triangular by computing its QR
 factorization and moving the orthogonal matrix Q to the left side
 of the equation.

 This subroutine simultaneously reduces A to a Hessenberg matrix H:
 Q**T*A*Z = H
 and transforms B to another upper triangular matrix T:
 Q**T*B*Z = T
 in order to reduce the problem to its standard form
 H*y = lambda*T*y
 where y = Z**T*x.

 The orthogonal matrices Q and Z are determined as products of Givens
 rotations. They may either be formed explicitly, or they may be
 postmultiplied into input matrices Q1 and Z1, so that

 Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T

 Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T

 If Q1 is the orthogonal matrix from the QR factorization of B in the
 original equation A*x = lambda*B*x, then SGGHRD reduces the original
 problem to generalized Hessenberg form.

Original Fortran LAPACK argument documentation for SGGHRD::

 COMPQ is CHARACTER*1
  = 'N': do not compute Q;
  = 'I': Q is initialized to the unit matrix, and the
  orthogonal matrix Q is returned;
  = 'V': Q must contain an orthogonal matrix Q1 on entry,
  and the product Q1*Q is returned.

 COMPZ is CHARACTER*1
  = 'N': do not compute Z;
  = 'I': Z is initialized to the unit matrix, and the
  orthogonal matrix Z is returned;
  = 'V': Z must contain an orthogonal matrix Z1 on entry,
  and the product Z1*Z is returned.

 ILO is INTEGER

 IHI is INTEGER
 
  ILO and IHI mark the rows and columns of A which are to be
  reduced. It is assumed that A is already upper triangular
  in rows and columns 1:ILO-1 and IHI+1:N. ILO and IHI are
  normally set by a previous call to SGGBAL; otherwise they
  should be set to 1 and N respectively.
  1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

 A is REAL array, dimension (LDA, N)
  On entry, the N-by-N general matrix to be reduced.
  On exit, the upper triangle and the first subdiagonal of A
  are overwritten with the upper Hessenberg matrix H, and the
  rest is set to zero.

 B is REAL array, dimension (LDB, N)
  On entry, the N-by-N upper triangular matrix B.
  On exit, the upper triangular matrix T = Q**T B Z. The
  elements below the diagonal are set to zero.

 Q is REAL array, dimension (LDQ, N)
  On entry, if COMPQ = 'V', the orthogonal matrix Q1,
  typically from the QR factorization of B.
  On exit, if COMPQ='I', the orthogonal matrix Q, and if
  COMPQ = 'V', the product Q1*Q.
  Not referenced if COMPQ='N'.

 Z is REAL array, dimension (LDZ, N)
  On entry, if COMPZ = 'V', the orthogonal matrix Z1.
  On exit, if COMPZ='I', the orthogonal matrix Z, and if
  COMPZ = 'V', the product Z1*Z.
  Not referenced if COMPZ='N'.

 */
inline proc gghrd(matrix_order : lapack_memory_order, compq : string, compz : string, ilo : c_int, ihi : c_int, a : [] c_float, b : [] c_float, q : [] c_float, z : [] c_float): c_int{
  return LAPACKE_sgghrd(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, (a.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgghrd for the type c_double.

For more information, see the documentation for :proc:`gghrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gghrd(matrix_order : lapack_memory_order, compq : string, compz : string, ilo : c_int, ihi : c_int, a : [] c_double, b : [] c_double, q : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dgghrd(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, (a.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgghrd for the type lapack_complex_float.

For more information, see the documentation for :proc:`gghrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gghrd(matrix_order : lapack_memory_order, compq : string, compz : string, ilo : c_int, ihi : c_int, a : [] complex(64), b : [] complex(64), q : [] complex(64), z : [] complex(64)): c_int{
  return LAPACKE_cgghrd(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, (a.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgghrd for the type lapack_complex_double.

For more information, see the documentation for :proc:`gghrd`, or consult the Netlibs or Intel documentation.
 */
inline proc gghrd(matrix_order : lapack_memory_order, compq : string, compz : string, ilo : c_int, ihi : c_int, a : [] complex(128), b : [] complex(128), q : [] complex(128), z : [] complex(128)): c_int{
  return LAPACKE_zgghrd(matrix_order, ascii(compq) : c_char, ascii(compz) : c_char, (a.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgglse for the type c_float.

Original Fortran LAPACK purpose documentation for SGGLSE::

 SGGLSE solves the linear equality-constrained least squares (LSE)
 problem:

 minimize || c - A*x ||_2 subject to B*x = d

 where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
 M-vector, and d is a given P-vector. It is assumed that
 P <= N <= M+P, and

 rank(B) = P and rank( (A) ) = N.
 ( (B) )

 These conditions ensure that the LSE problem has a unique solution,
 which is obtained using a generalized RQ factorization of the
 matrices (B, A) given by

 B = (0 R)*Q, A = Z*T*Q.

Original Fortran LAPACK argument documentation for SGGLSE::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, the elements on and above the diagonal of the array
  contain the min(M,N)-by-N upper trapezoidal matrix T.

 B is REAL array, dimension (LDB,N)
  On entry, the P-by-N matrix B.
  On exit, the upper triangle of the subarray B(1:P,N-P+1:N)
  contains the P-by-P upper triangular matrix R.

 C is REAL array, dimension (M)
  On entry, C contains the right hand side vector for the
  least squares part of the LSE problem.
  On exit, the residual sum of squares for the solution
  is given by the sum of squares of elements N-P+1 to M of
  vector C.

 D is REAL array, dimension (P)
  On entry, D contains the right hand side vector for the
  constrained equation.
  On exit, D is destroyed.

 X is REAL array, dimension (N)
  On exit, X is the solution of the LSE problem.

 */
inline proc gglse(matrix_order : lapack_memory_order, a : [] c_float, b : [] c_float, c : [] c_float, d : [] c_float, x : [] c_float): c_int{
  return LAPACKE_sgglse(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, d, x);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgglse for the type c_double.

For more information, see the documentation for :proc:`gglse`, or consult the Netlibs or Intel documentation.
 */
inline proc gglse(matrix_order : lapack_memory_order, a : [] c_double, b : [] c_double, c : [] c_double, d : [] c_double, x : [] c_double): c_int{
  return LAPACKE_dgglse(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, d, x);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgglse for the type lapack_complex_float.

For more information, see the documentation for :proc:`gglse`, or consult the Netlibs or Intel documentation.
 */
inline proc gglse(matrix_order : lapack_memory_order, a : [] complex(64), b : [] complex(64), c : [] complex(64), d : [] complex(64), x : [] complex(64)): c_int{
  return LAPACKE_cgglse(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, d, x);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgglse for the type lapack_complex_double.

For more information, see the documentation for :proc:`gglse`, or consult the Netlibs or Intel documentation.
 */
inline proc gglse(matrix_order : lapack_memory_order, a : [] complex(128), b : [] complex(128), c : [] complex(128), d : [] complex(128), x : [] complex(128)): c_int{
  return LAPACKE_zgglse(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, d, x);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggqrf for the type c_float.

Original Fortran LAPACK purpose documentation for SGGQRF::

 SGGQRF computes a generalized QR factorization of an N-by-M matrix A
 and an N-by-P matrix B:

 A = Q*R, B = Q*T*Z,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if N >= M, R = ( R11 ) M , or if N < M, R = ( R11 R12 ) N,
 ( 0 ) N-M N M-N
 M

 where R11 is upper triangular, and

 if N <= P, T = ( 0 T12 ) N, or if N > P, T = ( T11 ) N-P,
 P-N N ( T21 ) P
 P

 where T12 or T21 is upper triangular.

 In particular, if B is square and nonsingular, the GQR factorization
 of A and B implicitly gives the QR factorization of inv(B)*A:

 inv(B)*A = Z**T*(inv(T)*R)

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

Original Fortran LAPACK argument documentation for SGGQRF::

 A is REAL array, dimension (LDA,M)
  On entry, the N-by-M matrix A.
  On exit, the elements on and above the diagonal of the array
  contain the min(N,M)-by-M upper trapezoidal matrix R (R is
  upper triangular if N >= M); the elements below the diagonal,
  with the array TAUA, represent the orthogonal matrix Q as a
  product of min(N,M) elementary reflectors (see Further
  Details).

 TAUA is REAL array, dimension (min(N,M))
  The scalar factors of the elementary reflectors which
  represent the orthogonal matrix Q (see Further Details).

 B is REAL array, dimension (LDB,P)
  On entry, the N-by-P matrix B.
  On exit, if N <= P, the upper triangle of the subarray
  B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
  if N > P, the elements on and above the (N-P)-th subdiagonal
  contain the N-by-P upper trapezoidal matrix T; the remaining
  elements, with the array TAUB, represent the orthogonal
  matrix Z as a product of elementary reflectors (see Further
  Details).

 TAUB is REAL array, dimension (min(N,P))
  The scalar factors of the elementary reflectors which
  represent the orthogonal matrix Z (see Further Details).

 */
inline proc ggqrf(matrix_order : lapack_memory_order, a : [] c_float, taua : [] c_float, b : [] c_float, taub : [] c_float): c_int{
  return LAPACKE_sggqrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, taua, b, (b.domain.dim(2).size) : c_int, taub);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggqrf for the type c_double.

For more information, see the documentation for :proc:`ggqrf`, or consult the Netlibs or Intel documentation.
 */
inline proc ggqrf(matrix_order : lapack_memory_order, a : [] c_double, taua : [] c_double, b : [] c_double, taub : [] c_double): c_int{
  return LAPACKE_dggqrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, taua, b, (b.domain.dim(2).size) : c_int, taub);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggqrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggqrf`, or consult the Netlibs or Intel documentation.
 */
inline proc ggqrf(matrix_order : lapack_memory_order, a : [] complex(64), taua : [] complex(64), b : [] complex(64), taub : [] complex(64)): c_int{
  return LAPACKE_cggqrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, taua, b, (b.domain.dim(2).size) : c_int, taub);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggqrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggqrf`, or consult the Netlibs or Intel documentation.
 */
inline proc ggqrf(matrix_order : lapack_memory_order, a : [] complex(128), taua : [] complex(128), b : [] complex(128), taub : [] complex(128)): c_int{
  return LAPACKE_zggqrf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, taua, b, (b.domain.dim(2).size) : c_int, taub);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggrqf for the type c_float.

Original Fortran LAPACK purpose documentation for SGGRQF::

 SGGRQF computes a generalized RQ factorization of an M-by-N matrix A
 and a P-by-N matrix B:

 A = R*Q, B = Z*T*Q,

 where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
 matrix, and R and T assume one of the forms:

 if M <= N, R = ( 0 R12 ) M, or if M > N, R = ( R11 ) M-N,
 N-M M ( R21 ) N
 N

 where R12 or R21 is upper triangular, and

 if P >= N, T = ( T11 ) N , or if P < N, T = ( T11 T12 ) P,
 ( 0 ) P-N P N-P
 N

 where T11 is upper triangular.

 In particular, if B is square and nonsingular, the GRQ factorization
 of A and B implicitly gives the RQ factorization of A*inv(B):

 A*inv(B) = (R*inv(T))*Z**T

 where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
 transpose of the matrix Z.

Original Fortran LAPACK argument documentation for SGGRQF::

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, if M <= N, the upper triangle of the subarray
  A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R;
  if M > N, the elements on and above the (M-N)-th subdiagonal
  contain the M-by-N upper trapezoidal matrix R; the remaining
  elements, with the array TAUA, represent the orthogonal
  matrix Q as a product of elementary reflectors (see Further
  Details).

 TAUA is REAL array, dimension (min(M,N))
  The scalar factors of the elementary reflectors which
  represent the orthogonal matrix Q (see Further Details).

 B is REAL array, dimension (LDB,N)
  On entry, the P-by-N matrix B.
  On exit, the elements on and above the diagonal of the array
  contain the min(P,N)-by-N upper trapezoidal matrix T (T is
  upper triangular if P >= N); the elements below the diagonal,
  with the array TAUB, represent the orthogonal matrix Z as a
  product of elementary reflectors (see Further Details).

 TAUB is REAL array, dimension (min(P,N))
  The scalar factors of the elementary reflectors which
  represent the orthogonal matrix Z (see Further Details).

 */
inline proc ggrqf(matrix_order : lapack_memory_order, a : [] c_float, taua : [] c_float, b : [] c_float, taub : [] c_float): c_int{
  return LAPACKE_sggrqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, taua, b, (b.domain.dim(2).size) : c_int, taub);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggrqf for the type c_double.

For more information, see the documentation for :proc:`ggrqf`, or consult the Netlibs or Intel documentation.
 */
inline proc ggrqf(matrix_order : lapack_memory_order, a : [] c_double, taua : [] c_double, b : [] c_double, taub : [] c_double): c_int{
  return LAPACKE_dggrqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, taua, b, (b.domain.dim(2).size) : c_int, taub);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggrqf for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggrqf`, or consult the Netlibs or Intel documentation.
 */
inline proc ggrqf(matrix_order : lapack_memory_order, a : [] complex(64), taua : [] complex(64), b : [] complex(64), taub : [] complex(64)): c_int{
  return LAPACKE_cggrqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, taua, b, (b.domain.dim(2).size) : c_int, taub);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggrqf for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggrqf`, or consult the Netlibs or Intel documentation.
 */
inline proc ggrqf(matrix_order : lapack_memory_order, a : [] complex(128), taua : [] complex(128), b : [] complex(128), taub : [] complex(128)): c_int{
  return LAPACKE_zggrqf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, taua, b, (b.domain.dim(2).size) : c_int, taub);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggsvd for the type c_float.

Original Fortran LAPACK purpose documentation for SGGSVD::

 SGGSVD computes the generalized singular value decomposition (GSVD)
 of an M-by-N real matrix A and P-by-N real matrix B:

 U**T*A*Q = D1*( 0 R ), V**T*B*Q = D2*( 0 R )

 where U, V and Q are orthogonal matrices.
 Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,
 then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
 D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
 following structures, respectively:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 )
 L ( 0 0 R22 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where

 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The routine computes C, S, R, and optionally the orthogonal
 transformation matrices U, V and Q.

 In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
 A and B implicitly gives the SVD of A*inv(B):
 A*inv(B) = U*(D1*inv(D2))*V**T.
 If ( A**T,B**T)**T has orthonormal columns, then the GSVD of A and B is
 also equal to the CS decomposition of A and B. Furthermore, the GSVD
 can be used to derive the solution of the eigenvalue problem:
 A**T*A x = lambda* B**T*B x.
 In some literature, the GSVD of A and B is presented in the form
 U**T*A*X = ( 0 D1 ), V**T*B*X = ( 0 D2 )
 where U and V are orthogonal and X is nonsingular, D1 and D2 are
 ``diagonal''. The former GSVD form can be converted to the latter
 form by taking the nonsingular matrix X as

 X = Q*( I 0 )
 ( 0 inv(R) ).

Original Fortran LAPACK argument documentation for SGGSVD::

 JOBU is CHARACTER*1
  = 'U': Orthogonal matrix U is computed;
  = 'N': U is not computed.

 JOBV is CHARACTER*1
  = 'V': Orthogonal matrix V is computed;
  = 'N': V is not computed.

 JOBQ is CHARACTER*1
  = 'Q': Orthogonal matrix Q is computed;
  = 'N': Q is not computed.

 K is INTEGER

 L is INTEGER
 
  On exit, K and L specify the dimension of the subblocks
  described in Purpose.
  K + L = effective numerical rank of (A**T,B**T)**T.

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, A contains the triangular matrix R, or part of R.
  See Purpose for details.

 B is REAL array, dimension (LDB,N)
  On entry, the P-by-N matrix B.
  On exit, B contains the triangular matrix R if M-K-L < 0.
  See Purpose for details.

 ALPHA is REAL array, dimension (N)

 BETA is REAL array, dimension (N)
 
  On exit, ALPHA and BETA contain the generalized singular
  value pairs of A and B;
  ALPHA(1:K) = 1,
  BETA(1:K) = 0,
  and if M-K-L >= 0,
  ALPHA(K+1:K+L) = C,
  BETA(K+1:K+L) = S,
  or if M-K-L < 0,
  ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
  BETA(K+1:M) =S, BETA(M+1:K+L) =1
  and
  ALPHA(K+L+1:N) = 0
  BETA(K+L+1:N) = 0

 U is REAL array, dimension (LDU,M)
  If JOBU = 'U', U contains the M-by-M orthogonal matrix U.
  If JOBU = 'N', U is not referenced.

 V is REAL array, dimension (LDV,P)
  If JOBV = 'V', V contains the P-by-P orthogonal matrix V.
  If JOBV = 'N', V is not referenced.

 Q is REAL array, dimension (LDQ,N)
  If JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q.
  If JOBQ = 'N', Q is not referenced.

 IWORK is INTEGER array, dimension (N)
  On exit, IWORK stores the sorting information. More
  precisely, the following loop will sort ALPHA
  for I = K+1, min(M,K+L)
  swap ALPHA(I) and ALPHA(IWORK(I))
  endfor
  such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).

 */
inline proc ggsvd(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, ref k : c_int, ref l : c_int, a : [] c_float, b : [] c_float, alpha : [] c_float, beta : [] c_float, u : [] c_float, v : [] c_float, q : [] c_float, iwork : [] c_int): c_int{
  return LAPACKE_sggsvd(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, iwork);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggsvd for the type c_double.

For more information, see the documentation for :proc:`ggsvd`, or consult the Netlibs or Intel documentation.
 */
inline proc ggsvd(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, ref k : c_int, ref l : c_int, a : [] c_double, b : [] c_double, alpha : [] c_double, beta : [] c_double, u : [] c_double, v : [] c_double, q : [] c_double, iwork : [] c_int): c_int{
  return LAPACKE_dggsvd(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, iwork);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggsvd for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggsvd`, or consult the Netlibs or Intel documentation.
 */
inline proc ggsvd(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, ref k : c_int, ref l : c_int, a : [] complex(64), b : [] complex(64), alpha : [] c_float, beta : [] c_float, u : [] complex(64), v : [] complex(64), q : [] complex(64), iwork : [] c_int): c_int{
  return LAPACKE_cggsvd(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, iwork);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggsvd for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggsvd`, or consult the Netlibs or Intel documentation.
 */
inline proc ggsvd(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, ref k : c_int, ref l : c_int, a : [] complex(128), b : [] complex(128), alpha : [] c_double, beta : [] c_double, u : [] complex(128), v : [] complex(128), q : [] complex(128), iwork : [] c_int): c_int{
  return LAPACKE_zggsvd(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, iwork);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sggsvp for the type c_float.

Original Fortran LAPACK purpose documentation for SGGSVP::

 SGGSVP computes orthogonal matrices U, V and Q such that

 N-K-L K L
 U**T*A*Q = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 V**T*B*Q = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal. K+L = the effective
 numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T. 

 This decomposition is the preprocessing step for computing the
 Generalized Singular Value Decomposition (GSVD), see subroutine
 SGGSVD.

Original Fortran LAPACK argument documentation for SGGSVP::

 JOBU is CHARACTER*1
  = 'U': Orthogonal matrix U is computed;
  = 'N': U is not computed.

 JOBV is CHARACTER*1
  = 'V': Orthogonal matrix V is computed;
  = 'N': V is not computed.

 JOBQ is CHARACTER*1
  = 'Q': Orthogonal matrix Q is computed;
  = 'N': Q is not computed.

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, A contains the triangular (or trapezoidal) matrix
  described in the Purpose section.

 B is REAL array, dimension (LDB,N)
  On entry, the P-by-N matrix B.
  On exit, B contains the triangular matrix described in
  the Purpose section.

 TOLA is REAL

 TOLB is REAL
 
  TOLA and TOLB are the thresholds to determine the effective
  numerical rank of matrix B and a subblock of A. Generally,
  they are set to
  TOLA = MAX(M,N)*norm(A)*MACHEPS,
  TOLB = MAX(P,N)*norm(B)*MACHEPS.
  The size of TOLA and TOLB may affect the size of backward
  errors of the decomposition.

 K is INTEGER

 L is INTEGER
 
  On exit, K and L specify the dimension of the subblocks
  described in Purpose section.
  K + L = effective numerical rank of (A**T,B**T)**T.

 U is REAL array, dimension (LDU,M)
  If JOBU = 'U', U contains the orthogonal matrix U.
  If JOBU = 'N', U is not referenced.

 V is REAL array, dimension (LDV,P)
  If JOBV = 'V', V contains the orthogonal matrix V.
  If JOBV = 'N', V is not referenced.

 Q is REAL array, dimension (LDQ,N)
  If JOBQ = 'Q', Q contains the orthogonal matrix Q.
  If JOBQ = 'N', Q is not referenced.

 */
inline proc ggsvp(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, a : [] c_float, b : [] c_float, tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] c_float, v : [] c_float, q : [] c_float): c_int{
  return LAPACKE_sggsvp(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, tola, tolb, k, l, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dggsvp for the type c_double.

For more information, see the documentation for :proc:`ggsvp`, or consult the Netlibs or Intel documentation.
 */
inline proc ggsvp(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, a : [] c_double, b : [] c_double, tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] c_double, v : [] c_double, q : [] c_double): c_int{
  return LAPACKE_dggsvp(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, tola, tolb, k, l, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cggsvp for the type lapack_complex_float.

For more information, see the documentation for :proc:`ggsvp`, or consult the Netlibs or Intel documentation.
 */
inline proc ggsvp(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, a : [] complex(64), b : [] complex(64), tola : c_float, tolb : c_float, ref k : c_int, ref l : c_int, u : [] complex(64), v : [] complex(64), q : [] complex(64)): c_int{
  return LAPACKE_cggsvp(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, tola, tolb, k, l, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zggsvp for the type lapack_complex_double.

For more information, see the documentation for :proc:`ggsvp`, or consult the Netlibs or Intel documentation.
 */
inline proc ggsvp(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, a : [] complex(128), b : [] complex(128), tola : c_double, tolb : c_double, ref k : c_int, ref l : c_int, u : [] complex(128), v : [] complex(128), q : [] complex(128)): c_int{
  return LAPACKE_zggsvp(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, tola, tolb, k, l, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgtcon for the type c_float.

Original Fortran LAPACK purpose documentation for SGTCON::

 SGTCON estimates the reciprocal of the condition number of a real
 tridiagonal matrix A using the LU factorization as computed by
 SGTTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

Original Fortran LAPACK argument documentation for SGTCON::

 NORM is CHARACTER*1
  Specifies whether the 1-norm condition number or the
  infinity-norm condition number is required:
  = '1' or 'O': 1-norm;
  = 'I': Infinity-norm.

 N is INTEGER
  The order of the matrix A. N >= 0.

 DL is REAL array, dimension (N-1)
  The (n-1) multipliers that define the matrix L from the
  LU factorization of A as computed by SGTTRF.

 D is REAL array, dimension (N)
  The n diagonal elements of the upper triangular matrix U from
  the LU factorization of A.

 DU is REAL array, dimension (N-1)
  The (n-1) elements of the first superdiagonal of U.

 DU2 is REAL array, dimension (N-2)
  The (n-2) elements of the second superdiagonal of U.

 IPIV is INTEGER array, dimension (N)
  The pivot indices; for 1 <= i <= n, row i of the matrix was
  interchanged with row IPIV(i). IPIV(i) will always be either
  i or i+1; IPIV(i) = i indicates a row interchange was not
  required.

 ANORM is REAL
  If NORM = '1' or 'O', the 1-norm of the original matrix A.
  If NORM = 'I', the infinity-norm of the original matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
  estimate of the 1-norm of inv(A) computed in this routine.

 */
inline proc gtcon(norm : string, n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_sgtcon(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgtcon for the type c_double.

For more information, see the documentation for :proc:`gtcon`, or consult the Netlibs or Intel documentation.
 */
inline proc gtcon(norm : string, n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_dgtcon(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgtcon for the type lapack_complex_float.

For more information, see the documentation for :proc:`gtcon`, or consult the Netlibs or Intel documentation.
 */
inline proc gtcon(norm : string, n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_cgtcon(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgtcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`gtcon`, or consult the Netlibs or Intel documentation.
 */
inline proc gtcon(norm : string, n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zgtcon(ascii(norm) : c_char, n, dl, d, du, du2, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgtrfs for the type c_float.

Original Fortran LAPACK purpose documentation for SGTRFS::

 SGTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is tridiagonal, and provides
 error bounds and backward error estimates for the solution.

Original Fortran LAPACK argument documentation for SGTRFS::

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 N is INTEGER
  The order of the matrix A. N >= 0.

 DL is REAL array, dimension (N-1)
  The (n-1) subdiagonal elements of A.

 D is REAL array, dimension (N)
  The diagonal elements of A.

 DU is REAL array, dimension (N-1)
  The (n-1) superdiagonal elements of A.

 DLF is REAL array, dimension (N-1)
  The (n-1) multipliers that define the matrix L from the
  LU factorization of A as computed by SGTTRF.

 DF is REAL array, dimension (N)
  The n diagonal elements of the upper triangular matrix U from
  the LU factorization of A.

 DUF is REAL array, dimension (N-1)
  The (n-1) elements of the first superdiagonal of U.

 DU2 is REAL array, dimension (N-2)
  The (n-2) elements of the second superdiagonal of U.

 IPIV is INTEGER array, dimension (N)
  The pivot indices; for 1 <= i <= n, row i of the matrix was
  interchanged with row IPIV(i). IPIV(i) will always be either
  i or i+1; IPIV(i) = i indicates a row interchange was not
  required.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SGTTRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc gtrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sgtrfs(matrix_order, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, dlf, df, duf, du2, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgtrfs for the type c_double.

For more information, see the documentation for :proc:`gtrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc gtrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dgtrfs(matrix_order, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, dlf, df, duf, du2, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgtrfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`gtrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc gtrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cgtrfs(matrix_order, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, dlf, df, duf, du2, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgtrfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`gtrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc gtrfs(matrix_order : lapack_memory_order, trans : string, n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zgtrfs(matrix_order, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, dlf, df, duf, du2, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgtsv for the type c_float.

Original Fortran LAPACK purpose documentation for SGTSV::

 SGTSV solves the equation

 A*X = B,

 where A is an n by n tridiagonal matrix, by Gaussian elimination with
 partial pivoting.

 Note that the equation A**T*X = B may be solved by interchanging the
 order of the arguments DU and DL.

Original Fortran LAPACK argument documentation for SGTSV::

 DL is REAL array, dimension (N-1)
  On entry, DL must contain the (n-1) sub-diagonal elements of
  A.
 
  On exit, DL is overwritten by the (n-2) elements of the
  second super-diagonal of the upper triangular matrix U from
  the LU factorization of A, in DL(1), ..., DL(n-2).

 D is REAL array, dimension (N)
  On entry, D must contain the diagonal elements of A.
 
  On exit, D is overwritten by the n diagonal elements of U.

 DU is REAL array, dimension (N-1)
  On entry, DU must contain the (n-1) super-diagonal elements
  of A.
 
  On exit, DU is overwritten by the (n-1) elements of the first
  super-diagonal of U.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N by NRHS matrix of right hand side matrix B.
  On exit, if INFO = 0, the N by NRHS solution matrix X.

 */
inline proc gtsv(matrix_order : lapack_memory_order, dl : [] c_float, d : [] c_float, du : [] c_float, b : [] c_float): c_int{
  return LAPACKE_sgtsv(matrix_order, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgtsv for the type c_double.

For more information, see the documentation for :proc:`gtsv`, or consult the Netlibs or Intel documentation.
 */
inline proc gtsv(matrix_order : lapack_memory_order, dl : [] c_double, d : [] c_double, du : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dgtsv(matrix_order, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgtsv for the type lapack_complex_float.

For more information, see the documentation for :proc:`gtsv`, or consult the Netlibs or Intel documentation.
 */
inline proc gtsv(matrix_order : lapack_memory_order, n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cgtsv(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgtsv for the type lapack_complex_double.

For more information, see the documentation for :proc:`gtsv`, or consult the Netlibs or Intel documentation.
 */
inline proc gtsv(matrix_order : lapack_memory_order, n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zgtsv(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgtsvx for the type c_float.

Original Fortran LAPACK purpose documentation for SGTSVX::

 SGTSVX uses the LU factorization to compute the solution to a real
 system of linear equations A * X = B or A**T * X = B,
 where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for SGTSVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of A has been
  supplied on entry.
  = 'F': DLF, DF, DUF, DU2, and IPIV contain the factored
  form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV
  will not be modified.
  = 'N': The matrix will be copied to DLF, DF, and DUF
  and factored.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 N is INTEGER
  The order of the matrix A. N >= 0.

 DL is REAL array, dimension (N-1)
  The (n-1) subdiagonal elements of A.

 D is REAL array, dimension (N)
  The n diagonal elements of A.

 DU is REAL array, dimension (N-1)
  The (n-1) superdiagonal elements of A.

 DLF is REAL array, dimension (N-1)
  If FACT = 'F', then DLF is an input argument and on entry
  contains the (n-1) multipliers that define the matrix L from
  the LU factorization of A as computed by SGTTRF.
 
  If FACT = 'N', then DLF is an output argument and on exit
  contains the (n-1) multipliers that define the matrix L from
  the LU factorization of A.

 DF is REAL array, dimension (N)
  If FACT = 'F', then DF is an input argument and on entry
  contains the n diagonal elements of the upper triangular
  matrix U from the LU factorization of A.
 
  If FACT = 'N', then DF is an output argument and on exit
  contains the n diagonal elements of the upper triangular
  matrix U from the LU factorization of A.

 DUF is REAL array, dimension (N-1)
  If FACT = 'F', then DUF is an input argument and on entry
  contains the (n-1) elements of the first superdiagonal of U.
 
  If FACT = 'N', then DUF is an output argument and on exit
  contains the (n-1) elements of the first superdiagonal of U.

 DU2 is REAL array, dimension (N-2)
  If FACT = 'F', then DU2 is an input argument and on entry
  contains the (n-2) elements of the second superdiagonal of
  U.
 
  If FACT = 'N', then DU2 is an output argument and on exit
  contains the (n-2) elements of the second superdiagonal of
  U.

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains the pivot indices from the LU factorization of A as
  computed by SGTTRF.
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains the pivot indices from the LU factorization of A;
  row i of the matrix was interchanged with row IPIV(i).
  IPIV(i) will always be either i or i+1; IPIV(i) = i indicates
  a row interchange was not required.

 B is REAL array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A. If RCOND is less than the machine precision (in
  particular, if RCOND = 0), the matrix is singular to working
  precision. This condition is indicated by a return code of
  INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc gtsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, dlf : [] c_float, df : [] c_float, duf : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float, x : [] c_float, ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sgtsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, dlf, df, duf, du2, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgtsvx for the type c_double.

For more information, see the documentation for :proc:`gtsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc gtsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, dlf : [] c_double, df : [] c_double, duf : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double, x : [] c_double, ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dgtsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, dlf, df, duf, du2, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgtsvx for the type lapack_complex_float.

For more information, see the documentation for :proc:`gtsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc gtsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), dlf : [] complex(64), df : [] complex(64), duf : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cgtsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, dlf, df, duf, du2, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgtsvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`gtsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc gtsvx(matrix_order : lapack_memory_order, fact : string, trans : string, n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), dlf : [] complex(128), df : [] complex(128), duf : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zgtsvx(matrix_order, ascii(fact) : c_char, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, dlf, df, duf, du2, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgttrf for the type c_float.

Original Fortran LAPACK purpose documentation for SGTTRF::

 SGTTRF computes an LU factorization of a real tridiagonal matrix A
 using elimination with partial pivoting and row interchanges.

 The factorization has the form
 A = L * U
 where L is a product of permutation and unit lower bidiagonal
 matrices and U is upper triangular with nonzeros in only the main
 diagonal and first two superdiagonals.

Original Fortran LAPACK argument documentation for SGTTRF::

 N is INTEGER
  The order of the matrix A.

 DL is REAL array, dimension (N-1)
  On entry, DL must contain the (n-1) sub-diagonal elements of
  A.
 
  On exit, DL is overwritten by the (n-1) multipliers that
  define the matrix L from the LU factorization of A.

 D is REAL array, dimension (N)
  On entry, D must contain the diagonal elements of A.
 
  On exit, D is overwritten by the n diagonal elements of the
  upper triangular matrix U from the LU factorization of A.

 DU is REAL array, dimension (N-1)
  On entry, DU must contain the (n-1) super-diagonal elements
  of A.
 
  On exit, DU is overwritten by the (n-1) elements of the first
  super-diagonal of U.

 DU2 is REAL array, dimension (N-2)
  On exit, DU2 is overwritten by the (n-2) elements of the
  second super-diagonal of U.

 IPIV is INTEGER array, dimension (N)
  The pivot indices; for 1 <= i <= n, row i of the matrix was
  interchanged with row IPIV(i). IPIV(i) will always be either
  i or i+1; IPIV(i) = i indicates a row interchange was not
  required.

 */
inline proc gttrf(n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_sgttrf(n, dl, d, du, du2, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgttrf for the type c_double.

For more information, see the documentation for :proc:`gttrf`, or consult the Netlibs or Intel documentation.
 */
inline proc gttrf(n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dgttrf(n, dl, d, du, du2, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgttrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`gttrf`, or consult the Netlibs or Intel documentation.
 */
inline proc gttrf(n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_cgttrf(n, dl, d, du, du2, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgttrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`gttrf`, or consult the Netlibs or Intel documentation.
 */
inline proc gttrf(n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zgttrf(n, dl, d, du, du2, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgttrs for the type c_float.

Original Fortran LAPACK purpose documentation for SGTTRS::

 SGTTRS solves one of the systems of equations
 A*X = B or A**T*X = B,
 with a tridiagonal matrix A using the LU factorization computed
 by SGTTRF.

Original Fortran LAPACK argument documentation for SGTTRS::

 TRANS is CHARACTER*1
  Specifies the form of the system of equations.
  = 'N': A * X = B (No transpose)
  = 'T': A**T* X = B (Transpose)
  = 'C': A**T* X = B (Conjugate transpose = Transpose)

 N is INTEGER
  The order of the matrix A.

 DL is REAL array, dimension (N-1)
  The (n-1) multipliers that define the matrix L from the
  LU factorization of A.

 D is REAL array, dimension (N)
  The n diagonal elements of the upper triangular matrix U from
  the LU factorization of A.

 DU is REAL array, dimension (N-1)
  The (n-1) elements of the first super-diagonal of U.

 DU2 is REAL array, dimension (N-2)
  The (n-2) elements of the second super-diagonal of U.

 IPIV is INTEGER array, dimension (N)
  The pivot indices; for 1 <= i <= n, row i of the matrix was
  interchanged with row IPIV(i). IPIV(i) will always be either
  i or i+1; IPIV(i) = i indicates a row interchange was not
  required.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the matrix of right hand side vectors B.
  On exit, B is overwritten by the solution vectors X.

 */
inline proc gttrs(matrix_order : lapack_memory_order, trans : string, n : c_int, dl : [] c_float, d : [] c_float, du : [] c_float, du2 : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_sgttrs(matrix_order, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, du2, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgttrs for the type c_double.

For more information, see the documentation for :proc:`gttrs`, or consult the Netlibs or Intel documentation.
 */
inline proc gttrs(matrix_order : lapack_memory_order, trans : string, n : c_int, dl : [] c_double, d : [] c_double, du : [] c_double, du2 : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dgttrs(matrix_order, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, du2, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgttrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`gttrs`, or consult the Netlibs or Intel documentation.
 */
inline proc gttrs(matrix_order : lapack_memory_order, trans : string, n : c_int, dl : [] complex(64), d : [] complex(64), du : [] complex(64), du2 : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_cgttrs(matrix_order, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, du2, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgttrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`gttrs`, or consult the Netlibs or Intel documentation.
 */
inline proc gttrs(matrix_order : lapack_memory_order, trans : string, n : c_int, dl : [] complex(128), d : [] complex(128), du : [] complex(128), du2 : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zgttrs(matrix_order, ascii(trans) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, dl, d, du, du2, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chbev for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHBEV::

 CHBEV computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A.

Original Fortran LAPACK argument documentation for CHBEV::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is COMPLEX array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
 
  On exit, AB is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the first
  superdiagonal and the diagonal of the tridiagonal matrix T
  are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
  the diagonal and first subdiagonal of T are returned in the
  first two rows of AB.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc hbev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), w : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_chbev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhbev for the type lapack_complex_double.

For more information, see the documentation for :proc:`hbev`, or consult the Netlibs or Intel documentation.
 */
inline proc hbev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), w : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zhbev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chbevd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHBEVD::

 CHBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian band matrix A. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for CHBEVD::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is COMPLEX array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
 
  On exit, AB is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the first
  superdiagonal and the diagonal of the tridiagonal matrix T
  are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
  the diagonal and first subdiagonal of T are returned in the
  first two rows of AB.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc hbevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), w : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_chbevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhbevd for the type lapack_complex_double.

For more information, see the documentation for :proc:`hbevd`, or consult the Netlibs or Intel documentation.
 */
inline proc hbevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), w : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zhbevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chbevx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHBEVX::

 CHBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian band matrix A. Eigenvalues and eigenvectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for CHBEVX::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found;
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found;
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is COMPLEX array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
 
  On exit, AB is overwritten by values generated during the
  reduction to tridiagonal form.

 Q is COMPLEX array, dimension (LDQ, N)
  If JOBZ = 'V', the N-by-N unitary matrix used in the
  reduction to tridiagonal form.
  If JOBZ = 'N', the array Q is not referenced.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing AB to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  The first M elements contain the selected eigenvalues in
  ascending order.

 Z is COMPLEX array, dimension (LDZ, max(1,M))
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and the
  index of the eigenvector is returned in IFAIL.
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc hbevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), q : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ifail : [] c_int): c_int{
  return LAPACKE_chbevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhbevx for the type lapack_complex_double.

For more information, see the documentation for :proc:`hbevx`, or consult the Netlibs or Intel documentation.
 */
inline proc hbevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), q : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ifail : [] c_int): c_int{
  return LAPACKE_zhbevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chbgst for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHBGST::

 CHBGST reduces a complex Hermitian-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**H*S by CPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**H*A*X, where
 X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
 bandwidth of A.

Original Fortran LAPACK argument documentation for CHBGST::

 VECT is CHARACTER*1
  = 'N': do not form the transformation matrix X;
  = 'V': form X.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 KA is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= 0.

 KB is INTEGER
  The number of superdiagonals of the matrix B if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= KB >= 0.

 AB is COMPLEX array, dimension (LDAB,N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix A, stored in the first ka+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+ka).
 
  On exit, the transformed matrix X**H*A*X, stored in the same
  format as A.

 BB is COMPLEX array, dimension (LDBB,N)
  The banded factor S from the split Cholesky factorization of
  B, as returned by CPBSTF, stored in the first kb+1 rows of
  the array.

 X is COMPLEX array, dimension (LDX,N)
  If VECT = 'V', the n-by-n matrix X.
  If VECT = 'N', the array X is not referenced.

 */
inline proc hbgst(matrix_order : lapack_memory_order, vect : string, uplo : string, ka : c_int, kb : c_int, ab : [] complex(64), bb : [] complex(64), x : [] complex(64)): c_int{
  return LAPACKE_chbgst(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(2).size else x.domain.dim(1).size) : c_int, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhbgst for the type lapack_complex_double.

For more information, see the documentation for :proc:`hbgst`, or consult the Netlibs or Intel documentation.
 */
inline proc hbgst(matrix_order : lapack_memory_order, vect : string, uplo : string, ka : c_int, kb : c_int, ab : [] complex(128), bb : [] complex(128), x : [] complex(128)): c_int{
  return LAPACKE_zhbgst(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(2).size else x.domain.dim(1).size) : c_int, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chbgv for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHBGV::

 CHBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite.

Original Fortran LAPACK argument documentation for CHBGV::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 KA is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= 0.

 KB is INTEGER
  The number of superdiagonals of the matrix B if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KB >= 0.

 AB is COMPLEX array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix A, stored in the first ka+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+ka).
 
  On exit, the contents of AB are destroyed.

 BB is COMPLEX array, dimension (LDBB, N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix B, stored in the first kb+1 rows of the array. The
  j-th column of B is stored in the j-th column of the array BB
  as follows:
  if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
  if UPLO = 'L', BB(1+i-j,j) = B(i,j) for j<=i<=min(n,j+kb).
 
  On exit, the factor S from the split Cholesky factorization
  B = S**H*S, as returned by CPBSTF.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors, with the i-th column of Z holding the
  eigenvector associated with W(i). The eigenvectors are
  normalized so that Z**H*B*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc hbgv(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), bb : [] complex(64), w : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_chbgv(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhbgv for the type lapack_complex_double.

For more information, see the documentation for :proc:`hbgv`, or consult the Netlibs or Intel documentation.
 */
inline proc hbgv(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), bb : [] complex(128), w : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zhbgv(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chbgvd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHBGVD::

 CHBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for CHBGVD::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 KA is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= 0.

 KB is INTEGER
  The number of superdiagonals of the matrix B if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KB >= 0.

 AB is COMPLEX array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix A, stored in the first ka+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+ka).
 
  On exit, the contents of AB are destroyed.

 BB is COMPLEX array, dimension (LDBB, N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix B, stored in the first kb+1 rows of the array. The
  j-th column of B is stored in the j-th column of the array BB
  as follows:
  if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
  if UPLO = 'L', BB(1+i-j,j) = B(i,j) for j<=i<=min(n,j+kb).
 
  On exit, the factor S from the split Cholesky factorization
  B = S**H*S, as returned by CPBSTF.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors, with the i-th column of Z holding the
  eigenvector associated with W(i). The eigenvectors are
  normalized so that Z**H*B*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc hbgvd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(64), bb : [] complex(64), w : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_chbgvd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhbgvd for the type lapack_complex_double.

For more information, see the documentation for :proc:`hbgvd`, or consult the Netlibs or Intel documentation.
 */
inline proc hbgvd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] complex(128), bb : [] complex(128), w : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zhbgvd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chbgvx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHBGVX::

 CHBGVX computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for CHBGVX::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found;
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found;
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 KA is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= 0.

 KB is INTEGER
  The number of superdiagonals of the matrix B if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KB >= 0.

 AB is COMPLEX array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix A, stored in the first ka+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+ka).
 
  On exit, the contents of AB are destroyed.

 BB is COMPLEX array, dimension (LDBB, N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix B, stored in the first kb+1 rows of the array. The
  j-th column of B is stored in the j-th column of the array BB
  as follows:
  if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
  if UPLO = 'L', BB(1+i-j,j) = B(i,j) for j<=i<=min(n,j+kb).
 
  On exit, the factor S from the split Cholesky factorization
  B = S**H*S, as returned by CPBSTF.

 Q is COMPLEX array, dimension (LDQ, N)
  If JOBZ = 'V', the n-by-n matrix used in the reduction of
  A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,
  and consequently C to tridiagonal form.
  If JOBZ = 'N', the array Q is not referenced.

 VL is REAL

 VU is REAL
 
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
 
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing AP to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors, with the i-th column of Z holding the
  eigenvector associated with W(i). The eigenvectors are
  normalized so that Z**H*B*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc hbgvx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, ka : c_int, kb : c_int, ab : [] complex(64), bb : [] complex(64), q : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ifail : [] c_int): c_int{
  return LAPACKE_chbgvx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then q.domain.dim(2).size else q.domain.dim(1).size) : c_int, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhbgvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`hbgvx`, or consult the Netlibs or Intel documentation.
 */
inline proc hbgvx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, ka : c_int, kb : c_int, ab : [] complex(128), bb : [] complex(128), q : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ifail : [] c_int): c_int{
  return LAPACKE_zhbgvx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then q.domain.dim(2).size else q.domain.dim(1).size) : c_int, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chbtrd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHBTRD::

 CHBTRD reduces a complex Hermitian band matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

Original Fortran LAPACK argument documentation for CHBTRD::

 VECT is CHARACTER*1
  = 'N': do not form Q;
  = 'V': form Q;
  = 'U': update a matrix X, by forming X*Q.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is COMPLEX array, dimension (LDAB,N)
  On entry, the upper or lower triangle of the Hermitian band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
  On exit, the diagonal elements of AB are overwritten by the
  diagonal elements of the tridiagonal matrix T; if KD > 0, the
  elements on the first superdiagonal (if UPLO = 'U') or the
  first subdiagonal (if UPLO = 'L') are overwritten by the
  off-diagonal elements of T; the rest of AB is overwritten by
  values generated during the reduction.

 D is REAL array, dimension (N)
  The diagonal elements of the tridiagonal matrix T.

 E is REAL array, dimension (N-1)
  The off-diagonal elements of the tridiagonal matrix T:
  E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.

 Q is COMPLEX array, dimension (LDQ,N)
  On entry, if VECT = 'U', then Q must contain an N-by-N
  matrix X; if VECT = 'N' or 'V', then Q need not be set.
 
  On exit:
  if VECT = 'V', Q contains the N-by-N unitary matrix Q;
  if VECT = 'U', Q contains the product X*Q;
  if VECT = 'N', the array Q is not referenced.

 */
inline proc hbtrd(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), d : [] c_float, e : [] c_float, q : [] complex(64)): c_int{
  return LAPACKE_chbtrd(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, d, e, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhbtrd for the type lapack_complex_double.

For more information, see the documentation for :proc:`hbtrd`, or consult the Netlibs or Intel documentation.
 */
inline proc hbtrd(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), d : [] c_double, e : [] c_double, q : [] complex(128)): c_int{
  return LAPACKE_zhbtrd(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, d, e, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_checon for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHECON::

 CHECON estimates the reciprocal of the condition number of a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHETRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

Original Fortran LAPACK argument documentation for CHECON::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**H;
  = 'L': Lower triangular, form is A = L*D*L**H.

 A is COMPLEX array, dimension (LDA,N)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by CHETRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CHETRF.

 ANORM is REAL
  The 1-norm of the original matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
  estimate of the 1-norm of inv(A) computed in this routine.

 */
inline proc hecon(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_checon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhecon for the type lapack_complex_double.

For more information, see the documentation for :proc:`hecon`, or consult the Netlibs or Intel documentation.
 */
inline proc hecon(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zhecon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cheequb for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHEEQUB::

 CHEEQUB computes row and column scalings intended to equilibrate a
 Hermitian matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

Original Fortran LAPACK argument documentation for CHEEQUB::

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 A is COMPLEX array, dimension (LDA,N)
  The N-by-N Hermitian matrix whose scaling
  factors are to be computed. Only the diagonal elements of A
  are referenced.

 S is REAL array, dimension (N)
  If INFO = 0, S contains the scale factors for A.

 SCOND is REAL
  If INFO = 0, S contains the ratio of the smallest S(i) to
  the largest S(i). If SCOND >= 0.1 and AMAX is neither too
  large nor too small, it is not worth scaling by S.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc heequb(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_cheequb(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zheequb for the type lapack_complex_double.

For more information, see the documentation for :proc:`heequb`, or consult the Netlibs or Intel documentation.
 */
inline proc heequb(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_zheequb(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cheev for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHEEV::

 CHEEV computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A.

Original Fortran LAPACK argument documentation for CHEEV::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA, N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
  On exit, if JOBZ = 'V', then if INFO = 0, A contains the
  orthonormal eigenvectors of the matrix A.
  If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
  or the upper triangle (if UPLO='U') of A, including the
  diagonal, is destroyed.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 */
inline proc heev(matrix_order : lapack_memory_order, jobz : string, uplo : string, a : [] complex(64), w : [] c_float): c_int{
  return LAPACKE_cheev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zheev for the type lapack_complex_double.

For more information, see the documentation for :proc:`heev`, or consult the Netlibs or Intel documentation.
 */
inline proc heev(matrix_order : lapack_memory_order, jobz : string, uplo : string, a : [] complex(128), w : [] c_double): c_int{
  return LAPACKE_zheev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cheevd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHEEVD::

 CHEEVD computes all eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for CHEEVD::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA, N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
  On exit, if JOBZ = 'V', then if INFO = 0, A contains the
  orthonormal eigenvectors of the matrix A.
  If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
  or the upper triangle (if UPLO='U') of A, including the
  diagonal, is destroyed.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 */
inline proc heevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, a : [] complex(64), w : [] c_float): c_int{
  return LAPACKE_cheevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zheevd for the type lapack_complex_double.

For more information, see the documentation for :proc:`heevd`, or consult the Netlibs or Intel documentation.
 */
inline proc heevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, a : [] complex(128), w : [] c_double): c_int{
  return LAPACKE_zheevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cheevr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHEEVR::

 CHEEVR computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 CHEEVR first reduces the matrix A to tridiagonal form T with a call
 to CHETRD. Then, whenever possible, CHEEVR calls CSTEMR to compute
 the eigenspectrum using Relatively Robust Representations. CSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see DSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : CHEEVR calls CSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 CHEEVR calls SSTEBZ and CSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of CSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

Original Fortran LAPACK argument documentation for CHEEVR::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.
  For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and
  CSTEIN are called

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA, N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
  On exit, the lower triangle (if UPLO='L') or the upper
  triangle (if UPLO='U') of A, including the diagonal, is
  destroyed.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing A to tridiagonal form.
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.
 
  If high relative accuracy is important, set ABSTOL to
  SLAMCH( 'Safe minimum' ). Doing so will guarantee that
  eigenvalues are computed to high relative accuracy when
  possible in future releases. The current code does not
  make any guarantees about high relative accuracy, but
  furutre releases will. See J. Barlow and J. Demmel,
  "Computing Accurate Eigensystems of Scaled Diagonally
  Dominant Matrices", LAPACK Working Note #7, for a discussion
  of which matrices define their eigenvalues to high relative
  accuracy.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  The first M elements contain the selected eigenvalues in
  ascending order.

 Z is COMPLEX array, dimension (LDZ, max(1,M))
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
  The support of the eigenvectors in Z, i.e., the indices
  indicating the nonzero elements in Z. The i-th eigenvector
  is nonzero only in elements ISUPPZ( 2*i-1 ) through
  ISUPPZ( 2*i ).
  Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1

 */
inline proc heevr(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, a : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), isuppz : [] c_int): c_int{
  return LAPACKE_cheevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zheevr for the type lapack_complex_double.

For more information, see the documentation for :proc:`heevr`, or consult the Netlibs or Intel documentation.
 */
inline proc heevr(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, a : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), isuppz : [] c_int): c_int{
  return LAPACKE_zheevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cheevx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHEEVX::

 CHEEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for CHEEVX::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA, N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
  On exit, the lower triangle (if UPLO='L') or the upper
  triangle (if UPLO='U') of A, including the diagonal, is
  destroyed.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing A to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  On normal exit, the first M elements contain the selected
  eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, max(1,M))
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and the
  index of the eigenvector is returned in IFAIL.
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc heevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, a : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ifail : [] c_int): c_int{
  return LAPACKE_cheevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zheevx for the type lapack_complex_double.

For more information, see the documentation for :proc:`heevx`, or consult the Netlibs or Intel documentation.
 */
inline proc heevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, a : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ifail : [] c_int): c_int{
  return LAPACKE_zheevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chegst for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHEGST::

 CHEGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by CPOTRF.

Original Fortran LAPACK argument documentation for CHEGST::

 ITYPE is INTEGER
  = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
  = 2 or 3: compute U*A*U**H or L**H*A*L.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored and B is factored as
  U**H*U;
  = 'L': Lower triangle of A is stored and B is factored as
  L*L**H.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if INFO = 0, the transformed matrix, stored in the
  same format as A.

 B is COMPLEX array, dimension (LDB,N)
  The triangular factor from the Cholesky factorization of B,
  as returned by CPOTRF.

 */
inline proc hegst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, a : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_chegst(matrix_order, itype, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhegst for the type lapack_complex_double.

For more information, see the documentation for :proc:`hegst`, or consult the Netlibs or Intel documentation.
 */
inline proc hegst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, a : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zhegst(matrix_order, itype, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chegv for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHEGV::

 CHEGV computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian and B is also
 positive definite.

Original Fortran LAPACK argument documentation for CHEGV::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 A is COMPLEX array, dimension (LDA, N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
 
  On exit, if JOBZ = 'V', then if INFO = 0, A contains the
  matrix Z of eigenvectors. The eigenvectors are normalized
  as follows:
  if ITYPE = 1 or 2, Z**H*B*Z = I;
  if ITYPE = 3, Z**H*inv(B)*Z = I.
  If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
  or the lower triangle (if UPLO='L') of A, including the
  diagonal, is destroyed.

 B is COMPLEX array, dimension (LDB, N)
  On entry, the Hermitian positive definite matrix B.
  If UPLO = 'U', the leading N-by-N upper triangular part of B
  contains the upper triangular part of the matrix B.
  If UPLO = 'L', the leading N-by-N lower triangular part of B
  contains the lower triangular part of the matrix B.
 
  On exit, if INFO <= N, the part of B containing the matrix is
  overwritten by the triangular factor U or L from the Cholesky
  factorization B = U**H*U or B = L*L**H.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 */
inline proc hegv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, a : [] complex(64), b : [] complex(64), w : [] c_float): c_int{
  return LAPACKE_chegv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhegv for the type lapack_complex_double.

For more information, see the documentation for :proc:`hegv`, or consult the Netlibs or Intel documentation.
 */
inline proc hegv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, a : [] complex(128), b : [] complex(128), w : [] c_double): c_int{
  return LAPACKE_zhegv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chegvd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHEGVD::

 CHEGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for CHEGVD::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 A is COMPLEX array, dimension (LDA, N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
 
  On exit, if JOBZ = 'V', then if INFO = 0, A contains the
  matrix Z of eigenvectors. The eigenvectors are normalized
  as follows:
  if ITYPE = 1 or 2, Z**H*B*Z = I;
  if ITYPE = 3, Z**H*inv(B)*Z = I.
  If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
  or the lower triangle (if UPLO='L') of A, including the
  diagonal, is destroyed.

 B is COMPLEX array, dimension (LDB, N)
  On entry, the Hermitian matrix B. If UPLO = 'U', the
  leading N-by-N upper triangular part of B contains the
  upper triangular part of the matrix B. If UPLO = 'L',
  the leading N-by-N lower triangular part of B contains
  the lower triangular part of the matrix B.
 
  On exit, if INFO <= N, the part of B containing the matrix is
  overwritten by the triangular factor U or L from the Cholesky
  factorization B = U**H*U or B = L*L**H.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 */
inline proc hegvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, a : [] complex(64), b : [] complex(64), w : [] c_float): c_int{
  return LAPACKE_chegvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhegvd for the type lapack_complex_double.

For more information, see the documentation for :proc:`hegvd`, or consult the Netlibs or Intel documentation.
 */
inline proc hegvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, a : [] complex(128), b : [] complex(128), w : [] c_double): c_int{
  return LAPACKE_zhegvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chegvx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHEGVX::

 CHEGVX computes selected eigenvalues, and optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for CHEGVX::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 A is COMPLEX array, dimension (LDA, N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
 
  On exit, the lower triangle (if UPLO='L') or the upper
  triangle (if UPLO='U') of A, including the diagonal, is
  destroyed.

 B is COMPLEX array, dimension (LDB, N)
  On entry, the Hermitian matrix B. If UPLO = 'U', the
  leading N-by-N upper triangular part of B contains the
  upper triangular part of the matrix B. If UPLO = 'L',
  the leading N-by-N lower triangular part of B contains
  the lower triangular part of the matrix B.
 
  On exit, if INFO <= N, the part of B containing the matrix is
  overwritten by the triangular factor U or L from the Cholesky
  factorization B = U**H*U or B = L*L**H.

 VL is REAL

 VU is REAL
 
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
 
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing C to tridiagonal form, where C is the symmetric
  matrix of the standard symmetric problem to which the
  generalized problem is transformed.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  The first M elements contain the selected
  eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, max(1,M))
  If JOBZ = 'N', then Z is not referenced.
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  The eigenvectors are normalized as follows:
  if ITYPE = 1 or 2, Z**T*B*Z = I;
  if ITYPE = 3, Z**T*inv(B)*Z = I.
 
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and the
  index of the eigenvector is returned in IFAIL.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc hegvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, a : [] complex(64), b : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ifail : [] c_int): c_int{
  return LAPACKE_chegvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhegvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`hegvx`, or consult the Netlibs or Intel documentation.
 */
inline proc hegvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, a : [] complex(128), b : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ifail : [] c_int): c_int{
  return LAPACKE_zhegvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cherfs for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHERFS::

 CHERFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the solution.

Original Fortran LAPACK argument documentation for CHERFS::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA,N)
  The Hermitian matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular part
  of the matrix A, and the strictly lower triangular part of A
  is not referenced. If UPLO = 'L', the leading N-by-N lower
  triangular part of A contains the lower triangular part of
  the matrix A, and the strictly upper triangular part of A is
  not referenced.

 AF is COMPLEX array, dimension (LDAF,N)
  The factored form of the matrix A. AF contains the block
  diagonal matrix D and the multipliers used to obtain the
  factor U or L from the factorization A = U*D*U**H or
  A = L*D*L**H as computed by CHETRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CHETRF.

 B is COMPLEX array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is COMPLEX array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by CHETRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc herfs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cherfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zherfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`herfs`, or consult the Netlibs or Intel documentation.
 */
inline proc herfs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zherfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cherfsx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHERFSX::

 CHERFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

Original Fortran LAPACK argument documentation for CHERFSX::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done to A
  before calling this routine. This is needed to compute
  the solution and error bounds correctly.
  = 'N': No equilibration
  = 'Y': Both row and column equilibration, i.e., A has been
  replaced by diag(S) * A * diag(S).
  The right hand side B has been changed accordingly.

 A is COMPLEX array, dimension (LDA,N)
  The symmetric matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular
  part of the matrix A, and the strictly lower triangular
  part of A is not referenced. If UPLO = 'L', the leading
  N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.

 AF is COMPLEX array, dimension (LDAF,N)
  The factored form of the matrix A. AF contains the block
  diagonal matrix D and the multipliers used to obtain the
  factor U or L from the factorization A = U*D*U**T or A =
  L*D*L**T as computed by SSYTRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSYTRF.

 S is REAL array, dimension (N)
  The scale factors for A. If EQUED = 'Y', A is multiplied on
  the left and right by diag(S). S is an input argument if FACT =
  'F'; otherwise, S is an output argument. If FACT = 'F' and EQUED
  = 'Y', each element of S must be positive. If S is output, each
  element of S is a power of the radix. If S is input, each element
  of S should be a power of the radix to ensure a reliable solution
  and error estimates. Scaling by powers of the radix does not cause
  rounding errors unless the result underflows or overflows.
  Rounding errors during scaling lead to refining with a matrix that
  is not equivalent to the input matrix, producing error estimates
  that may not be reliable.

 B is COMPLEX array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is COMPLEX array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SGETRS.
  On exit, the improved solution matrix X.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc herfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, s : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_cherfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zherfsx for the type lapack_complex_double.

For more information, see the documentation for :proc:`herfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc herfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, s : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zherfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chesv for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHESV::

 CHESV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

Original Fortran LAPACK argument documentation for CHESV::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if INFO = 0, the block diagonal matrix D and the
  multipliers used to obtain the factor U or L from the
  factorization A = U*D*U**H or A = L*D*L**H as computed by
  CHETRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D, as
  determined by CHETRF. If IPIV(k) > 0, then rows and columns
  k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
  diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
  then rows and columns k-1 and -IPIV(k) were interchanged and
  D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and
  IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
  -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
  diagonal block.

 B is COMPLEX array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc hesv(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_chesv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhesv for the type lapack_complex_double.

For more information, see the documentation for :proc:`hesv`, or consult the Netlibs or Intel documentation.
 */
inline proc hesv(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zhesv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chesvx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHESVX::

 CHESVX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B,
 where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for CHESVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of A has been
  supplied on entry.
  = 'F': On entry, AF and IPIV contain the factored form
  of A. A, AF and IPIV will not be modified.
  = 'N': The matrix A will be copied to AF and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA,N)
  The Hermitian matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular part
  of the matrix A, and the strictly lower triangular part of A
  is not referenced. If UPLO = 'L', the leading N-by-N lower
  triangular part of A contains the lower triangular part of
  the matrix A, and the strictly upper triangular part of A is
  not referenced.

 AF is COMPLEX array, dimension (LDAF,N)
  If FACT = 'F', then AF is an input argument and on entry
  contains the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**H or A = L*D*L**H as computed by CHETRF.
 
  If FACT = 'N', then AF is an output argument and on exit
  returns the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**H or A = L*D*L**H.

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains details of the interchanges and the block structure
  of D, as determined by CHETRF.
  If IPIV(k) > 0, then rows and columns k and IPIV(k) were
  interchanged and D(k,k) is a 1-by-1 diagonal block.
  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
  columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
  is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) =
  IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
  interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains details of the interchanges and the block structure
  of D, as determined by CHETRF.

 B is COMPLEX array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is COMPLEX array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A. If RCOND is less than the machine precision (in
  particular, if RCOND = 0), the matrix is singular to working
  precision. This condition is indicated by a return code of
  INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc hesvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_chesvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhesvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`hesvx`, or consult the Netlibs or Intel documentation.
 */
inline proc hesvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zhesvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chesvxx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHESVXX::

 CHESVXX uses the diagonal pivoting factorization to compute the
 solution to a complex system of linear equations A * X = B, where
 A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. CHESVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 CHESVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 CHESVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what CHESVXX would itself produce.

Original Fortran LAPACK argument documentation for CHESVXX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AF and IPIV contain the factored form of A.
  If EQUED is not 'N', the matrix A has been
  equilibrated with scaling factors given by S.
  A, AF, and IPIV are not modified.
  = 'N': The matrix A will be copied to AF and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AF and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA,N)
  The symmetric matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular
  part of the matrix A, and the strictly lower triangular
  part of A is not referenced. If UPLO = 'L', the leading
  N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
  diag(S)*A*diag(S).

 AF is COMPLEX array, dimension (LDAF,N)
  If FACT = 'F', then AF is an input argument and on entry
  contains the block diagonal matrix D and the multipliers
  used to obtain the factor U or L from the factorization A =
  U*D*U**T or A = L*D*L**T as computed by SSYTRF.
 
  If FACT = 'N', then AF is an output argument and on exit
  returns the block diagonal matrix D and the multipliers
  used to obtain the factor U or L from the factorization A =
  U*D*U**T or A = L*D*L**T.

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains details of the interchanges and the block
  structure of D, as determined by CHETRF. If IPIV(k) > 0,
  then rows and columns k and IPIV(k) were interchanged and
  D(k,k) is a 1-by-1 diagonal block. If UPLO = 'U' and
  IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and
  -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2
  diagonal block. If UPLO = 'L' and IPIV(k) = IPIV(k+1) < 0,
  then rows and columns k+1 and -IPIV(k) were interchanged
  and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains details of the interchanges and the block
  structure of D, as determined by CHETRF.

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'Y': Both row and column equilibration, i.e., A has been
  replaced by diag(S) * A * diag(S).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 S is REAL array, dimension (N)
  The scale factors for A. If EQUED = 'Y', A is multiplied on
  the left and right by diag(S). S is an input argument if FACT =
  'F'; otherwise, S is an output argument. If FACT = 'F' and EQUED
  = 'Y', each element of S must be positive. If S is output, each
  element of S is a power of the radix. If S is input, each element
  of S should be a power of the radix to ensure a reliable solution
  and error estimates. Scaling by powers of the radix does not cause
  rounding errors unless the result underflows or overflows.
  Rounding errors during scaling lead to refining with a matrix that
  is not equivalent to the input matrix, producing error estimates
  that may not be reliable.

 B is COMPLEX array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit,
  if EQUED = 'N', B is not modified;
  if EQUED = 'Y', B is overwritten by diag(S)*B;

 X is COMPLEX array, dimension (LDX,NRHS)
  If INFO = 0, the N-by-NRHS solution matrix X to the original
  system of equations. Note that A and B are modified on exit if
  EQUED .ne. 'N', and the solution to the equilibrated system is
  inv(diag(S))*X.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 RPVGRW is REAL
  Reciprocal pivot growth. On exit, this contains the reciprocal
  pivot growth factor norm(A)/norm(U). The "max absolute element"
  norm is used. If this is much less than 1, then the stability of
  the LU factorization of the (equilibrated) matrix A could be poor.
  This also means that the solution X, estimated condition numbers,
  and error bounds could be unreliable. If factorization fails with
  0<INFO<=N, then this contains the reciprocal pivot growth factor
  for the leading INFO columns of A.

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc hesvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, ref equed : string, s : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_chesvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhesvxx for the type lapack_complex_double.

For more information, see the documentation for :proc:`hesvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc hesvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, ref equed : string, s : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zhesvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chetrd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHETRD::

 CHETRD reduces a complex Hermitian matrix A to real symmetric
 tridiagonal form T by a unitary similarity transformation:
 Q**H * A * Q = T.

Original Fortran LAPACK argument documentation for CHETRD::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
  On exit, if UPLO = 'U', the diagonal and first superdiagonal
  of A are overwritten by the corresponding elements of the
  tridiagonal matrix T, and the elements above the first
  superdiagonal, with the array TAU, represent the unitary
  matrix Q as a product of elementary reflectors; if UPLO
  = 'L', the diagonal and first subdiagonal of A are over-
  written by the corresponding elements of the tridiagonal
  matrix T, and the elements below the first subdiagonal, with
  the array TAU, represent the unitary matrix Q as a product
  of elementary reflectors. See Further Details.

 D is REAL array, dimension (N)
  The diagonal elements of the tridiagonal matrix T:
  D(i) = A(i,i).

 E is REAL array, dimension (N-1)
  The off-diagonal elements of the tridiagonal matrix T:
  E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.

 TAU is COMPLEX array, dimension (N-1)
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc hetrd(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), d : [] c_float, e : [] c_float, tau : [] complex(64)): c_int{
  return LAPACKE_chetrd(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, d, e, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhetrd for the type lapack_complex_double.

For more information, see the documentation for :proc:`hetrd`, or consult the Netlibs or Intel documentation.
 */
inline proc hetrd(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), d : [] c_double, e : [] c_double, tau : [] complex(128)): c_int{
  return LAPACKE_zhetrd(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, d, e, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chetrf for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHETRF::

 CHETRF computes the factorization of a complex Hermitian matrix A
 using the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with 
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

Original Fortran LAPACK argument documentation for CHETRF::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, the block diagonal matrix D and the multipliers used
  to obtain the factor U or L (see below for further details).

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D.
  If IPIV(k) > 0, then rows and columns k and IPIV(k) were
  interchanged and D(k,k) is a 1-by-1 diagonal block.
  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
  columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
  is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) =
  IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
  interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

 */
inline proc hetrf(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_chetrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhetrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`hetrf`, or consult the Netlibs or Intel documentation.
 */
inline proc hetrf(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zhetrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chetri for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHETRI::

 CHETRI computes the inverse of a complex Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 CHETRF.

Original Fortran LAPACK argument documentation for CHETRI::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**H;
  = 'L': Lower triangular, form is A = L*D*L**H.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the block diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by CHETRF.
 
  On exit, if INFO = 0, the (Hermitian) inverse of the original
  matrix. If UPLO = 'U', the upper triangular part of the
  inverse is formed and the part of A below the diagonal is not
  referenced; if UPLO = 'L' the lower triangular part of the
  inverse is formed and the part of A above the diagonal is
  not referenced.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CHETRF.

 */
inline proc hetri(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_chetri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhetri for the type lapack_complex_double.

For more information, see the documentation for :proc:`hetri`, or consult the Netlibs or Intel documentation.
 */
inline proc hetri(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zhetri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chetrs for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHETRS::

 CHETRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHETRF.

Original Fortran LAPACK argument documentation for CHETRS::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**H;
  = 'L': Lower triangular, form is A = L*D*L**H.

 A is COMPLEX array, dimension (LDA,N)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by CHETRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CHETRF.

 B is COMPLEX array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc hetrs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_chetrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhetrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`hetrs`, or consult the Netlibs or Intel documentation.
 */
inline proc hetrs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zhetrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chfrk for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHFRK::

 Level 3 BLAS like routine for C in RFP Format.

 CHFRK performs one of the Hermitian rank--k operations

 C := alpha*A*A**H + beta*C,

 or

 C := alpha*A**H*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n Hermitian
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

Original Fortran LAPACK argument documentation for CHFRK::

 TRANSR is CHARACTER*1
  = 'N': The Normal Form of RFP A is stored;
  = 'C': The Conjugate-transpose Form of RFP A is stored.

 UPLO is CHARACTER*1
  On entry, UPLO specifies whether the upper or lower
  triangular part of the array C is to be referenced as
  follows:
 
  UPLO = 'U' or 'u' Only the upper triangular part of C
  is to be referenced.
 
  UPLO = 'L' or 'l' Only the lower triangular part of C
  is to be referenced.
 
  Unchanged on exit.

 TRANS is CHARACTER*1
  On entry, TRANS specifies the operation to be performed as
  follows:
 
  TRANS = 'N' or 'n' C := alpha*A*A**H + beta*C.
 
  TRANS = 'C' or 'c' C := alpha*A**H*A + beta*C.
 
  Unchanged on exit.

 ALPHA is REAL
  On entry, ALPHA specifies the scalar alpha.
  Unchanged on exit.

 A is COMPLEX array, dimension (LDA,ka)
  where KA
  is K when TRANS = 'N' or 'n', and is N otherwise. Before
  entry with TRANS = 'N' or 'n', the leading N--by--K part of
  the array A must contain the matrix A, otherwise the leading
  K--by--N part of the array A must contain the matrix A.
  Unchanged on exit.

 BETA is REAL
  On entry, BETA specifies the scalar beta.
  Unchanged on exit.

 C is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the matrix A in RFP Format. RFP Format is
  described by TRANSR, UPLO and N. Note that the imaginary
  parts of the diagonal elements need not be set, they are
  assumed to be zero, and on exit they are set to zero.

 */
inline proc hfrk(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, alpha : c_float, a : [] complex(64), beta : c_float, c : [] complex(64)): c_int{
  return LAPACKE_chfrk(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (c.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, alpha, a, (a.domain.dim(2).size) : c_int, beta, c);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhfrk for the type lapack_complex_double.

For more information, see the documentation for :proc:`hfrk`, or consult the Netlibs or Intel documentation.
 */
inline proc hfrk(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, alpha : c_double, a : [] complex(128), beta : c_double, c : [] complex(128)): c_int{
  return LAPACKE_zhfrk(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (c.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, alpha, a, (a.domain.dim(2).size) : c_int, beta, c);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_shgeqz for the type c_float.

Original Fortran LAPACK purpose documentation for SHGEQZ::

 SHGEQZ computes the eigenvalues of a real matrix pair (H,T),
 where H is an upper Hessenberg matrix and T is upper triangular,
 using the double-shift QZ method.
 Matrix pairs of this type are produced by the reduction to
 generalized upper Hessenberg form of a real matrix pair (A,B):

 A = Q1*H*Z1**T, B = Q1*T*Z1**T,

 as computed by SGGHRD.

 If JOB='S', then the Hessenberg-triangular pair (H,T) is
 also reduced to generalized Schur form,
 
 H = Q*S*Z**T, T = Q*P*Z**T,
 
 where Q and Z are orthogonal matrices, P is an upper triangular
 matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
 diagonal blocks.

 The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
 (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
 eigenvalues.

 Additionally, the 2-by-2 upper triangular diagonal blocks of P
 corresponding to 2-by-2 blocks of S are reduced to positive diagonal
 form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
 P(j,j) > 0, and P(j+1,j+1) > 0.

 Optionally, the orthogonal matrix Q from the generalized Schur
 factorization may be postmultiplied into an input matrix Q1, and the
 orthogonal matrix Z may be postmultiplied into an input matrix Z1.
 If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced
 the matrix pair (A,B) to generalized upper Hessenberg form, then the
 output matrices Q1*Q and Z1*Z are the orthogonal factors from the
 generalized Schur factorization of (A,B):

 A = (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T.
 
 To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
 of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
 complex and beta real.
 If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
 generalized nonsymmetric eigenvalue problem (GNEP)
 A*x = lambda*B*x
 and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
 alternate form of the GNEP
 mu*A*y = B*y.
 Real eigenvalues can be read directly from the generalized Schur
 form: 
 alpha = S(i,i), beta = P(i,i).

 Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
 Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
 pp. 241--256.

Original Fortran LAPACK argument documentation for SHGEQZ::

 JOB is CHARACTER*1
  = 'E': Compute eigenvalues only;
  = 'S': Compute eigenvalues and the Schur form.

 COMPQ is CHARACTER*1
  = 'N': Left Schur vectors (Q) are not computed;
  = 'I': Q is initialized to the unit matrix and the matrix Q
  of left Schur vectors of (H,T) is returned;
  = 'V': Q must contain an orthogonal matrix Q1 on entry and
  the product Q1*Q is returned.

 COMPZ is CHARACTER*1
  = 'N': Right Schur vectors (Z) are not computed;
  = 'I': Z is initialized to the unit matrix and the matrix Z
  of right Schur vectors of (H,T) is returned;
  = 'V': Z must contain an orthogonal matrix Z1 on entry and
  the product Z1*Z is returned.

 ILO is INTEGER

 IHI is INTEGER
  ILO and IHI mark the rows and columns of H which are in
  Hessenberg form. It is assumed that A is already upper
  triangular in rows and columns 1:ILO-1 and IHI+1:N.
  If N > 0, 1 <= ILO <= IHI <= N; if N = 0, ILO=1 and IHI=0.

 H is REAL array, dimension (LDH, N)
  On entry, the N-by-N upper Hessenberg matrix H.
  On exit, if JOB = 'S', H contains the upper quasi-triangular
  matrix S from the generalized Schur factorization.
  If JOB = 'E', the diagonal blocks of H match those of S, but
  the rest of H is unspecified.

 T is REAL array, dimension (LDT, N)
  On entry, the N-by-N upper triangular matrix T.
  On exit, if JOB = 'S', T contains the upper triangular
  matrix P from the generalized Schur factorization;
  2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S
  are reduced to positive diagonal form, i.e., if H(j+1,j) is
  non-zero, then T(j+1,j) = T(j,j+1) = 0, T(j,j) > 0, and
  T(j+1,j+1) > 0.
  If JOB = 'E', the diagonal blocks of T match those of P, but
  the rest of T is unspecified.

 ALPHAR is REAL array, dimension (N)
  The real parts of each scalar alpha defining an eigenvalue
  of GNEP.

 ALPHAI is REAL array, dimension (N)
  The imaginary parts of each scalar alpha defining an
  eigenvalue of GNEP.
  If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
  positive, then the j-th and (j+1)-st eigenvalues are a
  complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j).

 BETA is REAL array, dimension (N)
  The scalars beta that define the eigenvalues of GNEP.
  Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
  beta = BETA(j) represent the j-th eigenvalue of the matrix
  pair (A,B), in one of the forms lambda = alpha/beta or
  mu = beta/alpha. Since either lambda or mu may overflow,
  they should not, in general, be computed.

 Q is REAL array, dimension (LDQ, N)
  On entry, if COMPZ = 'V', the orthogonal matrix Q1 used in
  the reduction of (A,B) to generalized Hessenberg form.
  On exit, if COMPZ = 'I', the orthogonal matrix of left Schur
  vectors of (H,T), and if COMPZ = 'V', the orthogonal matrix
  of left Schur vectors of (A,B).
  Not referenced if COMPZ = 'N'.

 Z is REAL array, dimension (LDZ, N)
  On entry, if COMPZ = 'V', the orthogonal matrix Z1 used in
  the reduction of (A,B) to generalized Hessenberg form.
  On exit, if COMPZ = 'I', the orthogonal matrix of
  right Schur vectors of (H,T), and if COMPZ = 'V', the
  orthogonal matrix of right Schur vectors of (A,B).
  Not referenced if COMPZ = 'N'.

 */
inline proc hgeqz(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, ilo : c_int, ihi : c_int, h : [] c_float, t : [] c_float, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, z : [] c_float): c_int{
  return LAPACKE_shgeqz(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, (h.domain.dim(1).size) : c_int, ilo, ihi, h, (h.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, alphar, alphai, beta, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dhgeqz for the type c_double.

For more information, see the documentation for :proc:`hgeqz`, or consult the Netlibs or Intel documentation.
 */
inline proc hgeqz(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, ilo : c_int, ihi : c_int, h : [] c_double, t : [] c_double, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dhgeqz(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, (h.domain.dim(1).size) : c_int, ilo, ihi, h, (h.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, alphar, alphai, beta, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chgeqz for the type lapack_complex_float.

For more information, see the documentation for :proc:`hgeqz`, or consult the Netlibs or Intel documentation.
 */
inline proc hgeqz(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, ilo : c_int, ihi : c_int, h : [] complex(64), t : [] complex(64), alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), z : [] complex(64)): c_int{
  return LAPACKE_chgeqz(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, (h.domain.dim(1).size) : c_int, ilo, ihi, h, (h.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, alpha, beta, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhgeqz for the type lapack_complex_double.

For more information, see the documentation for :proc:`hgeqz`, or consult the Netlibs or Intel documentation.
 */
inline proc hgeqz(matrix_order : lapack_memory_order, job : string, compq : string, compz : string, ilo : c_int, ihi : c_int, h : [] complex(128), t : [] complex(128), alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), z : [] complex(128)): c_int{
  return LAPACKE_zhgeqz(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, ascii(compz) : c_char, (h.domain.dim(1).size) : c_int, ilo, ihi, h, (h.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, alpha, beta, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpcon for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPCON::

 CHPCON estimates the reciprocal of the condition number of a complex
 Hermitian packed matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

Original Fortran LAPACK argument documentation for CHPCON::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**H;
  = 'L': Lower triangular, form is A = L*D*L**H.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by CHPTRF, stored as a
  packed triangular matrix.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CHPTRF.

 ANORM is REAL
  The 1-norm of the original matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
  estimate of the 1-norm of inv(A) computed in this routine.

 */
inline proc hpcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_chpcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpcon`, or consult the Netlibs or Intel documentation.
 */
inline proc hpcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zhpcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpev for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPEV::

 CHPEV computes all the eigenvalues and, optionally, eigenvectors of a
 complex Hermitian matrix in packed storage.

Original Fortran LAPACK argument documentation for CHPEV::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, AP is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the diagonal
  and first superdiagonal of the tridiagonal matrix T overwrite
  the corresponding elements of A, and if UPLO = 'L', the
  diagonal and first subdiagonal of T overwrite the
  corresponding elements of A.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc hpev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_chpev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpev for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpev`, or consult the Netlibs or Intel documentation.
 */
inline proc hpev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zhpev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpevd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPEVD::

 CHPEVD computes all the eigenvalues and, optionally, eigenvectors of
 a complex Hermitian matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for CHPEVD::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, AP is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the diagonal
  and first superdiagonal of the tridiagonal matrix T overwrite
  the corresponding elements of A, and if UPLO = 'L', the
  diagonal and first subdiagonal of T overwrite the
  corresponding elements of A.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc hpevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(64), w : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_chpevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpevd for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpevd`, or consult the Netlibs or Intel documentation.
 */
inline proc hpevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] complex(128), w : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zhpevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpevx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPEVX::

 CHPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex Hermitian matrix A in packed storage.
 Eigenvalues/vectors can be selected by specifying either a range of
 values or a range of indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for CHPEVX::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found;
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found;
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, AP is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the diagonal
  and first superdiagonal of the tridiagonal matrix T overwrite
  the corresponding elements of A, and if UPLO = 'L', the
  diagonal and first subdiagonal of T overwrite the
  corresponding elements of A.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing AP to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  If INFO = 0, the selected eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, max(1,M))
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and
  the index of the eigenvector is returned in IFAIL.
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc hpevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ifail : [] c_int): c_int{
  return LAPACKE_chpevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpevx for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpevx`, or consult the Netlibs or Intel documentation.
 */
inline proc hpevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ifail : [] c_int): c_int{
  return LAPACKE_zhpevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpgst for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPGST::

 CHPGST reduces a complex Hermitian-definite generalized
 eigenproblem to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

 B must have been previously factorized as U**H*U or L*L**H by CPPTRF.

Original Fortran LAPACK argument documentation for CHPGST::

 ITYPE is INTEGER
  = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
  = 2 or 3: compute U*A*U**H or L**H*A*L.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored and B is factored as
  U**H*U;
  = 'L': Lower triangle of A is stored and B is factored as
  L*L**H.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, if INFO = 0, the transformed matrix, stored in the
  same format as A.

 BP is COMPLEX array, dimension (N*(N+1)/2)
  The triangular factor from the Cholesky factorization of B,
  stored in the same format as A, as returned by CPPTRF.

 */
inline proc hpgst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64)): c_int{
  return LAPACKE_chpgst(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpgst for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpgst`, or consult the Netlibs or Intel documentation.
 */
inline proc hpgst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128)): c_int{
  return LAPACKE_zhpgst(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpgv for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPGV::

 CHPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be Hermitian, stored in packed format,
 and B is also positive definite.

Original Fortran LAPACK argument documentation for CHPGV::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, the contents of AP are destroyed.

 BP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  B, packed columnwise in a linear array. The j-th column of B
  is stored in the array BP as follows:
  if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
  if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
 
  On exit, the triangular factor U or L from the Cholesky
  factorization B = U**H*U or B = L*L**H, in the same storage
  format as B.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors. The eigenvectors are normalized as follows:
  if ITYPE = 1 or 2, Z**H*B*Z = I;
  if ITYPE = 3, Z**H*inv(B)*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc hpgv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_chpgv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpgv for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpgv`, or consult the Netlibs or Intel documentation.
 */
inline proc hpgv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zhpgv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpgvd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPGVD::

 CHPGVD computes all the eigenvalues and, optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for CHPGVD::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, the contents of AP are destroyed.

 BP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  B, packed columnwise in a linear array. The j-th column of B
  is stored in the array BP as follows:
  if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
  if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
 
  On exit, the triangular factor U or L from the Cholesky
  factorization B = U**H*U or B = L*L**H, in the same storage
  format as B.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors. The eigenvectors are normalized as follows:
  if ITYPE = 1 or 2, Z**H*B*Z = I;
  if ITYPE = 3, Z**H*inv(B)*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc hpgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64), w : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_chpgvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpgvd for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpgvd`, or consult the Netlibs or Intel documentation.
 */
inline proc hpgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128), w : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zhpgvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpgvx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPGVX::

 CHPGVX computes selected eigenvalues and, optionally, eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be Hermitian, stored in packed format, and B is also
 positive definite. Eigenvalues and eigenvectors can be selected by
 specifying either a range of values or a range of indices for the
 desired eigenvalues.

Original Fortran LAPACK argument documentation for CHPGVX::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found;
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found;
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, the contents of AP are destroyed.

 BP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  B, packed columnwise in a linear array. The j-th column of B
  is stored in the array BP as follows:
  if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
  if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
 
  On exit, the triangular factor U or L from the Cholesky
  factorization B = U**H*U or B = L*L**H, in the same storage
  format as B.

 VL is REAL

 VU is REAL
 
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
 
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing AP to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  On normal exit, the first M elements contain the selected
  eigenvalues in ascending order.

 Z is COMPLEX array, dimension (LDZ, N)
  If JOBZ = 'N', then Z is not referenced.
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  The eigenvectors are normalized as follows:
  if ITYPE = 1 or 2, Z**H*B*Z = I;
  if ITYPE = 3, Z**H*inv(B)*Z = I.
 
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and the
  index of the eigenvector is returned in IFAIL.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc hpgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(64), bp : [] complex(64), vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), ifail : [] c_int): c_int{
  return LAPACKE_chpgvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpgvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpgvx`, or consult the Netlibs or Intel documentation.
 */
inline proc hpgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] complex(128), bp : [] complex(128), vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), ifail : [] c_int): c_int{
  return LAPACKE_zhpgvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chprfs for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPRFS::

 CHPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is Hermitian indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

Original Fortran LAPACK argument documentation for CHPRFS::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  The upper or lower triangle of the Hermitian matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.

 AFP is COMPLEX array, dimension (N*(N+1)/2)
  The factored form of the matrix A. AFP contains the block
  diagonal matrix D and the multipliers used to obtain the
  factor U or L from the factorization A = U*D*U**H or
  A = L*D*L**H as computed by CHPTRF, stored as a packed
  triangular matrix.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CHPTRF.

 B is COMPLEX array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is COMPLEX array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by CHPTRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc hprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_chprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhprfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`hprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc hprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zhprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpsv for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPSV::

 CHPSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**H, if UPLO = 'U', or
 A = L * D * L**H, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is Hermitian and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

Original Fortran LAPACK argument documentation for CHPSV::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
  See below for further details.
 
  On exit, the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as
  a packed triangular matrix in the same storage format as A.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D, as
  determined by CHPTRF. If IPIV(k) > 0, then rows and columns
  k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
  diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
  then rows and columns k-1 and -IPIV(k) were interchanged and
  D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and
  IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
  -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
  diagonal block.

 B is COMPLEX array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc hpsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_chpsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpsv for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpsv`, or consult the Netlibs or Intel documentation.
 */
inline proc hpsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zhpsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chpsvx for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPSVX::

 CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
 A = L*D*L**H to compute the solution to a complex system of linear
 equations A * X = B, where A is an N-by-N Hermitian matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for CHPSVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of A has been
  supplied on entry.
  = 'F': On entry, AFP and IPIV contain the factored form of
  A. AFP and IPIV will not be modified.
  = 'N': The matrix A will be copied to AFP and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  The upper or lower triangle of the Hermitian matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
  See below for further details.

 AFP is COMPLEX array, dimension (N*(N+1)/2)
  If FACT = 'F', then AFP is an input argument and on entry
  contains the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as
  a packed triangular matrix in the same storage format as A.
 
  If FACT = 'N', then AFP is an output argument and on exit
  contains the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as
  a packed triangular matrix in the same storage format as A.

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains details of the interchanges and the block structure
  of D, as determined by CHPTRF.
  If IPIV(k) > 0, then rows and columns k and IPIV(k) were
  interchanged and D(k,k) is a 1-by-1 diagonal block.
  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
  columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
  is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) =
  IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
  interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains details of the interchanges and the block structure
  of D, as determined by CHPTRF.

 B is COMPLEX array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is COMPLEX array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A. If RCOND is less than the machine precision (in
  particular, if RCOND = 0), the matrix is singular to working
  precision. This condition is indicated by a return code of
  INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc hpsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_chpsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhpsvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`hpsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc hpsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zhpsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chptrd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPTRD::

 CHPTRD reduces a complex Hermitian matrix A stored in packed form to
 real symmetric tridiagonal form T by a unitary similarity
 transformation: Q**H * A * Q = T.

Original Fortran LAPACK argument documentation for CHPTRD::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
  On exit, if UPLO = 'U', the diagonal and first superdiagonal
  of A are overwritten by the corresponding elements of the
  tridiagonal matrix T, and the elements above the first
  superdiagonal, with the array TAU, represent the unitary
  matrix Q as a product of elementary reflectors; if UPLO
  = 'L', the diagonal and first subdiagonal of A are over-
  written by the corresponding elements of the tridiagonal
  matrix T, and the elements below the first subdiagonal, with
  the array TAU, represent the unitary matrix Q as a product
  of elementary reflectors. See Further Details.

 D is REAL array, dimension (N)
  The diagonal elements of the tridiagonal matrix T:
  D(i) = A(i,i).

 E is REAL array, dimension (N-1)
  The off-diagonal elements of the tridiagonal matrix T:
  E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.

 TAU is COMPLEX array, dimension (N-1)
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc hptrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), d : [] c_float, e : [] c_float, tau : [] complex(64)): c_int{
  return LAPACKE_chptrd(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhptrd for the type lapack_complex_double.

For more information, see the documentation for :proc:`hptrd`, or consult the Netlibs or Intel documentation.
 */
inline proc hptrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), d : [] c_double, e : [] c_double, tau : [] complex(128)): c_int{
  return LAPACKE_zhptrd(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chptrf for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPTRF::

 CHPTRF computes the factorization of a complex Hermitian packed
 matrix A using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**H or A = L*D*L**H

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is Hermitian and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

Original Fortran LAPACK argument documentation for CHPTRF::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the Hermitian matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, the block diagonal matrix D and the multipliers used
  to obtain the factor U or L, stored as a packed triangular
  matrix overwriting A (see below for further details).

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D.
  If IPIV(k) > 0, then rows and columns k and IPIV(k) were
  interchanged and D(k,k) is a 1-by-1 diagonal block.
  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
  columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
  is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) =
  IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
  interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

 */
inline proc hptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_chptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhptrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`hptrf`, or consult the Netlibs or Intel documentation.
 */
inline proc hptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zhptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chptri for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPTRI::

 CHPTRI computes the inverse of a complex Hermitian indefinite matrix
 A in packed storage using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHPTRF.

Original Fortran LAPACK argument documentation for CHPTRI::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**H;
  = 'L': Lower triangular, form is A = L*D*L**H.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  On entry, the block diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by CHPTRF,
  stored as a packed triangular matrix.
 
  On exit, if INFO = 0, the (Hermitian) inverse of the original
  matrix, stored as a packed triangular matrix. The j-th column
  of inv(A) is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;
  if UPLO = 'L',
  AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CHPTRF.

 */
inline proc hptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_chptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhptri for the type lapack_complex_double.

For more information, see the documentation for :proc:`hptri`, or consult the Netlibs or Intel documentation.
 */
inline proc hptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zhptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chptrs for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHPTRS::

 CHPTRS solves a system of linear equations A*X = B with a complex
 Hermitian matrix A stored in packed format using the factorization
 A = U*D*U**H or A = L*D*L**H computed by CHPTRF.

Original Fortran LAPACK argument documentation for CHPTRS::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**H;
  = 'L': Lower triangular, form is A = L*D*L**H.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by CHPTRF, stored as a
  packed triangular matrix.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CHPTRF.

 B is COMPLEX array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc hptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_chptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhptrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`hptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc hptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zhptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_shsein for the type c_float.

Original Fortran LAPACK purpose documentation for SHSEIN::

 SHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a real upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

 H * x = w * x, y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.

Original Fortran LAPACK argument documentation for SHSEIN::

 EIGSRC is CHARACTER*1
  Specifies the source of eigenvalues supplied in (WR,WI):
  = 'Q': the eigenvalues were found using SHSEQR; thus, if
  H has zero subdiagonal elements, and so is
  block-triangular, then the j-th eigenvalue can be
  assumed to be an eigenvalue of the block containing
  the j-th row/column. This property allows SHSEIN to
  perform inverse iteration on just one diagonal block.
  = 'N': no assumptions are made on the correspondence
  between eigenvalues and diagonal blocks. In this
  case, SHSEIN must always perform inverse iteration
  using the whole matrix H.

 INITV is CHARACTER*1
  = 'N': no initial vectors are supplied;
  = 'U': user-supplied initial vectors are stored in the arrays
  VL and/or VR.

 H is REAL array, dimension (LDH,N)
  The upper Hessenberg matrix H.
  If a NaN is detected in H, the routine will return with INFO=-6.

 WR is REAL array, dimension (N)

 WI is REAL array, dimension (N)
 
  On entry, the real and imaginary parts of the eigenvalues of
  H; a complex conjugate pair of eigenvalues must be stored in
  consecutive elements of WR and WI.
  On exit, WR may have been altered since close eigenvalues
  are perturbed slightly in searching for independent
  eigenvectors.

 VL is REAL array, dimension (LDVL,MM)
  On entry, if INITV = 'U' and SIDE = 'L' or 'B', VL must
  contain starting vectors for the inverse iteration for the
  left eigenvectors; the starting vector for each eigenvector
  must be in the same column(s) in which the eigenvector will
  be stored.
  On exit, if SIDE = 'L' or 'B', the left eigenvectors
  specified by SELECT will be stored consecutively in the
  columns of VL, in the same order as their eigenvalues. A
  complex eigenvector corresponding to a complex eigenvalue is
  stored in two consecutive columns, the first holding the real
  part and the second the imaginary part.
  If SIDE = 'R', VL is not referenced.

 VR is REAL array, dimension (LDVR,MM)
  On entry, if INITV = 'U' and SIDE = 'R' or 'B', VR must
  contain starting vectors for the inverse iteration for the
  right eigenvectors; the starting vector for each eigenvector
  must be in the same column(s) in which the eigenvector will
  be stored.
  On exit, if SIDE = 'R' or 'B', the right eigenvectors
  specified by SELECT will be stored consecutively in the
  columns of VR, in the same order as their eigenvalues. A
  complex eigenvector corresponding to a complex eigenvalue is
  stored in two consecutive columns, the first holding the real
  part and the second the imaginary part.
  If SIDE = 'L', VR is not referenced.

 MM is INTEGER
  The number of columns in the arrays VL and/or VR. MM >= M.

 M is INTEGER
  The number of columns in the arrays VL and/or VR required to
  store the eigenvectors; each selected real eigenvector
  occupies one column and each selected complex eigenvector
  occupies two columns.

 IFAILL is INTEGER array, dimension (MM)
  If SIDE = 'L' or 'B', IFAILL(i) = j > 0 if the left
  eigenvector in the i-th column of VL (corresponding to the
  eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the
  eigenvector converged satisfactorily. If the i-th and (i+1)th
  columns of VL hold a complex eigenvector, then IFAILL(i) and
  IFAILL(i+1) are set to the same value.
  If SIDE = 'R', IFAILL is not referenced.

 IFAILR is INTEGER array, dimension (MM)
  If SIDE = 'R' or 'B', IFAILR(i) = j > 0 if the right
  eigenvector in the i-th column of VR (corresponding to the
  eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the
  eigenvector converged satisfactorily. If the i-th and (i+1)th
  columns of VR hold a complex eigenvector, then IFAILR(i) and
  IFAILR(i+1) are set to the same value.
  If SIDE = 'L', IFAILR is not referenced.

 */
inline proc hsein(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, h : [] c_float, wr : [] c_float, wi : [] c_float, vl : [] c_float, vr : [] c_float, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int): c_int{
  return LAPACKE_shsein(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, (h.domain.dim(1).size) : c_int, h, (h.domain.dim(2).size) : c_int, wr, wi, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m, ifaill, ifailr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dhsein for the type c_double.

For more information, see the documentation for :proc:`hsein`, or consult the Netlibs or Intel documentation.
 */
inline proc hsein(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, h : [] c_double, wr : [] c_double, wi : [] c_double, vl : [] c_double, vr : [] c_double, mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int): c_int{
  return LAPACKE_dhsein(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, (h.domain.dim(1).size) : c_int, h, (h.domain.dim(2).size) : c_int, wr, wi, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m, ifaill, ifailr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chsein for the type lapack_complex_float.

For more information, see the documentation for :proc:`hsein`, or consult the Netlibs or Intel documentation.
 */
inline proc hsein(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, h : [] complex(64), w : [] complex(64), vl : [] complex(64), vr : [] complex(64), mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int): c_int{
  return LAPACKE_chsein(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, (h.domain.dim(1).size) : c_int, h, (h.domain.dim(2).size) : c_int, w, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m, ifaill, ifailr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhsein for the type lapack_complex_double.

For more information, see the documentation for :proc:`hsein`, or consult the Netlibs or Intel documentation.
 */
inline proc hsein(matrix_order : lapack_memory_order, job : string, eigsrc : string, initv : string, chlapack_select : [] c_int, h : [] complex(128), w : [] complex(128), vl : [] complex(128), vr : [] complex(128), mm : c_int, ref m : c_int, ifaill : [] c_int, ifailr : [] c_int): c_int{
  return LAPACKE_zhsein(matrix_order, ascii(job) : c_char, ascii(eigsrc) : c_char, ascii(initv) : c_char, chlapack_select, (h.domain.dim(1).size) : c_int, h, (h.domain.dim(2).size) : c_int, w, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m, ifaill, ifailr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_shseqr for the type c_float.

Original Fortran LAPACK purpose documentation for SHSEQR::

 SHSEQR computes the eigenvalues of a Hessenberg matrix H
 and, optionally, the matrices T and Z from the Schur decomposition
 H = Z T Z**T, where T is an upper quasi-triangular matrix (the
 Schur form), and Z is the orthogonal matrix of Schur vectors.

 Optionally Z may be postmultiplied into an input orthogonal
 matrix Q so that this routine can give the Schur factorization
 of a matrix A which has been reduced to the Hessenberg form H
 by the orthogonal matrix Q: A = Q*H*Q**T = (QZ)*T*(QZ)**T.

Original Fortran LAPACK argument documentation for SHSEQR::

 JOB is CHARACTER*1
  = 'E': compute eigenvalues only;
  = 'S': compute eigenvalues and the Schur form T.

 COMPZ is CHARACTER*1
  = 'N': no Schur vectors are computed;
  = 'I': Z is initialized to the unit matrix and the matrix Z
  of Schur vectors of H is returned;
  = 'V': Z must contain an orthogonal matrix Q on entry, and
  the product Q*Z is returned.

 ILO is INTEGER

 IHI is INTEGER
 
  It is assumed that H is already upper triangular in rows
  and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
  set by a previous call to SGEBAL, and then passed to ZGEHRD
  when the matrix output by SGEBAL is reduced to Hessenberg
  form. Otherwise ILO and IHI should be set to 1 and N
  respectively. If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
  If N = 0, then ILO = 1 and IHI = 0.

 H is REAL array, dimension (LDH,N)
  On entry, the upper Hessenberg matrix H.
  On exit, if INFO = 0 and JOB = 'S', then H contains the
  upper quasi-triangular matrix T from the Schur decomposition
  (the Schur form); 2-by-2 diagonal blocks (corresponding to
  complex conjugate pairs of eigenvalues) are returned in
  standard form, with H(i,i) = H(i+1,i+1) and
  H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and JOB = 'E', the
  contents of H are unspecified on exit. (The output value of
  H when INFO.GT.0 is given under the description of INFO
  below.)
 
  Unlike earlier versions of SHSEQR, this subroutine may
  explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
  or j = IHI+1, IHI+2, ... N.

 WR is REAL array, dimension (N)

 WI is REAL array, dimension (N)
 
  The real and imaginary parts, respectively, of the computed
  eigenvalues. If two eigenvalues are computed as a complex
  conjugate pair, they are stored in consecutive elements of
  WR and WI, say the i-th and (i+1)th, with WI(i) .GT. 0 and
  WI(i+1) .LT. 0. If JOB = 'S', the eigenvalues are stored in
  the same order as on the diagonal of the Schur form returned
  in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
  diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
  WI(i+1) = -WI(i).

 Z is REAL array, dimension (LDZ,N)
  If COMPZ = 'N', Z is not referenced.
  If COMPZ = 'I', on entry Z need not be set and on exit,
  if INFO = 0, Z contains the orthogonal matrix Z of the Schur
  vectors of H. If COMPZ = 'V', on entry Z must contain an
  N-by-N matrix Q, which is assumed to be equal to the unit
  matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
  if INFO = 0, Z contains Q*Z.
  Normally Q is the orthogonal matrix generated by SORGHR
  after the call to SGEHRD which formed the Hessenberg matrix
  H. (The output value of Z when INFO.GT.0 is given under
  the description of INFO below.)

 */
inline proc hseqr(matrix_order : lapack_memory_order, job : string, compz : string, ilo : c_int, ihi : c_int, h : [] c_float, wr : [] c_float, wi : [] c_float, z : [] c_float): c_int{
  return LAPACKE_shseqr(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, (h.domain.dim(1).size) : c_int, ilo, ihi, h, (h.domain.dim(2).size) : c_int, wr, wi, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dhseqr for the type c_double.

For more information, see the documentation for :proc:`hseqr`, or consult the Netlibs or Intel documentation.
 */
inline proc hseqr(matrix_order : lapack_memory_order, job : string, compz : string, ilo : c_int, ihi : c_int, h : [] c_double, wr : [] c_double, wi : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dhseqr(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, (h.domain.dim(1).size) : c_int, ilo, ihi, h, (h.domain.dim(2).size) : c_int, wr, wi, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chseqr for the type lapack_complex_float.

For more information, see the documentation for :proc:`hseqr`, or consult the Netlibs or Intel documentation.
 */
inline proc hseqr(matrix_order : lapack_memory_order, job : string, compz : string, ilo : c_int, ihi : c_int, h : [] complex(64), w : [] complex(64), z : [] complex(64)): c_int{
  return LAPACKE_chseqr(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, (h.domain.dim(1).size) : c_int, ilo, ihi, h, (h.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhseqr for the type lapack_complex_double.

For more information, see the documentation for :proc:`hseqr`, or consult the Netlibs or Intel documentation.
 */
inline proc hseqr(matrix_order : lapack_memory_order, job : string, compz : string, ilo : c_int, ihi : c_int, h : [] complex(128), w : [] complex(128), z : [] complex(128)): c_int{
  return LAPACKE_zhseqr(matrix_order, ascii(job) : c_char, ascii(compz) : c_char, (h.domain.dim(1).size) : c_int, ilo, ihi, h, (h.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clacgv for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CLACGV::

 CLACGV conjugates a complex vector of length N.

Original Fortran LAPACK argument documentation for CLACGV::

 N is INTEGER
  The length of the vector X. N >= 0.

 X is COMPLEX array, dimension
  (1+(N-1)*abs(INCX))
  On entry, the vector of length N to be conjugated.
  On exit, X is overwritten with conjg(X).

 INCX is INTEGER
  The spacing between successive elements of X.

 */
inline proc lacgv(n : c_int, x : [] complex(64), incx : c_int): c_int{
  return LAPACKE_clacgv(n, x, incx);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlacgv for the type lapack_complex_double.

For more information, see the documentation for :proc:`lacgv`, or consult the Netlibs or Intel documentation.
 */
inline proc lacgv(n : c_int, x : [] complex(128), incx : c_int): c_int{
  return LAPACKE_zlacgv(n, x, incx);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slacn2 for the type c_float.

Original Fortran LAPACK purpose documentation for SLACN2::

 SLACN2 estimates the 1-norm of a square, real matrix A.
 Reverse communication is used for evaluating matrix-vector products.

Original Fortran LAPACK argument documentation for SLACN2::

 N is INTEGER
  The order of the matrix. N >= 1.

 V is REAL array, dimension (N)
  On the final return, V = A*W, where EST = norm(V)/norm(W)
  (W is not returned).

 X is REAL array, dimension (N)
  On an intermediate return, X should be overwritten by
  A * X, if KASE=1,
  A**T * X, if KASE=2,
  and SLACN2 must be re-called with all the other parameters
  unchanged.

 ISGN is INTEGER array, dimension (N)

 EST is REAL
  On entry with KASE = 1 or 2 and ISAVE(1) = 3, EST should be
  unchanged from the previous call to SLACN2.
  On exit, EST is an estimate (a lower bound) for norm(A).

 KASE is INTEGER
  On the initial call to SLACN2, KASE should be 0.
  On an intermediate return, KASE will be 1 or 2, indicating
  whether X should be overwritten by A * X or A**T * X.
  On the final return from SLACN2, KASE will again be 0.

 ISAVE is INTEGER array, dimension (3)
  ISAVE is used to save variables between calls to SLACN2

 */
inline proc lacn2(n : c_int, v : [] c_float, x : [] c_float, isgn : [] c_int, ref est : c_float, ref kase : c_int, isave : [] c_int): c_int{
  return LAPACKE_slacn2(n, v, x, isgn, est, kase, isave);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlacn2 for the type c_double.

For more information, see the documentation for :proc:`lacn2`, or consult the Netlibs or Intel documentation.
 */
inline proc lacn2(n : c_int, v : [] c_double, x : [] c_double, isgn : [] c_int, ref est : c_double, ref kase : c_int, isave : [] c_int): c_int{
  return LAPACKE_dlacn2(n, v, x, isgn, est, kase, isave);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clacn2 for the type lapack_complex_float.

For more information, see the documentation for :proc:`lacn2`, or consult the Netlibs or Intel documentation.
 */
inline proc lacn2(n : c_int, v : [] complex(64), x : [] complex(64), ref est : c_float, ref kase : c_int, isave : [] c_int): c_int{
  return LAPACKE_clacn2(n, v, x, est, kase, isave);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlacn2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`lacn2`, or consult the Netlibs or Intel documentation.
 */
inline proc lacn2(n : c_int, v : [] complex(128), x : [] complex(128), ref est : c_double, ref kase : c_int, isave : [] c_int): c_int{
  return LAPACKE_zlacn2(n, v, x, est, kase, isave);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slacpy for the type c_float.

Original Fortran LAPACK purpose documentation for SLACPY::

 SLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.

Original Fortran LAPACK argument documentation for SLACPY::

 UPLO is CHARACTER*1
  Specifies the part of the matrix A to be copied to B.
  = 'U': Upper triangular part
  = 'L': Lower triangular part
  Otherwise: All of the matrix A

 A is REAL array, dimension (LDA,N)
  The m by n matrix A. If UPLO = 'U', only the upper triangle
  or trapezoid is accessed; if UPLO = 'L', only the lower
  triangle or trapezoid is accessed.

 B is REAL array, dimension (LDB,N)
  On exit, B = A in the locations specified by UPLO.

 */
inline proc lacpy(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, b : [] c_float): c_int{
  return LAPACKE_slacpy(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlacpy for the type c_double.

For more information, see the documentation for :proc:`lacpy`, or consult the Netlibs or Intel documentation.
 */
inline proc lacpy(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dlacpy(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clacpy for the type lapack_complex_float.

For more information, see the documentation for :proc:`lacpy`, or consult the Netlibs or Intel documentation.
 */
inline proc lacpy(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_clacpy(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlacpy for the type lapack_complex_double.

For more information, see the documentation for :proc:`lacpy`, or consult the Netlibs or Intel documentation.
 */
inline proc lacpy(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zlacpy(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clacp2 for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CLACP2::

 CLACP2 copies all or part of a real two-dimensional matrix A to a
 complex matrix B.

Original Fortran LAPACK argument documentation for CLACP2::

 UPLO is CHARACTER*1
  Specifies the part of the matrix A to be copied to B.
  = 'U': Upper triangular part
  = 'L': Lower triangular part
  Otherwise: All of the matrix A

 A is REAL array, dimension (LDA,N)
  The m by n matrix A. If UPLO = 'U', only the upper trapezium
  is accessed; if UPLO = 'L', only the lower trapezium is
  accessed.

 B is COMPLEX array, dimension (LDB,N)
  On exit, B = A in the locations specified by UPLO.

 */
inline proc lacp2(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, b : [] complex(64)): c_int{
  return LAPACKE_clacp2(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlacp2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`lacp2`, or consult the Netlibs or Intel documentation.
 */
inline proc lacp2(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, b : [] complex(128)): c_int{
  return LAPACKE_zlacp2(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlag2c for the type lapack_complex_double.

Original Fortran LAPACK purpose documentation for ZLAG2C::

 ZLAG2C converts a COMPLEX*16 matrix, SA, to a COMPLEX matrix, A.

 RMAX is the overflow for the SINGLE PRECISION arithmetic
 ZLAG2C checks that all the entries of A are between -RMAX and
 RMAX. If not the convertion is aborted and a flag is raised.

 This is an auxiliary routine so there is no argument checking.

Original Fortran LAPACK argument documentation for ZLAG2C::

 A is COMPLEX*16 array, dimension (LDA,N)
  On entry, the M-by-N coefficient matrix A.

 SA is COMPLEX array, dimension (LDSA,N)
  On exit, if INFO=0, the M-by-N coefficient matrix SA; if
  INFO>0, the content of SA is unspecified.

 */
inline proc lag2c(matrix_order : lapack_memory_order, a : [] complex(128), sa : [] complex(64)): c_int{
  return LAPACKE_zlag2c(matrix_order, (if matrix_order == lapack_memory_order.row_major then sa.domain.dim(1).size else sa.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sa, (sa.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slag2d for the type c_float.

Original Fortran LAPACK purpose documentation for SLAG2D::

 SLAG2D converts a SINGLE PRECISION matrix, SA, to a DOUBLE
 PRECISION matrix, A.

 Note that while it is possible to overflow while converting
 from double to single, it is not possible to overflow when
 converting from single to double.

 This is an auxiliary routine so there is no argument checking.

Original Fortran LAPACK argument documentation for SLAG2D::

 SA is REAL array, dimension (LDSA,N)
  On entry, the M-by-N coefficient matrix SA.

 A is DOUBLE PRECISION array, dimension (LDA,N)
  On exit, the M-by-N coefficient matrix A.

 */
inline proc lag2d(matrix_order : lapack_memory_order, sa : [] c_float, a : [] c_double): c_int{
  return LAPACKE_slag2d(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, sa, (sa.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlag2s for the type c_double.

Original Fortran LAPACK purpose documentation for DLAG2S::

 DLAG2S converts a DOUBLE PRECISION matrix, SA, to a SINGLE
 PRECISION matrix, A.

 RMAX is the overflow for the SINGLE PRECISION arithmetic
 DLAG2S checks that all the entries of A are between -RMAX and
 RMAX. If not the convertion is aborted and a flag is raised.

 This is an auxiliary routine so there is no argument checking.

Original Fortran LAPACK argument documentation for DLAG2S::

 A is DOUBLE PRECISION array, dimension (LDA,N)
  On entry, the M-by-N coefficient matrix A.

 SA is REAL array, dimension (LDSA,N)
  On exit, if INFO=0, the M-by-N coefficient matrix SA; if
  INFO>0, the content of SA is unspecified.

 */
inline proc lag2s(matrix_order : lapack_memory_order, a : [] c_double, sa : [] c_float): c_int{
  return LAPACKE_dlag2s(matrix_order, (if matrix_order == lapack_memory_order.row_major then sa.domain.dim(1).size else sa.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, sa, (sa.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clag2z for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CLAG2Z::

 CLAG2Z converts a COMPLEX matrix, SA, to a COMPLEX*16 matrix, A.

 Note that while it is possible to overflow while converting
 from double to single, it is not possible to overflow when
 converting from single to double.

 This is an auxiliary routine so there is no argument checking.

Original Fortran LAPACK argument documentation for CLAG2Z::

 SA is COMPLEX array, dimension (LDSA,N)
  On entry, the M-by-N coefficient matrix SA.

 A is COMPLEX*16 array, dimension (LDA,N)
  On exit, the M-by-N coefficient matrix A.

 */
inline proc lag2z(matrix_order : lapack_memory_order, sa : [] complex(64), a : [] complex(128)): c_int{
  return LAPACKE_clag2z(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, sa, (sa.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slagge for the type c_float.

Original Fortran LAPACK purpose documentation for SLAGGE::

 SLAGGE generates a real general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random orthogonal matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional orthogonal transformations.

Original Fortran LAPACK argument documentation for SLAGGE::

 KL is INTEGER
  The number of nonzero subdiagonals within the band of A.
  0 <= KL <= M-1.

 KU is INTEGER
  The number of nonzero superdiagonals within the band of A.
  0 <= KU <= N-1.

 D is REAL array, dimension (min(M,N))
  The diagonal elements of the diagonal matrix D.

 A is REAL array, dimension (LDA,N)
  The generated m by n matrix A.

 ISEED is INTEGER array, dimension (4)
  On entry, the seed of the random number generator; the array
  elements must be between 0 and 4095, and ISEED(4) must be
  odd.
  On exit, the seed is updated.

 */
inline proc lagge(matrix_order : lapack_memory_order, kl : c_int, ku : c_int, d : [] c_float, a : [] c_float, iseed : [] c_int): c_int{
  return LAPACKE_slagge(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, kl, ku, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlagge for the type c_double.

For more information, see the documentation for :proc:`lagge`, or consult the Netlibs or Intel documentation.
 */
inline proc lagge(matrix_order : lapack_memory_order, kl : c_int, ku : c_int, d : [] c_double, a : [] c_double, iseed : [] c_int): c_int{
  return LAPACKE_dlagge(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, kl, ku, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clagge for the type lapack_complex_float.

For more information, see the documentation for :proc:`lagge`, or consult the Netlibs or Intel documentation.
 */
inline proc lagge(matrix_order : lapack_memory_order, kl : c_int, ku : c_int, d : [] c_float, a : [] complex(64), iseed : [] c_int): c_int{
  return LAPACKE_clagge(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, kl, ku, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlagge for the type lapack_complex_double.

For more information, see the documentation for :proc:`lagge`, or consult the Netlibs or Intel documentation.
 */
inline proc lagge(matrix_order : lapack_memory_order, kl : c_int, ku : c_int, d : [] c_double, a : [] complex(128), iseed : [] c_int): c_int{
  return LAPACKE_zlagge(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, kl, ku, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slamch for the type c_float.

 */
inline proc lamch(cmach : string): c_float{
  return LAPACKE_slamch(ascii(cmach) : c_char);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlamch for the type c_double.

For more information, see the documentation for :proc:`lamch`, or consult the Netlibs or Intel documentation.
 */
inline proc lamch(cmach : string): c_double{
  return LAPACKE_dlamch(ascii(cmach) : c_char);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slange for the type c_float.

Original Fortran LAPACK purpose documentation for SLANGE::

 SLANGE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real matrix A.

Original Fortran LAPACK argument documentation for SLANGE::

 NORM is CHARACTER*1
  Specifies the value to be returned in SLANGE as described
  above.

 A is REAL array, dimension (LDA,N)
  The m by n matrix A.

 */
inline proc lange(matrix_order : lapack_memory_order, norm : string, a : [] c_float): c_float{
  return LAPACKE_slange(matrix_order, ascii(norm) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlange for the type c_double.

For more information, see the documentation for :proc:`lange`, or consult the Netlibs or Intel documentation.
 */
inline proc lange(matrix_order : lapack_memory_order, norm : string, a : [] c_double): c_double{
  return LAPACKE_dlange(matrix_order, ascii(norm) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clange for the type lapack_complex_float.

For more information, see the documentation for :proc:`lange`, or consult the Netlibs or Intel documentation.
 */
inline proc lange(matrix_order : lapack_memory_order, norm : string, a : [] complex(64)): c_float{
  return LAPACKE_clange(matrix_order, ascii(norm) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlange for the type lapack_complex_double.

For more information, see the documentation for :proc:`lange`, or consult the Netlibs or Intel documentation.
 */
inline proc lange(matrix_order : lapack_memory_order, norm : string, a : [] complex(128)): c_double{
  return LAPACKE_zlange(matrix_order, ascii(norm) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clanhe for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CLANHE::

 CLANHE returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 complex hermitian matrix A.

Original Fortran LAPACK argument documentation for CLANHE::

 NORM is CHARACTER*1
  Specifies the value to be returned in CLANHE as described
  above.

 UPLO is CHARACTER*1
  Specifies whether the upper or lower triangular part of the
  hermitian matrix A is to be referenced.
  = 'U': Upper triangular part of A is referenced
  = 'L': Lower triangular part of A is referenced

 A is COMPLEX array, dimension (LDA,N)
  The hermitian matrix A. If UPLO = 'U', the leading n by n
  upper triangular part of A contains the upper triangular part
  of the matrix A, and the strictly lower triangular part of A
  is not referenced. If UPLO = 'L', the leading n by n lower
  triangular part of A contains the lower triangular part of
  the matrix A, and the strictly upper triangular part of A is
  not referenced. Note that the imaginary parts of the diagonal
  elements need not be set and are assumed to be zero.

 */
inline proc lanhe(matrix_order : lapack_memory_order, norm : string, uplo : string, a : [] complex(64)): c_float{
  return LAPACKE_clanhe(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlanhe for the type lapack_complex_double.

For more information, see the documentation for :proc:`lanhe`, or consult the Netlibs or Intel documentation.
 */
inline proc lanhe(matrix_order : lapack_memory_order, norm : string, uplo : string, a : [] complex(128)): c_double{
  return LAPACKE_zlanhe(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slansy for the type c_float.

Original Fortran LAPACK purpose documentation for SLANSY::

 SLANSY returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 real symmetric matrix A.

Original Fortran LAPACK argument documentation for SLANSY::

 NORM is CHARACTER*1
  Specifies the value to be returned in SLANSY as described
  above.

 UPLO is CHARACTER*1
  Specifies whether the upper or lower triangular part of the
  symmetric matrix A is to be referenced.
  = 'U': Upper triangular part of A is referenced
  = 'L': Lower triangular part of A is referenced

 A is REAL array, dimension (LDA,N)
  The symmetric matrix A. If UPLO = 'U', the leading n by n
  upper triangular part of A contains the upper triangular part
  of the matrix A, and the strictly lower triangular part of A
  is not referenced. If UPLO = 'L', the leading n by n lower
  triangular part of A contains the lower triangular part of
  the matrix A, and the strictly upper triangular part of A is
  not referenced.

 */
inline proc lansy(matrix_order : lapack_memory_order, norm : string, uplo : string, a : [] c_float): c_float{
  return LAPACKE_slansy(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlansy for the type c_double.

For more information, see the documentation for :proc:`lansy`, or consult the Netlibs or Intel documentation.
 */
inline proc lansy(matrix_order : lapack_memory_order, norm : string, uplo : string, a : [] c_double): c_double{
  return LAPACKE_dlansy(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clansy for the type lapack_complex_float.

For more information, see the documentation for :proc:`lansy`, or consult the Netlibs or Intel documentation.
 */
inline proc lansy(matrix_order : lapack_memory_order, norm : string, uplo : string, a : [] complex(64)): c_float{
  return LAPACKE_clansy(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlansy for the type lapack_complex_double.

For more information, see the documentation for :proc:`lansy`, or consult the Netlibs or Intel documentation.
 */
inline proc lansy(matrix_order : lapack_memory_order, norm : string, uplo : string, a : [] complex(128)): c_double{
  return LAPACKE_zlansy(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slantr for the type c_float.

Original Fortran LAPACK purpose documentation for SLANTR::

 SLANTR returns the value of the one norm, or the Frobenius norm, or
 the infinity norm, or the element of largest absolute value of a
 trapezoidal or triangular matrix A.

Original Fortran LAPACK argument documentation for SLANTR::

 NORM is CHARACTER*1
  Specifies the value to be returned in SLANTR as described
  above.

 UPLO is CHARACTER*1
  Specifies whether the matrix A is upper or lower trapezoidal.
  = 'U': Upper trapezoidal
  = 'L': Lower trapezoidal
  Note that A is triangular instead of trapezoidal if M = N.

 DIAG is CHARACTER*1
  Specifies whether or not the matrix A has unit diagonal.
  = 'N': Non-unit diagonal
  = 'U': Unit diagonal

 A is REAL array, dimension (LDA,N)
  The trapezoidal matrix A (A is triangular if M = N).
  If UPLO = 'U', the leading m by n upper trapezoidal part of
  the array A contains the upper trapezoidal matrix, and the
  strictly lower triangular part of A is not referenced.
  If UPLO = 'L', the leading m by n lower trapezoidal part of
  the array A contains the lower trapezoidal matrix, and the
  strictly upper triangular part of A is not referenced. Note
  that when DIAG = 'U', the diagonal elements of A are not
  referenced and are assumed to be one.

 */
inline proc lantr(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, a : [] c_float): c_float{
  return LAPACKE_slantr(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlantr for the type c_double.

For more information, see the documentation for :proc:`lantr`, or consult the Netlibs or Intel documentation.
 */
inline proc lantr(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, a : [] c_double): c_double{
  return LAPACKE_dlantr(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clantr for the type lapack_complex_float.

For more information, see the documentation for :proc:`lantr`, or consult the Netlibs or Intel documentation.
 */
inline proc lantr(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, a : [] complex(64)): c_float{
  return LAPACKE_clantr(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlantr for the type lapack_complex_double.

For more information, see the documentation for :proc:`lantr`, or consult the Netlibs or Intel documentation.
 */
inline proc lantr(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, a : [] complex(128)): c_double{
  return LAPACKE_zlantr(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slarfb for the type c_float.

Original Fortran LAPACK purpose documentation for SLARFB::

 SLARFB applies a real block reflector H or its transpose H**T to a
 real m by n matrix C, from either the left or the right.

Original Fortran LAPACK argument documentation for SLARFB::

 SIDE is CHARACTER*1
  = 'L': apply H or H**T from the Left
  = 'R': apply H or H**T from the Right

 TRANS is CHARACTER*1
  = 'N': apply H (No transpose)
  = 'T': apply H**T (Transpose)

 DIRECT is CHARACTER*1
  Indicates how H is formed from a product of elementary
  reflectors
  = 'F': H = H(1) H(2) . . . H(k) (Forward)
  = 'B': H = H(k) . . . H(2) H(1) (Backward)

 STOREV is CHARACTER*1
  Indicates how the vectors which define the elementary
  reflectors are stored:
  = 'C': Columnwise
  = 'R': Rowwise

 V is REAL array, dimension
  (LDV,K) if STOREV = 'C'
  (LDV,M) if STOREV = 'R' and SIDE = 'L'
  (LDV,N) if STOREV = 'R' and SIDE = 'R'
  The matrix V. See Further Details.

 T is REAL array, dimension (LDT,K)
  The triangular k by k matrix T in the representation of the
  block reflector.

 C is REAL array, dimension (LDC,N)
  On entry, the m by n matrix C.
  On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T.

 */
inline proc larfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, v : [] c_float, t : [] c_float, c : [] c_float): c_int{
  return LAPACKE_slarfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, (t.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlarfb for the type c_double.

For more information, see the documentation for :proc:`larfb`, or consult the Netlibs or Intel documentation.
 */
inline proc larfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, v : [] c_double, t : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dlarfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, (t.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clarfb for the type lapack_complex_float.

For more information, see the documentation for :proc:`larfb`, or consult the Netlibs or Intel documentation.
 */
inline proc larfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, v : [] complex(64), t : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_clarfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, (t.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlarfb for the type lapack_complex_double.

For more information, see the documentation for :proc:`larfb`, or consult the Netlibs or Intel documentation.
 */
inline proc larfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, v : [] complex(128), t : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zlarfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, (t.domain.dim(1).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slarfg for the type c_float.

Original Fortran LAPACK purpose documentation for SLARFG::

 SLARFG generates a real elementary reflector H of order n, such
 that

 H * ( alpha ) = ( beta ), H**T * H = I.
 ( x ) ( 0 )

 where alpha and beta are scalars, and x is an (n-1)-element real
 vector. H is represented in the form

 H = I - tau * ( 1 ) * ( 1 v**T ) ,
 ( v )

 where tau is a real scalar and v is a real (n-1)-element
 vector.

 If the elements of x are all zero, then tau = 0 and H is taken to be
 the unit matrix.

 Otherwise 1 <= tau <= 2.

Original Fortran LAPACK argument documentation for SLARFG::

 N is INTEGER
  The order of the elementary reflector.

 ALPHA is REAL
  On entry, the value alpha.
  On exit, it is overwritten with the value beta.

 X is REAL array, dimension
  (1+(N-2)*abs(INCX))
  On entry, the vector x.
  On exit, it is overwritten with the vector v.

 INCX is INTEGER
  The increment between elements of X. INCX > 0.

 TAU is REAL
  The value tau.

 */
inline proc larfg(n : c_int, ref alpha : c_float, x : [] c_float, incx : c_int, ref tau : c_float): c_int{
  return LAPACKE_slarfg(n, alpha, x, incx, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlarfg for the type c_double.

For more information, see the documentation for :proc:`larfg`, or consult the Netlibs or Intel documentation.
 */
inline proc larfg(n : c_int, ref alpha : c_double, x : [] c_double, incx : c_int, ref tau : c_double): c_int{
  return LAPACKE_dlarfg(n, alpha, x, incx, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clarfg for the type lapack_complex_float.

For more information, see the documentation for :proc:`larfg`, or consult the Netlibs or Intel documentation.
 */
inline proc larfg(n : c_int, ref alpha : complex(64), x : [] complex(64), incx : c_int, ref tau : complex(64)): c_int{
  return LAPACKE_clarfg(n, alpha, x, incx, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlarfg for the type lapack_complex_double.

For more information, see the documentation for :proc:`larfg`, or consult the Netlibs or Intel documentation.
 */
inline proc larfg(n : c_int, ref alpha : complex(128), x : [] complex(128), incx : c_int, ref tau : complex(128)): c_int{
  return LAPACKE_zlarfg(n, alpha, x, incx, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slarft for the type c_float.

Original Fortran LAPACK purpose documentation for SLARFT::

 SLARFT forms the triangular factor T of a real block reflector H
 of order n, which is defined as a product of k elementary reflectors.

 If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

 If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

 If STOREV = 'C', the vector which defines the elementary reflector
 H(i) is stored in the i-th column of the array V, and

 H = I - V * T * V**T

 If STOREV = 'R', the vector which defines the elementary reflector
 H(i) is stored in the i-th row of the array V, and

 H = I - V**T * T * V

Original Fortran LAPACK argument documentation for SLARFT::

 DIRECT is CHARACTER*1
  Specifies the order in which the elementary reflectors are
  multiplied to form the block reflector:
  = 'F': H = H(1) H(2) . . . H(k) (Forward)
  = 'B': H = H(k) . . . H(2) H(1) (Backward)

 STOREV is CHARACTER*1
  Specifies how the vectors which define the elementary
  reflectors are stored (see also Further Details):
  = 'C': columnwise
  = 'R': rowwise

 N is INTEGER
  The order of the block reflector H. N >= 0.

 K is INTEGER
  The order of the triangular factor T (= the number of
  elementary reflectors). K >= 1.

 V is REAL array, dimension
  (LDV,K) if STOREV = 'C'
  (LDV,N) if STOREV = 'R'
  The matrix V. See further details.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i).

 T is REAL array, dimension (LDT,K)
  The k by k triangular factor T of the block reflector.
  If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
  lower triangular. The rest of the array is not used.

 */
inline proc larft(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] c_float, tau : [] c_float, t : [] c_float): c_int{
  return LAPACKE_slarft(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, (v.domain.dim(2).size) : c_int, tau, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlarft for the type c_double.

For more information, see the documentation for :proc:`larft`, or consult the Netlibs or Intel documentation.
 */
inline proc larft(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] c_double, tau : [] c_double, t : [] c_double): c_int{
  return LAPACKE_dlarft(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, (v.domain.dim(2).size) : c_int, tau, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clarft for the type lapack_complex_float.

For more information, see the documentation for :proc:`larft`, or consult the Netlibs or Intel documentation.
 */
inline proc larft(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] complex(64), tau : [] complex(64), t : [] complex(64)): c_int{
  return LAPACKE_clarft(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, (v.domain.dim(2).size) : c_int, tau, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlarft for the type lapack_complex_double.

For more information, see the documentation for :proc:`larft`, or consult the Netlibs or Intel documentation.
 */
inline proc larft(matrix_order : lapack_memory_order, direct : string, storev : string, n : c_int, k : c_int, v : [] complex(128), tau : [] complex(128), t : [] complex(128)): c_int{
  return LAPACKE_zlarft(matrix_order, ascii(direct) : c_char, ascii(storev) : c_char, n, k, v, (v.domain.dim(2).size) : c_int, tau, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slarfx for the type c_float.

Original Fortran LAPACK purpose documentation for SLARFX::

 SLARFX applies a real elementary reflector H to a real m by n
 matrix C, from either the left or the right. H is represented in the
 form

 H = I - tau * v * v**T

 where tau is a real scalar and v is a real vector.

 If tau = 0, then H is taken to be the unit matrix

 This version uses inline code if H has order < 11.

Original Fortran LAPACK argument documentation for SLARFX::

 SIDE is CHARACTER*1
  = 'L': form H * C
  = 'R': form C * H

 V is REAL array, dimension (M) if SIDE = 'L'
  or (N) if SIDE = 'R'
  The vector v in the representation of H.

 TAU is REAL
  The value tau in the representation of H.

 C is REAL array, dimension (LDC,N)
  On entry, the m by n matrix C.
  On exit, C is overwritten by the matrix H * C if SIDE = 'L',
  or C * H if SIDE = 'R'.

 WORK is REAL array, dimension
  (N) if SIDE = 'L'
  or (M) if SIDE = 'R'
  WORK is not referenced if H has order < 11.

 */
inline proc larfx(matrix_order : lapack_memory_order, side : string, v : [] c_float, tau : c_float, c : [] c_float, work : [] c_float): c_int{
  return LAPACKE_slarfx(matrix_order, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, v, tau, c, (c.domain.dim(2).size) : c_int, work);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlarfx for the type c_double.

For more information, see the documentation for :proc:`larfx`, or consult the Netlibs or Intel documentation.
 */
inline proc larfx(matrix_order : lapack_memory_order, side : string, v : [] c_double, tau : c_double, c : [] c_double, work : [] c_double): c_int{
  return LAPACKE_dlarfx(matrix_order, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, v, tau, c, (c.domain.dim(2).size) : c_int, work);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clarfx for the type lapack_complex_float.

For more information, see the documentation for :proc:`larfx`, or consult the Netlibs or Intel documentation.
 */
inline proc larfx(matrix_order : lapack_memory_order, side : string, v : [] complex(64), tau : complex(64), c : [] complex(64), work : [] complex(64)): c_int{
  return LAPACKE_clarfx(matrix_order, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, v, tau, c, (c.domain.dim(2).size) : c_int, work);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlarfx for the type lapack_complex_double.

For more information, see the documentation for :proc:`larfx`, or consult the Netlibs or Intel documentation.
 */
inline proc larfx(matrix_order : lapack_memory_order, side : string, v : [] complex(128), tau : complex(128), c : [] complex(128), work : [] complex(128)): c_int{
  return LAPACKE_zlarfx(matrix_order, ascii(side) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, v, tau, c, (c.domain.dim(2).size) : c_int, work);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slarnv for the type c_float.

Original Fortran LAPACK purpose documentation for SLARNV::

 SLARNV returns a vector of n random real numbers from a uniform or
 normal distribution.

Original Fortran LAPACK argument documentation for SLARNV::

 IDIST is INTEGER
  Specifies the distribution of the random numbers:
  = 1: uniform (0,1)
  = 2: uniform (-1,1)
  = 3: normal (0,1)

 ISEED is INTEGER array, dimension (4)
  On entry, the seed of the random number generator; the array
  elements must be between 0 and 4095, and ISEED(4) must be
  odd.
  On exit, the seed is updated.

 N is INTEGER
  The number of random numbers to be generated.

 X is REAL array, dimension (N)
  The generated random numbers.

 */
inline proc larnv(idist : c_int, iseed : [] c_int, n : c_int, x : [] c_float): c_int{
  return LAPACKE_slarnv(idist, iseed, n, x);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlarnv for the type c_double.

For more information, see the documentation for :proc:`larnv`, or consult the Netlibs or Intel documentation.
 */
inline proc larnv(idist : c_int, iseed : [] c_int, n : c_int, x : [] c_double): c_int{
  return LAPACKE_dlarnv(idist, iseed, n, x);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clarnv for the type lapack_complex_float.

For more information, see the documentation for :proc:`larnv`, or consult the Netlibs or Intel documentation.
 */
inline proc larnv(idist : c_int, iseed : [] c_int, n : c_int, x : [] complex(64)): c_int{
  return LAPACKE_clarnv(idist, iseed, n, x);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlarnv for the type lapack_complex_double.

For more information, see the documentation for :proc:`larnv`, or consult the Netlibs or Intel documentation.
 */
inline proc larnv(idist : c_int, iseed : [] c_int, n : c_int, x : [] complex(128)): c_int{
  return LAPACKE_zlarnv(idist, iseed, n, x);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slaset for the type c_float.

Original Fortran LAPACK purpose documentation for SLASET::

 SLASET initializes an m-by-n matrix A to BETA on the diagonal and
 ALPHA on the offdiagonals.

Original Fortran LAPACK argument documentation for SLASET::

 UPLO is CHARACTER*1
  Specifies the part of the matrix A to be set.
  = 'U': Upper triangular part is set; the strictly lower
  triangular part of A is not changed.
  = 'L': Lower triangular part is set; the strictly upper
  triangular part of A is not changed.
  Otherwise: All of the matrix A is set.

 ALPHA is REAL
  The constant to which the offdiagonal elements are to be set.

 BETA is REAL
  The constant to which the diagonal elements are to be set.

 A is REAL array, dimension (LDA,N)
  On exit, the leading m-by-n submatrix of A is set as follows:
 
  if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
  if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
  otherwise, A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,
 
  and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).

 */
inline proc laset(matrix_order : lapack_memory_order, uplo : string, alpha : c_float, beta : c_float, a : [] c_float): c_int{
  return LAPACKE_slaset(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, alpha, beta, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlaset for the type c_double.

For more information, see the documentation for :proc:`laset`, or consult the Netlibs or Intel documentation.
 */
inline proc laset(matrix_order : lapack_memory_order, uplo : string, alpha : c_double, beta : c_double, a : [] c_double): c_int{
  return LAPACKE_dlaset(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, alpha, beta, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_claset for the type lapack_complex_float.

For more information, see the documentation for :proc:`laset`, or consult the Netlibs or Intel documentation.
 */
inline proc laset(matrix_order : lapack_memory_order, uplo : string, alpha : complex(64), beta : complex(64), a : [] complex(64)): c_int{
  return LAPACKE_claset(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, alpha, beta, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlaset for the type lapack_complex_double.

For more information, see the documentation for :proc:`laset`, or consult the Netlibs or Intel documentation.
 */
inline proc laset(matrix_order : lapack_memory_order, uplo : string, alpha : complex(128), beta : complex(128), a : [] complex(128)): c_int{
  return LAPACKE_zlaset(matrix_order, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, alpha, beta, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slasrt for the type c_float.

Original Fortran LAPACK purpose documentation for SLASRT::

 Sort the numbers in D in increasing order (if ID = 'I') or
 in decreasing order (if ID = 'D' ).

 Use Quick Sort, reverting to Insertion sort on arrays of
 size <= 20. Dimension of STACK limits N to about 2**32.

Original Fortran LAPACK argument documentation for SLASRT::

 ID is CHARACTER*1
  = 'I': sort D in increasing order;
  = 'D': sort D in decreasing order.

 N is INTEGER
  The length of the array D.

 D is REAL array, dimension (N)
  On entry, the array to be sorted.
  On exit, D has been sorted into increasing order
  (D(1) <= ... <= D(N) ) or into decreasing order
  (D(1) >= ... >= D(N) ), depending on ID.

 */
inline proc lasrt(id : string, n : c_int, d : [] c_float): c_int{
  return LAPACKE_slasrt(ascii(id) : c_char, n, d);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlasrt for the type c_double.

For more information, see the documentation for :proc:`lasrt`, or consult the Netlibs or Intel documentation.
 */
inline proc lasrt(id : string, n : c_int, d : [] c_double): c_int{
  return LAPACKE_dlasrt(ascii(id) : c_char, n, d);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slaswp for the type c_float.

Original Fortran LAPACK purpose documentation for SLASWP::

 SLASWP performs a series of row interchanges on the matrix A.
 One row interchange is initiated for each of rows K1 through K2 of A.

Original Fortran LAPACK argument documentation for SLASWP::

 A is REAL array, dimension (LDA,N)
  On entry, the matrix of column dimension N to which the row
  interchanges will be applied.
  On exit, the permuted matrix.

 K1 is INTEGER
  The first element of IPIV for which a row interchange will
  be done.

 K2 is INTEGER
  The last element of IPIV for which a row interchange will
  be done.

 IPIV is INTEGER array, dimension (K2*abs(INCX))
  The vector of pivot indices. Only the elements in positions
  K1 through K2 of IPIV are accessed.
  IPIV(K) = L implies rows K and L are to be interchanged.

 INCX is INTEGER
  The increment between successive values of IPIV. If IPIV
  is negative, the pivots are applied in reverse order.

 */
inline proc laswp(matrix_order : lapack_memory_order, a : [] c_float, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int): c_int{
  return LAPACKE_slaswp(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, k1, k2, ipiv, incx);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlaswp for the type c_double.

For more information, see the documentation for :proc:`laswp`, or consult the Netlibs or Intel documentation.
 */
inline proc laswp(matrix_order : lapack_memory_order, a : [] c_double, k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int): c_int{
  return LAPACKE_dlaswp(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, k1, k2, ipiv, incx);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_claswp for the type lapack_complex_float.

For more information, see the documentation for :proc:`laswp`, or consult the Netlibs or Intel documentation.
 */
inline proc laswp(matrix_order : lapack_memory_order, a : [] complex(64), k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int): c_int{
  return LAPACKE_claswp(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, k1, k2, ipiv, incx);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlaswp for the type lapack_complex_double.

For more information, see the documentation for :proc:`laswp`, or consult the Netlibs or Intel documentation.
 */
inline proc laswp(matrix_order : lapack_memory_order, a : [] complex(128), k1 : c_int, k2 : c_int, ipiv : [] c_int, incx : c_int): c_int{
  return LAPACKE_zlaswp(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, k1, k2, ipiv, incx);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slatms for the type c_float.

Original Fortran LAPACK purpose documentation for SLATMS::

 SLATMS generates random matrices with specified singular values
 (or symmetric/hermitian with specified eigenvalues)
 for testing LAPACK programs.

 SLATMS operates by applying the following sequence of
 operations:

 Set the diagonal to D, where D may be input or
 computed according to MODE, COND, DMAX, and SYM
 as described below.

 Generate a matrix with the appropriate band structure, by one
 of two methods:

 Method A:
 Generate a dense M x N matrix by multiplying D on the left
 and the right by random unitary matrices, then:

 Reduce the bandwidth according to KL and KU, using
 Householder transformations.

 Method B:
 Convert the bandwidth-0 (i.e., diagonal) matrix to a
 bandwidth-1 matrix using Givens rotations, "chasing"
 out-of-band elements back, much as in QR; then
 convert the bandwidth-1 to a bandwidth-2 matrix, etc.
 Note that for reasonably small bandwidths (relative to
 M and N) this requires less storage, as a dense matrix
 is not generated. Also, for symmetric matrices, only
 one triangle is generated.

 Method A is chosen if the bandwidth is a large fraction of the
 order of the matrix, and LDA is at least M (so a dense
 matrix can be stored.) Method B is chosen if the bandwidth
 is small (< 1/2 N for symmetric, < .3 N+M for
 non-symmetric), or LDA is less than M and not less than the
 bandwidth.

 Pack the matrix if desired. Options specified by PACK are:
 no packing
 zero out upper half (if symmetric)
 zero out lower half (if symmetric)
 store the upper half columnwise (if symmetric or upper
 triangular)
 store the lower half columnwise (if symmetric or lower
 triangular)
 store the lower triangle in banded format (if symmetric
 or lower triangular)
 store the upper triangle in banded format (if symmetric
 or upper triangular)
 store the entire matrix in banded format
 If Method B is chosen, and band format is specified, then the
 matrix will be generated in the band format, so no repacking
 will be necessary.

Original Fortran LAPACK argument documentation for SLATMS::

 DIST is CHARACTER*1
  On entry, DIST specifies the type of distribution to be used
  to generate the random eigen-/singular values.
  'U' => UNIFORM( 0, 1 ) ( 'U' for uniform )
  'S' => UNIFORM( -1, 1 ) ( 'S' for symmetric )
  'N' => NORMAL( 0, 1 ) ( 'N' for normal )
  Not modified.

 ISEED is INTEGER array, dimension ( 4 )
  On entry ISEED specifies the seed of the random number
  generator. They should lie between 0 and 4095 inclusive,
  and ISEED(4) should be odd. The random number generator
  uses a linear congruential sequence limited to small
  integers, and so should produce machine independent
  random numbers. The values of ISEED are changed on
  exit, and can be used in the next call to SLATMS
  to continue the same random number sequence.
  Changed on exit.

 SYM is CHARACTER*1
  If SYM='S' or 'H', the generated matrix is symmetric, with
  eigenvalues specified by D, COND, MODE, and DMAX; they
  may be positive, negative, or zero.
  If SYM='P', the generated matrix is symmetric, with
  eigenvalues (= singular values) specified by D, COND,
  MODE, and DMAX; they will not be negative.
  If SYM='N', the generated matrix is nonsymmetric, with
  singular values specified by D, COND, MODE, and DMAX;
  they will not be negative.
  Not modified.

 D is REAL array, dimension ( MIN( M , N ) )
  This array is used to specify the singular values or
  eigenvalues of A (see SYM, above.) If MODE=0, then D is
  assumed to contain the singular/eigenvalues, otherwise
  they will be computed according to MODE, COND, and DMAX,
  and placed in D.
  Modified if MODE is nonzero.

 MODE is INTEGER
  On entry this describes how the singular/eigenvalues are to
  be specified:
  MODE = 0 means use D as input
  MODE = 1 sets D(1)=1 and D(2:N)=1.0/COND
  MODE = 2 sets D(1:N-1)=1 and D(N)=1.0/COND
  MODE = 3 sets D(I)=COND**(-(I-1)/(N-1))
  MODE = 4 sets D(i)=1 - (i-1)/(N-1)*(1 - 1/COND)
  MODE = 5 sets D to random numbers in the range
  ( 1/COND , 1 ) such that their logarithms
  are uniformly distributed.
  MODE = 6 set D to random numbers from same distribution
  as the rest of the matrix.
  MODE < 0 has the same meaning as ABS(MODE), except that
  the order of the elements of D is reversed.
  Thus if MODE is positive, D has entries ranging from
  1 to 1/COND, if negative, from 1/COND to 1,
  If SYM='S' or 'H', and MODE is neither 0, 6, nor -6, then
  the elements of D will also be multiplied by a random
  sign (i.e., +1 or -1.)
  Not modified.

 COND is REAL
  On entry, this is used as described under MODE above.
  If used, it must be >= 1. Not modified.

 DMAX is REAL
  If MODE is neither -6, 0 nor 6, the contents of D, as
  computed according to MODE and COND, will be scaled by
  DMAX / max(abs(D(i))); thus, the maximum absolute eigen- or
  singular value (which is to say the norm) will be abs(DMAX).
  Note that DMAX need not be positive: if DMAX is negative
  (or zero), D will be scaled by a negative number (or zero).
  Not modified.

 KL is INTEGER
  This specifies the lower bandwidth of the matrix. For
  example, KL=0 implies upper triangular, KL=1 implies upper
  Hessenberg, and KL being at least M-1 means that the matrix
  has full lower bandwidth. KL must equal KU if the matrix
  is symmetric.
  Not modified.

 KU is INTEGER
  This specifies the upper bandwidth of the matrix. For
  example, KU=0 implies lower triangular, KU=1 implies lower
  Hessenberg, and KU being at least N-1 means that the matrix
  has full upper bandwidth. KL must equal KU if the matrix
  is symmetric.
  Not modified.

 PACK is CHARACTER*1
  This specifies packing of matrix as follows:
  'N' => no packing
  'U' => zero out all subdiagonal entries (if symmetric)
  'L' => zero out all superdiagonal entries (if symmetric)
  'C' => store the upper triangle columnwise
  (only if the matrix is symmetric or upper triangular)
  'R' => store the lower triangle columnwise
  (only if the matrix is symmetric or lower triangular)
  'B' => store the lower triangle in band storage scheme
  (only if matrix symmetric or lower triangular)
  'Q' => store the upper triangle in band storage scheme
  (only if matrix symmetric or upper triangular)
  'Z' => store the entire matrix in band storage scheme
  (pivoting can be provided for by using this
  option to store A in the trailing rows of
  the allocated storage)
 
  Using these options, the various LAPACK packed and banded
  storage schemes can be obtained:
  GB - use 'Z'
  PB, SB or TB - use 'B' or 'Q'
  PP, SP or TP - use 'C' or 'R'
 
  If two calls to SLATMS differ only in the PACK parameter,
  they will generate mathematically equivalent matrices.
  Not modified.

 A is REAL array, dimension ( LDA, N )
  On exit A is the desired test matrix. A is first generated
  in full (unpacked) form, and then packed, if so specified
  by PACK. Thus, the first M elements of the first N
  columns will always be modified. If PACK specifies a
  packed or banded storage scheme, all LDA elements of the
  first N columns will be modified; the elements of the
  array which do not correspond to elements of the generated
  matrix are set to zero.
  Modified.

 */
inline proc latms(matrix_order : lapack_memory_order, dist : string, iseed : [] c_int, sym : string, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : string, a : [] c_float): c_int{
  return LAPACKE_slatms(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlatms for the type c_double.

For more information, see the documentation for :proc:`latms`, or consult the Netlibs or Intel documentation.
 */
inline proc latms(matrix_order : lapack_memory_order, dist : string, iseed : [] c_int, sym : string, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : string, a : [] c_double): c_int{
  return LAPACKE_dlatms(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clatms for the type lapack_complex_float.

For more information, see the documentation for :proc:`latms`, or consult the Netlibs or Intel documentation.
 */
inline proc latms(matrix_order : lapack_memory_order, dist : string, iseed : [] c_int, sym : string, d : [] c_float, mode : c_int, cond : c_float, dmax : c_float, kl : c_int, ku : c_int, pack : string, a : [] complex(64)): c_int{
  return LAPACKE_clatms(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlatms for the type lapack_complex_double.

For more information, see the documentation for :proc:`latms`, or consult the Netlibs or Intel documentation.
 */
inline proc latms(matrix_order : lapack_memory_order, dist : string, iseed : [] c_int, sym : string, d : [] c_double, mode : c_int, cond : c_double, dmax : c_double, kl : c_int, ku : c_int, pack : string, a : [] complex(128)): c_int{
  return LAPACKE_zlatms(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, ascii(dist) : c_char, iseed, ascii(sym) : c_char, d, mode, cond, dmax, kl, ku, ascii(pack) : c_char, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slauum for the type c_float.

Original Fortran LAPACK purpose documentation for SLAUUM::

 SLAUUM computes the product U * U**T or L**T * L, where the triangular
 factor U or L is stored in the upper or lower triangular part of
 the array A.

 If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
 overwriting the factor U in A.
 If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
 overwriting the factor L in A.

 This is the blocked form of the algorithm, calling Level 3 BLAS.

Original Fortran LAPACK argument documentation for SLAUUM::

 UPLO is CHARACTER*1
  Specifies whether the triangular factor stored in the array A
  is upper or lower triangular:
  = 'U': Upper triangular
  = 'L': Lower triangular

 N is INTEGER
  The order of the triangular factor U or L. N >= 0.

 A is REAL array, dimension (LDA,N)
  On entry, the triangular factor U or L.
  On exit, if UPLO = 'U', the upper triangle of A is
  overwritten with the upper triangle of the product U * U**T;
  if UPLO = 'L', the lower triangle of A is overwritten with
  the lower triangle of the product L**T * L.

 */
inline proc lauum(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float): c_int{
  return LAPACKE_slauum(matrix_order, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlauum for the type c_double.

For more information, see the documentation for :proc:`lauum`, or consult the Netlibs or Intel documentation.
 */
inline proc lauum(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double): c_int{
  return LAPACKE_dlauum(matrix_order, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clauum for the type lapack_complex_float.

For more information, see the documentation for :proc:`lauum`, or consult the Netlibs or Intel documentation.
 */
inline proc lauum(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64)): c_int{
  return LAPACKE_clauum(matrix_order, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlauum for the type lapack_complex_double.

For more information, see the documentation for :proc:`lauum`, or consult the Netlibs or Intel documentation.
 */
inline proc lauum(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128)): c_int{
  return LAPACKE_zlauum(matrix_order, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sopgtr for the type c_float.

Original Fortran LAPACK purpose documentation for SOPGTR::

 SOPGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 SSPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

Original Fortran LAPACK argument documentation for SOPGTR::

 UPLO is CHARACTER*1
  = 'U': Upper triangular packed storage used in previous
  call to SSPTRD;
  = 'L': Lower triangular packed storage used in previous
  call to SSPTRD.

 AP is REAL array, dimension (N*(N+1)/2)
  The vectors which define the elementary reflectors, as
  returned by SSPTRD.

 TAU is REAL array, dimension (N-1)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SSPTRD.

 Q is REAL array, dimension (LDQ,N)
  The N-by-N orthogonal matrix Q.

 */
inline proc opgtr(matrix_order : lapack_memory_order, uplo : string, ap : [] c_float, tau : [] c_float, q : [] c_float): c_int{
  return LAPACKE_sopgtr(matrix_order, ascii(uplo) : c_char, (q.domain.dim(1).size) : c_int, ap, tau, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dopgtr for the type c_double.

For more information, see the documentation for :proc:`opgtr`, or consult the Netlibs or Intel documentation.
 */
inline proc opgtr(matrix_order : lapack_memory_order, uplo : string, ap : [] c_double, tau : [] c_double, q : [] c_double): c_int{
  return LAPACKE_dopgtr(matrix_order, ascii(uplo) : c_char, (q.domain.dim(1).size) : c_int, ap, tau, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sopmtr for the type c_float.

Original Fortran LAPACK purpose documentation for SOPMTR::

 SOPMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by SSPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

Original Fortran LAPACK argument documentation for SOPMTR::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**T from the Left;
  = 'R': apply Q or Q**T from the Right.

 UPLO is CHARACTER*1
  = 'U': Upper triangular packed storage used in previous
  call to SSPTRD;
  = 'L': Lower triangular packed storage used in previous
  call to SSPTRD.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'T': Transpose, apply Q**T.

 AP is REAL array, dimension
  (M*(M+1)/2) if SIDE = 'L'
  (N*(N+1)/2) if SIDE = 'R'
  The vectors which define the elementary reflectors, as
  returned by SSPTRD. AP is modified by the routine but
  restored on exit.

 TAU is REAL array, dimension (M-1) if SIDE = 'L'
  or (N-1) if SIDE = 'R'
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SSPTRD.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

 */
inline proc opmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, ap : [] c_float, tau : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sopmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, ap, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dopmtr for the type c_double.

For more information, see the documentation for :proc:`opmtr`, or consult the Netlibs or Intel documentation.
 */
inline proc opmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, ap : [] c_double, tau : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dopmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, ap, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sorgbr for the type c_float.

Original Fortran LAPACK purpose documentation for SORGBR::

 SORGBR generates one of the real orthogonal matrices Q or P**T
 determined by SGEBRD when reducing a real matrix A to bidiagonal
 form: A = Q * B * P**T. Q and P**T are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
 is of order N:
 if k < n, P**T = G(k) . . . G(2) G(1) and SORGBR returns the first m
 rows of P**T, where n >= m >= k;
 if k >= n, P**T = G(n-1) . . . G(2) G(1) and SORGBR returns P**T as
 an N-by-N matrix.

Original Fortran LAPACK argument documentation for SORGBR::

 VECT is CHARACTER*1
  Specifies whether the matrix Q or the matrix P**T is
  required, as defined in the transformation applied by SGEBRD:
  = 'Q': generate Q;
  = 'P': generate P**T.

 K is INTEGER
  If VECT = 'Q', the number of columns in the original M-by-K
  matrix reduced by SGEBRD.
  If VECT = 'P', the number of rows in the original K-by-N
  matrix reduced by SGEBRD.
  K >= 0.

 A is REAL array, dimension (LDA,N)
  On entry, the vectors which define the elementary reflectors,
  as returned by SGEBRD.
  On exit, the M-by-N matrix Q or P**T.

 TAU is REAL array, dimension
  (min(M,K)) if VECT = 'Q'
  (min(N,K)) if VECT = 'P'
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i) or G(i), which determines Q or P**T, as
  returned by SGEBRD in its array argument TAUQ or TAUP.

 */
inline proc orgbr(matrix_order : lapack_memory_order, vect : string, k : c_int, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sorgbr(matrix_order, ascii(vect) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dorgbr for the type c_double.

For more information, see the documentation for :proc:`orgbr`, or consult the Netlibs or Intel documentation.
 */
inline proc orgbr(matrix_order : lapack_memory_order, vect : string, k : c_int, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dorgbr(matrix_order, ascii(vect) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sorghr for the type c_float.

Original Fortran LAPACK purpose documentation for SORGHR::

 SORGHR generates a real orthogonal matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 SGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

Original Fortran LAPACK argument documentation for SORGHR::

 N is INTEGER
  The order of the matrix Q. N >= 0.

 ILO is INTEGER

 IHI is INTEGER
 
  ILO and IHI must have the same values as in the previous call
  of SGEHRD. Q is equal to the unit matrix except in the
  submatrix Q(ilo+1:ihi,ilo+1:ihi).
  1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

 A is REAL array, dimension (LDA,N)
  On entry, the vectors which define the elementary reflectors,
  as returned by SGEHRD.
  On exit, the N-by-N orthogonal matrix Q.

 TAU is REAL array, dimension (N-1)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGEHRD.

 */
inline proc orghr(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sorghr(matrix_order, n, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dorghr for the type c_double.

For more information, see the documentation for :proc:`orghr`, or consult the Netlibs or Intel documentation.
 */
inline proc orghr(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dorghr(matrix_order, n, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sorglq for the type c_float.

Original Fortran LAPACK purpose documentation for SORGLQ::

 SORGLQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k) . . . H(2) H(1)

 as returned by SGELQF.

Original Fortran LAPACK argument documentation for SORGLQ::

 K is INTEGER
  The number of elementary reflectors whose product defines the
  matrix Q. M >= K >= 0.

 A is REAL array, dimension (LDA,N)
  On entry, the i-th row must contain the vector which defines
  the elementary reflector H(i), for i = 1,2,...,k, as returned
  by SGELQF in the first k rows of its array argument A.
  On exit, the M-by-N matrix Q.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGELQF.

 */
inline proc orglq(matrix_order : lapack_memory_order, k : c_int, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sorglq(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dorglq for the type c_double.

For more information, see the documentation for :proc:`orglq`, or consult the Netlibs or Intel documentation.
 */
inline proc orglq(matrix_order : lapack_memory_order, k : c_int, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dorglq(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sorgql for the type c_float.

Original Fortran LAPACK purpose documentation for SORGQL::

 SORGQL generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by SGEQLF.

Original Fortran LAPACK argument documentation for SORGQL::

 K is INTEGER
  The number of elementary reflectors whose product defines the
  matrix Q. N >= K >= 0.

 A is REAL array, dimension (LDA,N)
  On entry, the (n-k+i)-th column must contain the vector which
  defines the elementary reflector H(i), for i = 1,2,...,k, as
  returned by SGEQLF in the last k columns of its array
  argument A.
  On exit, the M-by-N matrix Q.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGEQLF.

 */
inline proc orgql(matrix_order : lapack_memory_order, k : c_int, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sorgql(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dorgql for the type c_double.

For more information, see the documentation for :proc:`orgql`, or consult the Netlibs or Intel documentation.
 */
inline proc orgql(matrix_order : lapack_memory_order, k : c_int, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dorgql(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sorgqr for the type c_float.

Original Fortran LAPACK purpose documentation for SORGQR::

 SORGQR generates an M-by-N real matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by SGEQRF.

Original Fortran LAPACK argument documentation for SORGQR::

 K is INTEGER
  The number of elementary reflectors whose product defines the
  matrix Q. N >= K >= 0.

 A is REAL array, dimension (LDA,N)
  On entry, the i-th column must contain the vector which
  defines the elementary reflector H(i), for i = 1,2,...,k, as
  returned by SGEQRF in the first k columns of its array
  argument A.
  On exit, the M-by-N matrix Q.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGEQRF.

 */
inline proc orgqr(matrix_order : lapack_memory_order, k : c_int, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sorgqr(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dorgqr for the type c_double.

For more information, see the documentation for :proc:`orgqr`, or consult the Netlibs or Intel documentation.
 */
inline proc orgqr(matrix_order : lapack_memory_order, k : c_int, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dorgqr(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sorgrq for the type c_float.

Original Fortran LAPACK purpose documentation for SORGRQ::

 SORGRQ generates an M-by-N real matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1) H(2) . . . H(k)

 as returned by SGERQF.

Original Fortran LAPACK argument documentation for SORGRQ::

 K is INTEGER
  The number of elementary reflectors whose product defines the
  matrix Q. M >= K >= 0.

 A is REAL array, dimension (LDA,N)
  On entry, the (m-k+i)-th row must contain the vector which
  defines the elementary reflector H(i), for i = 1,2,...,k, as
  returned by SGERQF in the last k rows of its array argument
  A.
  On exit, the M-by-N matrix Q.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGERQF.

 */
inline proc orgrq(matrix_order : lapack_memory_order, k : c_int, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sorgrq(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dorgrq for the type c_double.

For more information, see the documentation for :proc:`orgrq`, or consult the Netlibs or Intel documentation.
 */
inline proc orgrq(matrix_order : lapack_memory_order, k : c_int, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dorgrq(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sorgtr for the type c_float.

Original Fortran LAPACK purpose documentation for SORGTR::

 SORGTR generates a real orthogonal matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 SSYTRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

Original Fortran LAPACK argument documentation for SORGTR::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A contains elementary reflectors
  from SSYTRD;
  = 'L': Lower triangle of A contains elementary reflectors
  from SSYTRD.

 N is INTEGER
  The order of the matrix Q. N >= 0.

 A is REAL array, dimension (LDA,N)
  On entry, the vectors which define the elementary reflectors,
  as returned by SSYTRD.
  On exit, the N-by-N orthogonal matrix Q.

 TAU is REAL array, dimension (N-1)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SSYTRD.

 */
inline proc orgtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_sorgtr(matrix_order, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dorgtr for the type c_double.

For more information, see the documentation for :proc:`orgtr`, or consult the Netlibs or Intel documentation.
 */
inline proc orgtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dorgtr(matrix_order, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sormbr for the type c_float.

Original Fortran LAPACK purpose documentation for SORMBR::

 If VECT = 'Q', SORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 If VECT = 'P', SORMBR overwrites the general real M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'T': P**T * C C * P**T

 Here Q and P**T are the orthogonal matrices determined by SGEBRD when
 reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
 P**T are defined as products of elementary reflectors H(i) and G(i)
 respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the orthogonal matrix Q or P**T that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

Original Fortran LAPACK argument documentation for SORMBR::

 VECT is CHARACTER*1
  = 'Q': apply Q or Q**T;
  = 'P': apply P or P**T.

 SIDE is CHARACTER*1
  = 'L': apply Q, Q**T, P or P**T from the Left;
  = 'R': apply Q, Q**T, P or P**T from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q or P;
  = 'T': Transpose, apply Q**T or P**T.

 K is INTEGER
  If VECT = 'Q', the number of columns in the original
  matrix reduced by SGEBRD.
  If VECT = 'P', the number of rows in the original
  matrix reduced by SGEBRD.
  K >= 0.

 A is REAL array, dimension
  (LDA,min(nq,K)) if VECT = 'Q'
  (LDA,nq) if VECT = 'P'
  The vectors which define the elementary reflectors H(i) and
  G(i), whose products determine the matrices Q and P, as
  returned by SGEBRD.

 TAU is REAL array, dimension (min(nq,K))
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i) or G(i) which determines Q or P, as returned
  by SGEBRD in the array argument TAUQ or TAUP.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
  or P*C or P**T*C or C*P or C*P**T.

 */
inline proc ormbr(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, k : c_int, a : [] c_float, tau : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sormbr(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dormbr for the type c_double.

For more information, see the documentation for :proc:`ormbr`, or consult the Netlibs or Intel documentation.
 */
inline proc ormbr(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, k : c_int, a : [] c_double, tau : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dormbr(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sormhr for the type c_float.

Original Fortran LAPACK purpose documentation for SORMHR::

 SORMHR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by SGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

Original Fortran LAPACK argument documentation for SORMHR::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**T from the Left;
  = 'R': apply Q or Q**T from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'T': Transpose, apply Q**T.

 ILO is INTEGER

 IHI is INTEGER
 
  ILO and IHI must have the same values as in the previous call
  of SGEHRD. Q is equal to the unit matrix except in the
  submatrix Q(ilo+1:ihi,ilo+1:ihi).
  If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
  ILO = 1 and IHI = 0, if M = 0;
  if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
  ILO = 1 and IHI = 0, if N = 0.

 A is REAL array, dimension
  (LDA,M) if SIDE = 'L'
  (LDA,N) if SIDE = 'R'
  The vectors which define the elementary reflectors, as
  returned by SGEHRD.

 TAU is REAL array, dimension
  (M-1) if SIDE = 'L'
  (N-1) if SIDE = 'R'
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGEHRD.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

 */
inline proc ormhr(matrix_order : lapack_memory_order, side : string, trans : string, ilo : c_int, ihi : c_int, a : [] c_float, tau : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sormhr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dormhr for the type c_double.

For more information, see the documentation for :proc:`ormhr`, or consult the Netlibs or Intel documentation.
 */
inline proc ormhr(matrix_order : lapack_memory_order, side : string, trans : string, ilo : c_int, ihi : c_int, a : [] c_double, tau : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dormhr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sormlq for the type c_float.

Original Fortran LAPACK purpose documentation for SORMLQ::

 SORMLQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by SGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for SORMLQ::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**T from the Left;
  = 'R': apply Q or Q**T from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'T': Transpose, apply Q**T.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 A is REAL array, dimension
  (LDA,M) if SIDE = 'L',
  (LDA,N) if SIDE = 'R'
  The i-th row must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  SGELQF in the first k rows of its array argument A.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGELQF.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

 */
inline proc ormlq(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] c_float, tau : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sormlq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dormlq for the type c_double.

For more information, see the documentation for :proc:`ormlq`, or consult the Netlibs or Intel documentation.
 */
inline proc ormlq(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] c_double, tau : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dormlq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sormql for the type c_float.

Original Fortran LAPACK purpose documentation for SORMQL::

 SORMQL overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for SORMQL::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**T from the Left;
  = 'R': apply Q or Q**T from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'T': Transpose, apply Q**T.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 A is REAL array, dimension (LDA,K)
  The i-th column must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  SGEQLF in the last k columns of its array argument A.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGEQLF.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

 */
inline proc ormql(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] c_float, tau : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sormql(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dormql for the type c_double.

For more information, see the documentation for :proc:`ormql`, or consult the Netlibs or Intel documentation.
 */
inline proc ormql(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] c_double, tau : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dormql(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sormqr for the type c_float.

Original Fortran LAPACK purpose documentation for SORMQR::

 SORMQR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for SORMQR::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**T from the Left;
  = 'R': apply Q or Q**T from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'T': Transpose, apply Q**T.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 A is REAL array, dimension (LDA,K)
  The i-th column must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  SGEQRF in the first k columns of its array argument A.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGEQRF.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

 */
inline proc ormqr(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] c_float, tau : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sormqr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dormqr for the type c_double.

For more information, see the documentation for :proc:`ormqr`, or consult the Netlibs or Intel documentation.
 */
inline proc ormqr(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] c_double, tau : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dormqr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sormrq for the type c_float.

Original Fortran LAPACK purpose documentation for SORMRQ::

 SORMRQ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by SGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for SORMRQ::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**T from the Left;
  = 'R': apply Q or Q**T from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'T': Transpose, apply Q**T.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 A is REAL array, dimension
  (LDA,M) if SIDE = 'L',
  (LDA,N) if SIDE = 'R'
  The i-th row must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  SGERQF in the last k rows of its array argument A.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SGERQF.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

 */
inline proc ormrq(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] c_float, tau : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sormrq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dormrq for the type c_double.

For more information, see the documentation for :proc:`ormrq`, or consult the Netlibs or Intel documentation.
 */
inline proc ormrq(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] c_double, tau : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dormrq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sormrz for the type c_float.

Original Fortran LAPACK purpose documentation for SORMRZ::

 SORMRZ overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by STZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for SORMRZ::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**T from the Left;
  = 'R': apply Q or Q**T from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'T': Transpose, apply Q**T.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 L is INTEGER
  The number of columns of the matrix A containing
  the meaningful part of the Householder reflectors.
  If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.

 A is REAL array, dimension
  (LDA,M) if SIDE = 'L',
  (LDA,N) if SIDE = 'R'
  The i-th row must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  STZRZF in the last k rows of its array argument A.
  A is modified by the routine but restored on exit.

 TAU is REAL array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by STZRZF.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

 */
inline proc ormrz(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, l : c_int, a : [] c_float, tau : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sormrz(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dormrz for the type c_double.

For more information, see the documentation for :proc:`ormrz`, or consult the Netlibs or Intel documentation.
 */
inline proc ormrz(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, l : c_int, a : [] c_double, tau : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dormrz(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sormtr for the type c_float.

Original Fortran LAPACK purpose documentation for SORMTR::

 SORMTR overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'T': Q**T * C C * Q**T

 where Q is a real orthogonal matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by SSYTRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

Original Fortran LAPACK argument documentation for SORMTR::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**T from the Left;
  = 'R': apply Q or Q**T from the Right.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A contains elementary reflectors
  from SSYTRD;
  = 'L': Lower triangle of A contains elementary reflectors
  from SSYTRD.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'T': Transpose, apply Q**T.

 A is REAL array, dimension
  (LDA,M) if SIDE = 'L'
  (LDA,N) if SIDE = 'R'
  The vectors which define the elementary reflectors, as
  returned by SSYTRD.

 TAU is REAL array, dimension
  (M-1) if SIDE = 'L'
  (N-1) if SIDE = 'R'
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by SSYTRD.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

 */
inline proc ormtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, a : [] c_float, tau : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sormtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dormtr for the type c_double.

For more information, see the documentation for :proc:`ormtr`, or consult the Netlibs or Intel documentation.
 */
inline proc ormtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, a : [] c_double, tau : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dormtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spbcon for the type c_float.

Original Fortran LAPACK purpose documentation for SPBCON::

 SPBCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite band matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

Original Fortran LAPACK argument documentation for SPBCON::

 UPLO is CHARACTER*1
  = 'U': Upper triangular factor stored in AB;
  = 'L': Lower triangular factor stored in AB.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T of the band matrix A, stored in the
  first KD+1 rows of the array. The j-th column of U or L is
  stored in the j-th column of the array AB as follows:
  if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
  if UPLO ='L', AB(1+i-j,j) = L(i,j) for j<=i<=min(n,j+kd).

 ANORM is REAL
  The 1-norm (or infinity-norm) of the symmetric band matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
  estimate of the 1-norm of inv(A) computed in this routine.

 */
inline proc pbcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_spbcon(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpbcon for the type c_double.

For more information, see the documentation for :proc:`pbcon`, or consult the Netlibs or Intel documentation.
 */
inline proc pbcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_dpbcon(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpbcon for the type lapack_complex_float.

For more information, see the documentation for :proc:`pbcon`, or consult the Netlibs or Intel documentation.
 */
inline proc pbcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_cpbcon(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpbcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`pbcon`, or consult the Netlibs or Intel documentation.
 */
inline proc pbcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zpbcon(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spbequ for the type c_float.

Original Fortran LAPACK purpose documentation for SPBEQU::

 SPBEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite band matrix A and reduce its condition
 number (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

Original Fortran LAPACK argument documentation for SPBEQU::

 UPLO is CHARACTER*1
  = 'U': Upper triangular of A is stored;
  = 'L': Lower triangular of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  The upper or lower triangle of the symmetric band matrix A,
  stored in the first KD+1 rows of the array. The j-th column
  of A is stored in the j-th column of the array AB as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).

 S is REAL array, dimension (N)
  If INFO = 0, S contains the scale factors for A.

 SCOND is REAL
  If INFO = 0, S contains the ratio of the smallest S(i) to
  the largest S(i). If SCOND >= 0.1 and AMAX is neither too
  large nor too small, it is not worth scaling by S.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc pbequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_spbequ(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpbequ for the type c_double.

For more information, see the documentation for :proc:`pbequ`, or consult the Netlibs or Intel documentation.
 */
inline proc pbequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_dpbequ(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpbequ for the type lapack_complex_float.

For more information, see the documentation for :proc:`pbequ`, or consult the Netlibs or Intel documentation.
 */
inline proc pbequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_cpbequ(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpbequ for the type lapack_complex_double.

For more information, see the documentation for :proc:`pbequ`, or consult the Netlibs or Intel documentation.
 */
inline proc pbequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_zpbequ(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spbrfs for the type c_float.

Original Fortran LAPACK purpose documentation for SPBRFS::

 SPBRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and banded, and provides error bounds and backward error estimates
 for the solution.

Original Fortran LAPACK argument documentation for SPBRFS::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  The upper or lower triangle of the symmetric band matrix A,
  stored in the first KD+1 rows of the array. The j-th column
  of A is stored in the j-th column of the array AB as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).

 AFB is REAL array, dimension (LDAFB,N)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T of the band matrix A as computed by
  SPBTRF, in the same storage format as A (see AB).

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SPBTRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc pbrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, afb : [] c_float, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_spbrfs(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpbrfs for the type c_double.

For more information, see the documentation for :proc:`pbrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc pbrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, afb : [] c_double, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dpbrfs(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpbrfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`pbrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc pbrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), afb : [] complex(64), b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cpbrfs(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpbrfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`pbrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc pbrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), afb : [] complex(128), b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zpbrfs(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spbstf for the type c_float.

Original Fortran LAPACK purpose documentation for SPBSTF::

 SPBSTF computes a split Cholesky factorization of a real
 symmetric positive definite band matrix A.

 This routine is designed to be used in conjunction with SSBGST.

 The factorization has the form A = S**T*S where S is a band matrix
 of the same bandwidth as A and the following structure:

 S = ( U )
 ( M L )

 where U is upper triangular of order m = (n+kd)/2, and L is lower
 triangular of order n-m.

Original Fortran LAPACK argument documentation for SPBSTF::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 */
inline proc pbstf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] c_float, ldbb : c_int): c_int{
  return LAPACKE_spbstf(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpbstf for the type c_double.

For more information, see the documentation for :proc:`pbstf`, or consult the Netlibs or Intel documentation.
 */
inline proc pbstf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] c_double, ldbb : c_int): c_int{
  return LAPACKE_dpbstf(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpbstf for the type lapack_complex_float.

For more information, see the documentation for :proc:`pbstf`, or consult the Netlibs or Intel documentation.
 */
inline proc pbstf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] complex(64), ldbb : c_int): c_int{
  return LAPACKE_cpbstf(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpbstf for the type lapack_complex_double.

For more information, see the documentation for :proc:`pbstf`, or consult the Netlibs or Intel documentation.
 */
inline proc pbstf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kb : c_int, bb : [] complex(128), ldbb : c_int): c_int{
  return LAPACKE_zpbstf(matrix_order, ascii(uplo) : c_char, n, kb, bb, ldbb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spbsv for the type c_float.

Original Fortran LAPACK purpose documentation for SPBSV::

 SPBSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular band matrix, and L is a lower
 triangular band matrix, with the same number of superdiagonals or
 subdiagonals as A. The factored form of A is then used to solve the
 system of equations A * X = B.

Original Fortran LAPACK argument documentation for SPBSV::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(N,j+KD).
  See below for further details.
 
  On exit, if INFO = 0, the triangular factor U or L from the
  Cholesky factorization A = U**T*U or A = L*L**T of the band
  matrix A, in the same storage format as A.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc pbsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, b : [] c_float): c_int{
  return LAPACKE_spbsv(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpbsv for the type c_double.

For more information, see the documentation for :proc:`pbsv`, or consult the Netlibs or Intel documentation.
 */
inline proc pbsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dpbsv(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpbsv for the type lapack_complex_float.

For more information, see the documentation for :proc:`pbsv`, or consult the Netlibs or Intel documentation.
 */
inline proc pbsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cpbsv(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpbsv for the type lapack_complex_double.

For more information, see the documentation for :proc:`pbsv`, or consult the Netlibs or Intel documentation.
 */
inline proc pbsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zpbsv(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spbsvx for the type c_float.

Original Fortran LAPACK purpose documentation for SPBSVX::

 SPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite band matrix and X
 and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for SPBSVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AFB contains the factored form of A.
  If EQUED = 'Y', the matrix A has been equilibrated
  with scaling factors given by S. AB and AFB will not
  be modified.
  = 'N': The matrix A will be copied to AFB and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AFB and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first KD+1 rows of the array, except
  if FACT = 'F' and EQUED = 'Y', then A must contain the
  equilibrated matrix diag(S)*A*diag(S). The j-th column of A
  is stored in the j-th column of the array AB as follows:
  if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(N,j+KD).
  See below for further details.
 
  On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
  diag(S)*A*diag(S).

 AFB is REAL array, dimension (LDAFB,N)
  If FACT = 'F', then AFB is an input argument and on entry
  contains the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T of the band matrix
  A, in the same storage format as A (see AB). If EQUED = 'Y',
  then AFB is the factored form of the equilibrated matrix A.
 
  If FACT = 'N', then AFB is an output argument and on exit
  returns the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T.
 
  If FACT = 'E', then AFB is an output argument and on exit
  returns the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T of the equilibrated
  matrix A (see the description of A for the form of the
  equilibrated matrix).

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'Y': Equilibration was done, i.e., A has been replaced by
  diag(S) * A * diag(S).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 S is REAL array, dimension (N)
  The scale factors for A; not accessed if EQUED = 'N'. S is
  an input argument if FACT = 'F'; otherwise, S is an output
  argument. If FACT = 'F' and EQUED = 'Y', each element of S
  must be positive.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
  B is overwritten by diag(S) * B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
  the original system of equations. Note that if EQUED = 'Y',
  A and B are modified on exit, and the solution to the
  equilibrated system is inv(diag(S))*X.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A after equilibration (if done). If RCOND is less than the
  machine precision (in particular, if RCOND = 0), the matrix
  is singular to working precision. This condition is
  indicated by a return code of INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc pbsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, afb : [] c_float, ref equed : string, s : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_spbsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpbsvx for the type c_double.

For more information, see the documentation for :proc:`pbsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc pbsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, afb : [] c_double, ref equed : string, s : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dpbsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpbsvx for the type lapack_complex_float.

For more information, see the documentation for :proc:`pbsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc pbsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), afb : [] complex(64), ref equed : string, s : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cpbsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpbsvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`pbsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc pbsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), afb : [] complex(128), ref equed : string, s : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zpbsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, afb, (afb.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spbtrf for the type c_float.

Original Fortran LAPACK purpose documentation for SPBTRF::

 SPBTRF computes the Cholesky factorization of a real symmetric
 positive definite band matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

Original Fortran LAPACK argument documentation for SPBTRF::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
 
  On exit, if INFO = 0, the triangular factor U or L from the
  Cholesky factorization A = U**T*U or A = L*L**T of the band
  matrix A, in the same storage format as A.

 */
inline proc pbtrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float): c_int{
  return LAPACKE_spbtrf(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpbtrf for the type c_double.

For more information, see the documentation for :proc:`pbtrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pbtrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double): c_int{
  return LAPACKE_dpbtrf(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpbtrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`pbtrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pbtrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64)): c_int{
  return LAPACKE_cpbtrf(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpbtrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`pbtrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pbtrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128)): c_int{
  return LAPACKE_zpbtrf(matrix_order, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spbtrs for the type c_float.

Original Fortran LAPACK purpose documentation for SPBTRS::

 SPBTRS solves a system of linear equations A*X = B with a symmetric
 positive definite band matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by SPBTRF.

Original Fortran LAPACK argument documentation for SPBTRS::

 UPLO is CHARACTER*1
  = 'U': Upper triangular factor stored in AB;
  = 'L': Lower triangular factor stored in AB.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T of the band matrix A, stored in the
  first KD+1 rows of the array. The j-th column of U or L is
  stored in the j-th column of the array AB as follows:
  if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
  if UPLO ='L', AB(1+i-j,j) = L(i,j) for j<=i<=min(n,j+kd).

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc pbtrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_float, b : [] c_float): c_int{
  return LAPACKE_spbtrs(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpbtrs for the type c_double.

For more information, see the documentation for :proc:`pbtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pbtrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dpbtrs(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpbtrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`pbtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pbtrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cpbtrs(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpbtrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`pbtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pbtrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, kd : c_int, ab : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zpbtrs(matrix_order, ascii(uplo) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spftrf for the type c_float.

Original Fortran LAPACK purpose documentation for SPFTRF::

 SPFTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

Original Fortran LAPACK argument documentation for SPFTRF::

 TRANSR is CHARACTER*1
  = 'N': The Normal TRANSR of RFP A is stored;
  = 'T': The Transpose TRANSR of RFP A is stored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of RFP A is stored;
  = 'L': Lower triangle of RFP A is stored.

 A is REAL array, dimension ( N*(N+1)/2 );
  On entry, the symmetric matrix A in RFP format. RFP format is
  described by TRANSR, UPLO, and N as follows: If TRANSR = 'N'
  then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is
  (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = 'T' then RFP is
  the transpose of RFP A as defined when
  TRANSR = 'N'. The contents of RFP A are defined by UPLO as
  follows: If UPLO = 'U' the RFP A contains the NT elements of
  upper packed A. If UPLO = 'L' the RFP A contains the elements
  of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =
  'T'. When TRANSR is 'N' the LDA is N+1 when N is even and N
  is odd. See the Note below for more details.
 
  On exit, if INFO = 0, the factor U or L from the Cholesky
  factorization RFP A = U**T*U or RFP A = L*L**T.

 */
inline proc pftrf(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] c_float): c_int{
  return LAPACKE_spftrf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpftrf for the type c_double.

For more information, see the documentation for :proc:`pftrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pftrf(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] c_double): c_int{
  return LAPACKE_dpftrf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpftrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`pftrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pftrf(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] complex(64)): c_int{
  return LAPACKE_cpftrf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpftrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`pftrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pftrf(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] complex(128)): c_int{
  return LAPACKE_zpftrf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spftri for the type c_float.

Original Fortran LAPACK purpose documentation for SPFTRI::

 SPFTRI computes the inverse of a real (symmetric) positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by SPFTRF.

Original Fortran LAPACK argument documentation for SPFTRI::

 TRANSR is CHARACTER*1
  = 'N': The Normal TRANSR of RFP A is stored;
  = 'T': The Transpose TRANSR of RFP A is stored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension ( N*(N+1)/2 )
  On entry, the symmetric matrix A in RFP format. RFP format is
  described by TRANSR, UPLO, and N as follows: If TRANSR = 'N'
  then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is
  (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = 'T' then RFP is
  the transpose of RFP A as defined when
  TRANSR = 'N'. The contents of RFP A are defined by UPLO as
  follows: If UPLO = 'U' the RFP A contains the nt elements of
  upper packed A. If UPLO = 'L' the RFP A contains the elements
  of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =
  'T'. When TRANSR is 'N' the LDA is N+1 when N is even and N
  is odd. See the Note below for more details.
 
  On exit, the symmetric inverse of the original matrix, in the
  same storage format.

 */
inline proc pftri(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] c_float): c_int{
  return LAPACKE_spftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpftri for the type c_double.

For more information, see the documentation for :proc:`pftri`, or consult the Netlibs or Intel documentation.
 */
inline proc pftri(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] c_double): c_int{
  return LAPACKE_dpftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpftri for the type lapack_complex_float.

For more information, see the documentation for :proc:`pftri`, or consult the Netlibs or Intel documentation.
 */
inline proc pftri(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] complex(64)): c_int{
  return LAPACKE_cpftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpftri for the type lapack_complex_double.

For more information, see the documentation for :proc:`pftri`, or consult the Netlibs or Intel documentation.
 */
inline proc pftri(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] complex(128)): c_int{
  return LAPACKE_zpftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spftrs for the type c_float.

Original Fortran LAPACK purpose documentation for SPFTRS::

 SPFTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by SPFTRF.

Original Fortran LAPACK argument documentation for SPFTRS::

 TRANSR is CHARACTER*1
  = 'N': The Normal TRANSR of RFP A is stored;
  = 'T': The Transpose TRANSR of RFP A is stored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of RFP A is stored;
  = 'L': Lower triangle of RFP A is stored.

 A is REAL array, dimension ( N*(N+1)/2 )
  The triangular factor U or L from the Cholesky factorization
  of RFP A = U**H*U or RFP A = L*L**T, as computed by SPFTRF.
  See note below for more details about RFP A.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc pftrs(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] c_float, b : [] c_float): c_int{
  return LAPACKE_spftrs(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpftrs for the type c_double.

For more information, see the documentation for :proc:`pftrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pftrs(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dpftrs(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpftrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`pftrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pftrs(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cpftrs(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpftrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`pftrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pftrs(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zpftrs(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spocon for the type c_float.

Original Fortran LAPACK purpose documentation for SPOCON::

 SPOCON estimates the reciprocal of the condition number (in the 
 1-norm) of a real symmetric positive definite matrix using the
 Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

Original Fortran LAPACK argument documentation for SPOCON::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T, as computed by SPOTRF.

 ANORM is REAL
  The 1-norm (or infinity-norm) of the symmetric matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
  estimate of the 1-norm of inv(A) computed in this routine.

 */
inline proc pocon(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_spocon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpocon for the type c_double.

For more information, see the documentation for :proc:`pocon`, or consult the Netlibs or Intel documentation.
 */
inline proc pocon(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_dpocon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpocon for the type lapack_complex_float.

For more information, see the documentation for :proc:`pocon`, or consult the Netlibs or Intel documentation.
 */
inline proc pocon(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_cpocon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpocon for the type lapack_complex_double.

For more information, see the documentation for :proc:`pocon`, or consult the Netlibs or Intel documentation.
 */
inline proc pocon(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zpocon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spoequ for the type c_float.

Original Fortran LAPACK purpose documentation for SPOEQU::

 SPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

Original Fortran LAPACK argument documentation for SPOEQU::

 A is REAL array, dimension (LDA,N)
  The N-by-N symmetric positive definite matrix whose scaling
  factors are to be computed. Only the diagonal elements of A
  are referenced.

 S is REAL array, dimension (N)
  If INFO = 0, S contains the scale factors for A.

 SCOND is REAL
  If INFO = 0, S contains the ratio of the smallest S(i) to
  the largest S(i). If SCOND >= 0.1 and AMAX is neither too
  large nor too small, it is not worth scaling by S.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc poequ(matrix_order : lapack_memory_order, a : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_spoequ(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpoequ for the type c_double.

For more information, see the documentation for :proc:`poequ`, or consult the Netlibs or Intel documentation.
 */
inline proc poequ(matrix_order : lapack_memory_order, a : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_dpoequ(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpoequ for the type lapack_complex_float.

For more information, see the documentation for :proc:`poequ`, or consult the Netlibs or Intel documentation.
 */
inline proc poequ(matrix_order : lapack_memory_order, a : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_cpoequ(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpoequ for the type lapack_complex_double.

For more information, see the documentation for :proc:`poequ`, or consult the Netlibs or Intel documentation.
 */
inline proc poequ(matrix_order : lapack_memory_order, a : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_zpoequ(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spoequb for the type c_float.

Original Fortran LAPACK purpose documentation for SPOEQUB::

 SPOEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

Original Fortran LAPACK argument documentation for SPOEQUB::

 A is REAL array, dimension (LDA,N)
  The N-by-N symmetric positive definite matrix whose scaling
  factors are to be computed. Only the diagonal elements of A
  are referenced.

 S is REAL array, dimension (N)
  If INFO = 0, S contains the scale factors for A.

 SCOND is REAL
  If INFO = 0, S contains the ratio of the smallest S(i) to
  the largest S(i). If SCOND >= 0.1 and AMAX is neither too
  large nor too small, it is not worth scaling by S.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc poequb(matrix_order : lapack_memory_order, a : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_spoequb(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpoequb for the type c_double.

For more information, see the documentation for :proc:`poequb`, or consult the Netlibs or Intel documentation.
 */
inline proc poequb(matrix_order : lapack_memory_order, a : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_dpoequb(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpoequb for the type lapack_complex_float.

For more information, see the documentation for :proc:`poequb`, or consult the Netlibs or Intel documentation.
 */
inline proc poequb(matrix_order : lapack_memory_order, a : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_cpoequb(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpoequb for the type lapack_complex_double.

For more information, see the documentation for :proc:`poequb`, or consult the Netlibs or Intel documentation.
 */
inline proc poequb(matrix_order : lapack_memory_order, a : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_zpoequb(matrix_order, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sporfs for the type c_float.

Original Fortran LAPACK purpose documentation for SPORFS::

 SPORFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite,
 and provides error bounds and backward error estimates for the
 solution.

Original Fortran LAPACK argument documentation for SPORFS::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  The symmetric matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular part
  of the matrix A, and the strictly lower triangular part of A
  is not referenced. If UPLO = 'L', the leading N-by-N lower
  triangular part of A contains the lower triangular part of
  the matrix A, and the strictly upper triangular part of A is
  not referenced.

 AF is REAL array, dimension (LDAF,N)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T, as computed by SPOTRF.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SPOTRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc porfs(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, af : [] c_float, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sporfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dporfs for the type c_double.

For more information, see the documentation for :proc:`porfs`, or consult the Netlibs or Intel documentation.
 */
inline proc porfs(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, af : [] c_double, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dporfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cporfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`porfs`, or consult the Netlibs or Intel documentation.
 */
inline proc porfs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), af : [] complex(64), b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cporfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zporfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`porfs`, or consult the Netlibs or Intel documentation.
 */
inline proc porfs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), af : [] complex(128), b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zporfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sporfsx for the type c_float.

Original Fortran LAPACK purpose documentation for SPORFSX::

 SPORFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive
 definite, and provides error bounds and backward error estimates
 for the solution. In addition to normwise error bound, the code
 provides maximum componentwise error bound if possible. See
 comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the
 error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

Original Fortran LAPACK argument documentation for SPORFSX::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done to A
  before calling this routine. This is needed to compute
  the solution and error bounds correctly.
  = 'N': No equilibration
  = 'Y': Both row and column equilibration, i.e., A has been
  replaced by diag(S) * A * diag(S).
  The right hand side B has been changed accordingly.

 A is REAL array, dimension (LDA,N)
  The symmetric matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular part
  of the matrix A, and the strictly lower triangular part of A
  is not referenced. If UPLO = 'L', the leading N-by-N lower
  triangular part of A contains the lower triangular part of
  the matrix A, and the strictly upper triangular part of A is
  not referenced.

 AF is REAL array, dimension (LDAF,N)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T, as computed by SPOTRF.

 S is REAL array, dimension (N)
  The row scale factors for A. If EQUED = 'Y', A is multiplied on
  the left and right by diag(S). S is an input argument if FACT =
  'F'; otherwise, S is an output argument. If FACT = 'F' and EQUED
  = 'Y', each element of S must be positive. If S is output, each
  element of S is a power of the radix. If S is input, each element
  of S should be a power of the radix to ensure a reliable solution
  and error estimates. Scaling by powers of the radix does not cause
  rounding errors unless the result underflows or overflows.
  Rounding errors during scaling lead to refining with a matrix that
  is not equivalent to the input matrix, producing error estimates
  that may not be reliable.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SGETRS.
  On exit, the improved solution matrix X.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc porfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] c_float, af : [] c_float, s : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_sporfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dporfsx for the type c_double.

For more information, see the documentation for :proc:`porfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc porfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] c_double, af : [] c_double, s : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_dporfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cporfsx for the type lapack_complex_float.

For more information, see the documentation for :proc:`porfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc porfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] complex(64), af : [] complex(64), s : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_cporfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zporfsx for the type lapack_complex_double.

For more information, see the documentation for :proc:`porfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc porfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] complex(128), af : [] complex(128), s : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zporfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sposv for the type c_float.

Original Fortran LAPACK purpose documentation for SPOSV::

 SPOSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

Original Fortran LAPACK argument documentation for SPOSV::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if INFO = 0, the factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc posv(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, b : [] c_float): c_int{
  return LAPACKE_sposv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dposv for the type c_double.

For more information, see the documentation for :proc:`posv`, or consult the Netlibs or Intel documentation.
 */
inline proc posv(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dposv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cposv for the type lapack_complex_float.

For more information, see the documentation for :proc:`posv`, or consult the Netlibs or Intel documentation.
 */
inline proc posv(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cposv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zposv for the type lapack_complex_double.

For more information, see the documentation for :proc:`posv`, or consult the Netlibs or Intel documentation.
 */
inline proc posv(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zposv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsposv for the type c_double.

Original Fortran LAPACK purpose documentation for DSPOSV::

 DSPOSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 DSPOSV first attempts to factorize the matrix in SINGLE PRECISION
 and use this factorization within an iterative refinement procedure
 to produce a solution with DOUBLE PRECISION normwise backward error
 quality (see below). If the approach fails the method switches to a
 DOUBLE PRECISION factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio SINGLE PRECISION performance over DOUBLE PRECISION
 performance is too small. A reasonable strategy should take the
 number of right-hand sides and the size of the matrix into account.
 This might be done with a call to ILAENV in the future. Up to now, we
 always try iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

Original Fortran LAPACK argument documentation for DSPOSV::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is DOUBLE PRECISION array,
  dimension (LDA,N)
  On entry, the symmetric matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
  On exit, if iterative refinement has been successfully used
  (INFO.EQ.0 and ITER.GE.0, see description below), then A is
  unchanged, if double precision factorization has been used
  (INFO.EQ.0 and ITER.LT.0, see description below), then the
  array A contains the factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T.

 B is DOUBLE PRECISION array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is DOUBLE PRECISION array, dimension (LDX,NRHS)
  If INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc sposv(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, b : [] c_double, x : [] c_double, ref chlapack_iter : c_int): c_int{
  return LAPACKE_dsposv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, chlapack_iter);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zcposv for the type lapack_complex_double.

Original Fortran LAPACK purpose documentation for ZCPOSV::

 ZCPOSV computes the solution to a complex system of linear equations
 A * X = B,
 where A is an N-by-N Hermitian positive definite matrix and X and B
 are N-by-NRHS matrices.

 ZCPOSV first attempts to factorize the matrix in COMPLEX and use this
 factorization within an iterative refinement procedure to produce a
 solution with COMPLEX*16 normwise backward error quality (see below).
 If the approach fails the method switches to a COMPLEX*16
 factorization and solve.

 The iterative refinement is not going to be a winning strategy if
 the ratio COMPLEX performance over COMPLEX*16 performance is too
 small. A reasonable strategy should take the number of right-hand
 sides and the size of the matrix into account. This might be done
 with a call to ILAENV in the future. Up to now, we always try
 iterative refinement.

 The iterative refinement process is stopped if
 ITER > ITERMAX
 or for all the RHS we have:
 RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
 where
 o ITER is the number of the current iteration in the iterative
 refinement process
 o RNRM is the infinity-norm of the residual
 o XNRM is the infinity-norm of the solution
 o ANRM is the infinity-operator-norm of the matrix A
 o EPS is the machine epsilon returned by DLAMCH('Epsilon')
 The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
 respectively.

Original Fortran LAPACK argument documentation for ZCPOSV::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is COMPLEX*16 array,
  dimension (LDA,N)
  On entry, the Hermitian matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  Note that the imaginary parts of the diagonal
  elements need not be set and are assumed to be zero.
 
  On exit, if iterative refinement has been successfully used
  (INFO.EQ.0 and ITER.GE.0, see description below), then A is
  unchanged, if double precision factorization has been used
  (INFO.EQ.0 and ITER.LT.0, see description below), then the
  array A contains the factor U or L from the Cholesky
  factorization A = U**H*U or A = L*L**H.

 B is COMPLEX*16 array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is COMPLEX*16 array, dimension (LDX,NRHS)
  If INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc cposv(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), b : [] complex(128), x : [] complex(128), ref chlapack_iter : c_int): c_int{
  return LAPACKE_zcposv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, chlapack_iter);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sposvx for the type c_float.

Original Fortran LAPACK purpose documentation for SPOSVX::

 SPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix and X and B
 are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for SPOSVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AF contains the factored form of A.
  If EQUED = 'Y', the matrix A has been equilibrated
  with scaling factors given by S. A and AF will not
  be modified.
  = 'N': The matrix A will be copied to AF and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AF and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A, except if FACT = 'F' and
  EQUED = 'Y', then A must contain the equilibrated matrix
  diag(S)*A*diag(S). If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced. A is not modified if
  FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
 
  On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
  diag(S)*A*diag(S).

 AF is REAL array, dimension (LDAF,N)
  If FACT = 'F', then AF is an input argument and on entry
  contains the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T, in the same storage
  format as A. If EQUED .ne. 'N', then AF is the factored form
  of the equilibrated matrix diag(S)*A*diag(S).
 
  If FACT = 'N', then AF is an output argument and on exit
  returns the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T of the original
  matrix A.
 
  If FACT = 'E', then AF is an output argument and on exit
  returns the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T of the equilibrated
  matrix A (see the description of A for the form of the
  equilibrated matrix).

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'Y': Equilibration was done, i.e., A has been replaced by
  diag(S) * A * diag(S).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 S is REAL array, dimension (N)
  The scale factors for A; not accessed if EQUED = 'N'. S is
  an input argument if FACT = 'F'; otherwise, S is an output
  argument. If FACT = 'F' and EQUED = 'Y', each element of S
  must be positive.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
  B is overwritten by diag(S) * B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
  the original system of equations. Note that if EQUED = 'Y',
  A and B are modified on exit, and the solution to the
  equilibrated system is inv(diag(S))*X.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A after equilibration (if done). If RCOND is less than the
  machine precision (in particular, if RCOND = 0), the matrix
  is singular to working precision. This condition is
  indicated by a return code of INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc posvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] c_float, af : [] c_float, ref equed : string, s : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sposvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dposvx for the type c_double.

For more information, see the documentation for :proc:`posvx`, or consult the Netlibs or Intel documentation.
 */
inline proc posvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] c_double, af : [] c_double, ref equed : string, s : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dposvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cposvx for the type lapack_complex_float.

For more information, see the documentation for :proc:`posvx`, or consult the Netlibs or Intel documentation.
 */
inline proc posvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(64), af : [] complex(64), ref equed : string, s : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cposvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zposvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`posvx`, or consult the Netlibs or Intel documentation.
 */
inline proc posvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(128), af : [] complex(128), ref equed : string, s : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zposvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sposvxx for the type c_float.

Original Fortran LAPACK purpose documentation for SPOSVXX::

 SPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T
 to compute the solution to a real system of linear equations
 A * X = B, where A is an N-by-N symmetric positive definite matrix
 and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SPOSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SPOSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SPOSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SPOSVXX would itself produce.

Original Fortran LAPACK argument documentation for SPOSVXX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AF contains the factored form of A.
  If EQUED is not 'N', the matrix A has been
  equilibrated with scaling factors given by S.
  A and AF are not modified.
  = 'N': The matrix A will be copied to AF and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AF and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A, except if FACT = 'F' and EQUED =
  'Y', then A must contain the equilibrated matrix
  diag(S)*A*diag(S). If UPLO = 'U', the leading N-by-N upper
  triangular part of A contains the upper triangular part of the
  matrix A, and the strictly lower triangular part of A is not
  referenced. If UPLO = 'L', the leading N-by-N lower triangular
  part of A contains the lower triangular part of the matrix A, and
  the strictly upper triangular part of A is not referenced. A is
  not modified if FACT = 'F' or 'N', or if FACT = 'E' and EQUED =
  'N' on exit.
 
  On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
  diag(S)*A*diag(S).

 AF is REAL array, dimension (LDAF,N)
  If FACT = 'F', then AF is an input argument and on entry
  contains the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T, in the same storage
  format as A. If EQUED .ne. 'N', then AF is the factored
  form of the equilibrated matrix diag(S)*A*diag(S).
 
  If FACT = 'N', then AF is an output argument and on exit
  returns the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T of the original
  matrix A.
 
  If FACT = 'E', then AF is an output argument and on exit
  returns the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T of the equilibrated
  matrix A (see the description of A for the form of the
  equilibrated matrix).

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'Y': Both row and column equilibration, i.e., A has been
  replaced by diag(S) * A * diag(S).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 S is REAL array, dimension (N)
  The row scale factors for A. If EQUED = 'Y', A is multiplied on
  the left and right by diag(S). S is an input argument if FACT =
  'F'; otherwise, S is an output argument. If FACT = 'F' and EQUED
  = 'Y', each element of S must be positive. If S is output, each
  element of S is a power of the radix. If S is input, each element
  of S should be a power of the radix to ensure a reliable solution
  and error estimates. Scaling by powers of the radix does not cause
  rounding errors unless the result underflows or overflows.
  Rounding errors during scaling lead to refining with a matrix that
  is not equivalent to the input matrix, producing error estimates
  that may not be reliable.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit,
  if EQUED = 'N', B is not modified;
  if EQUED = 'Y', B is overwritten by diag(S)*B;

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0, the N-by-NRHS solution matrix X to the original
  system of equations. Note that A and B are modified on exit if
  EQUED .ne. 'N', and the solution to the equilibrated system is
  inv(diag(S))*X.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 RPVGRW is REAL
  Reciprocal pivot growth. On exit, this contains the reciprocal
  pivot growth factor norm(A)/norm(U). The "max absolute element"
  norm is used. If this is much less than 1, then the stability of
  the LU factorization of the (equilibrated) matrix A could be poor.
  This also means that the solution X, estimated condition numbers,
  and error bounds could be unreliable. If factorization fails with
  0<INFO<=N, then this contains the reciprocal pivot growth factor
  for the leading INFO columns of A.

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc posvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] c_float, af : [] c_float, ref equed : string, s : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_sposvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dposvxx for the type c_double.

For more information, see the documentation for :proc:`posvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc posvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] c_double, af : [] c_double, ref equed : string, s : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_dposvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cposvxx for the type lapack_complex_float.

For more information, see the documentation for :proc:`posvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc posvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(64), af : [] complex(64), ref equed : string, s : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_cposvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zposvxx for the type lapack_complex_double.

For more information, see the documentation for :proc:`posvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc posvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(128), af : [] complex(128), ref equed : string, s : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zposvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spotrf for the type c_float.

Original Fortran LAPACK purpose documentation for SPOTRF::

 SPOTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

 This is the block version of the algorithm, calling Level 3 BLAS.

Original Fortran LAPACK argument documentation for SPOTRF::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if INFO = 0, the factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T.

 */
inline proc potrf(matrix_order : lapack_memory_order, uplo : string, a : [] c_float): c_int{
  return LAPACKE_spotrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpotrf for the type c_double.

For more information, see the documentation for :proc:`potrf`, or consult the Netlibs or Intel documentation.
 */
inline proc potrf(matrix_order : lapack_memory_order, uplo : string, a : [] c_double): c_int{
  return LAPACKE_dpotrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpotrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`potrf`, or consult the Netlibs or Intel documentation.
 */
inline proc potrf(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64)): c_int{
  return LAPACKE_cpotrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpotrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`potrf`, or consult the Netlibs or Intel documentation.
 */
inline proc potrf(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128)): c_int{
  return LAPACKE_zpotrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spotri for the type c_float.

Original Fortran LAPACK purpose documentation for SPOTRI::

 SPOTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by SPOTRF.

Original Fortran LAPACK argument documentation for SPOTRI::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  On entry, the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T, as computed by
  SPOTRF.
  On exit, the upper or lower triangle of the (symmetric)
  inverse of A, overwriting the input factor U or L.

 */
inline proc potri(matrix_order : lapack_memory_order, uplo : string, a : [] c_float): c_int{
  return LAPACKE_spotri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpotri for the type c_double.

For more information, see the documentation for :proc:`potri`, or consult the Netlibs or Intel documentation.
 */
inline proc potri(matrix_order : lapack_memory_order, uplo : string, a : [] c_double): c_int{
  return LAPACKE_dpotri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpotri for the type lapack_complex_float.

For more information, see the documentation for :proc:`potri`, or consult the Netlibs or Intel documentation.
 */
inline proc potri(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64)): c_int{
  return LAPACKE_cpotri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpotri for the type lapack_complex_double.

For more information, see the documentation for :proc:`potri`, or consult the Netlibs or Intel documentation.
 */
inline proc potri(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128)): c_int{
  return LAPACKE_zpotri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spotrs for the type c_float.

Original Fortran LAPACK purpose documentation for SPOTRS::

 SPOTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A using the Cholesky factorization
 A = U**T*U or A = L*L**T computed by SPOTRF.

Original Fortran LAPACK argument documentation for SPOTRS::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T, as computed by SPOTRF.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc potrs(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, b : [] c_float): c_int{
  return LAPACKE_spotrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpotrs for the type c_double.

For more information, see the documentation for :proc:`potrs`, or consult the Netlibs or Intel documentation.
 */
inline proc potrs(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dpotrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpotrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`potrs`, or consult the Netlibs or Intel documentation.
 */
inline proc potrs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cpotrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpotrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`potrs`, or consult the Netlibs or Intel documentation.
 */
inline proc potrs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zpotrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sppcon for the type c_float.

Original Fortran LAPACK purpose documentation for SPPCON::

 SPPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite packed matrix using
 the Cholesky factorization A = U**T*U or A = L*L**T computed by
 SPPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

Original Fortran LAPACK argument documentation for SPPCON::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T, packed columnwise in a linear
  array. The j-th column of U or L is stored in the array AP
  as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.

 ANORM is REAL
  The 1-norm (or infinity-norm) of the symmetric matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
  estimate of the 1-norm of inv(A) computed in this routine.

 */
inline proc ppcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_sppcon(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dppcon for the type c_double.

For more information, see the documentation for :proc:`ppcon`, or consult the Netlibs or Intel documentation.
 */
inline proc ppcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_dppcon(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cppcon for the type lapack_complex_float.

For more information, see the documentation for :proc:`ppcon`, or consult the Netlibs or Intel documentation.
 */
inline proc ppcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_cppcon(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zppcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`ppcon`, or consult the Netlibs or Intel documentation.
 */
inline proc ppcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zppcon(matrix_order, ascii(uplo) : c_char, n, ap, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sppequ for the type c_float.

Original Fortran LAPACK purpose documentation for SPPEQU::

 SPPEQU computes row and column scalings intended to equilibrate a
 symmetric positive definite matrix A in packed storage and reduce
 its condition number (with respect to the two-norm). S contains the
 scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
 B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
 This choice of S puts the condition number of B within a factor N of
 the smallest possible condition number over all possible diagonal
 scalings.

Original Fortran LAPACK argument documentation for SPPEQU::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The upper or lower triangle of the symmetric matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.

 S is REAL array, dimension (N)
  If INFO = 0, S contains the scale factors for A.

 SCOND is REAL
  If INFO = 0, S contains the ratio of the smallest S(i) to
  the largest S(i). If SCOND >= 0.1 and AMAX is neither too
  large nor too small, it is not worth scaling by S.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc ppequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_sppequ(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dppequ for the type c_double.

For more information, see the documentation for :proc:`ppequ`, or consult the Netlibs or Intel documentation.
 */
inline proc ppequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_dppequ(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cppequ for the type lapack_complex_float.

For more information, see the documentation for :proc:`ppequ`, or consult the Netlibs or Intel documentation.
 */
inline proc ppequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_cppequ(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zppequ for the type lapack_complex_double.

For more information, see the documentation for :proc:`ppequ`, or consult the Netlibs or Intel documentation.
 */
inline proc ppequ(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_zppequ(matrix_order, ascii(uplo) : c_char, n, ap, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spprfs for the type c_float.

Original Fortran LAPACK purpose documentation for SPPRFS::

 SPPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and packed, and provides error bounds and backward error estimates
 for the solution.

Original Fortran LAPACK argument documentation for SPPRFS::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The upper or lower triangle of the symmetric matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.

 AFP is REAL array, dimension (N*(N+1)/2)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T, as computed by SPPTRF/CPPTRF,
  packed columnwise in a linear array in the same format as A
  (see AP).

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SPPTRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc pprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, afp : [] c_float, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_spprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpprfs for the type c_double.

For more information, see the documentation for :proc:`pprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc pprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, afp : [] c_double, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dpprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpprfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`pprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc pprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), afp : [] complex(64), b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cpprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpprfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`pprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc pprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), afp : [] complex(128), b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zpprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sppsv for the type c_float.

Original Fortran LAPACK purpose documentation for SPPSV::

 SPPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 The Cholesky decomposition is used to factor A as
 A = U**T* U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is a lower triangular
 matrix. The factored form of A is then used to solve the system of
 equations A * X = B.

Original Fortran LAPACK argument documentation for SPPSV::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
  See below for further details. 
 
  On exit, if INFO = 0, the factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T, in the same storage
  format as A.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc ppsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, b : [] c_float): c_int{
  return LAPACKE_sppsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dppsv for the type c_double.

For more information, see the documentation for :proc:`ppsv`, or consult the Netlibs or Intel documentation.
 */
inline proc ppsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dppsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cppsv for the type lapack_complex_float.

For more information, see the documentation for :proc:`ppsv`, or consult the Netlibs or Intel documentation.
 */
inline proc ppsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cppsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zppsv for the type lapack_complex_double.

For more information, see the documentation for :proc:`ppsv`, or consult the Netlibs or Intel documentation.
 */
inline proc ppsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zppsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sppsvx for the type c_float.

Original Fortran LAPACK purpose documentation for SPPSVX::

 SPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
 compute the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric positive definite matrix stored in
 packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for SPPSVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AFP contains the factored form of A.
  If EQUED = 'Y', the matrix A has been equilibrated
  with scaling factors given by S. AP and AFP will not
  be modified.
  = 'N': The matrix A will be copied to AFP and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AFP and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array, except if FACT = 'F'
  and EQUED = 'Y', then A must contain the equilibrated matrix
  diag(S)*A*diag(S). The j-th column of A is stored in the
  array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
  See below for further details. A is not modified if
  FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
 
  On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
  diag(S)*A*diag(S).

 AFP is REAL array, dimension
  (N*(N+1)/2)
  If FACT = 'F', then AFP is an input argument and on entry
  contains the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T, in the same storage
  format as A. If EQUED .ne. 'N', then AFP is the factored
  form of the equilibrated matrix A.
 
  If FACT = 'N', then AFP is an output argument and on exit
  returns the triangular factor U or L from the Cholesky
  factorization A = U**T * U or A = L * L**T of the original
  matrix A.
 
  If FACT = 'E', then AFP is an output argument and on exit
  returns the triangular factor U or L from the Cholesky
  factorization A = U**T * U or A = L * L**T of the equilibrated
  matrix A (see the description of AP for the form of the
  equilibrated matrix).

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'Y': Equilibration was done, i.e., A has been replaced by
  diag(S) * A * diag(S).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 S is REAL array, dimension (N)
  The scale factors for A; not accessed if EQUED = 'N'. S is
  an input argument if FACT = 'F'; otherwise, S is an output
  argument. If FACT = 'F' and EQUED = 'Y', each element of S
  must be positive.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
  B is overwritten by diag(S) * B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
  the original system of equations. Note that if EQUED = 'Y',
  A and B are modified on exit, and the solution to the
  equilibrated system is inv(diag(S))*X.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A after equilibration (if done). If RCOND is less than the
  machine precision (in particular, if RCOND = 0), the matrix
  is singular to working precision. This condition is
  indicated by a return code of INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc ppsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] c_float, afp : [] c_float, ref equed : string, s : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sppsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dppsvx for the type c_double.

For more information, see the documentation for :proc:`ppsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc ppsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] c_double, afp : [] c_double, ref equed : string, s : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dppsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cppsvx for the type lapack_complex_float.

For more information, see the documentation for :proc:`ppsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc ppsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] complex(64), afp : [] complex(64), ref equed : string, s : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cppsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zppsvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`ppsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc ppsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] complex(128), afp : [] complex(128), ref equed : string, s : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zppsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spptrf for the type c_float.

Original Fortran LAPACK purpose documentation for SPPTRF::

 SPPTRF computes the Cholesky factorization of a real symmetric
 positive definite matrix A stored in packed format.

 The factorization has the form
 A = U**T * U, if UPLO = 'U', or
 A = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular.

Original Fortran LAPACK argument documentation for SPPTRF::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
  See below for further details.
 
  On exit, if INFO = 0, the triangular factor U or L from the
  Cholesky factorization A = U**T*U or A = L*L**T, in the same
  storage format as A.

 */
inline proc pptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float): c_int{
  return LAPACKE_spptrf(matrix_order, ascii(uplo) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpptrf for the type c_double.

For more information, see the documentation for :proc:`pptrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double): c_int{
  return LAPACKE_dpptrf(matrix_order, ascii(uplo) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpptrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`pptrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64)): c_int{
  return LAPACKE_cpptrf(matrix_order, ascii(uplo) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpptrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`pptrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128)): c_int{
  return LAPACKE_zpptrf(matrix_order, ascii(uplo) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spptri for the type c_float.

Original Fortran LAPACK purpose documentation for SPPTRI::

 SPPTRI computes the inverse of a real symmetric positive definite
 matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
 computed by SPPTRF.

Original Fortran LAPACK argument documentation for SPPTRI::

 UPLO is CHARACTER*1
  = 'U': Upper triangular factor is stored in AP;
  = 'L': Lower triangular factor is stored in AP.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the triangular factor U or L from the Cholesky
  factorization A = U**T*U or A = L*L**T, packed columnwise as
  a linear array. The j-th column of U or L is stored in the
  array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
 
  On exit, the upper or lower triangle of the (symmetric)
  inverse of A, overwriting the input factor U or L.

 */
inline proc pptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float): c_int{
  return LAPACKE_spptri(matrix_order, ascii(uplo) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpptri for the type c_double.

For more information, see the documentation for :proc:`pptri`, or consult the Netlibs or Intel documentation.
 */
inline proc pptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double): c_int{
  return LAPACKE_dpptri(matrix_order, ascii(uplo) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpptri for the type lapack_complex_float.

For more information, see the documentation for :proc:`pptri`, or consult the Netlibs or Intel documentation.
 */
inline proc pptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64)): c_int{
  return LAPACKE_cpptri(matrix_order, ascii(uplo) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpptri for the type lapack_complex_double.

For more information, see the documentation for :proc:`pptri`, or consult the Netlibs or Intel documentation.
 */
inline proc pptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128)): c_int{
  return LAPACKE_zpptri(matrix_order, ascii(uplo) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spptrs for the type c_float.

Original Fortran LAPACK purpose documentation for SPPTRS::

 SPPTRS solves a system of linear equations A*X = B with a symmetric
 positive definite matrix A in packed storage using the Cholesky
 factorization A = U**T*U or A = L*L**T computed by SPPTRF.

Original Fortran LAPACK argument documentation for SPPTRS::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The triangular factor U or L from the Cholesky factorization
  A = U**T*U or A = L*L**T, packed columnwise in a linear
  array. The j-th column of U or L is stored in the array AP
  as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc pptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, b : [] c_float): c_int{
  return LAPACKE_spptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpptrs for the type c_double.

For more information, see the documentation for :proc:`pptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dpptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpptrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`pptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cpptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpptrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`pptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zpptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spstrf for the type c_float.

Original Fortran LAPACK purpose documentation for SPSTRF::

 SPSTRF computes the Cholesky factorization with complete
 pivoting of a real symmetric positive semidefinite matrix A.

 The factorization has the form
 P**T * A * P = U**T * U , if UPLO = 'U',
 P**T * A * P = L * L**T, if UPLO = 'L',
 where U is an upper triangular matrix and L is lower triangular, and
 P is stored as vector PIV.

 This algorithm does not attempt to check that A is positive
 semidefinite. This version of the algorithm calls level 3 BLAS.

Original Fortran LAPACK argument documentation for SPSTRF::

 UPLO is CHARACTER*1
  Specifies whether the upper or lower triangular part of the
  symmetric matrix A is stored.
  = 'U': Upper triangular
  = 'L': Lower triangular

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A. If UPLO = 'U', the leading
  n by n upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading n by n lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if INFO = 0, the factor U or L from the Cholesky
  factorization as above.

 PIV is INTEGER array, dimension (N)
  PIV is such that the nonzero entries are P( PIV(K), K ) = 1.

 RANK is INTEGER
  The rank of A given by the number of steps the algorithm
  completed.

 TOL is REAL
  User defined tolerance. If TOL < 0, then N*U*MAX( A(K,K) )
  will be used. The algorithm terminates at the (K-1)st step
  if the pivot <= TOL.

 */
inline proc pstrf(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, piv : [] c_int, ref rank : c_int, tol : c_float): c_int{
  return LAPACKE_spstrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, piv, rank, tol);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpstrf for the type c_double.

For more information, see the documentation for :proc:`pstrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pstrf(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, piv : [] c_int, ref rank : c_int, tol : c_double): c_int{
  return LAPACKE_dpstrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, piv, rank, tol);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpstrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`pstrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pstrf(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), piv : [] c_int, ref rank : c_int, tol : c_float): c_int{
  return LAPACKE_cpstrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, piv, rank, tol);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpstrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`pstrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pstrf(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), piv : [] c_int, ref rank : c_int, tol : c_double): c_int{
  return LAPACKE_zpstrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, piv, rank, tol);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sptcon for the type c_float.

Original Fortran LAPACK purpose documentation for SPTCON::

 SPTCON computes the reciprocal of the condition number (in the
 1-norm) of a real symmetric positive definite tridiagonal matrix
 using the factorization A = L*D*L**T or A = U**T*D*U computed by
 SPTTRF.

 Norm(inv(A)) is computed by a direct method, and the reciprocal of
 the condition number is computed as
 RCOND = 1 / (ANORM * norm(inv(A))).

Original Fortran LAPACK argument documentation for SPTCON::

 N is INTEGER
  The order of the matrix A. N >= 0.

 D is REAL array, dimension (N)
  The n diagonal elements of the diagonal matrix D from the
  factorization of A, as computed by SPTTRF.

 E is REAL array, dimension (N-1)
  The (n-1) off-diagonal elements of the unit bidiagonal factor
  U or L from the factorization of A, as computed by SPTTRF.

 ANORM is REAL
  The 1-norm of the original matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the
  1-norm of inv(A) computed in this routine.

 */
inline proc ptcon(n : c_int, d : [] c_float, e : [] c_float, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_sptcon(n, d, e, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dptcon for the type c_double.

For more information, see the documentation for :proc:`ptcon`, or consult the Netlibs or Intel documentation.
 */
inline proc ptcon(n : c_int, d : [] c_double, e : [] c_double, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_dptcon(n, d, e, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cptcon for the type lapack_complex_float.

For more information, see the documentation for :proc:`ptcon`, or consult the Netlibs or Intel documentation.
 */
inline proc ptcon(n : c_int, d : [] c_float, e : [] complex(64), anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_cptcon(n, d, e, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zptcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`ptcon`, or consult the Netlibs or Intel documentation.
 */
inline proc ptcon(n : c_int, d : [] c_double, e : [] complex(128), anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zptcon(n, d, e, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spteqr for the type c_float.

Original Fortran LAPACK purpose documentation for SPTEQR::

 SPTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric positive definite tridiagonal matrix by first factoring the
 matrix using SPTTRF, and then calling SBDSQR to compute the singular
 values of the bidiagonal factor.

 This routine computes the eigenvalues of the positive definite
 tridiagonal matrix to high relative accuracy. This means that if the
 eigenvalues range over many orders of magnitude in size, then the
 small eigenvalues and corresponding eigenvectors will be computed
 more accurately than, for example, with the standard QR method.

 The eigenvectors of a full or band symmetric positive definite matrix
 can also be found if SSYTRD, SSPTRD, or SSBTRD has been used to
 reduce this matrix to tridiagonal form. (The reduction to tridiagonal
 form, however, may preclude the possibility of obtaining high
 relative accuracy in the small eigenvalues of the original matrix, if
 these eigenvalues range over many orders of magnitude.)

Original Fortran LAPACK argument documentation for SPTEQR::

 COMPZ is CHARACTER*1
  = 'N': Compute eigenvalues only.
  = 'V': Compute eigenvectors of original symmetric
  matrix also. Array Z contains the orthogonal
  matrix used to reduce the original matrix to
  tridiagonal form.
  = 'I': Compute eigenvectors of tridiagonal matrix also.

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the tridiagonal
  matrix.
  On normal exit, D contains the eigenvalues, in descending
  order.

 E is REAL array, dimension (N-1)
  On entry, the (n-1) subdiagonal elements of the tridiagonal
  matrix.
  On exit, E has been destroyed.

 Z is REAL array, dimension (LDZ, N)
  On entry, if COMPZ = 'V', the orthogonal matrix used in the
  reduction to tridiagonal form.
  On exit, if COMPZ = 'V', the orthonormal eigenvectors of the
  original symmetric matrix;
  if COMPZ = 'I', the orthonormal eigenvectors of the
  tridiagonal matrix.
  If INFO > 0 on exit, Z contains the eigenvectors associated
  with only the stored eigenvalues.
  If COMPZ = 'N', then Z is not referenced.

 */
inline proc pteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float): c_int{
  return LAPACKE_spteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpteqr for the type c_double.

For more information, see the documentation for :proc:`pteqr`, or consult the Netlibs or Intel documentation.
 */
inline proc pteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dpteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpteqr for the type lapack_complex_float.

For more information, see the documentation for :proc:`pteqr`, or consult the Netlibs or Intel documentation.
 */
inline proc pteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_cpteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpteqr for the type lapack_complex_double.

For more information, see the documentation for :proc:`pteqr`, or consult the Netlibs or Intel documentation.
 */
inline proc pteqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zpteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sptrfs for the type c_float.

Original Fortran LAPACK purpose documentation for SPTRFS::

 SPTRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric positive definite
 and tridiagonal, and provides error bounds and backward error
 estimates for the solution.

Original Fortran LAPACK argument documentation for SPTRFS::

 N is INTEGER
  The order of the matrix A. N >= 0.

 D is REAL array, dimension (N)
  The n diagonal elements of the tridiagonal matrix A.

 E is REAL array, dimension (N-1)
  The (n-1) subdiagonal elements of the tridiagonal matrix A.

 DF is REAL array, dimension (N)
  The n diagonal elements of the diagonal matrix D from the
  factorization computed by SPTTRF.

 EF is REAL array, dimension (N-1)
  The (n-1) subdiagonal elements of the unit bidiagonal factor
  L from the factorization computed by SPTTRF.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SPTTRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j).

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc ptrfs(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sptrfs(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, df, ef, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dptrfs for the type c_double.

For more information, see the documentation for :proc:`ptrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc ptrfs(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dptrfs(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, df, ef, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cptrfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`ptrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc ptrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cptrfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, df, ef, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zptrfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`ptrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc ptrfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zptrfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, df, ef, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sptsv for the type c_float.

Original Fortran LAPACK purpose documentation for SPTSV::

 SPTSV computes the solution to a real system of linear equations
 A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
 matrix, and X and B are N-by-NRHS matrices.

 A is factored as A = L*D*L**T, and the factored form of A is then
 used to solve the system of equations.

Original Fortran LAPACK argument documentation for SPTSV::

 N is INTEGER
  The order of the matrix A. N >= 0.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the tridiagonal matrix
  A. On exit, the n diagonal elements of the diagonal matrix
  D from the factorization A = L*D*L**T.

 E is REAL array, dimension (N-1)
  On entry, the (n-1) subdiagonal elements of the tridiagonal
  matrix A. On exit, the (n-1) subdiagonal elements of the
  unit bidiagonal factor L from the L*D*L**T factorization of
  A. (E can also be regarded as the superdiagonal of the unit
  bidiagonal factor U from the U**T*D*U factorization of A.)

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc ptsv(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] c_float, b : [] c_float): c_int{
  return LAPACKE_sptsv(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dptsv for the type c_double.

For more information, see the documentation for :proc:`ptsv`, or consult the Netlibs or Intel documentation.
 */
inline proc ptsv(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dptsv(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cptsv for the type lapack_complex_float.

For more information, see the documentation for :proc:`ptsv`, or consult the Netlibs or Intel documentation.
 */
inline proc ptsv(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cptsv(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zptsv for the type lapack_complex_double.

For more information, see the documentation for :proc:`ptsv`, or consult the Netlibs or Intel documentation.
 */
inline proc ptsv(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zptsv(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sptsvx for the type c_float.

Original Fortran LAPACK purpose documentation for SPTSVX::

 SPTSVX uses the factorization A = L*D*L**T to compute the solution
 to a real system of linear equations A*X = B, where A is an N-by-N
 symmetric positive definite tridiagonal matrix and X and B are
 N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for SPTSVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of A has been
  supplied on entry.
  = 'F': On entry, DF and EF contain the factored form of A.
  D, E, DF, and EF will not be modified.
  = 'N': The matrix A will be copied to DF and EF and
  factored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 D is REAL array, dimension (N)
  The n diagonal elements of the tridiagonal matrix A.

 E is REAL array, dimension (N-1)
  The (n-1) subdiagonal elements of the tridiagonal matrix A.

 DF is REAL array, dimension (N)
  If FACT = 'F', then DF is an input argument and on entry
  contains the n diagonal elements of the diagonal matrix D
  from the L*D*L**T factorization of A.
  If FACT = 'N', then DF is an output argument and on exit
  contains the n diagonal elements of the diagonal matrix D
  from the L*D*L**T factorization of A.

 EF is REAL array, dimension (N-1)
  If FACT = 'F', then EF is an input argument and on entry
  contains the (n-1) subdiagonal elements of the unit
  bidiagonal factor L from the L*D*L**T factorization of A.
  If FACT = 'N', then EF is an output argument and on exit
  contains the (n-1) subdiagonal elements of the unit
  bidiagonal factor L from the L*D*L**T factorization of A.

 B is REAL array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.

 RCOND is REAL
  The reciprocal condition number of the matrix A. If RCOND
  is less than the machine precision (in particular, if
  RCOND = 0), the matrix is singular to working precision.
  This condition is indicated by a return code of INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j).

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in any
  element of A or B that makes X(j) an exact solution).

 */
inline proc ptsvx(matrix_order : lapack_memory_order, fact : string, n : c_int, d : [] c_float, e : [] c_float, df : [] c_float, ef : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sptsvx(matrix_order, ascii(fact) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, df, ef, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dptsvx for the type c_double.

For more information, see the documentation for :proc:`ptsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc ptsvx(matrix_order : lapack_memory_order, fact : string, n : c_int, d : [] c_double, e : [] c_double, df : [] c_double, ef : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dptsvx(matrix_order, ascii(fact) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, df, ef, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cptsvx for the type lapack_complex_float.

For more information, see the documentation for :proc:`ptsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc ptsvx(matrix_order : lapack_memory_order, fact : string, n : c_int, d : [] c_float, e : [] complex(64), df : [] c_float, ef : [] complex(64), b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cptsvx(matrix_order, ascii(fact) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, df, ef, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zptsvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`ptsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc ptsvx(matrix_order : lapack_memory_order, fact : string, n : c_int, d : [] c_double, e : [] complex(128), df : [] c_double, ef : [] complex(128), b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zptsvx(matrix_order, ascii(fact) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, df, ef, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spttrf for the type c_float.

Original Fortran LAPACK purpose documentation for SPTTRF::

 SPTTRF computes the L*D*L**T factorization of a real symmetric
 positive definite tridiagonal matrix A. The factorization may also
 be regarded as having the form A = U**T*D*U.

Original Fortran LAPACK argument documentation for SPTTRF::

 N is INTEGER
  The order of the matrix A. N >= 0.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the tridiagonal matrix
  A. On exit, the n diagonal elements of the diagonal matrix
  D from the L*D*L**T factorization of A.

 E is REAL array, dimension (N-1)
  On entry, the (n-1) subdiagonal elements of the tridiagonal
  matrix A. On exit, the (n-1) subdiagonal elements of the
  unit bidiagonal factor L from the L*D*L**T factorization of A.
  E can also be regarded as the superdiagonal of the unit
  bidiagonal factor U from the U**T*D*U factorization of A.

 */
inline proc pttrf(n : c_int, d : [] c_float, e : [] c_float): c_int{
  return LAPACKE_spttrf(n, d, e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpttrf for the type c_double.

For more information, see the documentation for :proc:`pttrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pttrf(n : c_int, d : [] c_double, e : [] c_double): c_int{
  return LAPACKE_dpttrf(n, d, e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpttrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`pttrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pttrf(n : c_int, d : [] c_float, e : [] complex(64)): c_int{
  return LAPACKE_cpttrf(n, d, e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpttrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`pttrf`, or consult the Netlibs or Intel documentation.
 */
inline proc pttrf(n : c_int, d : [] c_double, e : [] complex(128)): c_int{
  return LAPACKE_zpttrf(n, d, e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_spttrs for the type c_float.

Original Fortran LAPACK purpose documentation for SPTTRS::

 SPTTRS solves a tridiagonal system of the form
 A * X = B
 using the L*D*L**T factorization of A computed by SPTTRF. D is a
 diagonal matrix specified in the vector D, L is a unit bidiagonal
 matrix whose subdiagonal is specified in the vector E, and X and B
 are N by NRHS matrices.

Original Fortran LAPACK argument documentation for SPTTRS::

 N is INTEGER
  The order of the tridiagonal matrix A. N >= 0.

 D is REAL array, dimension (N)
  The n diagonal elements of the diagonal matrix D from the
  L*D*L**T factorization of A.

 E is REAL array, dimension (N-1)
  The (n-1) subdiagonal elements of the unit bidiagonal factor
  L from the L*D*L**T factorization of A. E can also be regarded
  as the superdiagonal of the unit bidiagonal factor U from the
  factorization A = U**T*D*U.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side vectors B for the system of
  linear equations.
  On exit, the solution vectors, X.

 */
inline proc pttrs(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] c_float, b : [] c_float): c_int{
  return LAPACKE_spttrs(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dpttrs for the type c_double.

For more information, see the documentation for :proc:`pttrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pttrs(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dpttrs(matrix_order, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cpttrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`pttrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pttrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, d : [] c_float, e : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_cpttrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zpttrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`pttrs`, or consult the Netlibs or Intel documentation.
 */
inline proc pttrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, d : [] c_double, e : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_zpttrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, d, e, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssbev for the type c_float.

Original Fortran LAPACK purpose documentation for SSBEV::

 SSBEV computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A.

Original Fortran LAPACK argument documentation for SSBEV::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
 
  On exit, AB is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the first
  superdiagonal and the diagonal of the tridiagonal matrix T
  are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
  the diagonal and first subdiagonal of T are returned in the
  first two rows of AB.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc sbev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, w : [] c_float, z : [] c_float): c_int{
  return LAPACKE_ssbev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsbev for the type c_double.

For more information, see the documentation for :proc:`sbev`, or consult the Netlibs or Intel documentation.
 */
inline proc sbev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, w : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dsbev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssbevd for the type c_float.

Original Fortran LAPACK purpose documentation for SSBEVD::

 SSBEVD computes all the eigenvalues and, optionally, eigenvectors of
 a real symmetric band matrix A. If eigenvectors are desired, it uses
 a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for SSBEVD::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
 
  On exit, AB is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the first
  superdiagonal and the diagonal of the tridiagonal matrix T
  are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
  the diagonal and first subdiagonal of T are returned in the
  first two rows of AB.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc sbevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, w : [] c_float, z : [] c_float): c_int{
  return LAPACKE_ssbevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsbevd for the type c_double.

For more information, see the documentation for :proc:`sbevd`, or consult the Netlibs or Intel documentation.
 */
inline proc sbevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, w : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dsbevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssbevx for the type c_float.

Original Fortran LAPACK purpose documentation for SSBEVX::

 SSBEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric band matrix A. Eigenvalues and eigenvectors can
 be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for SSBEVX::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found;
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found;
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
 
  On exit, AB is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the first
  superdiagonal and the diagonal of the tridiagonal matrix T
  are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
  the diagonal and first subdiagonal of T are returned in the
  first two rows of AB.

 Q is REAL array, dimension (LDQ, N)
  If JOBZ = 'V', the N-by-N orthogonal matrix used in the
  reduction to tridiagonal form.
  If JOBZ = 'N', the array Q is not referenced.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing AB to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  The first M elements contain the selected eigenvalues in
  ascending order.

 Z is REAL array, dimension (LDZ, max(1,M))
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and the
  index of the eigenvector is returned in IFAIL.
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc sbevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, q : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ifail : [] c_int): c_int{
  return LAPACKE_ssbevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsbevx for the type c_double.

For more information, see the documentation for :proc:`sbevx`, or consult the Netlibs or Intel documentation.
 */
inline proc sbevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, q : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ifail : [] c_int): c_int{
  return LAPACKE_dsbevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssbgst for the type c_float.

Original Fortran LAPACK purpose documentation for SSBGST::

 SSBGST reduces a real symmetric-definite banded generalized
 eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,
 such that C has the same bandwidth as A.

 B must have been previously factorized as S**T*S by SPBSTF, using a
 split Cholesky factorization. A is overwritten by C = X**T*A*X, where
 X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
 bandwidth of A.

Original Fortran LAPACK argument documentation for SSBGST::

 VECT is CHARACTER*1
  = 'N': do not form the transformation matrix X;
  = 'V': form X.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 KA is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= 0.

 KB is INTEGER
  The number of superdiagonals of the matrix B if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= KB >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first ka+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+ka).
 
  On exit, the transformed matrix X**T*A*X, stored in the same
  format as A.

 BB is REAL array, dimension (LDBB,N)
  The banded factor S from the split Cholesky factorization of
  B, as returned by SPBSTF, stored in the first KB+1 rows of
  the array.

 X is REAL array, dimension (LDX,N)
  If VECT = 'V', the n-by-n matrix X.
  If VECT = 'N', the array X is not referenced.

 */
inline proc sbgst(matrix_order : lapack_memory_order, vect : string, uplo : string, ka : c_int, kb : c_int, ab : [] c_float, bb : [] c_float, x : [] c_float): c_int{
  return LAPACKE_ssbgst(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(2).size else x.domain.dim(1).size) : c_int, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsbgst for the type c_double.

For more information, see the documentation for :proc:`sbgst`, or consult the Netlibs or Intel documentation.
 */
inline proc sbgst(matrix_order : lapack_memory_order, vect : string, uplo : string, ka : c_int, kb : c_int, ab : [] c_double, bb : [] c_double, x : [] c_double): c_int{
  return LAPACKE_dsbgst(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(2).size else x.domain.dim(1).size) : c_int, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssbgv for the type c_float.

Original Fortran LAPACK purpose documentation for SSBGV::

 SSBGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite.

Original Fortran LAPACK argument documentation for SSBGV::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 KA is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= 0.

 KB is INTEGER
  The number of superdiagonals of the matrix B if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KB >= 0.

 AB is REAL array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first ka+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+ka).
 
  On exit, the contents of AB are destroyed.

 BB is REAL array, dimension (LDBB, N)
  On entry, the upper or lower triangle of the symmetric band
  matrix B, stored in the first kb+1 rows of the array. The
  j-th column of B is stored in the j-th column of the array BB
  as follows:
  if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
  if UPLO = 'L', BB(1+i-j,j) = B(i,j) for j<=i<=min(n,j+kb).
 
  On exit, the factor S from the split Cholesky factorization
  B = S**T*S, as returned by SPBSTF.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors, with the i-th column of Z holding the
  eigenvector associated with W(i). The eigenvectors are
  normalized so that Z**T*B*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc sbgv(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, bb : [] c_float, w : [] c_float, z : [] c_float): c_int{
  return LAPACKE_ssbgv(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsbgv for the type c_double.

For more information, see the documentation for :proc:`sbgv`, or consult the Netlibs or Intel documentation.
 */
inline proc sbgv(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, bb : [] c_double, w : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dsbgv(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssbgvd for the type c_float.

Original Fortran LAPACK purpose documentation for SSBGVD::

 SSBGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of the
 form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric and
 banded, and B is also positive definite. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for SSBGVD::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 KA is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= 0.

 KB is INTEGER
  The number of superdiagonals of the matrix B if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KB >= 0.

 AB is REAL array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first ka+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+ka).
 
  On exit, the contents of AB are destroyed.

 BB is REAL array, dimension (LDBB, N)
  On entry, the upper or lower triangle of the symmetric band
  matrix B, stored in the first kb+1 rows of the array. The
  j-th column of B is stored in the j-th column of the array BB
  as follows:
  if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
  if UPLO = 'L', BB(1+i-j,j) = B(i,j) for j<=i<=min(n,j+kb).
 
  On exit, the factor S from the split Cholesky factorization
  B = S**T*S, as returned by SPBSTF.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors, with the i-th column of Z holding the
  eigenvector associated with W(i). The eigenvectors are
  normalized so Z**T*B*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc sbgvd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_float, bb : [] c_float, w : [] c_float, z : [] c_float): c_int{
  return LAPACKE_ssbgvd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsbgvd for the type c_double.

For more information, see the documentation for :proc:`sbgvd`, or consult the Netlibs or Intel documentation.
 */
inline proc sbgvd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ka : c_int, kb : c_int, ab : [] c_double, bb : [] c_double, w : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dsbgvd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssbgvx for the type c_float.

Original Fortran LAPACK purpose documentation for SSBGVX::

 SSBGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite banded eigenproblem, of
 the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
 and banded, and B is also positive definite. Eigenvalues and
 eigenvectors can be selected by specifying either all eigenvalues,
 a range of values or a range of indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for SSBGVX::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 KA is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KA >= 0.

 KB is INTEGER
  The number of superdiagonals of the matrix B if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KB >= 0.

 AB is REAL array, dimension (LDAB, N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first ka+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+ka).
 
  On exit, the contents of AB are destroyed.

 BB is REAL array, dimension (LDBB, N)
  On entry, the upper or lower triangle of the symmetric band
  matrix B, stored in the first kb+1 rows of the array. The
  j-th column of B is stored in the j-th column of the array BB
  as follows:
  if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
  if UPLO = 'L', BB(1+i-j,j) = B(i,j) for j<=i<=min(n,j+kb).
 
  On exit, the factor S from the split Cholesky factorization
  B = S**T*S, as returned by SPBSTF.

 Q is REAL array, dimension (LDQ, N)
  If JOBZ = 'V', the n-by-n matrix used in the reduction of
  A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,
  and consequently C to tridiagonal form.
  If JOBZ = 'N', the array Q is not referenced.

 VL is REAL

 VU is REAL
 
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
 
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing A to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors, with the i-th column of Z holding the
  eigenvector associated with W(i). The eigenvectors are
  normalized so Z**T*B*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 IFAIL is INTEGER array, dimension (M)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvalues that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc sbgvx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, ka : c_int, kb : c_int, ab : [] c_float, bb : [] c_float, q : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ifail : [] c_int): c_int{
  return LAPACKE_ssbgvx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then q.domain.dim(2).size else q.domain.dim(1).size) : c_int, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsbgvx for the type c_double.

For more information, see the documentation for :proc:`sbgvx`, or consult the Netlibs or Intel documentation.
 */
inline proc sbgvx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, ka : c_int, kb : c_int, ab : [] c_double, bb : [] c_double, q : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ifail : [] c_int): c_int{
  return LAPACKE_dsbgvx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (if matrix_order == lapack_memory_order.row_major then q.domain.dim(2).size else q.domain.dim(1).size) : c_int, ka, kb, ab, (ab.domain.dim(2).size) : c_int, bb, (bb.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssbtrd for the type c_float.

Original Fortran LAPACK purpose documentation for SSBTRD::

 SSBTRD reduces a real symmetric band matrix A to symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

Original Fortran LAPACK argument documentation for SSBTRD::

 VECT is CHARACTER*1
  = 'N': do not form Q;
  = 'V': form Q;
  = 'U': update a matrix X, by forming X*Q.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals of the matrix A if UPLO = 'U',
  or the number of subdiagonals if UPLO = 'L'. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  On entry, the upper or lower triangle of the symmetric band
  matrix A, stored in the first KD+1 rows of the array. The
  j-th column of A is stored in the j-th column of the array AB
  as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
  On exit, the diagonal elements of AB are overwritten by the
  diagonal elements of the tridiagonal matrix T; if KD > 0, the
  elements on the first superdiagonal (if UPLO = 'U') or the
  first subdiagonal (if UPLO = 'L') are overwritten by the
  off-diagonal elements of T; the rest of AB is overwritten by
  values generated during the reduction.

 D is REAL array, dimension (N)
  The diagonal elements of the tridiagonal matrix T.

 E is REAL array, dimension (N-1)
  The off-diagonal elements of the tridiagonal matrix T:
  E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.

 Q is REAL array, dimension (LDQ,N)
  On entry, if VECT = 'U', then Q must contain an N-by-N
  matrix X; if VECT = 'N' or 'V', then Q need not be set.
 
  On exit:
  if VECT = 'V', Q contains the N-by-N orthogonal matrix Q;
  if VECT = 'U', Q contains the product X*Q;
  if VECT = 'N', the array Q is not referenced.

 */
inline proc sbtrd(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] c_float, d : [] c_float, e : [] c_float, q : [] c_float): c_int{
  return LAPACKE_ssbtrd(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, d, e, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsbtrd for the type c_double.

For more information, see the documentation for :proc:`sbtrd`, or consult the Netlibs or Intel documentation.
 */
inline proc sbtrd(matrix_order : lapack_memory_order, vect : string, uplo : string, n : c_int, kd : c_int, ab : [] c_double, d : [] c_double, e : [] c_double, q : [] c_double): c_int{
  return LAPACKE_dsbtrd(matrix_order, ascii(vect) : c_char, ascii(uplo) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, d, e, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssfrk for the type c_float.

Original Fortran LAPACK purpose documentation for SSFRK::

 Level 3 BLAS like routine for C in RFP Format.

 SSFRK performs one of the symmetric rank--k operations

 C := alpha*A*A**T + beta*C,

 or

 C := alpha*A**T*A + beta*C,

 where alpha and beta are real scalars, C is an n--by--n symmetric
 matrix and A is an n--by--k matrix in the first case and a k--by--n
 matrix in the second case.

Original Fortran LAPACK argument documentation for SSFRK::

 TRANSR is CHARACTER*1
  = 'N': The Normal Form of RFP A is stored;
  = 'T': The Transpose Form of RFP A is stored.

 UPLO is CHARACTER*1
  On entry, UPLO specifies whether the upper or lower
  triangular part of the array C is to be referenced as
  follows:
 
  UPLO = 'U' or 'u' Only the upper triangular part of C
  is to be referenced.
 
  UPLO = 'L' or 'l' Only the lower triangular part of C
  is to be referenced.
 
  Unchanged on exit.

 TRANS is CHARACTER*1
  On entry, TRANS specifies the operation to be performed as
  follows:
 
  TRANS = 'N' or 'n' C := alpha*A*A**T + beta*C.
 
  TRANS = 'T' or 't' C := alpha*A**T*A + beta*C.
 
  Unchanged on exit.

 ALPHA is REAL
  On entry, ALPHA specifies the scalar alpha.
  Unchanged on exit.

 A is REAL array of DIMENSION (LDA,ka)
  where KA
  is K when TRANS = 'N' or 'n', and is N otherwise. Before
  entry with TRANS = 'N' or 'n', the leading N--by--K part of
  the array A must contain the matrix A, otherwise the leading
  K--by--N part of the array A must contain the matrix A.
  Unchanged on exit.

 BETA is REAL
  On entry, BETA specifies the scalar beta.
  Unchanged on exit.

 C is REAL array, dimension (NT)
  NT = N*(N+1)/2. On entry, the symmetric matrix C in RFP
  Format. RFP Format is described by TRANSR, UPLO and N.

 */
inline proc sfrk(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, alpha : c_float, a : [] c_float, beta : c_float, c : [] c_float): c_int{
  return LAPACKE_ssfrk(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (c.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, alpha, a, (a.domain.dim(2).size) : c_int, beta, c);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsfrk for the type c_double.

For more information, see the documentation for :proc:`sfrk`, or consult the Netlibs or Intel documentation.
 */
inline proc sfrk(matrix_order : lapack_memory_order, transr : string, uplo : string, trans : string, alpha : c_double, a : [] c_double, beta : c_double, c : [] c_double): c_int{
  return LAPACKE_dsfrk(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (c.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, alpha, a, (a.domain.dim(2).size) : c_int, beta, c);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspcon for the type c_float.

Original Fortran LAPACK purpose documentation for SSPCON::

 SSPCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric packed matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by SSPTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

Original Fortran LAPACK argument documentation for SSPCON::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by SSPTRF, stored as a
  packed triangular matrix.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSPTRF.

 ANORM is REAL
  The 1-norm of the original matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
  estimate of the 1-norm of inv(A) computed in this routine.

 */
inline proc spcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_sspcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspcon for the type c_double.

For more information, see the documentation for :proc:`spcon`, or consult the Netlibs or Intel documentation.
 */
inline proc spcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_dspcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cspcon for the type lapack_complex_float.

For more information, see the documentation for :proc:`spcon`, or consult the Netlibs or Intel documentation.
 */
inline proc spcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_cspcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zspcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`spcon`, or consult the Netlibs or Intel documentation.
 */
inline proc spcon(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zspcon(matrix_order, ascii(uplo) : c_char, n, ap, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspev for the type c_float.

Original Fortran LAPACK purpose documentation for SSPEV::

 SSPEV computes all the eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A in packed storage.

Original Fortran LAPACK argument documentation for SSPEV::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, AP is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the diagonal
  and first superdiagonal of the tridiagonal matrix T overwrite
  the corresponding elements of A, and if UPLO = 'L', the
  diagonal and first subdiagonal of T overwrite the
  corresponding elements of A.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc spev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float): c_int{
  return LAPACKE_sspev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspev for the type c_double.

For more information, see the documentation for :proc:`spev`, or consult the Netlibs or Intel documentation.
 */
inline proc spev(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dspev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspevd for the type c_float.

Original Fortran LAPACK purpose documentation for SSPEVD::

 SSPEVD computes all the eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. If eigenvectors are
 desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for SSPEVD::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, AP is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the diagonal
  and first superdiagonal of the tridiagonal matrix T overwrite
  the corresponding elements of A, and if UPLO = 'L', the
  diagonal and first subdiagonal of T overwrite the
  corresponding elements of A.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc spevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_float, w : [] c_float, z : [] c_float): c_int{
  return LAPACKE_sspevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspevd for the type c_double.

For more information, see the documentation for :proc:`spevd`, or consult the Netlibs or Intel documentation.
 */
inline proc spevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, n : c_int, ap : [] c_double, w : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dspevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspevx for the type c_float.

Original Fortran LAPACK purpose documentation for SSPEVX::

 SSPEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A in packed storage. Eigenvalues/vectors
 can be selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for SSPEVX::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found;
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found;
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, AP is overwritten by values generated during the
  reduction to tridiagonal form. If UPLO = 'U', the diagonal
  and first superdiagonal of the tridiagonal matrix T overwrite
  the corresponding elements of A, and if UPLO = 'L', the
  diagonal and first subdiagonal of T overwrite the
  corresponding elements of A.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing AP to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  If INFO = 0, the selected eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, max(1,M))
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and the
  index of the eigenvector is returned in IFAIL.
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc spevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ifail : [] c_int): c_int{
  return LAPACKE_sspevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspevx for the type c_double.

For more information, see the documentation for :proc:`spevx`, or consult the Netlibs or Intel documentation.
 */
inline proc spevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ifail : [] c_int): c_int{
  return LAPACKE_dspevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspgst for the type c_float.

Original Fortran LAPACK purpose documentation for SSPGST::

 SSPGST reduces a real symmetric-definite generalized eigenproblem
 to standard form, using packed storage.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by SPPTRF.

Original Fortran LAPACK argument documentation for SSPGST::

 ITYPE is INTEGER
  = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T);
  = 2 or 3: compute U*A*U**T or L**T*A*L.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored and B is factored as
  U**T*U;
  = 'L': Lower triangle of A is stored and B is factored as
  L*L**T.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, if INFO = 0, the transformed matrix, stored in the
  same format as A.

 BP is REAL array, dimension (N*(N+1)/2)
  The triangular factor from the Cholesky factorization of B,
  stored in the same format as A, as returned by SPPTRF.

 */
inline proc spgst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float): c_int{
  return LAPACKE_sspgst(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspgst for the type c_double.

For more information, see the documentation for :proc:`spgst`, or consult the Netlibs or Intel documentation.
 */
inline proc spgst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double): c_int{
  return LAPACKE_dspgst(matrix_order, itype, ascii(uplo) : c_char, n, ap, bp);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspgv for the type c_float.

Original Fortran LAPACK purpose documentation for SSPGV::

 SSPGV computes all the eigenvalues and, optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric, stored in packed format,
 and B is also positive definite.

Original Fortran LAPACK argument documentation for SSPGV::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 AP is REAL array, dimension
  (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, the contents of AP are destroyed.

 BP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  B, packed columnwise in a linear array. The j-th column of B
  is stored in the array BP as follows:
  if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
  if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
 
  On exit, the triangular factor U or L from the Cholesky
  factorization B = U**T*U or B = L*L**T, in the same storage
  format as B.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors. The eigenvectors are normalized as follows:
  if ITYPE = 1 or 2, Z**T*B*Z = I;
  if ITYPE = 3, Z**T*inv(B)*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc spgv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float): c_int{
  return LAPACKE_sspgv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspgv for the type c_double.

For more information, see the documentation for :proc:`spgv`, or consult the Netlibs or Intel documentation.
 */
inline proc spgv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dspgv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspgvd for the type c_float.

Original Fortran LAPACK purpose documentation for SSPGVD::

 SSPGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric, stored in packed format, and B is also
 positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for SSPGVD::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 N is INTEGER
  The order of the matrices A and B. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, the contents of AP are destroyed.

 BP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  B, packed columnwise in a linear array. The j-th column of B
  is stored in the array BP as follows:
  if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
  if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
 
  On exit, the triangular factor U or L from the Cholesky
  factorization B = U**T*U or B = L*L**T, in the same storage
  format as B.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
  eigenvectors. The eigenvectors are normalized as follows:
  if ITYPE = 1 or 2, Z**T*B*Z = I;
  if ITYPE = 3, Z**T*inv(B)*Z = I.
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc spgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float, w : [] c_float, z : [] c_float): c_int{
  return LAPACKE_sspgvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspgvd for the type c_double.

For more information, see the documentation for :proc:`spgvd`, or consult the Netlibs or Intel documentation.
 */
inline proc spgvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double, w : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dspgvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, n, ap, bp, w, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspgvx for the type c_float.

Original Fortran LAPACK purpose documentation for SSPGVX::

 SSPGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric, stored in packed storage, and B
 is also positive definite. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

Original Fortran LAPACK argument documentation for SSPGVX::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A and B are stored;
  = 'L': Lower triangle of A and B are stored.

 N is INTEGER
  The order of the matrix pencil (A,B). N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, the contents of AP are destroyed.

 BP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  B, packed columnwise in a linear array. The j-th column of B
  is stored in the array BP as follows:
  if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
  if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
 
  On exit, the triangular factor U or L from the Cholesky
  factorization B = U**T*U or B = L*L**T, in the same storage
  format as B.

 VL is REAL

 VU is REAL
 
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
 
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing A to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  On normal exit, the first M elements contain the selected
  eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, max(1,M))
  If JOBZ = 'N', then Z is not referenced.
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  The eigenvectors are normalized as follows:
  if ITYPE = 1 or 2, Z**T*B*Z = I;
  if ITYPE = 3, Z**T*inv(B)*Z = I.
 
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and the
  index of the eigenvector is returned in IFAIL.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc spgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_float, bp : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ifail : [] c_int): c_int{
  return LAPACKE_sspgvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspgvx for the type c_double.

For more information, see the documentation for :proc:`spgvx`, or consult the Netlibs or Intel documentation.
 */
inline proc spgvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, ap : [] c_double, bp : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ifail : [] c_int): c_int{
  return LAPACKE_dspgvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssprfs for the type c_float.

Original Fortran LAPACK purpose documentation for SSPRFS::

 SSPRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite
 and packed, and provides error bounds and backward error estimates
 for the solution.

Original Fortran LAPACK argument documentation for SSPRFS::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The upper or lower triangle of the symmetric matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.

 AFP is REAL array, dimension (N*(N+1)/2)
  The factored form of the matrix A. AFP contains the block
  diagonal matrix D and the multipliers used to obtain the
  factor U or L from the factorization A = U*D*U**T or
  A = L*D*L**T as computed by SSPTRF, stored as a packed
  triangular matrix.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSPTRF.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SSPTRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc sprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_ssprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsprfs for the type c_double.

For more information, see the documentation for :proc:`sprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc sprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dsprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csprfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`sprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc sprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_csprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsprfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`sprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc sprfs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zsprfs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspsv for the type c_float.

Original Fortran LAPACK purpose documentation for SSPSV::

 SSPSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix stored in packed format and X
 and B are N-by-NRHS matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, D is symmetric and block diagonal with 1-by-1
 and 2-by-2 diagonal blocks. The factored form of A is then used to
 solve the system of equations A * X = B.

Original Fortran LAPACK argument documentation for SSPSV::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
  See below for further details.
 
  On exit, the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
  a packed triangular matrix in the same storage format as A.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D, as
  determined by SSPTRF. If IPIV(k) > 0, then rows and columns
  k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
  diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
  then rows and columns k-1 and -IPIV(k) were interchanged and
  D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and
  IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
  -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
  diagonal block.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc spsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_sspsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspsv for the type c_double.

For more information, see the documentation for :proc:`spsv`, or consult the Netlibs or Intel documentation.
 */
inline proc spsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dspsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cspsv for the type lapack_complex_float.

For more information, see the documentation for :proc:`spsv`, or consult the Netlibs or Intel documentation.
 */
inline proc spsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_cspsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zspsv for the type lapack_complex_double.

For more information, see the documentation for :proc:`spsv`, or consult the Netlibs or Intel documentation.
 */
inline proc spsv(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zspsv(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sspsvx for the type c_float.

Original Fortran LAPACK purpose documentation for SSPSVX::

 SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a real system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for SSPSVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of A has been
  supplied on entry.
  = 'F': On entry, AFP and IPIV contain the factored form of
  A. AP, AFP and IPIV will not be modified.
  = 'N': The matrix A will be copied to AFP and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The number of linear equations, i.e., the order of the
  matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The upper or lower triangle of the symmetric matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
  See below for further details.

 AFP is REAL array, dimension
  (N*(N+1)/2)
  If FACT = 'F', then AFP is an input argument and on entry
  contains the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
  a packed triangular matrix in the same storage format as A.
 
  If FACT = 'N', then AFP is an output argument and on exit
  contains the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
  a packed triangular matrix in the same storage format as A.

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains details of the interchanges and the block structure
  of D, as determined by SSPTRF.
  If IPIV(k) > 0, then rows and columns k and IPIV(k) were
  interchanged and D(k,k) is a 1-by-1 diagonal block.
  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
  columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
  is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) =
  IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
  interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains details of the interchanges and the block structure
  of D, as determined by SSPTRF.

 B is REAL array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A. If RCOND is less than the machine precision (in
  particular, if RCOND = 0), the matrix is singular to working
  precision. This condition is indicated by a return code of
  INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc spsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] c_float, afp : [] c_float, ipiv : [] c_int, b : [] c_float, x : [] c_float, ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_sspsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dspsvx for the type c_double.

For more information, see the documentation for :proc:`spsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc spsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] c_double, afp : [] c_double, ipiv : [] c_int, b : [] c_double, x : [] c_double, ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dspsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cspsvx for the type lapack_complex_float.

For more information, see the documentation for :proc:`spsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc spsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] complex(64), afp : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_cspsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zspsvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`spsvx`, or consult the Netlibs or Intel documentation.
 */
inline proc spsvx(matrix_order : lapack_memory_order, fact : string, uplo : string, n : c_int, ap : [] complex(128), afp : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zspsvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, afp, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssptrd for the type c_float.

Original Fortran LAPACK purpose documentation for SSPTRD::

 SSPTRD reduces a real symmetric matrix A stored in packed form to
 symmetric tridiagonal form T by an orthogonal similarity
 transformation: Q**T * A * Q = T.

Original Fortran LAPACK argument documentation for SSPTRD::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
  On exit, if UPLO = 'U', the diagonal and first superdiagonal
  of A are overwritten by the corresponding elements of the
  tridiagonal matrix T, and the elements above the first
  superdiagonal, with the array TAU, represent the orthogonal
  matrix Q as a product of elementary reflectors; if UPLO
  = 'L', the diagonal and first subdiagonal of A are over-
  written by the corresponding elements of the tridiagonal
  matrix T, and the elements below the first subdiagonal, with
  the array TAU, represent the orthogonal matrix Q as a product
  of elementary reflectors. See Further Details.

 D is REAL array, dimension (N)
  The diagonal elements of the tridiagonal matrix T:
  D(i) = A(i,i).

 E is REAL array, dimension (N-1)
  The off-diagonal elements of the tridiagonal matrix T:
  E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.

 TAU is REAL array, dimension (N-1)
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc sptrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, d : [] c_float, e : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_ssptrd(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsptrd for the type c_double.

For more information, see the documentation for :proc:`sptrd`, or consult the Netlibs or Intel documentation.
 */
inline proc sptrd(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, d : [] c_double, e : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dsptrd(matrix_order, ascii(uplo) : c_char, n, ap, d, e, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssptrf for the type c_float.

Original Fortran LAPACK purpose documentation for SSPTRF::

 SSPTRF computes the factorization of a real symmetric matrix A stored
 in packed format using the Bunch-Kaufman diagonal pivoting method:

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

Original Fortran LAPACK argument documentation for SSPTRF::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangle of the symmetric matrix
  A, packed columnwise in a linear array. The j-th column of A
  is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
 
  On exit, the block diagonal matrix D and the multipliers used
  to obtain the factor U or L, stored as a packed triangular
  matrix overwriting A (see below for further details).

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D.
  If IPIV(k) > 0, then rows and columns k and IPIV(k) were
  interchanged and D(k,k) is a 1-by-1 diagonal block.
  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
  columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
  is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) =
  IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
  interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

 */
inline proc sptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_ssptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsptrf for the type c_double.

For more information, see the documentation for :proc:`sptrf`, or consult the Netlibs or Intel documentation.
 */
inline proc sptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dsptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csptrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`sptrf`, or consult the Netlibs or Intel documentation.
 */
inline proc sptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_csptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsptrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`sptrf`, or consult the Netlibs or Intel documentation.
 */
inline proc sptrf(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zsptrf(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssptri for the type c_float.

Original Fortran LAPACK purpose documentation for SSPTRI::

 SSPTRI computes the inverse of a real symmetric indefinite matrix
 A in packed storage using the factorization A = U*D*U**T or
 A = L*D*L**T computed by SSPTRF.

Original Fortran LAPACK argument documentation for SSPTRI::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the block diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by SSPTRF,
  stored as a packed triangular matrix.
 
  On exit, if INFO = 0, the (symmetric) inverse of the original
  matrix, stored as a packed triangular matrix. The j-th column
  of inv(A) is stored in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;
  if UPLO = 'L',
  AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSPTRF.

 */
inline proc sptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_ssptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsptri for the type c_double.

For more information, see the documentation for :proc:`sptri`, or consult the Netlibs or Intel documentation.
 */
inline proc sptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dsptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csptri for the type lapack_complex_float.

For more information, see the documentation for :proc:`sptri`, or consult the Netlibs or Intel documentation.
 */
inline proc sptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_csptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsptri for the type lapack_complex_double.

For more information, see the documentation for :proc:`sptri`, or consult the Netlibs or Intel documentation.
 */
inline proc sptri(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zsptri(matrix_order, ascii(uplo) : c_char, n, ap, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssptrs for the type c_float.

Original Fortran LAPACK purpose documentation for SSPTRS::

 SSPTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A stored in packed format using the factorization
 A = U*D*U**T or A = L*D*L**T computed by SSPTRF.

Original Fortran LAPACK argument documentation for SSPTRS::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by SSPTRF, stored as a
  packed triangular matrix.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSPTRF.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc sptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_ssptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsptrs for the type c_double.

For more information, see the documentation for :proc:`sptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc sptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dsptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csptrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`sptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc sptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_csptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsptrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`sptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc sptrs(matrix_order : lapack_memory_order, uplo : string, n : c_int, ap : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zsptrs(matrix_order, ascii(uplo) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sstebz for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEBZ::

 SSTEBZ computes the eigenvalues of a symmetric tridiagonal
 matrix T. The user may ask for all eigenvalues, all eigenvalues
 in the half-open interval (VL, VU], or the IL-th through IU-th
 eigenvalues.

 To avoid overflow, the matrix must be scaled so that its
 largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
 accuracy, it should not be much smaller than that.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966.

Original Fortran LAPACK argument documentation for SSTEBZ::

 RANGE is CHARACTER*1
  = 'A': ("All") all eigenvalues will be found.
  = 'V': ("Value") all eigenvalues in the half-open interval
  (VL, VU] will be found.
  = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
  entire matrix) will be found.

 ORDER is CHARACTER*1
  = 'B': ("By Block") the eigenvalues will be grouped by
  split-off block (see IBLOCK, ISPLIT) and
  ordered from smallest to largest within
  the block.
  = 'E': ("Entire matrix")
  the eigenvalues for the entire matrix
  will be ordered from smallest to
  largest.

 N is INTEGER
  The order of the tridiagonal matrix T. N >= 0.

 VL is REAL

 VU is REAL
 
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. Eigenvalues less than or equal
  to VL, or greater than VU, will not be returned. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
 
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute tolerance for the eigenvalues. An eigenvalue
  (or cluster) is considered to be located if it has been
  determined to lie in an interval whose width is ABSTOL or
  less. If ABSTOL is less than or equal to zero, then ULP*|T|
  will be used, where |T| means the 1-norm of T.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.

 D is REAL array, dimension (N)
  The n diagonal elements of the tridiagonal matrix T.

 E is REAL array, dimension (N-1)
  The (n-1) off-diagonal elements of the tridiagonal matrix T.

 M is INTEGER
  The actual number of eigenvalues found. 0 <= M <= N.
  (See also the description of INFO=2,3.)

 NSPLIT is INTEGER
  The number of diagonal blocks in the matrix T.
  1 <= NSPLIT <= N.

 W is REAL array, dimension (N)
  On exit, the first M elements of W will contain the
  eigenvalues. (SSTEBZ may use the remaining N-M elements as
  workspace.)

 IBLOCK is INTEGER array, dimension (N)
  At each row/column j where E(j) is zero or small, the
  matrix T is considered to split into a block diagonal
  matrix. On exit, if INFO = 0, IBLOCK(i) specifies to which
  block (from 1 to the number of blocks) the eigenvalue W(i)
  belongs. (SSTEBZ may use the remaining N-M elements as
  workspace.)

 ISPLIT is INTEGER array, dimension (N)
  The splitting points, at which T breaks up into submatrices.
  The first submatrix consists of rows/columns 1 to ISPLIT(1),
  the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
  etc., and the NSPLIT-th consists of rows/columns
  ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
  (Only the first NSPLIT elements will actually be used, but
  since the user cannot know a priori what value NSPLIT will
  have, N words must be reserved for ISPLIT.)

 */
inline proc stebz(range : string, order : string, n : c_int, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, d : [] c_float, e : [] c_float, ref m : c_int, ref nsplit : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int): c_int{
  return LAPACKE_sstebz(ascii(range) : c_char, ascii(order) : c_char, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dstebz for the type c_double.

For more information, see the documentation for :proc:`stebz`, or consult the Netlibs or Intel documentation.
 */
inline proc stebz(range : string, order : string, n : c_int, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, d : [] c_double, e : [] c_double, ref m : c_int, ref nsplit : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int): c_int{
  return LAPACKE_dstebz(ascii(range) : c_char, ascii(order) : c_char, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sstedc for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEDC::

 SSTEDC computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the divide and conquer method.
 The eigenvectors of a full or band real symmetric matrix can also be
 found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this
 matrix to tridiagonal form.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none. See SLAED3 for details.

Original Fortran LAPACK argument documentation for SSTEDC::

 COMPZ is CHARACTER*1
  = 'N': Compute eigenvalues only.
  = 'I': Compute eigenvectors of tridiagonal matrix also.
  = 'V': Compute eigenvectors of original dense symmetric
  matrix also. On entry, Z contains the orthogonal
  matrix used to reduce the original matrix to
  tridiagonal form.

 N is INTEGER
  The dimension of the symmetric tridiagonal matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the diagonal elements of the tridiagonal matrix.
  On exit, if INFO = 0, the eigenvalues in ascending order.

 E is REAL array, dimension (N-1)
  On entry, the subdiagonal elements of the tridiagonal matrix.
  On exit, E has been destroyed.

 Z is REAL array, dimension (LDZ,N)
  On entry, if COMPZ = 'V', then Z contains the orthogonal
  matrix used in the reduction to tridiagonal form.
  On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
  orthonormal eigenvectors of the original symmetric matrix,
  and if COMPZ = 'I', Z contains the orthonormal eigenvectors
  of the symmetric tridiagonal matrix.
  If COMPZ = 'N', then Z is not referenced.

 */
inline proc stedc(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float): c_int{
  return LAPACKE_sstedc(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dstedc for the type c_double.

For more information, see the documentation for :proc:`stedc`, or consult the Netlibs or Intel documentation.
 */
inline proc stedc(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dstedc(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cstedc for the type lapack_complex_float.

For more information, see the documentation for :proc:`stedc`, or consult the Netlibs or Intel documentation.
 */
inline proc stedc(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_cstedc(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zstedc for the type lapack_complex_double.

For more information, see the documentation for :proc:`stedc`, or consult the Netlibs or Intel documentation.
 */
inline proc stedc(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zstedc(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sstegr for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEGR::

 SSTEGR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 SSTEGR is a compatability wrapper around the improved SSTEMR routine.
 See SSTEMR for further details.

 One important change is that the ABSTOL parameter no longer provides any
 benefit and hence is no longer used.

 Note : SSTEGR and SSTEMR work only on machines which follow
 IEEE-754 floating-point standard in their handling of infinities and
 NaNs. Normal execution may create these exceptiona values and hence
 may abort due to a floating point exception in environments which
 do not conform to the IEEE-754 standard.

Original Fortran LAPACK argument documentation for SSTEGR::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the N diagonal elements of the tridiagonal matrix
  T. On exit, D is overwritten.

 E is REAL array, dimension (N)
  On entry, the (N-1) subdiagonal elements of the tridiagonal
  matrix T in elements 1 to N-1 of E. E(N) need not be set on
  input, but is used internally as workspace.
  On exit, E is overwritten.

 VL is REAL

 VU is REAL
 
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
 
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  Unused. Was the absolute error tolerance for the
  eigenvalues/eigenvectors in previous versions.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  The first M elements contain the selected eigenvalues in
  ascending order.

 Z is REAL array, dimension (LDZ, max(1,M) )
  If JOBZ = 'V', and if INFO = 0, then the first M columns of Z
  contain the orthonormal eigenvectors of the matrix T
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.
  Supplying N columns is always safe.

 ISUPPZ is INTEGER ARRAY, dimension ( 2*max(1,M) )
  The support of the eigenvectors in Z, i.e., the indices
  indicating the nonzero elements in Z. The i-th computed eigenvector
  is nonzero only in elements ISUPPZ( 2*i-1 ) through
  ISUPPZ( 2*i ). This is relevant in the case when the matrix
  is split. ISUPPZ is only accessed when JOBZ is 'V' and N > 0.

 */
inline proc stegr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, isuppz : [] c_int): c_int{
  return LAPACKE_sstegr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dstegr for the type c_double.

For more information, see the documentation for :proc:`stegr`, or consult the Netlibs or Intel documentation.
 */
inline proc stegr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, isuppz : [] c_int): c_int{
  return LAPACKE_dstegr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cstegr for the type lapack_complex_float.

For more information, see the documentation for :proc:`stegr`, or consult the Netlibs or Intel documentation.
 */
inline proc stegr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] complex(64), isuppz : [] c_int): c_int{
  return LAPACKE_cstegr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zstegr for the type lapack_complex_double.

For more information, see the documentation for :proc:`stegr`, or consult the Netlibs or Intel documentation.
 */
inline proc stegr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] complex(128), isuppz : [] c_int): c_int{
  return LAPACKE_zstegr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sstein for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEIN::

 SSTEIN computes the eigenvectors of a real symmetric tridiagonal
 matrix T corresponding to specified eigenvalues, using inverse
 iteration.

 The maximum number of iterations allowed for each eigenvector is
 specified by an internal parameter MAXITS (currently set to 5).

Original Fortran LAPACK argument documentation for SSTEIN::

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  The n diagonal elements of the tridiagonal matrix T.

 E is REAL array, dimension (N-1)
  The (n-1) subdiagonal elements of the tridiagonal matrix
  T, in elements 1 to N-1.

 M is INTEGER
  The number of eigenvectors to be found. 0 <= M <= N.

 W is REAL array, dimension (N)
  The first M elements of W contain the eigenvalues for
  which eigenvectors are to be computed. The eigenvalues
  should be grouped by split-off block and ordered from
  smallest to largest within the block. ( The output array
  W from SSTEBZ with ORDER = 'B' is expected here. )

 IBLOCK is INTEGER array, dimension (N)
  The submatrix indices associated with the corresponding
  eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
  the first submatrix from the top, =2 if W(i) belongs to
  the second submatrix, etc. ( The output array IBLOCK
  from SSTEBZ is expected here. )

 ISPLIT is INTEGER array, dimension (N)
  The splitting points, at which T breaks up into submatrices.
  The first submatrix consists of rows/columns 1 to
  ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
  through ISPLIT( 2 ), etc.
  ( The output array ISPLIT from SSTEBZ is expected here. )

 Z is REAL array, dimension (LDZ, M)
  The computed eigenvectors. The eigenvector associated
  with the eigenvalue W(i) is stored in the i-th column of
  Z. Any vector which fails to converge is set to its current
  iterate after MAXITS iterations.

 */
inline proc stein(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] c_float, m : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, z : [] c_float, ifailv : [] c_int): c_int{
  return LAPACKE_sstein(matrix_order, n, d, e, m, w, iblock, isplit, z, (z.domain.dim(2).size) : c_int, ifailv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dstein for the type c_double.

For more information, see the documentation for :proc:`stein`, or consult the Netlibs or Intel documentation.
 */
inline proc stein(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] c_double, m : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, z : [] c_double, ifailv : [] c_int): c_int{
  return LAPACKE_dstein(matrix_order, n, d, e, m, w, iblock, isplit, z, (z.domain.dim(2).size) : c_int, ifailv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cstein for the type lapack_complex_float.

For more information, see the documentation for :proc:`stein`, or consult the Netlibs or Intel documentation.
 */
inline proc stein(matrix_order : lapack_memory_order, n : c_int, d : [] c_float, e : [] c_float, m : c_int, w : [] c_float, iblock : [] c_int, isplit : [] c_int, z : [] complex(64), ifailv : [] c_int): c_int{
  return LAPACKE_cstein(matrix_order, n, d, e, m, w, iblock, isplit, z, (z.domain.dim(2).size) : c_int, ifailv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zstein for the type lapack_complex_double.

For more information, see the documentation for :proc:`stein`, or consult the Netlibs or Intel documentation.
 */
inline proc stein(matrix_order : lapack_memory_order, n : c_int, d : [] c_double, e : [] c_double, m : c_int, w : [] c_double, iblock : [] c_int, isplit : [] c_int, z : [] complex(128), ifailv : [] c_int): c_int{
  return LAPACKE_zstein(matrix_order, n, d, e, m, w, iblock, isplit, z, (z.domain.dim(2).size) : c_int, ifailv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sstemr for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEMR::

 SSTEMR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
 a well defined set of pairwise different real eigenvalues, the corresponding
 real eigenvectors are pairwise orthogonal.

 The spectrum may be computed either completely or partially by specifying
 either an interval (VL,VU] or a range of indices IL:IU for the desired
 eigenvalues.

 Depending on the number of desired eigenvalues, these are computed either
 by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
 computed by the use of various suitable L D L^T factorizations near clusters
 of close eigenvalues (referred to as RRRs, Relatively Robust
 Representations). An informal sketch of the algorithm follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 For more details, see:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.

 Further Details
 1.SSTEMR works only on machines which follow IEEE-754
 floating-point standard in their handling of infinities and NaNs.
 This permits the use of efficient inner loops avoiding a check for
 zero divisors.

Original Fortran LAPACK argument documentation for SSTEMR::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the N diagonal elements of the tridiagonal matrix
  T. On exit, D is overwritten.

 E is REAL array, dimension (N)
  On entry, the (N-1) subdiagonal elements of the tridiagonal
  matrix T in elements 1 to N-1 of E. E(N) need not be set on
  input, but is used internally as workspace.
  On exit, E is overwritten.

 VL is REAL

 VU is REAL
 
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
 
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0.
  Not referenced if RANGE = 'A' or 'V'.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  The first M elements contain the selected eigenvalues in
  ascending order.

 Z is REAL array, dimension (LDZ, max(1,M) )
  If JOBZ = 'V', and if INFO = 0, then the first M columns of Z
  contain the orthonormal eigenvectors of the matrix T
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and can be computed with a workspace
  query by setting NZC = -1, see below.

 NZC is INTEGER
  The number of eigenvectors to be held in the array Z.
  If RANGE = 'A', then NZC >= max(1,N).
  If RANGE = 'V', then NZC >= the number of eigenvalues in (VL,VU].
  If RANGE = 'I', then NZC >= IU-IL+1.
  If NZC = -1, then a workspace query is assumed; the
  routine calculates the number of columns of the array Z that
  are needed to hold the eigenvectors.
  This value is returned as the first entry of the Z array, and
  no error message related to NZC is issued by XERBLA.

 ISUPPZ is INTEGER ARRAY, dimension ( 2*max(1,M) )
  The support of the eigenvectors in Z, i.e., the indices
  indicating the nonzero elements in Z. The i-th computed eigenvector
  is nonzero only in elements ISUPPZ( 2*i-1 ) through
  ISUPPZ( 2*i ). This is relevant in the case when the matrix
  is split. ISUPPZ is only accessed when JOBZ is 'V' and N > 0.

 TRYRAC is LOGICAL
  If TRYRAC.EQ..TRUE., indicates that the code should check whether
  the tridiagonal matrix defines its eigenvalues to high relative
  accuracy. If so, the code uses relative-accuracy preserving
  algorithms that might be (a bit) slower depending on the matrix.
  If the matrix does not define its eigenvalues to high relative
  accuracy, the code can uses possibly faster algorithms.
  If TRYRAC.EQ..FALSE., the code is not required to guarantee
  relatively accurate eigenvalues and can use the fastest possible
  techniques.
  On exit, a .TRUE. TRYRAC will be set to .FALSE. if the matrix
  does not define its eigenvalues to high relative accuracy.

 */
inline proc stemr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] c_float, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int): c_int{
  return LAPACKE_sstemr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, (z.domain.dim(2).size) : c_int, nzc, isuppz, tryrac);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dstemr for the type c_double.

For more information, see the documentation for :proc:`stemr`, or consult the Netlibs or Intel documentation.
 */
inline proc stemr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] c_double, nzc : c_int, isuppz : [] c_int, ref tryrac : c_int): c_int{
  return LAPACKE_dstemr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, (z.domain.dim(2).size) : c_int, nzc, isuppz, tryrac);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cstemr for the type lapack_complex_float.

For more information, see the documentation for :proc:`stemr`, or consult the Netlibs or Intel documentation.
 */
inline proc stemr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, ref m : c_int, w : [] c_float, z : [] complex(64), nzc : c_int, isuppz : [] c_int, ref tryrac : c_int): c_int{
  return LAPACKE_cstemr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, (z.domain.dim(2).size) : c_int, nzc, isuppz, tryrac);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zstemr for the type lapack_complex_double.

For more information, see the documentation for :proc:`stemr`, or consult the Netlibs or Intel documentation.
 */
inline proc stemr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, ref m : c_int, w : [] c_double, z : [] complex(128), nzc : c_int, isuppz : [] c_int, ref tryrac : c_int): c_int{
  return LAPACKE_zstemr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, m, w, z, (z.domain.dim(2).size) : c_int, nzc, isuppz, tryrac);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssteqr for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEQR::

 SSTEQR computes all eigenvalues and, optionally, eigenvectors of a
 symmetric tridiagonal matrix using the implicit QL or QR method.
 The eigenvectors of a full or band symmetric matrix can also be found
 if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to
 tridiagonal form.

Original Fortran LAPACK argument documentation for SSTEQR::

 COMPZ is CHARACTER*1
  = 'N': Compute eigenvalues only.
  = 'V': Compute eigenvalues and eigenvectors of the original
  symmetric matrix. On entry, Z must contain the
  orthogonal matrix used to reduce the original matrix
  to tridiagonal form.
  = 'I': Compute eigenvalues and eigenvectors of the
  tridiagonal matrix. Z is initialized to the identity
  matrix.

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the diagonal elements of the tridiagonal matrix.
  On exit, if INFO = 0, the eigenvalues in ascending order.

 E is REAL array, dimension (N-1)
  On entry, the (n-1) subdiagonal elements of the tridiagonal
  matrix.
  On exit, E has been destroyed.

 Z is REAL array, dimension (LDZ, N)
  On entry, if COMPZ = 'V', then Z contains the orthogonal
  matrix used in the reduction to tridiagonal form.
  On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
  orthonormal eigenvectors of the original symmetric matrix,
  and if COMPZ = 'I', Z contains the orthonormal eigenvectors
  of the symmetric tridiagonal matrix.
  If COMPZ = 'N', then Z is not referenced.

 */
inline proc steqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float): c_int{
  return LAPACKE_ssteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsteqr for the type c_double.

For more information, see the documentation for :proc:`steqr`, or consult the Netlibs or Intel documentation.
 */
inline proc steqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dsteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csteqr for the type lapack_complex_float.

For more information, see the documentation for :proc:`steqr`, or consult the Netlibs or Intel documentation.
 */
inline proc steqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] complex(64)): c_int{
  return LAPACKE_csteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsteqr for the type lapack_complex_double.

For more information, see the documentation for :proc:`steqr`, or consult the Netlibs or Intel documentation.
 */
inline proc steqr(matrix_order : lapack_memory_order, compz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] complex(128)): c_int{
  return LAPACKE_zsteqr(matrix_order, ascii(compz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssterf for the type c_float.

Original Fortran LAPACK purpose documentation for SSTERF::

 SSTERF computes all eigenvalues of a symmetric tridiagonal matrix
 using the Pal-Walker-Kahan variant of the QL or QR algorithm.

Original Fortran LAPACK argument documentation for SSTERF::

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the tridiagonal matrix.
  On exit, if INFO = 0, the eigenvalues in ascending order.

 E is REAL array, dimension (N-1)
  On entry, the (n-1) subdiagonal elements of the tridiagonal
  matrix.
  On exit, E has been destroyed.

 */
inline proc sterf(n : c_int, d : [] c_float, e : [] c_float): c_int{
  return LAPACKE_ssterf(n, d, e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsterf for the type c_double.

For more information, see the documentation for :proc:`sterf`, or consult the Netlibs or Intel documentation.
 */
inline proc sterf(n : c_int, d : [] c_double, e : [] c_double): c_int{
  return LAPACKE_dsterf(n, d, e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sstev for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEV::

 SSTEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix A.

Original Fortran LAPACK argument documentation for SSTEV::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the tridiagonal matrix
  A.
  On exit, if INFO = 0, the eigenvalues in ascending order.

 E is REAL array, dimension (N-1)
  On entry, the (n-1) subdiagonal elements of the tridiagonal
  matrix A, stored in elements 1 to N-1 of E.
  On exit, the contents of E are destroyed.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with D(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc stev(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float): c_int{
  return LAPACKE_sstev(matrix_order, ascii(jobz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dstev for the type c_double.

For more information, see the documentation for :proc:`stev`, or consult the Netlibs or Intel documentation.
 */
inline proc stev(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dstev(matrix_order, ascii(jobz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sstevd for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEVD::

 SSTEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric tridiagonal matrix. If eigenvectors are desired, it
 uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for SSTEVD::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the tridiagonal matrix
  A.
  On exit, if INFO = 0, the eigenvalues in ascending order.

 E is REAL array, dimension (N-1)
  On entry, the (n-1) subdiagonal elements of the tridiagonal
  matrix A, stored in elements 1 to N-1 of E.
  On exit, the contents of E are destroyed.

 Z is REAL array, dimension (LDZ, N)
  If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
  eigenvectors of the matrix A, with the i-th column of Z
  holding the eigenvector associated with D(i).
  If JOBZ = 'N', then Z is not referenced.

 */
inline proc stevd(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_float, e : [] c_float, z : [] c_float): c_int{
  return LAPACKE_sstevd(matrix_order, ascii(jobz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dstevd for the type c_double.

For more information, see the documentation for :proc:`stevd`, or consult the Netlibs or Intel documentation.
 */
inline proc stevd(matrix_order : lapack_memory_order, jobz : string, n : c_int, d : [] c_double, e : [] c_double, z : [] c_double): c_int{
  return LAPACKE_dstevd(matrix_order, ascii(jobz) : c_char, n, d, e, z, (z.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sstevr for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEVR::

 SSTEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix T. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

 Whenever possible, SSTEVR calls SSTEMR to compute the
 eigenspectrum using Relatively Robust Representations. SSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows. For the i-th
 unreduced block of T,
 (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
 is a relatively robust representation,
 (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
 relative accuracy by the dqds algorithm,
 (c) If there is a cluster of close eigenvalues, "choose" sigma_i
 close to the cluster, and go to step (a),
 (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
 compute the corresponding eigenvector by forming a
 rank-revealing twisted factorization.
 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
 Computer Science Division Technical Report No. UCB//CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : SSTEVR calls SSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 SSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of SSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

Original Fortran LAPACK argument documentation for SSTEVR::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.
  For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and
  SSTEIN are called

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the tridiagonal matrix
  A.
  On exit, D may be multiplied by a constant factor chosen
  to avoid over/underflow in computing the eigenvalues.

 E is REAL array, dimension (max(1,N-1))
  On entry, the (n-1) subdiagonal elements of the tridiagonal
  matrix A in elements 1 to N-1 of E.
  On exit, E may be multiplied by a constant factor chosen
  to avoid over/underflow in computing the eigenvalues.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing A to tridiagonal form.
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.
 
  If high relative accuracy is important, set ABSTOL to
  SLAMCH( 'Safe minimum' ). Doing so will guarantee that
  eigenvalues are computed to high relative accuracy when
  possible in future releases. The current code does not
  make any guarantees about high relative accuracy, but
  future releases will. See J. Barlow and J. Demmel,
  "Computing Accurate Eigensystems of Scaled Diagonally
  Dominant Matrices", LAPACK Working Note #7, for a discussion
  of which matrices define their eigenvalues to high relative
  accuracy.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  The first M elements contain the selected eigenvalues in
  ascending order.

 Z is REAL array, dimension (LDZ, max(1,M) )
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
  The support of the eigenvectors in Z, i.e., the indices
  indicating the nonzero elements in Z. The i-th eigenvector
  is nonzero only in elements ISUPPZ( 2*i-1 ) through
  ISUPPZ( 2*i ).
  Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1

 */
inline proc stevr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, isuppz : [] c_int): c_int{
  return LAPACKE_sstevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dstevr for the type c_double.

For more information, see the documentation for :proc:`stevr`, or consult the Netlibs or Intel documentation.
 */
inline proc stevr(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, isuppz : [] c_int): c_int{
  return LAPACKE_dstevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sstevx for the type c_float.

Original Fortran LAPACK purpose documentation for SSTEVX::

 SSTEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric tridiagonal matrix A. Eigenvalues and
 eigenvectors can be selected by specifying either a range of values
 or a range of indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for SSTEVX::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.

 N is INTEGER
  The order of the matrix. N >= 0.

 D is REAL array, dimension (N)
  On entry, the n diagonal elements of the tridiagonal matrix
  A.
  On exit, D may be multiplied by a constant factor chosen
  to avoid over/underflow in computing the eigenvalues.

 E is REAL array, dimension (max(1,N-1))
  On entry, the (n-1) subdiagonal elements of the tridiagonal
  matrix A in elements 1 to N-1 of E.
  On exit, E may be multiplied by a constant factor chosen
  to avoid over/underflow in computing the eigenvalues.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less
  than or equal to zero, then EPS*|T| will be used in
  its place, where |T| is the 1-norm of the tridiagonal
  matrix.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  The first M elements contain the selected eigenvalues in
  ascending order.

 Z is REAL array, dimension (LDZ, max(1,M) )
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If an eigenvector fails to converge (INFO > 0), then that
  column of Z contains the latest approximation to the
  eigenvector, and the index of the eigenvector is returned
  in IFAIL. If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc stevx(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_float, e : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ifail : [] c_int): c_int{
  return LAPACKE_sstevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dstevx for the type c_double.

For more information, see the documentation for :proc:`stevx`, or consult the Netlibs or Intel documentation.
 */
inline proc stevx(matrix_order : lapack_memory_order, jobz : string, range : string, n : c_int, d : [] c_double, e : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ifail : [] c_int): c_int{
  return LAPACKE_dstevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, n, d, e, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssycon for the type c_float.

Original Fortran LAPACK purpose documentation for SSYCON::

 SSYCON estimates the reciprocal of the condition number (in the
 1-norm) of a real symmetric matrix A using the factorization
 A = U*D*U**T or A = L*D*L**T computed by SSYTRF.

 An estimate is obtained for norm(inv(A)), and the reciprocal of the
 condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

Original Fortran LAPACK argument documentation for SSYCON::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is REAL array, dimension (LDA,N)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by SSYTRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSYTRF.

 ANORM is REAL
  The 1-norm of the original matrix A.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
  estimate of the 1-norm of inv(A) computed in this routine.

 */
inline proc sycon(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_ssycon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsycon for the type c_double.

For more information, see the documentation for :proc:`sycon`, or consult the Netlibs or Intel documentation.
 */
inline proc sycon(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_dsycon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csycon for the type lapack_complex_float.

For more information, see the documentation for :proc:`sycon`, or consult the Netlibs or Intel documentation.
 */
inline proc sycon(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, anorm : c_float, ref rcond : c_float): c_int{
  return LAPACKE_csycon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsycon for the type lapack_complex_double.

For more information, see the documentation for :proc:`sycon`, or consult the Netlibs or Intel documentation.
 */
inline proc sycon(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, anorm : c_double, ref rcond : c_double): c_int{
  return LAPACKE_zsycon(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, anorm, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssyequb for the type c_float.

Original Fortran LAPACK purpose documentation for SSYEQUB::

 SSYEQUB computes row and column scalings intended to equilibrate a
 symmetric matrix A and reduce its condition number
 (with respect to the two-norm). S contains the scale factors,
 S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
 elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal. This
 choice of S puts the condition number of B within a factor N of the
 smallest possible condition number over all possible diagonal
 scalings.

Original Fortran LAPACK argument documentation for SSYEQUB::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is REAL array, dimension (LDA,N)
  The N-by-N symmetric matrix whose scaling
  factors are to be computed. Only the diagonal elements of A
  are referenced.

 S is REAL array, dimension (N)
  If INFO = 0, S contains the scale factors for A.

 SCOND is REAL
  If INFO = 0, S contains the ratio of the smallest S(i) to
  the largest S(i). If SCOND >= 0.1 and AMAX is neither too
  large nor too small, it is not worth scaling by S.

 AMAX is REAL
  Absolute value of largest matrix element. If AMAX is very
  close to overflow or very close to underflow, the matrix
  should be scaled.

 */
inline proc syequb(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_ssyequb(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsyequb for the type c_double.

For more information, see the documentation for :proc:`syequb`, or consult the Netlibs or Intel documentation.
 */
inline proc syequb(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_dsyequb(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csyequb for the type lapack_complex_float.

For more information, see the documentation for :proc:`syequb`, or consult the Netlibs or Intel documentation.
 */
inline proc syequb(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), s : [] c_float, ref scond : c_float, ref amax : c_float): c_int{
  return LAPACKE_csyequb(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsyequb for the type lapack_complex_double.

For more information, see the documentation for :proc:`syequb`, or consult the Netlibs or Intel documentation.
 */
inline proc syequb(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), s : [] c_double, ref scond : c_double, ref amax : c_double): c_int{
  return LAPACKE_zsyequb(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, s, scond, amax);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssyev for the type c_float.

Original Fortran LAPACK purpose documentation for SSYEV::

 SSYEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A.

Original Fortran LAPACK argument documentation for SSYEV::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA, N)
  On entry, the symmetric matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
  On exit, if JOBZ = 'V', then if INFO = 0, A contains the
  orthonormal eigenvectors of the matrix A.
  If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
  or the upper triangle (if UPLO='U') of A, including the
  diagonal, is destroyed.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 */
inline proc syev(matrix_order : lapack_memory_order, jobz : string, uplo : string, a : [] c_float, w : [] c_float): c_int{
  return LAPACKE_ssyev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsyev for the type c_double.

For more information, see the documentation for :proc:`syev`, or consult the Netlibs or Intel documentation.
 */
inline proc syev(matrix_order : lapack_memory_order, jobz : string, uplo : string, a : [] c_double, w : [] c_double): c_int{
  return LAPACKE_dsyev(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssyevd for the type c_float.

Original Fortran LAPACK purpose documentation for SSYEVD::

 SSYEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 Because of large use of BLAS of level 3, SSYEVD needs N**2 more
 workspace than SSYEVX.

Original Fortran LAPACK argument documentation for SSYEVD::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA, N)
  On entry, the symmetric matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
  On exit, if JOBZ = 'V', then if INFO = 0, A contains the
  orthonormal eigenvectors of the matrix A.
  If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
  or the upper triangle (if UPLO='U') of A, including the
  diagonal, is destroyed.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 */
inline proc syevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, a : [] c_float, w : [] c_float): c_int{
  return LAPACKE_ssyevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsyevd for the type c_double.

For more information, see the documentation for :proc:`syevd`, or consult the Netlibs or Intel documentation.
 */
inline proc syevd(matrix_order : lapack_memory_order, jobz : string, uplo : string, a : [] c_double, w : [] c_double): c_int{
  return LAPACKE_dsyevd(matrix_order, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssyevr for the type c_float.

Original Fortran LAPACK purpose documentation for SSYEVR::

 SSYEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 SSYEVR first reduces the matrix A to tridiagonal form T with a call
 to SSYTRD. Then, whenever possible, SSYEVR calls SSTEMR to compute
 the eigenspectrum using Relatively Robust Representations. SSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
 (a) Compute T - sigma I = L D L^T, so that L and D
 define all the wanted eigenvalues to high relative accuracy.
 This means that small relative changes in the entries of D and L
 cause only small relative changes in the eigenvalues and
 eigenvectors. The standard (unfactored) representation of the
 tridiagonal matrix T does not have this property in general.
 (b) Compute the eigenvalues to suitable accuracy.
 If the eigenvectors are desired, the algorithm attains full
 accuracy of the computed eigenvalues only right before
 the corresponding vectors have to be computed, see steps c) and d).
 (c) For each cluster of close eigenvalues, select a new
 shift close to the cluster, find a new factorization, and refine
 the shifted eigenvalues to suitable accuracy.
 (d) For each eigenvalue with a large enough relative separation compute
 the corresponding eigenvector by forming a rank revealing twisted
 factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see SSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
 to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
 Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
 Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
 2004. Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
 tridiagonal eigenvalue/eigenvector problem",
 Computer Science Division Technical Report No. UCB/CSD-97-971,
 UC Berkeley, May 1997.


 Note 1 : SSYEVR calls SSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 SSYEVR calls SSTEBZ and SSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of SSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.

Original Fortran LAPACK argument documentation for SSYEVR::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.
  For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and
  SSTEIN are called

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA, N)
  On entry, the symmetric matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
  On exit, the lower triangle (if UPLO='L') or the upper
  triangle (if UPLO='U') of A, including the diagonal, is
  destroyed.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing A to tridiagonal form.
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.
 
  If high relative accuracy is important, set ABSTOL to
  SLAMCH( 'Safe minimum' ). Doing so will guarantee that
  eigenvalues are computed to high relative accuracy when
  possible in future releases. The current code does not
  make any guarantees about high relative accuracy, but
  future releases will. See J. Barlow and J. Demmel,
  "Computing Accurate Eigensystems of Scaled Diagonally
  Dominant Matrices", LAPACK Working Note #7, for a discussion
  of which matrices define their eigenvalues to high relative
  accuracy.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  The first M elements contain the selected eigenvalues in
  ascending order.

 Z is REAL array, dimension (LDZ, max(1,M))
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.
  Supplying N columns is always safe.

 ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
  The support of the eigenvectors in Z, i.e., the indices
  indicating the nonzero elements in Z. The i-th eigenvector
  is nonzero only in elements ISUPPZ( 2*i-1 ) through
  ISUPPZ( 2*i ).
  Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1

 */
inline proc syevr(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, a : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, isuppz : [] c_int): c_int{
  return LAPACKE_ssyevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsyevr for the type c_double.

For more information, see the documentation for :proc:`syevr`, or consult the Netlibs or Intel documentation.
 */
inline proc syevr(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, a : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, isuppz : [] c_int): c_int{
  return LAPACKE_dsyevr(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, isuppz);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssyevx for the type c_float.

Original Fortran LAPACK purpose documentation for SSYEVX::

 SSYEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A. Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.

Original Fortran LAPACK argument documentation for SSYEVX::

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA, N)
  On entry, the symmetric matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
  On exit, the lower triangle (if UPLO='L') or the upper
  triangle (if UPLO='U') of A, including the diagonal, is
  destroyed.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing A to tridiagonal form.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*SLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').
 
  See "Computing Small Singular Values of Bidiagonal Matrices
  with Guaranteed High Relative Accuracy," by Demmel and
  Kahan, LAPACK Working Note #3.

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  On normal exit, the first M elements contain the selected
  eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, max(1,M))
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and the
  index of the eigenvector is returned in IFAIL.
  If JOBZ = 'N', then Z is not referenced.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc syevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, a : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ifail : [] c_int): c_int{
  return LAPACKE_ssyevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsyevx for the type c_double.

For more information, see the documentation for :proc:`syevx`, or consult the Netlibs or Intel documentation.
 */
inline proc syevx(matrix_order : lapack_memory_order, jobz : string, range : string, uplo : string, a : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ifail : [] c_int): c_int{
  return LAPACKE_dsyevx(matrix_order, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssygst for the type c_float.

Original Fortran LAPACK purpose documentation for SSYGST::

 SSYGST reduces a real symmetric-definite generalized eigenproblem
 to standard form.

 If ITYPE = 1, the problem is A*x = lambda*B*x,
 and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)

 If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
 B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.

 B must have been previously factorized as U**T*U or L*L**T by SPOTRF.

Original Fortran LAPACK argument documentation for SSYGST::

 ITYPE is INTEGER
  = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T);
  = 2 or 3: compute U*A*U**T or L**T*A*L.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored and B is factored as
  U**T*U;
  = 'L': Lower triangle of A is stored and B is factored as
  L*L**T.

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if INFO = 0, the transformed matrix, stored in the
  same format as A.

 B is REAL array, dimension (LDB,N)
  The triangular factor from the Cholesky factorization of B,
  as returned by SPOTRF.

 */
inline proc sygst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, a : [] c_float, b : [] c_float): c_int{
  return LAPACKE_ssygst(matrix_order, itype, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsygst for the type c_double.

For more information, see the documentation for :proc:`sygst`, or consult the Netlibs or Intel documentation.
 */
inline proc sygst(matrix_order : lapack_memory_order, itype : c_int, uplo : string, a : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dsygst(matrix_order, itype, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssygv for the type c_float.

Original Fortran LAPACK purpose documentation for SSYGV::

 SSYGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric and B is also
 positive definite.

Original Fortran LAPACK argument documentation for SSYGV::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 A is REAL array, dimension (LDA, N)
  On entry, the symmetric matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
 
  On exit, if JOBZ = 'V', then if INFO = 0, A contains the
  matrix Z of eigenvectors. The eigenvectors are normalized
  as follows:
  if ITYPE = 1 or 2, Z**T*B*Z = I;
  if ITYPE = 3, Z**T*inv(B)*Z = I.
  If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
  or the lower triangle (if UPLO='L') of A, including the
  diagonal, is destroyed.

 B is REAL array, dimension (LDB, N)
  On entry, the symmetric positive definite matrix B.
  If UPLO = 'U', the leading N-by-N upper triangular part of B
  contains the upper triangular part of the matrix B.
  If UPLO = 'L', the leading N-by-N lower triangular part of B
  contains the lower triangular part of the matrix B.
 
  On exit, if INFO <= N, the part of B containing the matrix is
  overwritten by the triangular factor U or L from the Cholesky
  factorization B = U**T*U or B = L*L**T.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 */
inline proc sygv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, a : [] c_float, b : [] c_float, w : [] c_float): c_int{
  return LAPACKE_ssygv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsygv for the type c_double.

For more information, see the documentation for :proc:`sygv`, or consult the Netlibs or Intel documentation.
 */
inline proc sygv(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, a : [] c_double, b : [] c_double, w : [] c_double): c_int{
  return LAPACKE_dsygv(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssygvd for the type c_float.

Original Fortran LAPACK purpose documentation for SSYGVD::

 SSYGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A and
 B are assumed to be symmetric and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

Original Fortran LAPACK argument documentation for SSYGVD::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 UPLO is CHARACTER*1
  = 'U': Upper triangles of A and B are stored;
  = 'L': Lower triangles of A and B are stored.

 A is REAL array, dimension (LDA, N)
  On entry, the symmetric matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
 
  On exit, if JOBZ = 'V', then if INFO = 0, A contains the
  matrix Z of eigenvectors. The eigenvectors are normalized
  as follows:
  if ITYPE = 1 or 2, Z**T*B*Z = I;
  if ITYPE = 3, Z**T*inv(B)*Z = I.
  If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
  or the lower triangle (if UPLO='L') of A, including the
  diagonal, is destroyed.

 B is REAL array, dimension (LDB, N)
  On entry, the symmetric matrix B. If UPLO = 'U', the
  leading N-by-N upper triangular part of B contains the
  upper triangular part of the matrix B. If UPLO = 'L',
  the leading N-by-N lower triangular part of B contains
  the lower triangular part of the matrix B.
 
  On exit, if INFO <= N, the part of B containing the matrix is
  overwritten by the triangular factor U or L from the Cholesky
  factorization B = U**T*U or B = L*L**T.

 W is REAL array, dimension (N)
  If INFO = 0, the eigenvalues in ascending order.

 */
inline proc sygvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, a : [] c_float, b : [] c_float, w : [] c_float): c_int{
  return LAPACKE_ssygvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsygvd for the type c_double.

For more information, see the documentation for :proc:`sygvd`, or consult the Netlibs or Intel documentation.
 */
inline proc sygvd(matrix_order : lapack_memory_order, itype : c_int, jobz : string, uplo : string, a : [] c_double, b : [] c_double, w : [] c_double): c_int{
  return LAPACKE_dsygvd(matrix_order, itype, ascii(jobz) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, w);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssygvx for the type c_float.

Original Fortran LAPACK purpose documentation for SSYGVX::

 SSYGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. Here A
 and B are assumed to be symmetric and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.

Original Fortran LAPACK argument documentation for SSYGVX::

 ITYPE is INTEGER
  Specifies the problem type to be solved:
  = 1: A*x = (lambda)*B*x
  = 2: A*B*x = (lambda)*x
  = 3: B*A*x = (lambda)*x

 JOBZ is CHARACTER*1
  = 'N': Compute eigenvalues only;
  = 'V': Compute eigenvalues and eigenvectors.

 RANGE is CHARACTER*1
  = 'A': all eigenvalues will be found.
  = 'V': all eigenvalues in the half-open interval (VL,VU]
  will be found.
  = 'I': the IL-th through IU-th eigenvalues will be found.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A and B are stored;
  = 'L': Lower triangle of A and B are stored.

 N is INTEGER
  The order of the matrix pencil (A,B). N >= 0.

 A is REAL array, dimension (LDA, N)
  On entry, the symmetric matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of A contains the
  upper triangular part of the matrix A. If UPLO = 'L',
  the leading N-by-N lower triangular part of A contains
  the lower triangular part of the matrix A.
 
  On exit, the lower triangle (if UPLO='L') or the upper
  triangle (if UPLO='U') of A, including the diagonal, is
  destroyed.

 B is REAL array, dimension (LDA, N)
  On entry, the symmetric matrix B. If UPLO = 'U', the
  leading N-by-N upper triangular part of B contains the
  upper triangular part of the matrix B. If UPLO = 'L',
  the leading N-by-N lower triangular part of B contains
  the lower triangular part of the matrix B.
 
  On exit, if INFO <= N, the part of B containing the matrix is
  overwritten by the triangular factor U or L from the Cholesky
  factorization B = U**T*U or B = L*L**T.

 VL is REAL

 VU is REAL
  If RANGE='V', the lower and upper bounds of the interval to
  be searched for eigenvalues. VL < VU.
  Not referenced if RANGE = 'A' or 'I'.

 IL is INTEGER

 IU is INTEGER
  If RANGE='I', the indices (in ascending order) of the
  smallest and largest eigenvalues to be returned.
  1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
  Not referenced if RANGE = 'A' or 'V'.

 ABSTOL is REAL
  The absolute error tolerance for the eigenvalues.
  An approximate eigenvalue is accepted as converged
  when it is determined to lie in an interval [a,b]
  of width less than or equal to
 
  ABSTOL + EPS * max( |a|,|b| ) ,
 
  where EPS is the machine precision. If ABSTOL is less than
  or equal to zero, then EPS*|T| will be used in its place,
  where |T| is the 1-norm of the tridiagonal matrix obtained
  by reducing C to tridiagonal form, where C is the symmetric
  matrix of the standard symmetric problem to which the
  generalized problem is transformed.
 
  Eigenvalues will be computed most accurately when ABSTOL is
  set to twice the underflow threshold 2*DLAMCH('S'), not zero.
  If this routine returns with INFO>0, indicating that some
  eigenvectors did not converge, try setting ABSTOL to
  2*SLAMCH('S').

 M is INTEGER
  The total number of eigenvalues found. 0 <= M <= N.
  If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

 W is REAL array, dimension (N)
  On normal exit, the first M elements contain the selected
  eigenvalues in ascending order.

 Z is REAL array, dimension (LDZ, max(1,M))
  If JOBZ = 'N', then Z is not referenced.
  If JOBZ = 'V', then if INFO = 0, the first M columns of Z
  contain the orthonormal eigenvectors of the matrix A
  corresponding to the selected eigenvalues, with the i-th
  column of Z holding the eigenvector associated with W(i).
  The eigenvectors are normalized as follows:
  if ITYPE = 1 or 2, Z**T*B*Z = I;
  if ITYPE = 3, Z**T*inv(B)*Z = I.
 
  If an eigenvector fails to converge, then that column of Z
  contains the latest approximation to the eigenvector, and the
  index of the eigenvector is returned in IFAIL.
  Note: the user must ensure that at least max(1,M) columns are
  supplied in the array Z; if RANGE = 'V', the exact value of M
  is not known in advance and an upper bound must be used.

 IFAIL is INTEGER array, dimension (N)
  If JOBZ = 'V', then if INFO = 0, the first M elements of
  IFAIL are zero. If INFO > 0, then IFAIL contains the
  indices of the eigenvectors that failed to converge.
  If JOBZ = 'N', then IFAIL is not referenced.

 */
inline proc sygvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] c_float, b : [] c_float, vl : c_float, vu : c_float, il : c_int, iu : c_int, abstol : c_float, ref m : c_int, w : [] c_float, z : [] c_float, ifail : [] c_int): c_int{
  return LAPACKE_ssygvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsygvx for the type c_double.

For more information, see the documentation for :proc:`sygvx`, or consult the Netlibs or Intel documentation.
 */
inline proc sygvx(matrix_order : lapack_memory_order, itype : c_int, jobz : string, range : string, uplo : string, n : c_int, a : [] c_double, b : [] c_double, vl : c_double, vu : c_double, il : c_int, iu : c_int, abstol : c_double, ref m : c_int, w : [] c_double, z : [] c_double, ifail : [] c_int): c_int{
  return LAPACKE_dsygvx(matrix_order, itype, ascii(jobz) : c_char, ascii(range) : c_char, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, vl, vu, il, iu, abstol, m, w, z, (z.domain.dim(2).size) : c_int, ifail);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssyrfs for the type c_float.

Original Fortran LAPACK purpose documentation for SSYRFS::

 SSYRFS improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the solution.

Original Fortran LAPACK argument documentation for SSYRFS::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  The symmetric matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular part
  of the matrix A, and the strictly lower triangular part of A
  is not referenced. If UPLO = 'L', the leading N-by-N lower
  triangular part of A contains the lower triangular part of
  the matrix A, and the strictly upper triangular part of A is
  not referenced.

 AF is REAL array, dimension (LDAF,N)
  The factored form of the matrix A. AF contains the block
  diagonal matrix D and the multipliers used to obtain the
  factor U or L from the factorization A = U*D*U**T or
  A = L*D*L**T as computed by SSYTRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSYTRF.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SSYTRS.
  On exit, the improved solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc syrfs(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, af : [] c_float, ipiv : [] c_int, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_ssyrfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsyrfs for the type c_double.

For more information, see the documentation for :proc:`syrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc syrfs(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, af : [] c_double, ipiv : [] c_int, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dsyrfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csyrfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`syrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc syrfs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_csyrfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsyrfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`syrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc syrfs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zsyrfs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssyrfsx for the type c_float.

Original Fortran LAPACK purpose documentation for SSYRFSX::

 SSYRFSX improves the computed solution to a system of linear
 equations when the coefficient matrix is symmetric indefinite, and
 provides error bounds and backward error estimates for the
 solution. In addition to normwise error bound, the code provides
 maximum componentwise error bound if possible. See comments for
 ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.

 The original system of linear equations may have been equilibrated
 before calling this routine, as described by arguments EQUED and S
 below. In this case, the solution and error bounds returned are
 for the original unequilibrated system.

Original Fortran LAPACK argument documentation for SSYRFSX::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done to A
  before calling this routine. This is needed to compute
  the solution and error bounds correctly.
  = 'N': No equilibration
  = 'Y': Both row and column equilibration, i.e., A has been
  replaced by diag(S) * A * diag(S).
  The right hand side B has been changed accordingly.

 A is REAL array, dimension (LDA,N)
  The symmetric matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular
  part of the matrix A, and the strictly lower triangular
  part of A is not referenced. If UPLO = 'L', the leading
  N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.

 AF is REAL array, dimension (LDAF,N)
  The factored form of the matrix A. AF contains the block
  diagonal matrix D and the multipliers used to obtain the
  factor U or L from the factorization A = U*D*U**T or A =
  L*D*L**T as computed by SSYTRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSYTRF.

 S is REAL array, dimension (N)
  The scale factors for A. If EQUED = 'Y', A is multiplied on
  the left and right by diag(S). S is an input argument if FACT =
  'F'; otherwise, S is an output argument. If FACT = 'F' and EQUED
  = 'Y', each element of S must be positive. If S is output, each
  element of S is a power of the radix. If S is input, each element
  of S should be a power of the radix to ensure a reliable solution
  and error estimates. Scaling by powers of the radix does not cause
  rounding errors unless the result underflows or overflows.
  Rounding errors during scaling lead to refining with a matrix that
  is not equivalent to the input matrix, producing error estimates
  that may not be reliable.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  On entry, the solution matrix X, as computed by SGETRS.
  On exit, the improved solution matrix X.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc syrfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] c_float, af : [] c_float, ipiv : [] c_int, s : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_ssyrfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsyrfsx for the type c_double.

For more information, see the documentation for :proc:`syrfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc syrfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] c_double, af : [] c_double, ipiv : [] c_int, s : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_dsyrfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csyrfsx for the type lapack_complex_float.

For more information, see the documentation for :proc:`syrfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc syrfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, s : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_csyrfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsyrfsx for the type lapack_complex_double.

For more information, see the documentation for :proc:`syrfsx`, or consult the Netlibs or Intel documentation.
 */
inline proc syrfsx(matrix_order : lapack_memory_order, uplo : string, equed : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, s : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zsyrfsx(matrix_order, ascii(uplo) : c_char, ascii(equed) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssysv for the type c_float.

Original Fortran LAPACK purpose documentation for SSYSV::

 SSYSV computes the solution to a real system of linear equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks. The factored form of A is then
 used to solve the system of equations A * X = B.

Original Fortran LAPACK argument documentation for SSYSV::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if INFO = 0, the block diagonal matrix D and the
  multipliers used to obtain the factor U or L from the
  factorization A = U*D*U**T or A = L*D*L**T as computed by
  SSYTRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D, as
  determined by SSYTRF. If IPIV(k) > 0, then rows and columns
  k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
  diagonal block. If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
  then rows and columns k-1 and -IPIV(k) were interchanged and
  D(k-1:k,k-1:k) is a 2-by-2 diagonal block. If UPLO = 'L' and
  IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
  -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
  diagonal block.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc sysv(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_ssysv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsysv for the type c_double.

For more information, see the documentation for :proc:`sysv`, or consult the Netlibs or Intel documentation.
 */
inline proc sysv(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dsysv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csysv for the type lapack_complex_float.

For more information, see the documentation for :proc:`sysv`, or consult the Netlibs or Intel documentation.
 */
inline proc sysv(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_csysv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsysv for the type lapack_complex_double.

For more information, see the documentation for :proc:`sysv`, or consult the Netlibs or Intel documentation.
 */
inline proc sysv(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zsysv(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssysvx for the type c_float.

Original Fortran LAPACK purpose documentation for SSYSVX::

 SSYSVX uses the diagonal pivoting factorization to compute the
 solution to a real system of linear equations A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 Error bounds on the solution and a condition estimate are also
 provided.

Original Fortran LAPACK argument documentation for SSYSVX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of A has been
  supplied on entry.
  = 'F': On entry, AF and IPIV contain the factored form of
  A. AF and IPIV will not be modified.
  = 'N': The matrix A will be copied to AF and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  The symmetric matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular part
  of the matrix A, and the strictly lower triangular part of A
  is not referenced. If UPLO = 'L', the leading N-by-N lower
  triangular part of A contains the lower triangular part of
  the matrix A, and the strictly upper triangular part of A is
  not referenced.

 AF is REAL array, dimension (LDAF,N)
  If FACT = 'F', then AF is an input argument and on entry
  contains the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**T or A = L*D*L**T as computed by SSYTRF.
 
  If FACT = 'N', then AF is an output argument and on exit
  returns the block diagonal matrix D and the multipliers used
  to obtain the factor U or L from the factorization
  A = U*D*U**T or A = L*D*L**T.

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains details of the interchanges and the block structure
  of D, as determined by SSYTRF.
  If IPIV(k) > 0, then rows and columns k and IPIV(k) were
  interchanged and D(k,k) is a 1-by-1 diagonal block.
  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
  columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
  is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) =
  IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
  interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains details of the interchanges and the block structure
  of D, as determined by SSYTRF.

 B is REAL array, dimension (LDB,NRHS)
  The N-by-NRHS right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

 RCOND is REAL
  The estimate of the reciprocal condition number of the matrix
  A. If RCOND is less than the machine precision (in
  particular, if RCOND = 0), the matrix is singular to working
  precision. This condition is indicated by a return code of
  INFO > 0.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc sysvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] c_float, af : [] c_float, ipiv : [] c_int, b : [] c_float, x : [] c_float, ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_ssysvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsysvx for the type c_double.

For more information, see the documentation for :proc:`sysvx`, or consult the Netlibs or Intel documentation.
 */
inline proc sysvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] c_double, af : [] c_double, ipiv : [] c_int, b : [] c_double, x : [] c_double, ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dsysvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csysvx for the type lapack_complex_float.

For more information, see the documentation for :proc:`sysvx`, or consult the Netlibs or Intel documentation.
 */
inline proc sysvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_csysvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsysvx for the type lapack_complex_double.

For more information, see the documentation for :proc:`sysvx`, or consult the Netlibs or Intel documentation.
 */
inline proc sysvx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_zsysvx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssysvxx for the type c_float.

Original Fortran LAPACK purpose documentation for SSYSVXX::

 SSYSVXX uses the diagonal pivoting factorization to compute the
 solution to a real system of linear equations A * X = B, where A
 is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.

 If requested, both normwise and maximum componentwise error bounds
 are returned. SSYSVXX will return a solution with a tiny
 guaranteed error (O(eps) where eps is the working machine
 precision) unless the matrix is very ill-conditioned, in which
 case a warning is returned. Relevant condition numbers also are
 calculated and returned.

 SSYSVXX accepts user-provided factorizations and equilibration
 factors; see the definitions of the FACT and EQUED options.
 Solving with refinement and using a factorization from a previous
 SSYSVXX call will also produce a solution with either O(eps)
 errors or warnings, but we cannot make that claim for general
 user-provided factorizations and equilibration factors if they
 differ from what SSYSVXX would itself produce.

Original Fortran LAPACK argument documentation for SSYSVXX::

 FACT is CHARACTER*1
  Specifies whether or not the factored form of the matrix A is
  supplied on entry, and if not, whether the matrix A should be
  equilibrated before it is factored.
  = 'F': On entry, AF and IPIV contain the factored form of A.
  If EQUED is not 'N', the matrix A has been
  equilibrated with scaling factors given by S.
  A, AF, and IPIV are not modified.
  = 'N': The matrix A will be copied to AF and factored.
  = 'E': The matrix A will be equilibrated if necessary, then
  copied to AF and factored.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  The symmetric matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of A contains the upper triangular
  part of the matrix A, and the strictly lower triangular
  part of A is not referenced. If UPLO = 'L', the leading
  N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
  diag(S)*A*diag(S).

 AF is REAL array, dimension (LDAF,N)
  If FACT = 'F', then AF is an input argument and on entry
  contains the block diagonal matrix D and the multipliers
  used to obtain the factor U or L from the factorization A =
  U*D*U**T or A = L*D*L**T as computed by SSYTRF.
 
  If FACT = 'N', then AF is an output argument and on exit
  returns the block diagonal matrix D and the multipliers
  used to obtain the factor U or L from the factorization A =
  U*D*U**T or A = L*D*L**T.

 IPIV is INTEGER array, dimension (N)
  If FACT = 'F', then IPIV is an input argument and on entry
  contains details of the interchanges and the block
  structure of D, as determined by SSYTRF. If IPIV(k) > 0,
  then rows and columns k and IPIV(k) were interchanged and
  D(k,k) is a 1-by-1 diagonal block. If UPLO = 'U' and
  IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and
  -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2
  diagonal block. If UPLO = 'L' and IPIV(k) = IPIV(k+1) < 0,
  then rows and columns k+1 and -IPIV(k) were interchanged
  and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
 
  If FACT = 'N', then IPIV is an output argument and on exit
  contains details of the interchanges and the block
  structure of D, as determined by SSYTRF.

 EQUED is CHARACTER*1
  Specifies the form of equilibration that was done.
  = 'N': No equilibration (always true if FACT = 'N').
  = 'Y': Both row and column equilibration, i.e., A has been
  replaced by diag(S) * A * diag(S).
  EQUED is an input argument if FACT = 'F'; otherwise, it is an
  output argument.

 S is REAL array, dimension (N)
  The scale factors for A. If EQUED = 'Y', A is multiplied on
  the left and right by diag(S). S is an input argument if FACT =
  'F'; otherwise, S is an output argument. If FACT = 'F' and EQUED
  = 'Y', each element of S must be positive. If S is output, each
  element of S is a power of the radix. If S is input, each element
  of S should be a power of the radix to ensure a reliable solution
  and error estimates. Scaling by powers of the radix does not cause
  rounding errors unless the result underflows or overflows.
  Rounding errors during scaling lead to refining with a matrix that
  is not equivalent to the input matrix, producing error estimates
  that may not be reliable.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit,
  if EQUED = 'N', B is not modified;
  if EQUED = 'Y', B is overwritten by diag(S)*B;

 X is REAL array, dimension (LDX,NRHS)
  If INFO = 0, the N-by-NRHS solution matrix X to the original
  system of equations. Note that A and B are modified on exit if
  EQUED .ne. 'N', and the solution to the equilibrated system is
  inv(diag(S))*X.

 RCOND is REAL
  Reciprocal scaled condition number. This is an estimate of the
  reciprocal Skeel condition number of the matrix A after
  equilibration (if done). If this is less than the machine
  precision (in particular, if it is zero), the matrix is singular
  to working precision. Note that the error may still be small even
  if this number is very small and the matrix appears ill-
  conditioned.

 RPVGRW is REAL
  Reciprocal pivot growth. On exit, this contains the reciprocal
  pivot growth factor norm(A)/norm(U). The "max absolute element"
  norm is used. If this is much less than 1, then the stability of
  the LU factorization of the (equilibrated) matrix A could be poor.
  This also means that the solution X, estimated condition numbers,
  and error bounds could be unreliable. If factorization fails with
  0<INFO<=N, then this contains the reciprocal pivot growth factor
  for the leading INFO columns of A.

 BERR is REAL array, dimension (NRHS)
  Componentwise relative backward error. This is the
  componentwise relative backward error of each solution vector X(j)
  (i.e., the smallest relative change in any element of A or B that
  makes X(j) an exact solution).

 N_ERR_BNDS is INTEGER
  Number of error bounds to return for each right hand side
  and each type (normwise or componentwise). See ERR_BNDS_NORM and
  ERR_BNDS_COMP below.

 ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  normwise relative error, which is defined as follows:
 
  Normwise relative error in the ith solution vector:
  max_j (abs(XTRUE(j,i) - X(j,i)))
  ------------------------------
  max_j abs(X(j,i))
 
  The array is indexed by the type of error information as described
  below. There currently are up to three pieces of information
  returned.
 
  The first index in ERR_BNDS_NORM(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_NORM(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated normwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*A, where S scales each row by a power of the
  radix so all absolute row sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)
  For each right-hand side, this array contains information about
  various error bounds and condition numbers corresponding to the
  componentwise relative error, which is defined as follows:
 
  Componentwise relative error in the ith solution vector:
  abs(XTRUE(j,i) - X(j,i))
  max_j ----------------------
  abs(X(j,i))
 
  The array is indexed by the right-hand side i (on which the
  componentwise relative error depends), and the type of error
  information as described below. There currently are up to three
  pieces of information returned for each right-hand side. If
  componentwise accuracy is not requested (PARAMS(3) = 0.0), then
  ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at most
  the first (:,N_ERR_BNDS) entries are returned.
 
  The first index in ERR_BNDS_COMP(i,:) corresponds to the ith
  right-hand side.
 
  The second index in ERR_BNDS_COMP(:,err) contains the following
  three fields:
  err = 1 "Trust/don't trust" boolean. Trust the answer if the
  reciprocal condition number is less than the threshold
  sqrt(n) * slamch('Epsilon').
 
  err = 2 "Guaranteed" error bound: The estimated forward error,
  almost certainly within a factor of 10 of the true error
  so long as the next entry is greater than the threshold
  sqrt(n) * slamch('Epsilon'). This error bound should only
  be trusted if the previous boolean is true.
 
  err = 3 Reciprocal condition number: Estimated componentwise
  reciprocal condition number. Compared with the threshold
  sqrt(n) * slamch('Epsilon') to determine if the error
  estimate is "guaranteed". These reciprocal condition
  numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
  appropriately scaled matrix Z.
  Let Z = S*(A*diag(x)), where x is the solution for the
  current right-hand side and S scales each row of
  A*diag(x) by a power of the radix so all absolute row
  sums of Z are approximately 1.
 
  See Lapack Working Note 165 for further details and extra
  cautions.

 NPARAMS is INTEGER
  Specifies the number of parameters set in PARAMS. If .LE. 0, the
  PARAMS array is never referenced and default values are used.

 PARAMS is REAL array, dimension NPARAMS
  Specifies algorithm parameters. If an entry is .LT. 0.0, then
  that entry will be filled with default value used for that
  parameter. Only positions up to NPARAMS are accessed; defaults
  are used for higher-numbered parameters.
 
  PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative
  refinement or not.
  Default: 1.0
  = 0.0 : No refinement is performed, and no error bounds are
  computed.
  = 1.0 : Use the double-precision refinement algorithm,
  possibly with doubled-single computations if the
  compilation environment does not support DOUBLE
  PRECISION.
  (other values are reserved for future use)
 
  PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual
  computations allowed for refinement.
  Default: 10
  Aggressive: Set to 100 to permit convergence using approximate
  factorizations or factorizations other than LU. If
  the factorization uses a technique other than
  Gaussian elimination, the guarantees in
  err_bnds_norm and err_bnds_comp may no longer be
  trustworthy.
 
  PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code
  will attempt to find a solution with small componentwise
  relative error in the double-precision algorithm. Positive
  is true, 0.0 is false.
  Default: 1.0 (attempt componentwise convergence)

 */
inline proc sysvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] c_float, af : [] c_float, ipiv : [] c_int, ref equed : string, s : [] c_float, b : [] c_float, x : [] c_float, ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_ssysvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsysvxx for the type c_double.

For more information, see the documentation for :proc:`sysvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc sysvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] c_double, af : [] c_double, ipiv : [] c_int, ref equed : string, s : [] c_double, b : [] c_double, x : [] c_double, ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_dsysvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csysvxx for the type lapack_complex_float.

For more information, see the documentation for :proc:`sysvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc sysvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(64), af : [] complex(64), ipiv : [] c_int, ref equed : string, s : [] c_float, b : [] complex(64), x : [] complex(64), ref rcond : c_float, ref rpvgrw : c_float, berr : [] c_float, n_err_bnds : c_int, err_bnds_norm : [] c_float, err_bnds_comp : [] c_float, nparams : c_int, params : [] c_float): c_int{
  return LAPACKE_csysvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsysvxx for the type lapack_complex_double.

For more information, see the documentation for :proc:`sysvxx`, or consult the Netlibs or Intel documentation.
 */
inline proc sysvxx(matrix_order : lapack_memory_order, fact : string, uplo : string, a : [] complex(128), af : [] complex(128), ipiv : [] c_int, ref equed : string, s : [] c_double, b : [] complex(128), x : [] complex(128), ref rcond : c_double, ref rpvgrw : c_double, berr : [] c_double, n_err_bnds : c_int, err_bnds_norm : [] c_double, err_bnds_comp : [] c_double, nparams : c_int, params : [] c_double): c_int{
  return LAPACKE_zsysvxx(matrix_order, ascii(fact) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, af, (af.domain.dim(2).size) : c_int, ipiv, ascii(equed) : c_char, s, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssytrd for the type c_float.

Original Fortran LAPACK purpose documentation for SSYTRD::

 SSYTRD reduces a real symmetric matrix A to real symmetric
 tridiagonal form T by an orthogonal similarity transformation:
 Q**T * A * Q = T.

Original Fortran LAPACK argument documentation for SSYTRD::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
  On exit, if UPLO = 'U', the diagonal and first superdiagonal
  of A are overwritten by the corresponding elements of the
  tridiagonal matrix T, and the elements above the first
  superdiagonal, with the array TAU, represent the orthogonal
  matrix Q as a product of elementary reflectors; if UPLO
  = 'L', the diagonal and first subdiagonal of A are over-
  written by the corresponding elements of the tridiagonal
  matrix T, and the elements below the first subdiagonal, with
  the array TAU, represent the orthogonal matrix Q as a product
  of elementary reflectors. See Further Details.

 D is REAL array, dimension (N)
  The diagonal elements of the tridiagonal matrix T:
  D(i) = A(i,i).

 E is REAL array, dimension (N-1)
  The off-diagonal elements of the tridiagonal matrix T:
  E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.

 TAU is REAL array, dimension (N-1)
  The scalar factors of the elementary reflectors (see Further
  Details).

 */
inline proc sytrd(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, d : [] c_float, e : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_ssytrd(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, d, e, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsytrd for the type c_double.

For more information, see the documentation for :proc:`sytrd`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrd(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, d : [] c_double, e : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dsytrd(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, d, e, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssytrf for the type c_float.

Original Fortran LAPACK purpose documentation for SSYTRF::

 SSYTRF computes the factorization of a real symmetric matrix A using
 the Bunch-Kaufman diagonal pivoting method. The form of the
 factorization is

 A = U*D*U**T or A = L*D*L**T

 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with 
 1-by-1 and 2-by-2 diagonal blocks.

 This is the blocked version of the algorithm, calling Level 3 BLAS.

Original Fortran LAPACK argument documentation for SSYTRF::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, the block diagonal matrix D and the multipliers used
  to obtain the factor U or L (see below for further details).

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D.
  If IPIV(k) > 0, then rows and columns k and IPIV(k) were
  interchanged and D(k,k) is a 1-by-1 diagonal block.
  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
  columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
  is a 2-by-2 diagonal block. If UPLO = 'L' and IPIV(k) =
  IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
  interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

 */
inline proc sytrf(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_ssytrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsytrf for the type c_double.

For more information, see the documentation for :proc:`sytrf`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrf(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dsytrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csytrf for the type lapack_complex_float.

For more information, see the documentation for :proc:`sytrf`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrf(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_csytrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsytrf for the type lapack_complex_double.

For more information, see the documentation for :proc:`sytrf`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrf(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zsytrf(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssytri for the type c_float.

Original Fortran LAPACK purpose documentation for SSYTRI::

 SSYTRI computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 SSYTRF.

Original Fortran LAPACK argument documentation for SSYTRI::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is REAL array, dimension (LDA,N)
  On entry, the block diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by SSYTRF.
 
  On exit, if INFO = 0, the (symmetric) inverse of the original
  matrix. If UPLO = 'U', the upper triangular part of the
  inverse is formed and the part of A below the diagonal is not
  referenced; if UPLO = 'L' the lower triangular part of the
  inverse is formed and the part of A above the diagonal is
  not referenced.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSYTRF.

 */
inline proc sytri(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_ssytri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsytri for the type c_double.

For more information, see the documentation for :proc:`sytri`, or consult the Netlibs or Intel documentation.
 */
inline proc sytri(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dsytri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csytri for the type lapack_complex_float.

For more information, see the documentation for :proc:`sytri`, or consult the Netlibs or Intel documentation.
 */
inline proc sytri(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_csytri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsytri for the type lapack_complex_double.

For more information, see the documentation for :proc:`sytri`, or consult the Netlibs or Intel documentation.
 */
inline proc sytri(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zsytri(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssytrs for the type c_float.

Original Fortran LAPACK purpose documentation for SSYTRS::

 SSYTRS solves a system of linear equations A*X = B with a real
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by SSYTRF.

Original Fortran LAPACK argument documentation for SSYTRS::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is REAL array, dimension (LDA,N)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by SSYTRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by SSYTRF.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc sytrs(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_ssytrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsytrs for the type c_double.

For more information, see the documentation for :proc:`sytrs`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrs(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dsytrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csytrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`sytrs`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_csytrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsytrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`sytrs`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrs(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zsytrs(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stbcon for the type c_float.

Original Fortran LAPACK purpose documentation for STBCON::

 STBCON estimates the reciprocal of the condition number of a
 triangular band matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

Original Fortran LAPACK argument documentation for STBCON::

 NORM is CHARACTER*1
  Specifies whether the 1-norm condition number or the
  infinity-norm condition number is required:
  = '1' or 'O': 1-norm;
  = 'I': Infinity-norm.

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals or subdiagonals of the
  triangular band matrix A. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  The upper or lower triangular band matrix A, stored in the
  first kd+1 rows of the array. The j-th column of A is stored
  in the j-th column of the array AB as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
  If DIAG = 'U', the diagonal elements of A are not referenced
  and are assumed to be 1.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(norm(A) * norm(inv(A))).

 */
inline proc tbcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] c_float, ref rcond : c_float): c_int{
  return LAPACKE_stbcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtbcon for the type c_double.

For more information, see the documentation for :proc:`tbcon`, or consult the Netlibs or Intel documentation.
 */
inline proc tbcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] c_double, ref rcond : c_double): c_int{
  return LAPACKE_dtbcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctbcon for the type lapack_complex_float.

For more information, see the documentation for :proc:`tbcon`, or consult the Netlibs or Intel documentation.
 */
inline proc tbcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] complex(64), ref rcond : c_float): c_int{
  return LAPACKE_ctbcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztbcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`tbcon`, or consult the Netlibs or Intel documentation.
 */
inline proc tbcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, kd : c_int, ab : [] complex(128), ref rcond : c_double): c_int{
  return LAPACKE_ztbcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, kd, ab, (ab.domain.dim(2).size) : c_int, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stbrfs for the type c_float.

Original Fortran LAPACK purpose documentation for STBRFS::

 STBRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular band
 coefficient matrix.

 The solution matrix X must be computed by STBTRS or some other
 means before entering this routine. STBRFS does not do iterative
 refinement because doing so cannot improve the backward error.

Original Fortran LAPACK argument documentation for STBRFS::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals or subdiagonals of the
  triangular band matrix A. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  The upper or lower triangular band matrix A, stored in the
  first kd+1 rows of the array. The j-th column of A is stored
  in the j-th column of the array AB as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
  If DIAG = 'U', the diagonal elements of A are not referenced
  and are assumed to be 1.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  The solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc tbrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, ab : [] c_float, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_stbrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtbrfs for the type c_double.

For more information, see the documentation for :proc:`tbrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc tbrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, ab : [] c_double, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dtbrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctbrfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`tbrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc tbrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, ab : [] complex(64), b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_ctbrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztbrfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`tbrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc tbrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, ab : [] complex(128), b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_ztbrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stbtrs for the type c_float.

Original Fortran LAPACK purpose documentation for STBTRS::

 STBTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular band matrix of order N, and B is an
 N-by NRHS matrix. A check is made to verify that A is nonsingular.

Original Fortran LAPACK argument documentation for STBTRS::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 TRANS is CHARACTER*1
  Specifies the form the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 N is INTEGER
  The order of the matrix A. N >= 0.

 KD is INTEGER
  The number of superdiagonals or subdiagonals of the
  triangular band matrix A. KD >= 0.

 AB is REAL array, dimension (LDAB,N)
  The upper or lower triangular band matrix A, stored in the
  first kd+1 rows of AB. The j-th column of A is stored
  in the j-th column of the array AB as follows:
  if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
  if UPLO = 'L', AB(1+i-j,j) = A(i,j) for j<=i<=min(n,j+kd).
  If DIAG = 'U', the diagonal elements of A are not referenced
  and are assumed to be 1.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, if INFO = 0, the solution matrix X.

 */
inline proc tbtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, ab : [] c_float, b : [] c_float): c_int{
  return LAPACKE_stbtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtbtrs for the type c_double.

For more information, see the documentation for :proc:`tbtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc tbtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, ab : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dtbtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctbtrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`tbtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc tbtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, ab : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_ctbtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztbtrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`tbtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc tbtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, kd : c_int, ab : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_ztbtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, kd, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ab, (ab.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stfsm for the type c_float.

Original Fortran LAPACK purpose documentation for STFSM::

 Level 3 BLAS like routine for A in RFP Format.

 STFSM solves the matrix equation

 op( A )*X = alpha*B or X*op( A ) = alpha*B

 where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 non-unit, upper or lower triangular matrix and op( A ) is one of

 op( A ) = A or op( A ) = A**T.

 A is in Rectangular Full Packed (RFP) Format.

 The matrix X is overwritten on B.

Original Fortran LAPACK argument documentation for STFSM::

 TRANSR is CHARACTER*1
  = 'N': The Normal Form of RFP A is stored;
  = 'T': The Transpose Form of RFP A is stored.

 SIDE is CHARACTER*1
  On entry, SIDE specifies whether op( A ) appears on the left
  or right of X as follows:
 
  SIDE = 'L' or 'l' op( A )*X = alpha*B.
 
  SIDE = 'R' or 'r' X*op( A ) = alpha*B.
 
  Unchanged on exit.

 UPLO is CHARACTER*1
  On entry, UPLO specifies whether the RFP matrix A came from
  an upper or lower triangular matrix as follows:
  UPLO = 'U' or 'u' RFP A came from an upper triangular matrix
  UPLO = 'L' or 'l' RFP A came from a lower triangular matrix
 
  Unchanged on exit.

 TRANS is CHARACTER*1
  On entry, TRANS specifies the form of op( A ) to be used
  in the matrix multiplication as follows:
 
  TRANS = 'N' or 'n' op( A ) = A.
 
  TRANS = 'T' or 't' op( A ) = A'.
 
  Unchanged on exit.

 DIAG is CHARACTER*1
  On entry, DIAG specifies whether or not RFP A is unit
  triangular as follows:
 
  DIAG = 'U' or 'u' A is assumed to be unit triangular.
 
  DIAG = 'N' or 'n' A is not assumed to be unit
  triangular.
 
  Unchanged on exit.

 ALPHA is REAL
  On entry, ALPHA specifies the scalar alpha. When alpha is
  zero then A is not referenced and B need not be set before
  entry.
  Unchanged on exit.

 A is REAL array, dimension (NT)
  NT = N*(N+1)/2. On entry, the matrix A in RFP Format.
  RFP Format is described by TRANSR, UPLO and N as follows:
  If TRANSR='N' then RFP A is (0:N,0:K-1) when N is even;
  K=N/2. RFP A is (0:N-1,0:K) when N is odd; K=N/2. If
  TRANSR = 'T' then RFP is the transpose of RFP A as
  defined when TRANSR = 'N'. The contents of RFP A are defined
  by UPLO as follows: If UPLO = 'U' the RFP A contains the NT
  elements of upper packed A either in normal or
  transpose Format. If UPLO = 'L' the RFP A contains
  the NT elements of lower packed A either in normal or
  transpose Format. The LDA of RFP A is (N+1)/2 when
  TRANSR = 'T'. When TRANSR is 'N' the LDA is N+1 when N is
  even and is N when is odd.
  See the Note below for more details. Unchanged on exit.

 B is REAL array, DIMENSION (LDB,N)
  Before entry, the leading m by n part of the array B must
  contain the right-hand side matrix B, and on exit is
  overwritten by the solution matrix X.

 LDB is INTEGER
  On entry, LDB specifies the first dimension of B as declared
  in the calling (sub) program. LDB must be at least
  max( 1, m ).
  Unchanged on exit.

 */
inline proc tfsm(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, alpha : c_float, a : [] c_float, b : [] c_float, ldb : c_int): c_int{
  return LAPACKE_stfsm(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, alpha, a, b, ldb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtfsm for the type c_double.

For more information, see the documentation for :proc:`tfsm`, or consult the Netlibs or Intel documentation.
 */
inline proc tfsm(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, alpha : c_double, a : [] c_double, b : [] c_double, ldb : c_int): c_int{
  return LAPACKE_dtfsm(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, alpha, a, b, ldb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctfsm for the type lapack_complex_float.

For more information, see the documentation for :proc:`tfsm`, or consult the Netlibs or Intel documentation.
 */
inline proc tfsm(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, alpha : complex(64), a : [] complex(64), b : [] complex(64), ldb : c_int): c_int{
  return LAPACKE_ctfsm(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, alpha, a, b, ldb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztfsm for the type lapack_complex_double.

For more information, see the documentation for :proc:`tfsm`, or consult the Netlibs or Intel documentation.
 */
inline proc tfsm(matrix_order : lapack_memory_order, transr : string, side : string, uplo : string, trans : string, diag : string, alpha : complex(128), a : [] complex(128), b : [] complex(128), ldb : c_int): c_int{
  return LAPACKE_ztfsm(matrix_order, ascii(transr) : c_char, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, alpha, a, b, ldb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stftri for the type c_float.

Original Fortran LAPACK purpose documentation for STFTRI::

 STFTRI computes the inverse of a triangular matrix A stored in RFP
 format.

 This is a Level 3 BLAS version of the algorithm.

Original Fortran LAPACK argument documentation for STFTRI::

 TRANSR is CHARACTER*1
  = 'N': The Normal TRANSR of RFP A is stored;
  = 'T': The Transpose TRANSR of RFP A is stored.

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 A is REAL array, dimension (NT);
  NT=N*(N+1)/2. On entry, the triangular factor of a Hermitian
  Positive Definite matrix A in RFP format. RFP format is
  described by TRANSR, UPLO, and N as follows: If TRANSR = 'N'
  then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is
  (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = 'T' then RFP is
  the transpose of RFP A as defined when
  TRANSR = 'N'. The contents of RFP A are defined by UPLO as
  follows: If UPLO = 'U' the RFP A contains the nt elements of
  upper packed A; If UPLO = 'L' the RFP A contains the nt
  elements of lower packed A. The LDA of RFP A is (N+1)/2 when
  TRANSR = 'T'. When TRANSR is 'N' the LDA is N+1 when N is
  even and N is odd. See the Note below for more details.
 
  On exit, the (triangular) inverse of the original matrix, in
  the same storage format.

 */
inline proc tftri(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, a : [] c_float): c_int{
  return LAPACKE_stftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtftri for the type c_double.

For more information, see the documentation for :proc:`tftri`, or consult the Netlibs or Intel documentation.
 */
inline proc tftri(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, a : [] c_double): c_int{
  return LAPACKE_dtftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctftri for the type lapack_complex_float.

For more information, see the documentation for :proc:`tftri`, or consult the Netlibs or Intel documentation.
 */
inline proc tftri(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, a : [] complex(64)): c_int{
  return LAPACKE_ctftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztftri for the type lapack_complex_double.

For more information, see the documentation for :proc:`tftri`, or consult the Netlibs or Intel documentation.
 */
inline proc tftri(matrix_order : lapack_memory_order, transr : string, uplo : string, diag : string, a : [] complex(128)): c_int{
  return LAPACKE_ztftri(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stfttp for the type c_float.

Original Fortran LAPACK purpose documentation for STFTTP::

 STFTTP copies a triangular matrix A from rectangular full packed
 format (TF) to standard packed format (TP).

Original Fortran LAPACK argument documentation for STFTTP::

 TRANSR is CHARACTER*1
  = 'N': ARF is in Normal format;
  = 'T': ARF is in Transpose format;

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 N is INTEGER
  The order of the matrix A. N >= 0.

 ARF is REAL array, dimension ( N*(N+1)/2 ),
  On entry, the upper or lower triangular matrix A stored in
  RFP format. For a further discussion see Notes below.

 AP is REAL array, dimension ( N*(N+1)/2 ),
  On exit, the upper or lower triangular matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.

 */
inline proc tfttp(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_float, ap : [] c_float): c_int{
  return LAPACKE_stfttp(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtfttp for the type c_double.

For more information, see the documentation for :proc:`tfttp`, or consult the Netlibs or Intel documentation.
 */
inline proc tfttp(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] c_double, ap : [] c_double): c_int{
  return LAPACKE_dtfttp(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctfttp for the type lapack_complex_float.

For more information, see the documentation for :proc:`tfttp`, or consult the Netlibs or Intel documentation.
 */
inline proc tfttp(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(64), ap : [] complex(64)): c_int{
  return LAPACKE_ctfttp(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztfttp for the type lapack_complex_double.

For more information, see the documentation for :proc:`tfttp`, or consult the Netlibs or Intel documentation.
 */
inline proc tfttp(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, arf : [] complex(128), ap : [] complex(128)): c_int{
  return LAPACKE_ztfttp(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, arf, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stfttr for the type c_float.

Original Fortran LAPACK purpose documentation for STFTTR::

 STFTTR copies a triangular matrix A from rectangular full packed
 format (TF) to standard full format (TR).

Original Fortran LAPACK argument documentation for STFTTR::

 TRANSR is CHARACTER*1
  = 'N': ARF is in Normal format;
  = 'T': ARF is in Transpose format.

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 ARF is REAL array, dimension (N*(N+1)/2).
  On entry, the upper (if UPLO = 'U') or lower (if UPLO = 'L')
  matrix A in RFP format. See the "Notes" below for more
  details.

 A is REAL array, dimension (LDA,N)
  On exit, the triangular matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of the array A contains
  the upper triangular matrix, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of the array A contains
  the lower triangular matrix, and the strictly upper
  triangular part of A is not referenced.

 LDA is INTEGER
  The leading dimension of the array A. LDA >= max(1,N).

 */
inline proc tfttr(matrix_order : lapack_memory_order, transr : string, uplo : string, arf : [] c_float, a : [] c_float, lda : c_int): c_int{
  return LAPACKE_stfttr(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (arf.domain.dim(1).size) : c_int, arf, a, lda);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtfttr for the type c_double.

For more information, see the documentation for :proc:`tfttr`, or consult the Netlibs or Intel documentation.
 */
inline proc tfttr(matrix_order : lapack_memory_order, transr : string, uplo : string, arf : [] c_double, a : [] c_double, lda : c_int): c_int{
  return LAPACKE_dtfttr(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (arf.domain.dim(1).size) : c_int, arf, a, lda);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctfttr for the type lapack_complex_float.

For more information, see the documentation for :proc:`tfttr`, or consult the Netlibs or Intel documentation.
 */
inline proc tfttr(matrix_order : lapack_memory_order, transr : string, uplo : string, arf : [] complex(64), a : [] complex(64), lda : c_int): c_int{
  return LAPACKE_ctfttr(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, arf, a, lda);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztfttr for the type lapack_complex_double.

For more information, see the documentation for :proc:`tfttr`, or consult the Netlibs or Intel documentation.
 */
inline proc tfttr(matrix_order : lapack_memory_order, transr : string, uplo : string, arf : [] complex(128), a : [] complex(128), lda : c_int): c_int{
  return LAPACKE_ztfttr(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, arf, a, lda);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stgevc for the type c_float.

Original Fortran LAPACK purpose documentation for STGEVC::

 STGEVC computes some or all of the right and/or left eigenvectors of
 a pair of real matrices (S,P), where S is a quasi-triangular matrix
 and P is upper triangular. Matrix pairs of this type are produced by
 the generalized Schur factorization of a matrix pair (A,B):

 A = Q*S*Z**T, B = Q*P*Z**T

 as computed by SGGHRD + SHGEQZ.

 The right eigenvector x and the left eigenvector y of (S,P)
 corresponding to an eigenvalue w are defined by:
 
 S*x = w*P*x, (y**H)*S = w*(y**H)*P,
 
 where y**H denotes the conjugate tranpose of y.
 The eigenvalues are not input to this routine, but are computed
 directly from the diagonal blocks of S and P.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of (S,P), or the products Z*X and/or Q*Y,
 where Z and Q are input matrices.
 If Q and Z are the orthogonal factors from the generalized Schur
 factorization of a matrix pair (A,B), then Z*X and Q*Y
 are the matrices of right and left eigenvectors of (A,B).

Original Fortran LAPACK argument documentation for STGEVC::

 SIDE is CHARACTER*1
  = 'R': compute right eigenvectors only;
  = 'L': compute left eigenvectors only;
  = 'B': compute both right and left eigenvectors.

 HOWMNY is CHARACTER*1
  = 'A': compute all right and/or left eigenvectors;
  = 'B': compute all right and/or left eigenvectors,
  backtransformed by the matrices in VR and/or VL;
  = 'S': compute selected right and/or left eigenvectors,
  specified by the logical array SELECT.

 S is REAL array, dimension (LDS,N)
  The upper quasi-triangular matrix S from a generalized Schur
  factorization, as computed by SHGEQZ.

 P is REAL array, dimension (LDP,N)
  The upper triangular matrix P from a generalized Schur
  factorization, as computed by SHGEQZ.
  2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks
  of S must be in positive diagonal form.

 VL is REAL array, dimension (LDVL,MM)
  On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
  contain an N-by-N matrix Q (usually the orthogonal matrix Q
  of left Schur vectors returned by SHGEQZ).
  On exit, if SIDE = 'L' or 'B', VL contains:
  if HOWMNY = 'A', the matrix Y of left eigenvectors of (S,P);
  if HOWMNY = 'B', the matrix Q*Y;
  if HOWMNY = 'S', the left eigenvectors of (S,P) specified by
  SELECT, stored consecutively in the columns of
  VL, in the same order as their eigenvalues.
 
  A complex eigenvector corresponding to a complex eigenvalue
  is stored in two consecutive columns, the first holding the
  real part, and the second the imaginary part.
 
  Not referenced if SIDE = 'R'.

 VR is REAL array, dimension (LDVR,MM)
  On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
  contain an N-by-N matrix Z (usually the orthogonal matrix Z
  of right Schur vectors returned by SHGEQZ).
 
  On exit, if SIDE = 'R' or 'B', VR contains:
  if HOWMNY = 'A', the matrix X of right eigenvectors of (S,P);
  if HOWMNY = 'B' or 'b', the matrix Z*X;
  if HOWMNY = 'S' or 's', the right eigenvectors of (S,P)
  specified by SELECT, stored consecutively in the
  columns of VR, in the same order as their
  eigenvalues.
 
  A complex eigenvector corresponding to a complex eigenvalue
  is stored in two consecutive columns, the first holding the
  real part and the second the imaginary part.
  
  Not referenced if SIDE = 'L'.

 MM is INTEGER
  The number of columns in the arrays VL and/or VR. MM >= M.

 M is INTEGER
  The number of columns in the arrays VL and/or VR actually
  used to store the eigenvectors. If HOWMNY = 'A' or 'B', M
  is set to N. Each selected real eigenvector occupies one
  column and each selected complex eigenvector occupies two
  columns.

 */
inline proc tgevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, s : [] c_float, p : [] c_float, vl : [] c_float, vr : [] c_float, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_stgevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, (s.domain.dim(1).size) : c_int, s, (s.domain.dim(2).size) : c_int, p, (p.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtgevc for the type c_double.

For more information, see the documentation for :proc:`tgevc`, or consult the Netlibs or Intel documentation.
 */
inline proc tgevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, s : [] c_double, p : [] c_double, vl : [] c_double, vr : [] c_double, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_dtgevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, (s.domain.dim(1).size) : c_int, s, (s.domain.dim(2).size) : c_int, p, (p.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctgevc for the type lapack_complex_float.

For more information, see the documentation for :proc:`tgevc`, or consult the Netlibs or Intel documentation.
 */
inline proc tgevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, s : [] complex(64), p : [] complex(64), vl : [] complex(64), vr : [] complex(64), mm : c_int, ref m : c_int): c_int{
  return LAPACKE_ctgevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, (s.domain.dim(1).size) : c_int, s, (s.domain.dim(2).size) : c_int, p, (p.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztgevc for the type lapack_complex_double.

For more information, see the documentation for :proc:`tgevc`, or consult the Netlibs or Intel documentation.
 */
inline proc tgevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, s : [] complex(128), p : [] complex(128), vl : [] complex(128), vr : [] complex(128), mm : c_int, ref m : c_int): c_int{
  return LAPACKE_ztgevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, (s.domain.dim(1).size) : c_int, s, (s.domain.dim(2).size) : c_int, p, (p.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stgexc for the type c_float.

Original Fortran LAPACK purpose documentation for STGEXC::

 STGEXC reorders the generalized real Schur decomposition of a real
 matrix pair (A,B) using an orthogonal equivalence transformation

 (A, B) = Q * (A, B) * Z**T,

 so that the diagonal block of (A, B) with row index IFST is moved
 to row ILST.

 (A, B) must be in generalized real Schur canonical form (as returned
 by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
 diagonal blocks. B is upper triangular.

 Optionally, the matrices Q and Z of generalized Schur vectors are
 updated.

 Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
 Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T

Original Fortran LAPACK argument documentation for STGEXC::

 WANTQ is LOGICAL
  .TRUE. : update the left transformation matrix Q;
  .FALSE.: do not update Q.

 WANTZ is LOGICAL
  .TRUE. : update the right transformation matrix Z;
  .FALSE.: do not update Z.

 A is REAL array, dimension (LDA,N)
  On entry, the matrix A in generalized real Schur canonical
  form.
  On exit, the updated matrix A, again in generalized
  real Schur canonical form.

 B is REAL array, dimension (LDB,N)
  On entry, the matrix B in generalized real Schur canonical
  form (A,B).
  On exit, the updated matrix B, again in generalized
  real Schur canonical form (A,B).

 Q is REAL array, dimension (LDZ,N)
  On entry, if WANTQ = .TRUE., the orthogonal matrix Q.
  On exit, the updated matrix Q.
  If WANTQ = .FALSE., Q is not referenced.

 Z is REAL array, dimension (LDZ,N)
  On entry, if WANTZ = .TRUE., the orthogonal matrix Z.
  On exit, the updated matrix Z.
  If WANTZ = .FALSE., Z is not referenced.

 IFST is INTEGER

 ILST is INTEGER
  Specify the reordering of the diagonal blocks of (A, B).
  The block with row index IFST is moved to row ILST, by a
  sequence of swapping between adjacent blocks.
  On exit, if IFST pointed on entry to the second row of
  a 2-by-2 block, it is changed to point to the first row;
  ILST always points to the first row of the block in its
  final position (which may differ from its input value by
  +1 or -1). 1 <= IFST, ILST <= N.

 */
inline proc tgexc(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, a : [] c_float, b : [] c_float, q : [] c_float, z : [] c_float, ref ifst : c_int, ref ilst : c_int): c_int{
  return LAPACKE_stgexc(matrix_order, wantq, wantz, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int, ifst, ilst);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtgexc for the type c_double.

For more information, see the documentation for :proc:`tgexc`, or consult the Netlibs or Intel documentation.
 */
inline proc tgexc(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, a : [] c_double, b : [] c_double, q : [] c_double, z : [] c_double, ref ifst : c_int, ref ilst : c_int): c_int{
  return LAPACKE_dtgexc(matrix_order, wantq, wantz, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int, ifst, ilst);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctgexc for the type lapack_complex_float.

For more information, see the documentation for :proc:`tgexc`, or consult the Netlibs or Intel documentation.
 */
inline proc tgexc(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, a : [] complex(64), b : [] complex(64), q : [] complex(64), z : [] complex(64), ifst : c_int, ilst : c_int): c_int{
  return LAPACKE_ctgexc(matrix_order, wantq, wantz, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int, ifst, ilst);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztgexc for the type lapack_complex_double.

For more information, see the documentation for :proc:`tgexc`, or consult the Netlibs or Intel documentation.
 */
inline proc tgexc(matrix_order : lapack_memory_order, wantq : c_int, wantz : c_int, a : [] complex(128), b : [] complex(128), q : [] complex(128), z : [] complex(128), ifst : c_int, ilst : c_int): c_int{
  return LAPACKE_ztgexc(matrix_order, wantq, wantz, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int, ifst, ilst);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stgsen for the type c_float.

Original Fortran LAPACK purpose documentation for STGSEN::

 STGSEN reorders the generalized real Schur decomposition of a real
 matrix pair (A, B) (in terms of an orthonormal equivalence trans-
 formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
 appears in the leading diagonal blocks of the upper quasi-triangular
 matrix A and the upper triangular B. The leading columns of Q and
 Z form orthonormal bases of the corresponding left and right eigen-
 spaces (deflating subspaces). (A, B) must be in generalized real
 Schur canonical form (as returned by SGGES), i.e. A is block upper
 triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
 triangular.

 STGSEN also computes the generalized eigenvalues

 w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)

 of the reordered matrix pair (A, B).

 Optionally, STGSEN computes the estimates of reciprocal condition
 numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
 (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
 between the matrix pairs (A11, B11) and (A22,B22) that correspond to
 the selected cluster and the eigenvalues outside the cluster, resp.,
 and norms of "projections" onto left and right eigenspaces w.r.t.
 the selected cluster in the (1,1)-block.

Original Fortran LAPACK argument documentation for STGSEN::

 IJOB is INTEGER
  Specifies whether condition numbers are required for the
  cluster of eigenvalues (PL and PR) or the deflating subspaces
  (Difu and Difl):
  =0: Only reorder w.r.t. SELECT. No extras.
  =1: Reciprocal of norms of "projections" onto left and right
  eigenspaces w.r.t. the selected cluster (PL and PR).
  =2: Upper bounds on Difu and Difl. F-norm-based estimate
  (DIF(1:2)).
  =3: Estimate of Difu and Difl. 1-norm-based estimate
  (DIF(1:2)).
  About 5 times as expensive as IJOB = 2.
  =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
  version to get it all.
  =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above)

 WANTQ is LOGICAL
  .TRUE. : update the left transformation matrix Q;
  .FALSE.: do not update Q.

 WANTZ is LOGICAL
  .TRUE. : update the right transformation matrix Z;
  .FALSE.: do not update Z.

 A is REAL array, dimension(LDA,N)
  On entry, the upper quasi-triangular matrix A, with (A, B) in
  generalized real Schur canonical form.
  On exit, A is overwritten by the reordered matrix A.

 B is REAL array, dimension(LDB,N)
  On entry, the upper triangular matrix B, with (A, B) in
  generalized real Schur canonical form.
  On exit, B is overwritten by the reordered matrix B.

 ALPHAR is REAL array, dimension (N)

 ALPHAI is REAL array, dimension (N)

 BETA is REAL array, dimension (N)
 
  On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
  be the generalized eigenvalues. ALPHAR(j) + ALPHAI(j)*i
  and BETA(j),j=1,...,N are the diagonals of the complex Schur
  form (S,T) that would result if the 2-by-2 diagonal blocks of
  the real generalized Schur form of (A,B) were further reduced
  to triangular form using complex unitary transformations.
  If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
  positive, then the j-th and (j+1)-st eigenvalues are a
  complex conjugate pair, with ALPHAI(j+1) negative.

 Q is REAL array, dimension (LDQ,N)
  On entry, if WANTQ = .TRUE., Q is an N-by-N matrix.
  On exit, Q has been postmultiplied by the left orthogonal
  transformation matrix which reorder (A, B); The leading M
  columns of Q form orthonormal bases for the specified pair of
  left eigenspaces (deflating subspaces).
  If WANTQ = .FALSE., Q is not referenced.

 Z is REAL array, dimension (LDZ,N)
  On entry, if WANTZ = .TRUE., Z is an N-by-N matrix.
  On exit, Z has been postmultiplied by the left orthogonal
  transformation matrix which reorder (A, B); The leading M
  columns of Z form orthonormal bases for the specified pair of
  left eigenspaces (deflating subspaces).
  If WANTZ = .FALSE., Z is not referenced.

 M is INTEGER
  The dimension of the specified pair of left and right eigen-
  spaces (deflating subspaces). 0 <= M <= N.

 PL is REAL

 PR is REAL
 
  If IJOB = 1, 4 or 5, PL, PR are lower bounds on the
  reciprocal of the norm of "projections" onto left and right
  eigenspaces with respect to the selected cluster.
  0 < PL, PR <= 1.
  If M = 0 or M = N, PL = PR = 1.
  If IJOB = 0, 2 or 3, PL and PR are not referenced.

 DIF is REAL array, dimension (2).
  If IJOB >= 2, DIF(1:2) store the estimates of Difu and Difl.
  If IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on
  Difu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based
  estimates of Difu and Difl.
  If M = 0 or N, DIF(1:2) = F-norm([A, B]).
  If IJOB = 0 or 1, DIF is not referenced.

 */
inline proc tgsen(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, a : [] c_float, b : [] c_float, alphar : [] c_float, alphai : [] c_float, beta : [] c_float, q : [] c_float, z : [] c_float, ref m : c_int, ref pl : c_float, ref pr : c_float, dif : [] c_float): c_int{
  return LAPACKE_stgsen(matrix_order, ijob, wantq, wantz, chlapack_select, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alphar, alphai, beta, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int, m, pl, pr, dif);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtgsen for the type c_double.

For more information, see the documentation for :proc:`tgsen`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsen(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, a : [] c_double, b : [] c_double, alphar : [] c_double, alphai : [] c_double, beta : [] c_double, q : [] c_double, z : [] c_double, ref m : c_int, ref pl : c_double, ref pr : c_double, dif : [] c_double): c_int{
  return LAPACKE_dtgsen(matrix_order, ijob, wantq, wantz, chlapack_select, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alphar, alphai, beta, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int, m, pl, pr, dif);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctgsen for the type lapack_complex_float.

For more information, see the documentation for :proc:`tgsen`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsen(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, a : [] complex(64), b : [] complex(64), alpha : [] complex(64), beta : [] complex(64), q : [] complex(64), z : [] complex(64), ref m : c_int, ref pl : c_float, ref pr : c_float, dif : [] c_float): c_int{
  return LAPACKE_ctgsen(matrix_order, ijob, wantq, wantz, chlapack_select, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int, m, pl, pr, dif);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztgsen for the type lapack_complex_double.

For more information, see the documentation for :proc:`tgsen`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsen(matrix_order : lapack_memory_order, ijob : c_int, wantq : c_int, wantz : c_int, chlapack_select : [] c_int, a : [] complex(128), b : [] complex(128), alpha : [] complex(128), beta : [] complex(128), q : [] complex(128), z : [] complex(128), ref m : c_int, ref pl : c_double, ref pr : c_double, dif : [] c_double): c_int{
  return LAPACKE_ztgsen(matrix_order, ijob, wantq, wantz, chlapack_select, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, alpha, beta, q, (q.domain.dim(2).size) : c_int, z, (z.domain.dim(2).size) : c_int, m, pl, pr, dif);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stgsja for the type c_float.

Original Fortran LAPACK purpose documentation for STGSJA::

 STGSJA computes the generalized singular value decomposition (GSVD)
 of two real upper triangular (or trapezoidal) matrices A and B.

 On entry, it is assumed that matrices A and B have the following
 forms, which may be obtained by the preprocessing subroutine SGGSVP
 from a general M-by-N matrix A and P-by-N matrix B:

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L >= 0;
 L ( 0 0 A23 )
 M-K-L ( 0 0 0 )

 N-K-L K L
 A = K ( 0 A12 A13 ) if M-K-L < 0;
 M-K ( 0 0 A23 )

 N-K-L K L
 B = L ( 0 0 B13 )
 P-L ( 0 0 0 )

 where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
 upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
 otherwise A23 is (M-K)-by-L upper trapezoidal.

 On exit,

 U**T *A*Q = D1*( 0 R ), V**T *B*Q = D2*( 0 R ),

 where U, V and Q are orthogonal matrices.
 R is a nonsingular upper triangular matrix, and D1 and D2 are
 ``diagonal'' matrices, which are of the following structures:

 If M-K-L >= 0,

 K L
 D1 = K ( I 0 )
 L ( 0 C )
 M-K-L ( 0 0 )

 K L
 D2 = L ( 0 S )
 P-L ( 0 0 )

 N-K-L K L
 ( 0 R ) = K ( 0 R11 R12 ) K
 L ( 0 0 R22 ) L

 where

 C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
 S = diag( BETA(K+1), ... , BETA(K+L) ),
 C**2 + S**2 = I.

 R is stored in A(1:K+L,N-K-L+1:N) on exit.

 If M-K-L < 0,

 K M-K K+L-M
 D1 = K ( I 0 0 )
 M-K ( 0 C 0 )

 K M-K K+L-M
 D2 = M-K ( 0 S 0 )
 K+L-M ( 0 0 I )
 P-L ( 0 0 0 )

 N-K-L K M-K K+L-M
 ( 0 R ) = K ( 0 R11 R12 R13 )
 M-K ( 0 0 R22 R23 )
 K+L-M ( 0 0 0 R33 )

 where
 C = diag( ALPHA(K+1), ... , ALPHA(M) ),
 S = diag( BETA(K+1), ... , BETA(M) ),
 C**2 + S**2 = I.

 R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
 ( 0 R22 R23 )
 in B(M-K+1:L,N+M-K-L+1:N) on exit.

 The computation of the orthogonal transformation matrices U, V or Q
 is optional. These matrices may either be formed explicitly, or they
 may be postmultiplied into input matrices U1, V1, or Q1.

Original Fortran LAPACK argument documentation for STGSJA::

 JOBU is CHARACTER*1
  = 'U': U must contain an orthogonal matrix U1 on entry, and
  the product U1*U is returned;
  = 'I': U is initialized to the unit matrix, and the
  orthogonal matrix U is returned;
  = 'N': U is not computed.

 JOBV is CHARACTER*1
  = 'V': V must contain an orthogonal matrix V1 on entry, and
  the product V1*V is returned;
  = 'I': V is initialized to the unit matrix, and the
  orthogonal matrix V is returned;
  = 'N': V is not computed.

 JOBQ is CHARACTER*1
  = 'Q': Q must contain an orthogonal matrix Q1 on entry, and
  the product Q1*Q is returned;
  = 'I': Q is initialized to the unit matrix, and the
  orthogonal matrix Q is returned;
  = 'N': Q is not computed.

 K is INTEGER

 L is INTEGER
 
  K and L specify the subblocks in the input matrices A and B:
  A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,N-L+1:N)
  of A and B, whose GSVD is going to be computed by STGSJA.
  See Further Details.

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
  matrix R or part of R. See Purpose for details.

 B is REAL array, dimension (LDB,N)
  On entry, the P-by-N matrix B.
  On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
  a part of R. See Purpose for details.

 TOLA is REAL

 TOLB is REAL
 
  TOLA and TOLB are the convergence criteria for the Jacobi-
  Kogbetliantz iteration procedure. Generally, they are the
  same as used in the preprocessing step, say
  TOLA = max(M,N)*norm(A)*MACHEPS,
  TOLB = max(P,N)*norm(B)*MACHEPS.

 ALPHA is REAL array, dimension (N)

 BETA is REAL array, dimension (N)
 
  On exit, ALPHA and BETA contain the generalized singular
  value pairs of A and B;
  ALPHA(1:K) = 1,
  BETA(1:K) = 0,
  and if M-K-L >= 0,
  ALPHA(K+1:K+L) = diag(C),
  BETA(K+1:K+L) = diag(S),
  or if M-K-L < 0,
  ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
  BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
  Furthermore, if K+L < N,
  ALPHA(K+L+1:N) = 0 and
  BETA(K+L+1:N) = 0.

 U is REAL array, dimension (LDU,M)
  On entry, if JOBU = 'U', U must contain a matrix U1 (usually
  the orthogonal matrix returned by SGGSVP).
  On exit,
  if JOBU = 'I', U contains the orthogonal matrix U;
  if JOBU = 'U', U contains the product U1*U.
  If JOBU = 'N', U is not referenced.

 V is REAL array, dimension (LDV,P)
  On entry, if JOBV = 'V', V must contain a matrix V1 (usually
  the orthogonal matrix returned by SGGSVP).
  On exit,
  if JOBV = 'I', V contains the orthogonal matrix V;
  if JOBV = 'V', V contains the product V1*V.
  If JOBV = 'N', V is not referenced.

 Q is REAL array, dimension (LDQ,N)
  On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
  the orthogonal matrix returned by SGGSVP).
  On exit,
  if JOBQ = 'I', Q contains the orthogonal matrix Q;
  if JOBQ = 'Q', Q contains the product Q1*Q.
  If JOBQ = 'N', Q is not referenced.

 NCYCLE is INTEGER
  The number of cycles required for convergence.

 */
inline proc tgsja(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, k : c_int, l : c_int, a : [] c_float, b : [] c_float, tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] c_float, v : [] c_float, q : [] c_float, ref ncycle : c_int): c_int{
  return LAPACKE_stgsja(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, tola, tolb, alpha, beta, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, ncycle);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtgsja for the type c_double.

For more information, see the documentation for :proc:`tgsja`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsja(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, k : c_int, l : c_int, a : [] c_double, b : [] c_double, tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] c_double, v : [] c_double, q : [] c_double, ref ncycle : c_int): c_int{
  return LAPACKE_dtgsja(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, tola, tolb, alpha, beta, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, ncycle);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctgsja for the type lapack_complex_float.

For more information, see the documentation for :proc:`tgsja`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsja(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, k : c_int, l : c_int, a : [] complex(64), b : [] complex(64), tola : c_float, tolb : c_float, alpha : [] c_float, beta : [] c_float, u : [] complex(64), v : [] complex(64), q : [] complex(64), ref ncycle : c_int): c_int{
  return LAPACKE_ctgsja(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, tola, tolb, alpha, beta, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, ncycle);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztgsja for the type lapack_complex_double.

For more information, see the documentation for :proc:`tgsja`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsja(matrix_order : lapack_memory_order, jobu : string, jobv : string, jobq : string, k : c_int, l : c_int, a : [] complex(128), b : [] complex(128), tola : c_double, tolb : c_double, alpha : [] c_double, beta : [] c_double, u : [] complex(128), v : [] complex(128), q : [] complex(128), ref ncycle : c_int): c_int{
  return LAPACKE_ztgsja(matrix_order, ascii(jobu) : c_char, ascii(jobv) : c_char, ascii(jobq) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, tola, tolb, alpha, beta, u, (u.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, ncycle);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stgsna for the type c_float.

Original Fortran LAPACK purpose documentation for STGSNA::

 STGSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or eigenvectors of a matrix pair (A, B) in
 generalized real Schur canonical form (or of any matrix pair
 (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
 Z**T denotes the transpose of Z.

 (A, B) must be in generalized real Schur form (as returned by SGGES),
 i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
 blocks. B is upper triangular.

Original Fortran LAPACK argument documentation for STGSNA::

 JOB is CHARACTER*1
  Specifies whether condition numbers are required for
  eigenvalues (S) or eigenvectors (DIF):
  = 'E': for eigenvalues only (S);
  = 'V': for eigenvectors only (DIF);
  = 'B': for both eigenvalues and eigenvectors (S and DIF).

 HOWMNY is CHARACTER*1
  = 'A': compute condition numbers for all eigenpairs;
  = 'S': compute condition numbers for selected eigenpairs
  specified by the array SELECT.

 N is INTEGER
  The order of the square matrix pair (A, B). N >= 0.

 A is REAL array, dimension (LDA,N)
  The upper quasi-triangular matrix A in the pair (A,B).

 B is REAL array, dimension (LDB,N)
  The upper triangular matrix B in the pair (A,B).

 VL is REAL array, dimension (LDVL,M)
  If JOB = 'E' or 'B', VL must contain left eigenvectors of
  (A, B), corresponding to the eigenpairs specified by HOWMNY
  and SELECT. The eigenvectors must be stored in consecutive
  columns of VL, as returned by STGEVC.
  If JOB = 'V', VL is not referenced.

 VR is REAL array, dimension (LDVR,M)
  If JOB = 'E' or 'B', VR must contain right eigenvectors of
  (A, B), corresponding to the eigenpairs specified by HOWMNY
  and SELECT. The eigenvectors must be stored in consecutive
  columns ov VR, as returned by STGEVC.
  If JOB = 'V', VR is not referenced.

 S is REAL array, dimension (MM)
  If JOB = 'E' or 'B', the reciprocal condition numbers of the
  selected eigenvalues, stored in consecutive elements of the
  array. For a complex conjugate pair of eigenvalues two
  consecutive elements of S are set to the same value. Thus
  S(j), DIF(j), and the j-th columns of VL and VR all
  correspond to the same eigenpair (but not in general the
  j-th eigenpair, unless all eigenpairs are selected).
  If JOB = 'V', S is not referenced.

 DIF is REAL array, dimension (MM)
  If JOB = 'V' or 'B', the estimated reciprocal condition
  numbers of the selected eigenvectors, stored in consecutive
  elements of the array. For a complex eigenvector two
  consecutive elements of DIF are set to the same value. If
  the eigenvalues cannot be reordered to compute DIF(j), DIF(j)
  is set to 0; this can only occur when the true value would be
  very small anyway.
  If JOB = 'E', DIF is not referenced.

 MM is INTEGER
  The number of elements in the arrays S and DIF. MM >= M.

 M is INTEGER
  The number of elements of the arrays S and DIF used to store
  the specified condition numbers; for each selected real
  eigenvalue one element is used, and for each selected complex
  conjugate pair of eigenvalues, two elements are used.
  If HOWMNY = 'A', M is set to N.

 */
inline proc tgsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] c_float, b : [] c_float, vl : [] c_float, vr : [] c_float, s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_stgsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, s, dif, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtgsna for the type c_double.

For more information, see the documentation for :proc:`tgsna`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] c_double, b : [] c_double, vl : [] c_double, vr : [] c_double, s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_dtgsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, s, dif, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctgsna for the type lapack_complex_float.

For more information, see the documentation for :proc:`tgsna`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] complex(64), b : [] complex(64), vl : [] complex(64), vr : [] complex(64), s : [] c_float, dif : [] c_float, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_ctgsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, s, dif, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztgsna for the type lapack_complex_double.

For more information, see the documentation for :proc:`tgsna`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, n : c_int, a : [] complex(128), b : [] complex(128), vl : [] complex(128), vr : [] complex(128), s : [] c_double, dif : [] c_double, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_ztgsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, n, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, s, dif, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stgsyl for the type c_float.

Original Fortran LAPACK purpose documentation for STGSYL::

 STGSYL solves the generalized Sylvester equation:

 A * R - L * B = scale * C (1)
 D * R - L * E = scale * F

 where R and L are unknown m-by-n matrices, (A, D), (B, E) and
 (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
 respectively, with real entries. (A, D) and (B, E) must be in
 generalized (real) Schur canonical form, i.e. A, B are upper quasi
 triangular and D, E are upper triangular.

 The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
 scaling factor chosen to avoid overflow.

 In matrix notation (1) is equivalent to solve Zx = scale b, where
 Z is defined as

 Z = [ kron(In, A) -kron(B**T, Im) ] (2)
 [ kron(In, D) -kron(E**T, Im) ].

 Here Ik is the identity matrix of size k and X**T is the transpose of
 X. kron(X, Y) is the Kronecker product between the matrices X and Y.

 If TRANS = 'T', STGSYL solves the transposed system Z**T*y = scale*b,
 which is equivalent to solve for R and L in

 A**T * R + D**T * L = scale * C (3)
 R * B**T + L * E**T = scale * -F

 This case (TRANS = 'T') is used to compute an one-norm-based estimate
 of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
 and (B,E), using SLACON.

 If IJOB >= 1, STGSYL computes a Frobenius norm-based estimate
 of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
 reciprocal of the smallest singular value of Z. See [1-2] for more
 information.

 This is a level 3 BLAS algorithm.

Original Fortran LAPACK argument documentation for STGSYL::

 TRANS is CHARACTER*1
  = 'N', solve the generalized Sylvester equation (1).
  = 'T', solve the 'transposed' system (3).

 IJOB is INTEGER
  Specifies what kind of functionality to be performed.
  =0: solve (1) only.
  =1: The functionality of 0 and 3.
  =2: The functionality of 0 and 4.
  =3: Only an estimate of Dif[(A,D), (B,E)] is computed.
  (look ahead strategy IJOB = 1 is used).
  =4: Only an estimate of Dif[(A,D), (B,E)] is computed.
  ( SGECON on sub-systems is used ).
  Not referenced if TRANS = 'T'.

 A is REAL array, dimension (LDA, M)
  The upper quasi triangular matrix A.

 B is REAL array, dimension (LDB, N)
  The upper quasi triangular matrix B.

 C is REAL array, dimension (LDC, N)
  On entry, C contains the right-hand-side of the first matrix
  equation in (1) or (3).
  On exit, if IJOB = 0, 1 or 2, C has been overwritten by
  the solution R. If IJOB = 3 or 4 and TRANS = 'N', C holds R,
  the solution achieved during the computation of the
  Dif-estimate.

 D is REAL array, dimension (LDD, M)
  The upper triangular matrix D.

 E is REAL array, dimension (LDE, N)
  The upper triangular matrix E.

 F is REAL array, dimension (LDF, N)
  On entry, F contains the right-hand-side of the second matrix
  equation in (1) or (3).
  On exit, if IJOB = 0, 1 or 2, F has been overwritten by
  the solution L. If IJOB = 3 or 4 and TRANS = 'N', F holds L,
  the solution achieved during the computation of the
  Dif-estimate.

 SCALE is REAL
  On exit SCALE is the scaling factor in (1) or (3).
  If 0 < SCALE < 1, C and F hold the solutions R and L, resp.,
  to a slightly perturbed system but the input matrices A, B, D
  and E have not been changed. If SCALE = 0, C and F hold the
  solutions R and L, respectively, to the homogeneous system
  with C = F = 0. Normally, SCALE = 1.

 DIF is REAL
  On exit DIF is the reciprocal of a lower bound of the
  reciprocal of the Dif-function, i.e. DIF is an upper bound of
  Dif[(A,D), (B,E)] = sigma_min(Z), where Z as in (2).
  IF IJOB = 0 or TRANS = 'T', DIF is not touched.

 */
inline proc tgsyl(matrix_order : lapack_memory_order, trans : string, ijob : c_int, a : [] c_float, b : [] c_float, c : [] c_float, d : [] c_float, e : [] c_float, f : [] c_float, ref scale : c_float, ref dif : c_float): c_int{
  return LAPACKE_stgsyl(matrix_order, ascii(trans) : c_char, ijob, (a.domain.dim(1).size) : c_int, (b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int, d, (d.domain.dim(2).size) : c_int, e, (e.domain.dim(2).size) : c_int, f, (f.domain.dim(2).size) : c_int, scale, dif);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtgsyl for the type c_double.

For more information, see the documentation for :proc:`tgsyl`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsyl(matrix_order : lapack_memory_order, trans : string, ijob : c_int, a : [] c_double, b : [] c_double, c : [] c_double, d : [] c_double, e : [] c_double, f : [] c_double, ref scale : c_double, ref dif : c_double): c_int{
  return LAPACKE_dtgsyl(matrix_order, ascii(trans) : c_char, ijob, (a.domain.dim(1).size) : c_int, (b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int, d, (d.domain.dim(2).size) : c_int, e, (e.domain.dim(2).size) : c_int, f, (f.domain.dim(2).size) : c_int, scale, dif);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctgsyl for the type lapack_complex_float.

For more information, see the documentation for :proc:`tgsyl`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsyl(matrix_order : lapack_memory_order, trans : string, ijob : c_int, a : [] complex(64), b : [] complex(64), c : [] complex(64), d : [] complex(64), e : [] complex(64), f : [] complex(64), ref scale : c_float, ref dif : c_float): c_int{
  return LAPACKE_ctgsyl(matrix_order, ascii(trans) : c_char, ijob, (a.domain.dim(1).size) : c_int, (b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int, d, (d.domain.dim(2).size) : c_int, e, (e.domain.dim(2).size) : c_int, f, (f.domain.dim(2).size) : c_int, scale, dif);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztgsyl for the type lapack_complex_double.

For more information, see the documentation for :proc:`tgsyl`, or consult the Netlibs or Intel documentation.
 */
inline proc tgsyl(matrix_order : lapack_memory_order, trans : string, ijob : c_int, a : [] complex(128), b : [] complex(128), c : [] complex(128), d : [] complex(128), e : [] complex(128), f : [] complex(128), ref scale : c_double, ref dif : c_double): c_int{
  return LAPACKE_ztgsyl(matrix_order, ascii(trans) : c_char, ijob, (a.domain.dim(1).size) : c_int, (b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int, d, (d.domain.dim(2).size) : c_int, e, (e.domain.dim(2).size) : c_int, f, (f.domain.dim(2).size) : c_int, scale, dif);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stpcon for the type c_float.

Original Fortran LAPACK purpose documentation for STPCON::

 STPCON estimates the reciprocal of the condition number of a packed
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

Original Fortran LAPACK argument documentation for STPCON::

 NORM is CHARACTER*1
  Specifies whether the 1-norm condition number or the
  infinity-norm condition number is required:
  = '1' or 'O': 1-norm;
  = 'I': Infinity-norm.

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The upper or lower triangular matrix A, packed columnwise in
  a linear array. The j-th column of A is stored in the array
  AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
  If DIAG = 'U', the diagonal elements of A are not referenced
  and are assumed to be 1.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(norm(A) * norm(inv(A))).

 */
inline proc tpcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] c_float, ref rcond : c_float): c_int{
  return LAPACKE_stpcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtpcon for the type c_double.

For more information, see the documentation for :proc:`tpcon`, or consult the Netlibs or Intel documentation.
 */
inline proc tpcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] c_double, ref rcond : c_double): c_int{
  return LAPACKE_dtpcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctpcon for the type lapack_complex_float.

For more information, see the documentation for :proc:`tpcon`, or consult the Netlibs or Intel documentation.
 */
inline proc tpcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] complex(64), ref rcond : c_float): c_int{
  return LAPACKE_ctpcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztpcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`tpcon`, or consult the Netlibs or Intel documentation.
 */
inline proc tpcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, n : c_int, ap : [] complex(128), ref rcond : c_double): c_int{
  return LAPACKE_ztpcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stprfs for the type c_float.

Original Fortran LAPACK purpose documentation for STPRFS::

 STPRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular packed
 coefficient matrix.

 The solution matrix X must be computed by STPTRS or some other
 means before entering this routine. STPRFS does not do iterative
 refinement because doing so cannot improve the backward error.

Original Fortran LAPACK argument documentation for STPRFS::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The upper or lower triangular matrix A, packed columnwise in
  a linear array. The j-th column of A is stored in the array
  AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
  If DIAG = 'U', the diagonal elements of A are not referenced
  and are assumed to be 1.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  The solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc tprfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, ap : [] c_float, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_stprfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtprfs for the type c_double.

For more information, see the documentation for :proc:`tprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc tprfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, ap : [] c_double, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dtprfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctprfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`tprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc tprfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, ap : [] complex(64), b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_ctprfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztprfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`tprfs`, or consult the Netlibs or Intel documentation.
 */
inline proc tprfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, ap : [] complex(128), b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_ztprfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stptri for the type c_float.

Original Fortran LAPACK purpose documentation for STPTRI::

 STPTRI computes the inverse of a real upper or lower triangular
 matrix A stored in packed format.

Original Fortran LAPACK argument documentation for STPTRI::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  On entry, the upper or lower triangular matrix A, stored
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n.
  See below for further details.
  On exit, the (triangular) inverse of the original matrix, in
  the same packed storage format.

 */
inline proc tptri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] c_float): c_int{
  return LAPACKE_stptri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtptri for the type c_double.

For more information, see the documentation for :proc:`tptri`, or consult the Netlibs or Intel documentation.
 */
inline proc tptri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] c_double): c_int{
  return LAPACKE_dtptri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctptri for the type lapack_complex_float.

For more information, see the documentation for :proc:`tptri`, or consult the Netlibs or Intel documentation.
 */
inline proc tptri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] complex(64)): c_int{
  return LAPACKE_ctptri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztptri for the type lapack_complex_double.

For more information, see the documentation for :proc:`tptri`, or consult the Netlibs or Intel documentation.
 */
inline proc tptri(matrix_order : lapack_memory_order, uplo : string, diag : string, n : c_int, ap : [] complex(128)): c_int{
  return LAPACKE_ztptri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, n, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stptrs for the type c_float.

Original Fortran LAPACK purpose documentation for STPTRS::

 STPTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N stored in packed format,
 and B is an N-by-NRHS matrix. A check is made to verify that A is
 nonsingular.

Original Fortran LAPACK argument documentation for STPTRS::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension (N*(N+1)/2)
  The upper or lower triangular matrix A, packed columnwise in
  a linear array. The j-th column of A is stored in the array
  AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, if INFO = 0, the solution matrix X.

 */
inline proc tptrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, ap : [] c_float, b : [] c_float): c_int{
  return LAPACKE_stptrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtptrs for the type c_double.

For more information, see the documentation for :proc:`tptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc tptrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, ap : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dtptrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctptrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`tptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc tptrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, ap : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_ctptrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztptrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`tptrs`, or consult the Netlibs or Intel documentation.
 */
inline proc tptrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, n : c_int, ap : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_ztptrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, n, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, ap, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stpttf for the type c_float.

Original Fortran LAPACK purpose documentation for STPTTF::

 STPTTF copies a triangular matrix A from standard packed format (TP)
 to rectangular full packed format (TF).

Original Fortran LAPACK argument documentation for STPTTF::

 TRANSR is CHARACTER*1
  = 'N': ARF in Normal format is wanted;
  = 'T': ARF in Conjugate-transpose format is wanted.

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 N is INTEGER
  The order of the matrix A. N >= 0.

 AP is REAL array, dimension ( N*(N+1)/2 ),
  On entry, the upper or lower triangular matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.

 ARF is REAL array, dimension ( N*(N+1)/2 ),
  On exit, the upper or lower triangular matrix A stored in
  RFP format. For a further discussion see Notes below.

 */
inline proc tpttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] c_float, arf : [] c_float): c_int{
  return LAPACKE_stpttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtpttf for the type c_double.

For more information, see the documentation for :proc:`tpttf`, or consult the Netlibs or Intel documentation.
 */
inline proc tpttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] c_double, arf : [] c_double): c_int{
  return LAPACKE_dtpttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctpttf for the type lapack_complex_float.

For more information, see the documentation for :proc:`tpttf`, or consult the Netlibs or Intel documentation.
 */
inline proc tpttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] complex(64), arf : [] complex(64)): c_int{
  return LAPACKE_ctpttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztpttf for the type lapack_complex_double.

For more information, see the documentation for :proc:`tpttf`, or consult the Netlibs or Intel documentation.
 */
inline proc tpttf(matrix_order : lapack_memory_order, transr : string, uplo : string, n : c_int, ap : [] complex(128), arf : [] complex(128)): c_int{
  return LAPACKE_ztpttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, n, ap, arf);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stpttr for the type c_float.

Original Fortran LAPACK purpose documentation for STPTTR::

 STPTTR copies a triangular matrix A from standard packed format (TP)
 to standard full format (TR).

Original Fortran LAPACK argument documentation for STPTTR::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular.
  = 'L': A is lower triangular.

 AP is REAL array, dimension ( N*(N+1)/2 ),
  On entry, the upper or lower triangular matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.

 A is REAL array, dimension ( LDA, N )
  On exit, the triangular matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.

 */
inline proc tpttr(matrix_order : lapack_memory_order, uplo : string, ap : [] c_float, a : [] c_float): c_int{
  return LAPACKE_stpttr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, ap, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtpttr for the type c_double.

For more information, see the documentation for :proc:`tpttr`, or consult the Netlibs or Intel documentation.
 */
inline proc tpttr(matrix_order : lapack_memory_order, uplo : string, ap : [] c_double, a : [] c_double): c_int{
  return LAPACKE_dtpttr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, ap, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctpttr for the type lapack_complex_float.

For more information, see the documentation for :proc:`tpttr`, or consult the Netlibs or Intel documentation.
 */
inline proc tpttr(matrix_order : lapack_memory_order, uplo : string, ap : [] complex(64), a : [] complex(64)): c_int{
  return LAPACKE_ctpttr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, ap, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztpttr for the type lapack_complex_double.

For more information, see the documentation for :proc:`tpttr`, or consult the Netlibs or Intel documentation.
 */
inline proc tpttr(matrix_order : lapack_memory_order, uplo : string, ap : [] complex(128), a : [] complex(128)): c_int{
  return LAPACKE_ztpttr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, ap, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strcon for the type c_float.

Original Fortran LAPACK purpose documentation for STRCON::

 STRCON estimates the reciprocal of the condition number of a
 triangular matrix A, in either the 1-norm or the infinity-norm.

 The norm of A is computed and an estimate is obtained for
 norm(inv(A)), then the reciprocal of the condition number is
 computed as
 RCOND = 1 / ( norm(A) * norm(inv(A)) ).

Original Fortran LAPACK argument documentation for STRCON::

 NORM is CHARACTER*1
  Specifies whether the 1-norm condition number or the
  infinity-norm condition number is required:
  = '1' or 'O': 1-norm;
  = 'I': Infinity-norm.

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 A is REAL array, dimension (LDA,N)
  The triangular matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of the array A contains the upper
  triangular matrix, and the strictly lower triangular part of
  A is not referenced. If UPLO = 'L', the leading N-by-N lower
  triangular part of the array A contains the lower triangular
  matrix, and the strictly upper triangular part of A is not
  referenced. If DIAG = 'U', the diagonal elements of A are
  also not referenced and are assumed to be 1.

 RCOND is REAL
  The reciprocal of the condition number of the matrix A,
  computed as RCOND = 1/(norm(A) * norm(inv(A))).

 */
inline proc trcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, a : [] c_float, ref rcond : c_float): c_int{
  return LAPACKE_strcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrcon for the type c_double.

For more information, see the documentation for :proc:`trcon`, or consult the Netlibs or Intel documentation.
 */
inline proc trcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, a : [] c_double, ref rcond : c_double): c_int{
  return LAPACKE_dtrcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrcon for the type lapack_complex_float.

For more information, see the documentation for :proc:`trcon`, or consult the Netlibs or Intel documentation.
 */
inline proc trcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, a : [] complex(64), ref rcond : c_float): c_int{
  return LAPACKE_ctrcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrcon for the type lapack_complex_double.

For more information, see the documentation for :proc:`trcon`, or consult the Netlibs or Intel documentation.
 */
inline proc trcon(matrix_order : lapack_memory_order, norm : string, uplo : string, diag : string, a : [] complex(128), ref rcond : c_double): c_int{
  return LAPACKE_ztrcon(matrix_order, ascii(norm) : c_char, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, rcond);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strevc for the type c_float.

Original Fortran LAPACK purpose documentation for STREVC::

 STREVC computes some or all of the right and/or left eigenvectors of
 a real upper quasi-triangular matrix T.
 Matrices of this type are produced by the Schur factorization of
 a real general matrix: A = Q*T*Q**T, as computed by SHSEQR.
 
 The right eigenvector x and the left eigenvector y of T corresponding
 to an eigenvalue w are defined by:
 
 T*x = w*x, (y**T)*T = w*(y**T)
 
 where y**T denotes the transpose of y.
 The eigenvalues are not input to this routine, but are read directly
 from the diagonal blocks of T.
 
 This routine returns the matrices X and/or Y of right and left
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
 input matrix. If Q is the orthogonal factor that reduces a matrix
 A to Schur form T, then Q*X and Q*Y are the matrices of right and
 left eigenvectors of A.

Original Fortran LAPACK argument documentation for STREVC::

 SIDE is CHARACTER*1
  = 'R': compute right eigenvectors only;
  = 'L': compute left eigenvectors only;
  = 'B': compute both right and left eigenvectors.

 HOWMNY is CHARACTER*1
  = 'A': compute all right and/or left eigenvectors;
  = 'B': compute all right and/or left eigenvectors,
  backtransformed by the matrices in VR and/or VL;
  = 'S': compute selected right and/or left eigenvectors,
  as indicated by the logical array SELECT.

 T is REAL array, dimension (LDT,N)
  The upper quasi-triangular matrix T in Schur canonical form.

 VL is REAL array, dimension (LDVL,MM)
  On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
  contain an N-by-N matrix Q (usually the orthogonal matrix Q
  of Schur vectors returned by SHSEQR).
  On exit, if SIDE = 'L' or 'B', VL contains:
  if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
  if HOWMNY = 'B', the matrix Q*Y;
  if HOWMNY = 'S', the left eigenvectors of T specified by
  SELECT, stored consecutively in the columns
  of VL, in the same order as their
  eigenvalues.
  A complex eigenvector corresponding to a complex eigenvalue
  is stored in two consecutive columns, the first holding the
  real part, and the second the imaginary part.
  Not referenced if SIDE = 'R'.

 VR is REAL array, dimension (LDVR,MM)
  On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
  contain an N-by-N matrix Q (usually the orthogonal matrix Q
  of Schur vectors returned by SHSEQR).
  On exit, if SIDE = 'R' or 'B', VR contains:
  if HOWMNY = 'A', the matrix X of right eigenvectors of T;
  if HOWMNY = 'B', the matrix Q*X;
  if HOWMNY = 'S', the right eigenvectors of T specified by
  SELECT, stored consecutively in the columns
  of VR, in the same order as their
  eigenvalues.
  A complex eigenvector corresponding to a complex eigenvalue
  is stored in two consecutive columns, the first holding the
  real part and the second the imaginary part.
  Not referenced if SIDE = 'L'.

 MM is INTEGER
  The number of columns in the arrays VL and/or VR. MM >= M.

 M is INTEGER
  The number of columns in the arrays VL and/or VR actually
  used to store the eigenvectors.
  If HOWMNY = 'A' or 'B', M is set to N.
  Each selected real eigenvector occupies one column and each
  selected complex eigenvector occupies two columns.

 */
inline proc trevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, t : [] c_float, vl : [] c_float, vr : [] c_float, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_strevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrevc for the type c_double.

For more information, see the documentation for :proc:`trevc`, or consult the Netlibs or Intel documentation.
 */
inline proc trevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, t : [] c_double, vl : [] c_double, vr : [] c_double, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_dtrevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrevc for the type lapack_complex_float.

For more information, see the documentation for :proc:`trevc`, or consult the Netlibs or Intel documentation.
 */
inline proc trevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, t : [] complex(64), vl : [] complex(64), vr : [] complex(64), mm : c_int, ref m : c_int): c_int{
  return LAPACKE_ctrevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrevc for the type lapack_complex_double.

For more information, see the documentation for :proc:`trevc`, or consult the Netlibs or Intel documentation.
 */
inline proc trevc(matrix_order : lapack_memory_order, side : string, howmny : string, chlapack_select : [] c_int, t : [] complex(128), vl : [] complex(128), vr : [] complex(128), mm : c_int, ref m : c_int): c_int{
  return LAPACKE_ztrevc(matrix_order, ascii(side) : c_char, ascii(howmny) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strexc for the type c_float.

Original Fortran LAPACK purpose documentation for STREXC::

 STREXC reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
 moved to row ILST.

 The real Schur form T is reordered by an orthogonal similarity
 transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
 is updated by postmultiplying it with Z.

 T must be in Schur canonical form (as returned by SHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

Original Fortran LAPACK argument documentation for STREXC::

 COMPQ is CHARACTER*1
  = 'V': update the matrix Q of Schur vectors;
  = 'N': do not update Q.

 T is REAL array, dimension (LDT,N)
  On entry, the upper quasi-triangular matrix T, in Schur
  Schur canonical form.
  On exit, the reordered upper quasi-triangular matrix, again
  in Schur canonical form.

 Q is REAL array, dimension (LDQ,N)
  On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
  On exit, if COMPQ = 'V', Q has been postmultiplied by the
  orthogonal transformation matrix Z which reorders T.
  If COMPQ = 'N', Q is not referenced.

 IFST is INTEGER

 ILST is INTEGER
 
  Specify the reordering of the diagonal blocks of T.
  The block with row index IFST is moved to row ILST, by a
  sequence of transpositions between adjacent blocks.
  On exit, if IFST pointed on entry to the second row of a
  2-by-2 block, it is changed to point to the first row; ILST
  always points to the first row of the block in its final
  position (which may differ from its input value by +1 or -1).
  1 <= IFST <= N; 1 <= ILST <= N.

 */
inline proc trexc(matrix_order : lapack_memory_order, compq : string, t : [] c_float, q : [] c_float, ref ifst : c_int, ref ilst : c_int): c_int{
  return LAPACKE_strexc(matrix_order, ascii(compq) : c_char, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, ifst, ilst);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrexc for the type c_double.

For more information, see the documentation for :proc:`trexc`, or consult the Netlibs or Intel documentation.
 */
inline proc trexc(matrix_order : lapack_memory_order, compq : string, t : [] c_double, q : [] c_double, ref ifst : c_int, ref ilst : c_int): c_int{
  return LAPACKE_dtrexc(matrix_order, ascii(compq) : c_char, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, ifst, ilst);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrexc for the type lapack_complex_float.

For more information, see the documentation for :proc:`trexc`, or consult the Netlibs or Intel documentation.
 */
inline proc trexc(matrix_order : lapack_memory_order, compq : string, t : [] complex(64), q : [] complex(64), ifst : c_int, ilst : c_int): c_int{
  return LAPACKE_ctrexc(matrix_order, ascii(compq) : c_char, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, ifst, ilst);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrexc for the type lapack_complex_double.

For more information, see the documentation for :proc:`trexc`, or consult the Netlibs or Intel documentation.
 */
inline proc trexc(matrix_order : lapack_memory_order, compq : string, t : [] complex(128), q : [] complex(128), ifst : c_int, ilst : c_int): c_int{
  return LAPACKE_ztrexc(matrix_order, ascii(compq) : c_char, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, ifst, ilst);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strrfs for the type c_float.

Original Fortran LAPACK purpose documentation for STRRFS::

 STRRFS provides error bounds and backward error estimates for the
 solution to a system of linear equations with a triangular
 coefficient matrix.

 The solution matrix X must be computed by STRTRS or some other
 means before entering this routine. STRRFS does not do iterative
 refinement because doing so cannot improve the backward error.

Original Fortran LAPACK argument documentation for STRRFS::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 A is REAL array, dimension (LDA,N)
  The triangular matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of the array A contains the upper
  triangular matrix, and the strictly lower triangular part of
  A is not referenced. If UPLO = 'L', the leading N-by-N lower
  triangular part of the array A contains the lower triangular
  matrix, and the strictly upper triangular part of A is not
  referenced. If DIAG = 'U', the diagonal elements of A are
  also not referenced and are assumed to be 1.

 B is REAL array, dimension (LDB,NRHS)
  The right hand side matrix B.

 X is REAL array, dimension (LDX,NRHS)
  The solution matrix X.

 FERR is REAL array, dimension (NRHS)
  The estimated forward error bound for each solution vector
  X(j) (the j-th column of the solution matrix X).
  If XTRUE is the true solution corresponding to X(j), FERR(j)
  is an estimated upper bound for the magnitude of the largest
  element in (X(j) - XTRUE) divided by the magnitude of the
  largest element in X(j). The estimate is as reliable as
  the estimate for RCOND, and is almost always a slight
  overestimate of the true error.

 BERR is REAL array, dimension (NRHS)
  The componentwise relative backward error of each solution
  vector X(j) (i.e., the smallest relative change in
  any element of A or B that makes X(j) an exact solution).

 */
inline proc trrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, a : [] c_float, b : [] c_float, x : [] c_float, ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_strrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrrfs for the type c_double.

For more information, see the documentation for :proc:`trrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc trrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, a : [] c_double, b : [] c_double, x : [] c_double, ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_dtrrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrrfs for the type lapack_complex_float.

For more information, see the documentation for :proc:`trrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc trrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, a : [] complex(64), b : [] complex(64), x : [] complex(64), ferr : [] c_float, berr : [] c_float): c_int{
  return LAPACKE_ctrrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrrfs for the type lapack_complex_double.

For more information, see the documentation for :proc:`trrfs`, or consult the Netlibs or Intel documentation.
 */
inline proc trrfs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, a : [] complex(128), b : [] complex(128), x : [] complex(128), ferr : [] c_double, berr : [] c_double): c_int{
  return LAPACKE_ztrrfs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, x, (x.domain.dim(2).size) : c_int, ferr, berr);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strsen for the type c_float.

Original Fortran LAPACK purpose documentation for STRSEN::

 STRSEN reorders the real Schur factorization of a real matrix
 A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
 the leading diagonal blocks of the upper quasi-triangular matrix T,
 and the leading columns of Q form an orthonormal basis of the
 corresponding right invariant subspace.

 Optionally the routine computes the reciprocal condition numbers of
 the cluster of eigenvalues and/or the invariant subspace.

 T must be in Schur canonical form (as returned by SHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

Original Fortran LAPACK argument documentation for STRSEN::

 JOB is CHARACTER*1
  Specifies whether condition numbers are required for the
  cluster of eigenvalues (S) or the invariant subspace (SEP):
  = 'N': none;
  = 'E': for eigenvalues only (S);
  = 'V': for invariant subspace only (SEP);
  = 'B': for both eigenvalues and invariant subspace (S and
  SEP).

 COMPQ is CHARACTER*1
  = 'V': update the matrix Q of Schur vectors;
  = 'N': do not update Q.

 T is REAL array, dimension (LDT,N)
  On entry, the upper quasi-triangular matrix T, in Schur
  canonical form.
  On exit, T is overwritten by the reordered matrix T, again in
  Schur canonical form, with the selected eigenvalues in the
  leading diagonal blocks.

 Q is REAL array, dimension (LDQ,N)
  On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
  On exit, if COMPQ = 'V', Q has been postmultiplied by the
  orthogonal transformation matrix which reorders T; the
  leading M columns of Q form an orthonormal basis for the
  specified invariant subspace.
  If COMPQ = 'N', Q is not referenced.

 WR is REAL array, dimension (N)

 WI is REAL array, dimension (N)
 
  The real and imaginary parts, respectively, of the reordered
  eigenvalues of T. The eigenvalues are stored in the same
  order as on the diagonal of T, with WR(i) = T(i,i) and, if
  T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) > 0 and
  WI(i+1) = -WI(i). Note that if a complex eigenvalue is
  sufficiently ill-conditioned, then its value may differ
  significantly from its value before reordering.

 M is INTEGER
  The dimension of the specified invariant subspace.
  0 < = M <= N.

 S is REAL
  If JOB = 'E' or 'B', S is a lower bound on the reciprocal
  condition number for the selected cluster of eigenvalues.
  S cannot underestimate the true reciprocal condition number
  by more than a factor of sqrt(N). If M = 0 or N, S = 1.
  If JOB = 'N' or 'V', S is not referenced.

 SEP is REAL
  If JOB = 'V' or 'B', SEP is the estimated reciprocal
  condition number of the specified invariant subspace. If
  M = 0 or N, SEP = norm(T).
  If JOB = 'N' or 'E', SEP is not referenced.

 */
inline proc trsen(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, t : [] c_float, q : [] c_float, wr : [] c_float, wi : [] c_float, ref m : c_int, ref s : c_float, ref sep : c_float): c_int{
  return LAPACKE_strsen(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, wr, wi, m, s, sep);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrsen for the type c_double.

For more information, see the documentation for :proc:`trsen`, or consult the Netlibs or Intel documentation.
 */
inline proc trsen(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, t : [] c_double, q : [] c_double, wr : [] c_double, wi : [] c_double, ref m : c_int, ref s : c_double, ref sep : c_double): c_int{
  return LAPACKE_dtrsen(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, wr, wi, m, s, sep);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrsen for the type lapack_complex_float.

For more information, see the documentation for :proc:`trsen`, or consult the Netlibs or Intel documentation.
 */
inline proc trsen(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, t : [] complex(64), q : [] complex(64), w : [] complex(64), ref m : c_int, ref s : c_float, ref sep : c_float): c_int{
  return LAPACKE_ctrsen(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, w, m, s, sep);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrsen for the type lapack_complex_double.

For more information, see the documentation for :proc:`trsen`, or consult the Netlibs or Intel documentation.
 */
inline proc trsen(matrix_order : lapack_memory_order, job : string, compq : string, chlapack_select : [] c_int, t : [] complex(128), q : [] complex(128), w : [] complex(128), ref m : c_int, ref s : c_double, ref sep : c_double): c_int{
  return LAPACKE_ztrsen(matrix_order, ascii(job) : c_char, ascii(compq) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, q, (q.domain.dim(2).size) : c_int, w, m, s, sep);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strsna for the type c_float.

Original Fortran LAPACK purpose documentation for STRSNA::

 STRSNA estimates reciprocal condition numbers for specified
 eigenvalues and/or right eigenvectors of a real upper
 quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
 orthogonal).

 T must be in Schur canonical form (as returned by SHSEQR), that is,
 block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

Original Fortran LAPACK argument documentation for STRSNA::

 JOB is CHARACTER*1
  Specifies whether condition numbers are required for
  eigenvalues (S) or eigenvectors (SEP):
  = 'E': for eigenvalues only (S);
  = 'V': for eigenvectors only (SEP);
  = 'B': for both eigenvalues and eigenvectors (S and SEP).

 HOWMNY is CHARACTER*1
  = 'A': compute condition numbers for all eigenpairs;
  = 'S': compute condition numbers for selected eigenpairs
  specified by the array SELECT.

 T is REAL array, dimension (LDT,N)
  The upper quasi-triangular matrix T, in Schur canonical form.

 VL is REAL array, dimension (LDVL,M)
  If JOB = 'E' or 'B', VL must contain left eigenvectors of T
  (or of any Q*T*Q**T with Q orthogonal), corresponding to the
  eigenpairs specified by HOWMNY and SELECT. The eigenvectors
  must be stored in consecutive columns of VL, as returned by
  SHSEIN or STREVC.
  If JOB = 'V', VL is not referenced.

 VR is REAL array, dimension (LDVR,M)
  If JOB = 'E' or 'B', VR must contain right eigenvectors of T
  (or of any Q*T*Q**T with Q orthogonal), corresponding to the
  eigenpairs specified by HOWMNY and SELECT. The eigenvectors
  must be stored in consecutive columns of VR, as returned by
  SHSEIN or STREVC.
  If JOB = 'V', VR is not referenced.

 S is REAL array, dimension (MM)
  If JOB = 'E' or 'B', the reciprocal condition numbers of the
  selected eigenvalues, stored in consecutive elements of the
  array. For a complex conjugate pair of eigenvalues two
  consecutive elements of S are set to the same value. Thus
  S(j), SEP(j), and the j-th columns of VL and VR all
  correspond to the same eigenpair (but not in general the
  j-th eigenpair, unless all eigenpairs are selected).
  If JOB = 'V', S is not referenced.

 SEP is REAL array, dimension (MM)
  If JOB = 'V' or 'B', the estimated reciprocal condition
  numbers of the selected eigenvectors, stored in consecutive
  elements of the array. For a complex eigenvector two
  consecutive elements of SEP are set to the same value. If
  the eigenvalues cannot be reordered to compute SEP(j), SEP(j)
  is set to 0; this can only occur when the true value would be
  very small anyway.
  If JOB = 'E', SEP is not referenced.

 MM is INTEGER
  The number of elements in the arrays S (if JOB = 'E' or 'B')
  and/or SEP (if JOB = 'V' or 'B'). MM >= M.

 M is INTEGER
  The number of elements of the arrays S and/or SEP actually
  used to store the estimated condition numbers.
  If HOWMNY = 'A', M is set to N.

 */
inline proc trsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, t : [] c_float, vl : [] c_float, vr : [] c_float, s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_strsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, s, sep, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrsna for the type c_double.

For more information, see the documentation for :proc:`trsna`, or consult the Netlibs or Intel documentation.
 */
inline proc trsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, t : [] c_double, vl : [] c_double, vr : [] c_double, s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_dtrsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, s, sep, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrsna for the type lapack_complex_float.

For more information, see the documentation for :proc:`trsna`, or consult the Netlibs or Intel documentation.
 */
inline proc trsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, t : [] complex(64), vl : [] complex(64), vr : [] complex(64), s : [] c_float, sep : [] c_float, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_ctrsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, s, sep, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrsna for the type lapack_complex_double.

For more information, see the documentation for :proc:`trsna`, or consult the Netlibs or Intel documentation.
 */
inline proc trsna(matrix_order : lapack_memory_order, job : string, howmny : string, chlapack_select : [] c_int, t : [] complex(128), vl : [] complex(128), vr : [] complex(128), s : [] c_double, sep : [] c_double, mm : c_int, ref m : c_int): c_int{
  return LAPACKE_ztrsna(matrix_order, ascii(job) : c_char, ascii(howmny) : c_char, chlapack_select, (t.domain.dim(1).size) : c_int, t, (t.domain.dim(2).size) : c_int, vl, (vl.domain.dim(2).size) : c_int, vr, (vr.domain.dim(2).size) : c_int, s, sep, mm, m);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strsyl for the type c_float.

Original Fortran LAPACK purpose documentation for STRSYL::

 STRSYL solves the real Sylvester matrix equation:

 op(A)*X + X*op(B) = scale*C or
 op(A)*X - X*op(B) = scale*C,

 where op(A) = A or A**T, and A and B are both upper quasi-
 triangular. A is M-by-M and B is N-by-N; the right hand side C and
 the solution X are M-by-N; and scale is an output scale factor, set
 <= 1 to avoid overflow in X.

 A and B must be in Schur canonical form (as returned by SHSEQR), that
 is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
 each 2-by-2 diagonal block has its diagonal elements equal and its
 off-diagonal elements of opposite sign.

Original Fortran LAPACK argument documentation for STRSYL::

 TRANA is CHARACTER*1
  Specifies the option op(A):
  = 'N': op(A) = A (No transpose)
  = 'T': op(A) = A**T (Transpose)
  = 'C': op(A) = A**H (Conjugate transpose = Transpose)

 TRANB is CHARACTER*1
  Specifies the option op(B):
  = 'N': op(B) = B (No transpose)
  = 'T': op(B) = B**T (Transpose)
  = 'C': op(B) = B**H (Conjugate transpose = Transpose)

 ISGN is INTEGER
  Specifies the sign in the equation:
  = +1: solve op(A)*X + X*op(B) = scale*C
  = -1: solve op(A)*X - X*op(B) = scale*C

 A is REAL array, dimension (LDA,M)
  The upper quasi-triangular matrix A, in Schur canonical form.

 B is REAL array, dimension (LDB,N)
  The upper quasi-triangular matrix B, in Schur canonical form.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N right hand side matrix C.
  On exit, C is overwritten by the solution matrix X.

 SCALE is REAL
  The scale factor, scale, set <= 1 to avoid overflow in X.

 */
inline proc trsyl(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, a : [] c_float, b : [] c_float, c : [] c_float, ref scale : c_float): c_int{
  return LAPACKE_strsyl(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, (a.domain.dim(1).size) : c_int, (b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int, scale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrsyl for the type c_double.

For more information, see the documentation for :proc:`trsyl`, or consult the Netlibs or Intel documentation.
 */
inline proc trsyl(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, a : [] c_double, b : [] c_double, c : [] c_double, ref scale : c_double): c_int{
  return LAPACKE_dtrsyl(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, (a.domain.dim(1).size) : c_int, (b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int, scale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrsyl for the type lapack_complex_float.

For more information, see the documentation for :proc:`trsyl`, or consult the Netlibs or Intel documentation.
 */
inline proc trsyl(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, a : [] complex(64), b : [] complex(64), c : [] complex(64), ref scale : c_float): c_int{
  return LAPACKE_ctrsyl(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, (a.domain.dim(1).size) : c_int, (b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int, scale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrsyl for the type lapack_complex_double.

For more information, see the documentation for :proc:`trsyl`, or consult the Netlibs or Intel documentation.
 */
inline proc trsyl(matrix_order : lapack_memory_order, trana : string, tranb : string, isgn : c_int, a : [] complex(128), b : [] complex(128), c : [] complex(128), ref scale : c_double): c_int{
  return LAPACKE_ztrsyl(matrix_order, ascii(trana) : c_char, ascii(tranb) : c_char, isgn, (a.domain.dim(1).size) : c_int, (b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int, scale);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strtri for the type c_float.

Original Fortran LAPACK purpose documentation for STRTRI::

 STRTRI computes the inverse of a real upper or lower triangular
 matrix A.

 This is the Level 3 BLAS version of the algorithm.

Original Fortran LAPACK argument documentation for STRTRI::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 A is REAL array, dimension (LDA,N)
  On entry, the triangular matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of the array A contains
  the upper triangular matrix, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of the array A contains
  the lower triangular matrix, and the strictly upper
  triangular part of A is not referenced. If DIAG = 'U', the
  diagonal elements of A are also not referenced and are
  assumed to be 1.
  On exit, the (triangular) inverse of the original matrix, in
  the same storage format.

 */
inline proc trtri(matrix_order : lapack_memory_order, uplo : string, diag : string, a : [] c_float): c_int{
  return LAPACKE_strtri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrtri for the type c_double.

For more information, see the documentation for :proc:`trtri`, or consult the Netlibs or Intel documentation.
 */
inline proc trtri(matrix_order : lapack_memory_order, uplo : string, diag : string, a : [] c_double): c_int{
  return LAPACKE_dtrtri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrtri for the type lapack_complex_float.

For more information, see the documentation for :proc:`trtri`, or consult the Netlibs or Intel documentation.
 */
inline proc trtri(matrix_order : lapack_memory_order, uplo : string, diag : string, a : [] complex(64)): c_int{
  return LAPACKE_ctrtri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrtri for the type lapack_complex_double.

For more information, see the documentation for :proc:`trtri`, or consult the Netlibs or Intel documentation.
 */
inline proc trtri(matrix_order : lapack_memory_order, uplo : string, diag : string, a : [] complex(128)): c_int{
  return LAPACKE_ztrtri(matrix_order, ascii(uplo) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strtrs for the type c_float.

Original Fortran LAPACK purpose documentation for STRTRS::

 STRTRS solves a triangular system of the form

 A * X = B or A**T * X = B,

 where A is a triangular matrix of order N, and B is an N-by-NRHS
 matrix. A check is made to verify that A is nonsingular.

Original Fortran LAPACK argument documentation for STRTRS::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular;
  = 'L': A is lower triangular.

 TRANS is CHARACTER*1
  Specifies the form of the system of equations:
  = 'N': A * X = B (No transpose)
  = 'T': A**T * X = B (Transpose)
  = 'C': A**H * X = B (Conjugate transpose = Transpose)

 DIAG is CHARACTER*1
  = 'N': A is non-unit triangular;
  = 'U': A is unit triangular.

 A is REAL array, dimension (LDA,N)
  The triangular matrix A. If UPLO = 'U', the leading N-by-N
  upper triangular part of the array A contains the upper
  triangular matrix, and the strictly lower triangular part of
  A is not referenced. If UPLO = 'L', the leading N-by-N lower
  triangular part of the array A contains the lower triangular
  matrix, and the strictly upper triangular part of A is not
  referenced. If DIAG = 'U', the diagonal elements of A are
  also not referenced and are assumed to be 1.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, if INFO = 0, the solution matrix X.

 */
inline proc trtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, a : [] c_float, b : [] c_float): c_int{
  return LAPACKE_strtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrtrs for the type c_double.

For more information, see the documentation for :proc:`trtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc trtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, a : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dtrtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrtrs for the type lapack_complex_float.

For more information, see the documentation for :proc:`trtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc trtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, a : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_ctrtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrtrs for the type lapack_complex_double.

For more information, see the documentation for :proc:`trtrs`, or consult the Netlibs or Intel documentation.
 */
inline proc trtrs(matrix_order : lapack_memory_order, uplo : string, trans : string, diag : string, a : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_ztrtrs(matrix_order, ascii(uplo) : c_char, ascii(trans) : c_char, ascii(diag) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strttf for the type c_float.

Original Fortran LAPACK purpose documentation for STRTTF::

 STRTTF copies a triangular matrix A from standard full format (TR)
 to rectangular full packed format (TF) .

Original Fortran LAPACK argument documentation for STRTTF::

 TRANSR is CHARACTER*1
  = 'N': ARF in Normal form is wanted;
  = 'T': ARF in Transpose form is wanted.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N).
  On entry, the triangular matrix A. If UPLO = 'U', the
  leading N-by-N upper triangular part of the array A contains
  the upper triangular matrix, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of the array A contains
  the lower triangular matrix, and the strictly upper
  triangular part of A is not referenced.

 LDA is INTEGER
  The leading dimension of the matrix A. LDA >= max(1,N).

 ARF is REAL array, dimension (NT).
  NT=N*(N+1)/2. On exit, the triangular matrix A in RFP format.

 */
inline proc trttf(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] c_float, lda : c_int, arf : [] c_float): c_int{
  return LAPACKE_strttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, lda, arf);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrttf for the type c_double.

For more information, see the documentation for :proc:`trttf`, or consult the Netlibs or Intel documentation.
 */
inline proc trttf(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] c_double, lda : c_int, arf : [] c_double): c_int{
  return LAPACKE_dtrttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, lda, arf);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrttf for the type lapack_complex_float.

For more information, see the documentation for :proc:`trttf`, or consult the Netlibs or Intel documentation.
 */
inline proc trttf(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] complex(64), lda : c_int, arf : [] complex(64)): c_int{
  return LAPACKE_ctrttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, lda, arf);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrttf for the type lapack_complex_double.

For more information, see the documentation for :proc:`trttf`, or consult the Netlibs or Intel documentation.
 */
inline proc trttf(matrix_order : lapack_memory_order, transr : string, uplo : string, a : [] complex(128), lda : c_int, arf : [] complex(128)): c_int{
  return LAPACKE_ztrttf(matrix_order, ascii(transr) : c_char, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, lda, arf);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_strttp for the type c_float.

Original Fortran LAPACK purpose documentation for STRTTP::

 STRTTP copies a triangular matrix A from full format (TR) to standard
 packed format (TP).

Original Fortran LAPACK argument documentation for STRTTP::

 UPLO is CHARACTER*1
  = 'U': A is upper triangular.
  = 'L': A is lower triangular.

 A is REAL array, dimension (LDA,N)
  On exit, the triangular matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.

 AP is REAL array, dimension (N*(N+1)/2
  On exit, the upper or lower triangular matrix A, packed
  columnwise in a linear array. The j-th column of A is stored
  in the array AP as follows:
  if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
  if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.

 */
inline proc trttp(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ap : [] c_float): c_int{
  return LAPACKE_strttp(matrix_order, ascii(uplo) : c_char, (ap.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtrttp for the type c_double.

For more information, see the documentation for :proc:`trttp`, or consult the Netlibs or Intel documentation.
 */
inline proc trttp(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ap : [] c_double): c_int{
  return LAPACKE_dtrttp(matrix_order, ascii(uplo) : c_char, (ap.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctrttp for the type lapack_complex_float.

For more information, see the documentation for :proc:`trttp`, or consult the Netlibs or Intel documentation.
 */
inline proc trttp(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ap : [] complex(64)): c_int{
  return LAPACKE_ctrttp(matrix_order, ascii(uplo) : c_char, (ap.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztrttp for the type lapack_complex_double.

For more information, see the documentation for :proc:`trttp`, or consult the Netlibs or Intel documentation.
 */
inline proc trttp(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ap : [] complex(128)): c_int{
  return LAPACKE_ztrttp(matrix_order, ascii(uplo) : c_char, (ap.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ap);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stzrzf for the type c_float.

Original Fortran LAPACK purpose documentation for STZRZF::

 STZRZF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
 to upper triangular form by means of orthogonal transformations.

 The upper trapezoidal matrix A is factored as

 A = ( R 0 ) * Z,

 where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
 triangular matrix.

Original Fortran LAPACK argument documentation for STZRZF::

 A is REAL array, dimension (LDA,N)
  On entry, the leading M-by-N upper trapezoidal part of the
  array A must contain the matrix to be factorized.
  On exit, the leading M-by-M upper triangular part of A
  contains the upper triangular matrix R, and elements M+1 to
  N of the first M rows of A, with the array TAU, represent the
  orthogonal matrix Z as a product of M elementary reflectors.

 TAU is REAL array, dimension (M)
  The scalar factors of the elementary reflectors.

 */
inline proc tzrzf(matrix_order : lapack_memory_order, a : [] c_float, tau : [] c_float): c_int{
  return LAPACKE_stzrzf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtzrzf for the type c_double.

For more information, see the documentation for :proc:`tzrzf`, or consult the Netlibs or Intel documentation.
 */
inline proc tzrzf(matrix_order : lapack_memory_order, a : [] c_double, tau : [] c_double): c_int{
  return LAPACKE_dtzrzf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctzrzf for the type lapack_complex_float.

For more information, see the documentation for :proc:`tzrzf`, or consult the Netlibs or Intel documentation.
 */
inline proc tzrzf(matrix_order : lapack_memory_order, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_ctzrzf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztzrzf for the type lapack_complex_double.

For more information, see the documentation for :proc:`tzrzf`, or consult the Netlibs or Intel documentation.
 */
inline proc tzrzf(matrix_order : lapack_memory_order, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_ztzrzf(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cungbr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNGBR::

 CUNGBR generates one of the complex unitary matrices Q or P**H
 determined by CGEBRD when reducing a complex matrix A to bidiagonal
 form: A = Q * B * P**H. Q and P**H are defined as products of
 elementary reflectors H(i) or G(i) respectively.

 If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
 is of order M:
 if m >= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n
 columns of Q, where m >= n >= k;
 if m < k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an
 M-by-M matrix.

 If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
 is of order N:
 if k < n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m
 rows of P**H, where n >= m >= k;
 if k >= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as
 an N-by-N matrix.

Original Fortran LAPACK argument documentation for CUNGBR::

 VECT is CHARACTER*1
  Specifies whether the matrix Q or the matrix P**H is
  required, as defined in the transformation applied by CGEBRD:
  = 'Q': generate Q;
  = 'P': generate P**H.

 K is INTEGER
  If VECT = 'Q', the number of columns in the original M-by-K
  matrix reduced by CGEBRD.
  If VECT = 'P', the number of rows in the original K-by-N
  matrix reduced by CGEBRD.
  K >= 0.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the vectors which define the elementary reflectors,
  as returned by CGEBRD.
  On exit, the M-by-N matrix Q or P**H.

 TAU is COMPLEX array, dimension
  (min(M,K)) if VECT = 'Q'
  (min(N,K)) if VECT = 'P'
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i) or G(i), which determines Q or P**H, as
  returned by CGEBRD in its array argument TAUQ or TAUP.

 */
inline proc ungbr(matrix_order : lapack_memory_order, vect : string, k : c_int, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cungbr(matrix_order, ascii(vect) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zungbr for the type lapack_complex_double.

For more information, see the documentation for :proc:`ungbr`, or consult the Netlibs or Intel documentation.
 */
inline proc ungbr(matrix_order : lapack_memory_order, vect : string, k : c_int, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zungbr(matrix_order, ascii(vect) : c_char, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunghr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNGHR::

 CUNGHR generates a complex unitary matrix Q which is defined as the
 product of IHI-ILO elementary reflectors of order N, as returned by
 CGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

Original Fortran LAPACK argument documentation for CUNGHR::

 N is INTEGER
  The order of the matrix Q. N >= 0.

 ILO is INTEGER

 IHI is INTEGER
 
  ILO and IHI must have the same values as in the previous call
  of CGEHRD. Q is equal to the unit matrix except in the
  submatrix Q(ilo+1:ihi,ilo+1:ihi).
  1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the vectors which define the elementary reflectors,
  as returned by CGEHRD.
  On exit, the N-by-N unitary matrix Q.

 TAU is COMPLEX array, dimension (N-1)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGEHRD.

 */
inline proc unghr(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cunghr(matrix_order, n, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunghr for the type lapack_complex_double.

For more information, see the documentation for :proc:`unghr`, or consult the Netlibs or Intel documentation.
 */
inline proc unghr(matrix_order : lapack_memory_order, n : c_int, ilo : c_int, ihi : c_int, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zunghr(matrix_order, n, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunglq for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNGLQ::

 CUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the first M rows of a product of K elementary
 reflectors of order N

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by CGELQF.

Original Fortran LAPACK argument documentation for CUNGLQ::

 K is INTEGER
  The number of elementary reflectors whose product defines the
  matrix Q. M >= K >= 0.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the i-th row must contain the vector which defines
  the elementary reflector H(i), for i = 1,2,...,k, as returned
  by CGELQF in the first k rows of its array argument A.
  On exit, the M-by-N matrix Q.

 TAU is COMPLEX array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGELQF.

 */
inline proc unglq(matrix_order : lapack_memory_order, k : c_int, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cunglq(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunglq for the type lapack_complex_double.

For more information, see the documentation for :proc:`unglq`, or consult the Netlibs or Intel documentation.
 */
inline proc unglq(matrix_order : lapack_memory_order, k : c_int, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zunglq(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cungql for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNGQL::

 CUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the last N columns of a product of K elementary
 reflectors of order M

 Q = H(k) . . . H(2) H(1)

 as returned by CGEQLF.

Original Fortran LAPACK argument documentation for CUNGQL::

 K is INTEGER
  The number of elementary reflectors whose product defines the
  matrix Q. N >= K >= 0.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the (n-k+i)-th column must contain the vector which
  defines the elementary reflector H(i), for i = 1,2,...,k, as
  returned by CGEQLF in the last k columns of its array
  argument A.
  On exit, the M-by-N matrix Q.

 TAU is COMPLEX array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGEQLF.

 */
inline proc ungql(matrix_order : lapack_memory_order, k : c_int, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cungql(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zungql for the type lapack_complex_double.

For more information, see the documentation for :proc:`ungql`, or consult the Netlibs or Intel documentation.
 */
inline proc ungql(matrix_order : lapack_memory_order, k : c_int, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zungql(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cungqr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNGQR::

 CUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
 which is defined as the first N columns of a product of K elementary
 reflectors of order M

 Q = H(1) H(2) . . . H(k)

 as returned by CGEQRF.

Original Fortran LAPACK argument documentation for CUNGQR::

 K is INTEGER
  The number of elementary reflectors whose product defines the
  matrix Q. N >= K >= 0.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the i-th column must contain the vector which
  defines the elementary reflector H(i), for i = 1,2,...,k, as
  returned by CGEQRF in the first k columns of its array
  argument A.
  On exit, the M-by-N matrix Q.

 TAU is COMPLEX array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGEQRF.

 */
inline proc ungqr(matrix_order : lapack_memory_order, k : c_int, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cungqr(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zungqr for the type lapack_complex_double.

For more information, see the documentation for :proc:`ungqr`, or consult the Netlibs or Intel documentation.
 */
inline proc ungqr(matrix_order : lapack_memory_order, k : c_int, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zungqr(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cungrq for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNGRQ::

 CUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
 which is defined as the last M rows of a product of K elementary
 reflectors of order N

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by CGERQF.

Original Fortran LAPACK argument documentation for CUNGRQ::

 K is INTEGER
  The number of elementary reflectors whose product defines the
  matrix Q. M >= K >= 0.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the (m-k+i)-th row must contain the vector which
  defines the elementary reflector H(i), for i = 1,2,...,k, as
  returned by CGERQF in the last k rows of its array argument
  A.
  On exit, the M-by-N matrix Q.

 TAU is COMPLEX array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGERQF.

 */
inline proc ungrq(matrix_order : lapack_memory_order, k : c_int, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cungrq(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zungrq for the type lapack_complex_double.

For more information, see the documentation for :proc:`ungrq`, or consult the Netlibs or Intel documentation.
 */
inline proc ungrq(matrix_order : lapack_memory_order, k : c_int, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zungrq(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cungtr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNGTR::

 CUNGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors of order N, as returned by
 CHETRD:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

Original Fortran LAPACK argument documentation for CUNGTR::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A contains elementary reflectors
  from CHETRD;
  = 'L': Lower triangle of A contains elementary reflectors
  from CHETRD.

 N is INTEGER
  The order of the matrix Q. N >= 0.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the vectors which define the elementary reflectors,
  as returned by CHETRD.
  On exit, the N-by-N unitary matrix Q.

 TAU is COMPLEX array, dimension (N-1)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CHETRD.

 */
inline proc ungtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(64), tau : [] complex(64)): c_int{
  return LAPACKE_cungtr(matrix_order, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zungtr for the type lapack_complex_double.

For more information, see the documentation for :proc:`ungtr`, or consult the Netlibs or Intel documentation.
 */
inline proc ungtr(matrix_order : lapack_memory_order, uplo : string, n : c_int, a : [] complex(128), tau : [] complex(128)): c_int{
  return LAPACKE_zungtr(matrix_order, ascii(uplo) : c_char, n, a, (a.domain.dim(2).size) : c_int, tau);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunmbr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNMBR::

 If VECT = 'Q', CUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C
 with
 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': P * C C * P
 TRANS = 'C': P**H * C C * P**H

 Here Q and P**H are the unitary matrices determined by CGEBRD when
 reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
 and P**H are defined as products of elementary reflectors H(i) and
 G(i) respectively.

 Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
 order of the unitary matrix Q or P**H that is applied.

 If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
 if nq >= k, Q = H(1) H(2) . . . H(k);
 if nq < k, Q = H(1) H(2) . . . H(nq-1).

 If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
 if k < nq, P = G(1) G(2) . . . G(k);
 if k >= nq, P = G(1) G(2) . . . G(nq-1).

Original Fortran LAPACK argument documentation for CUNMBR::

 VECT is CHARACTER*1
  = 'Q': apply Q or Q**H;
  = 'P': apply P or P**H.

 SIDE is CHARACTER*1
  = 'L': apply Q, Q**H, P or P**H from the Left;
  = 'R': apply Q, Q**H, P or P**H from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q or P;
  = 'C': Conjugate transpose, apply Q**H or P**H.

 K is INTEGER
  If VECT = 'Q', the number of columns in the original
  matrix reduced by CGEBRD.
  If VECT = 'P', the number of rows in the original
  matrix reduced by CGEBRD.
  K >= 0.

 A is COMPLEX array, dimension
  (LDA,min(nq,K)) if VECT = 'Q'
  (LDA,nq) if VECT = 'P'
  The vectors which define the elementary reflectors H(i) and
  G(i), whose products determine the matrices Q and P, as
  returned by CGEBRD.

 TAU is COMPLEX array, dimension (min(nq,K))
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i) or G(i) which determines Q or P, as returned
  by CGEBRD in the array argument TAUQ or TAUP.

 C is COMPLEX array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
  or P*C or P**H*C or C*P or C*P**H.

 */
inline proc unmbr(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, k : c_int, a : [] complex(64), tau : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cunmbr(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunmbr for the type lapack_complex_double.

For more information, see the documentation for :proc:`unmbr`, or consult the Netlibs or Intel documentation.
 */
inline proc unmbr(matrix_order : lapack_memory_order, vect : string, side : string, trans : string, k : c_int, a : [] complex(128), tau : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zunmbr(matrix_order, ascii(vect) : c_char, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunmhr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNMHR::

 CUNMHR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 IHI-ILO elementary reflectors, as returned by CGEHRD:

 Q = H(ilo) H(ilo+1) . . . H(ihi-1).

Original Fortran LAPACK argument documentation for CUNMHR::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**H from the Left;
  = 'R': apply Q or Q**H from the Right.

 TRANS is CHARACTER*1
  = 'N': apply Q (No transpose)
  = 'C': apply Q**H (Conjugate transpose)

 ILO is INTEGER

 IHI is INTEGER
 
  ILO and IHI must have the same values as in the previous call
  of CGEHRD. Q is equal to the unit matrix except in the
  submatrix Q(ilo+1:ihi,ilo+1:ihi).
  If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
  ILO = 1 and IHI = 0, if M = 0;
  if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
  ILO = 1 and IHI = 0, if N = 0.

 A is COMPLEX array, dimension
  (LDA,M) if SIDE = 'L'
  (LDA,N) if SIDE = 'R'
  The vectors which define the elementary reflectors, as
  returned by CGEHRD.

 TAU is COMPLEX array, dimension
  (M-1) if SIDE = 'L'
  (N-1) if SIDE = 'R'
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGEHRD.

 C is COMPLEX array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

 */
inline proc unmhr(matrix_order : lapack_memory_order, side : string, trans : string, ilo : c_int, ihi : c_int, a : [] complex(64), tau : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cunmhr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunmhr for the type lapack_complex_double.

For more information, see the documentation for :proc:`unmhr`, or consult the Netlibs or Intel documentation.
 */
inline proc unmhr(matrix_order : lapack_memory_order, side : string, trans : string, ilo : c_int, ihi : c_int, a : [] complex(128), tau : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zunmhr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, ilo, ihi, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunmlq for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNMLQ::

 CUNMLQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k)**H . . . H(2)**H H(1)**H

 as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for CUNMLQ::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**H from the Left;
  = 'R': apply Q or Q**H from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'C': Conjugate transpose, apply Q**H.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 A is COMPLEX array, dimension
  (LDA,M) if SIDE = 'L',
  (LDA,N) if SIDE = 'R'
  The i-th row must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  CGELQF in the first k rows of its array argument A.

 TAU is COMPLEX array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGELQF.

 C is COMPLEX array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

 */
inline proc unmlq(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] complex(64), tau : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cunmlq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunmlq for the type lapack_complex_double.

For more information, see the documentation for :proc:`unmlq`, or consult the Netlibs or Intel documentation.
 */
inline proc unmlq(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] complex(128), tau : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zunmlq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunmql for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNMQL::

 CUNMQL overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(k) . . . H(2) H(1)

 as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for CUNMQL::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**H from the Left;
  = 'R': apply Q or Q**H from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'C': Transpose, apply Q**H.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 A is COMPLEX array, dimension (LDA,K)
  The i-th column must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  CGEQLF in the last k columns of its array argument A.

 TAU is COMPLEX array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGEQLF.

 C is COMPLEX array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

 */
inline proc unmql(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] complex(64), tau : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cunmql(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunmql for the type lapack_complex_double.

For more information, see the documentation for :proc:`unmql`, or consult the Netlibs or Intel documentation.
 */
inline proc unmql(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] complex(128), tau : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zunmql(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunmqr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNMQR::

 CUNMQR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for CUNMQR::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**H from the Left;
  = 'R': apply Q or Q**H from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'C': Conjugate transpose, apply Q**H.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 A is COMPLEX array, dimension (LDA,K)
  The i-th column must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  CGEQRF in the first k columns of its array argument A.

 TAU is COMPLEX array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGEQRF.

 C is COMPLEX array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

 */
inline proc unmqr(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] complex(64), tau : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cunmqr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunmqr for the type lapack_complex_double.

For more information, see the documentation for :proc:`unmqr`, or consult the Netlibs or Intel documentation.
 */
inline proc unmqr(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] complex(128), tau : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zunmqr(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunmrq for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNMRQ::

 CUNMRQ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1)**H H(2)**H . . . H(k)**H

 as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for CUNMRQ::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**H from the Left;
  = 'R': apply Q or Q**H from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'C': Transpose, apply Q**H.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 A is COMPLEX array, dimension
  (LDA,M) if SIDE = 'L',
  (LDA,N) if SIDE = 'R'
  The i-th row must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  CGERQF in the last k rows of its array argument A.

 TAU is COMPLEX array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CGERQF.

 C is COMPLEX array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

 */
inline proc unmrq(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] complex(64), tau : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cunmrq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunmrq for the type lapack_complex_double.

For more information, see the documentation for :proc:`unmrq`, or consult the Netlibs or Intel documentation.
 */
inline proc unmrq(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, a : [] complex(128), tau : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zunmrq(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunmrz for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNMRZ::

 CUNMRZ overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix defined as the product of k
 elementary reflectors

 Q = H(1) H(2) . . . H(k)

 as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N
 if SIDE = 'R'.

Original Fortran LAPACK argument documentation for CUNMRZ::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**H from the Left;
  = 'R': apply Q or Q**H from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'C': Conjugate transpose, apply Q**H.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 L is INTEGER
  The number of columns of the matrix A containing
  the meaningful part of the Householder reflectors.
  If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.

 A is COMPLEX array, dimension
  (LDA,M) if SIDE = 'L',
  (LDA,N) if SIDE = 'R'
  The i-th row must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  CTZRZF in the last k rows of its array argument A.
  A is modified by the routine but restored on exit.

 TAU is COMPLEX array, dimension (K)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CTZRZF.

 C is COMPLEX array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

 */
inline proc unmrz(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, l : c_int, a : [] complex(64), tau : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cunmrz(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunmrz for the type lapack_complex_double.

For more information, see the documentation for :proc:`unmrz`, or consult the Netlibs or Intel documentation.
 */
inline proc unmrz(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, l : c_int, a : [] complex(128), tau : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zunmrz(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, l, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunmtr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNMTR::

 CUNMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by CHETRD:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

Original Fortran LAPACK argument documentation for CUNMTR::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**H from the Left;
  = 'R': apply Q or Q**H from the Right.

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A contains elementary reflectors
  from CHETRD;
  = 'L': Lower triangle of A contains elementary reflectors
  from CHETRD.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'C': Conjugate transpose, apply Q**H.

 A is COMPLEX array, dimension
  (LDA,M) if SIDE = 'L'
  (LDA,N) if SIDE = 'R'
  The vectors which define the elementary reflectors, as
  returned by CHETRD.

 TAU is COMPLEX array, dimension
  (M-1) if SIDE = 'L'
  (N-1) if SIDE = 'R'
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CHETRD.

 C is COMPLEX array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

 */
inline proc unmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, a : [] complex(64), tau : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cunmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunmtr for the type lapack_complex_double.

For more information, see the documentation for :proc:`unmtr`, or consult the Netlibs or Intel documentation.
 */
inline proc unmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, a : [] complex(128), tau : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zunmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cupgtr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUPGTR::

 CUPGTR generates a complex unitary matrix Q which is defined as the
 product of n-1 elementary reflectors H(i) of order n, as returned by
 CHPTRD using packed storage:

 if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),

 if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).

Original Fortran LAPACK argument documentation for CUPGTR::

 UPLO is CHARACTER*1
  = 'U': Upper triangular packed storage used in previous
  call to CHPTRD;
  = 'L': Lower triangular packed storage used in previous
  call to CHPTRD.

 AP is COMPLEX array, dimension (N*(N+1)/2)
  The vectors which define the elementary reflectors, as
  returned by CHPTRD.

 TAU is COMPLEX array, dimension (N-1)
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CHPTRD.

 Q is COMPLEX array, dimension (LDQ,N)
  The N-by-N unitary matrix Q.

 */
inline proc upgtr(matrix_order : lapack_memory_order, uplo : string, ap : [] complex(64), tau : [] complex(64), q : [] complex(64)): c_int{
  return LAPACKE_cupgtr(matrix_order, ascii(uplo) : c_char, (q.domain.dim(1).size) : c_int, ap, tau, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zupgtr for the type lapack_complex_double.

For more information, see the documentation for :proc:`upgtr`, or consult the Netlibs or Intel documentation.
 */
inline proc upgtr(matrix_order : lapack_memory_order, uplo : string, ap : [] complex(128), tau : [] complex(128), q : [] complex(128)): c_int{
  return LAPACKE_zupgtr(matrix_order, ascii(uplo) : c_char, (q.domain.dim(1).size) : c_int, ap, tau, q, (q.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cupmtr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUPMTR::

 CUPMTR overwrites the general complex M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q * C C * Q
 TRANS = 'C': Q**H * C C * Q**H

 where Q is a complex unitary matrix of order nq, with nq = m if
 SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
 nq-1 elementary reflectors, as returned by CHPTRD using packed
 storage:

 if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

 if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

Original Fortran LAPACK argument documentation for CUPMTR::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**H from the Left;
  = 'R': apply Q or Q**H from the Right.

 UPLO is CHARACTER*1
  = 'U': Upper triangular packed storage used in previous
  call to CHPTRD;
  = 'L': Lower triangular packed storage used in previous
  call to CHPTRD.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'C': Conjugate transpose, apply Q**H.

 AP is COMPLEX array, dimension
  (M*(M+1)/2) if SIDE = 'L'
  (N*(N+1)/2) if SIDE = 'R'
  The vectors which define the elementary reflectors, as
  returned by CHPTRD. AP is modified by the routine but
  restored on exit.

 TAU is COMPLEX array, dimension (M-1) if SIDE = 'L'
  or (N-1) if SIDE = 'R'
  TAU(i) must contain the scalar factor of the elementary
  reflector H(i), as returned by CHPTRD.

 C is COMPLEX array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

 */
inline proc upmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, ap : [] complex(64), tau : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cupmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, ap, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zupmtr for the type lapack_complex_double.

For more information, see the documentation for :proc:`upmtr`, or consult the Netlibs or Intel documentation.
 */
inline proc upmtr(matrix_order : lapack_memory_order, side : string, uplo : string, trans : string, ap : [] complex(128), tau : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zupmtr(matrix_order, ascii(side) : c_char, ascii(uplo) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, ap, tau, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_claghe for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CLAGHE::

 CLAGHE generates a complex hermitian matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 unitary transformations.

Original Fortran LAPACK argument documentation for CLAGHE::

 K is INTEGER
  The number of nonzero subdiagonals within the band of A.
  0 <= K <= N-1.

 D is REAL array, dimension (N)
  The diagonal elements of the diagonal matrix D.

 A is COMPLEX array, dimension (LDA,N)
  The generated n by n hermitian matrix A (the full matrix is
  stored).

 ISEED is INTEGER array, dimension (4)
  On entry, the seed of the random number generator; the array
  elements must be between 0 and 4095, and ISEED(4) must be
  odd.
  On exit, the seed is updated.

 */
inline proc laghe(matrix_order : lapack_memory_order, k : c_int, d : [] c_float, a : [] complex(64), iseed : [] c_int): c_int{
  return LAPACKE_claghe(matrix_order, (a.domain.dim(1).size) : c_int, k, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlaghe for the type lapack_complex_double.

For more information, see the documentation for :proc:`laghe`, or consult the Netlibs or Intel documentation.
 */
inline proc laghe(matrix_order : lapack_memory_order, k : c_int, d : [] c_double, a : [] complex(128), iseed : [] c_int): c_int{
  return LAPACKE_zlaghe(matrix_order, (a.domain.dim(1).size) : c_int, k, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slagsy for the type c_float.

Original Fortran LAPACK purpose documentation for SLAGSY::

 SLAGSY generates a real symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random orthogonal matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 orthogonal transformations.

Original Fortran LAPACK argument documentation for SLAGSY::

 K is INTEGER
  The number of nonzero subdiagonals within the band of A.
  0 <= K <= N-1.

 D is REAL array, dimension (N)
  The diagonal elements of the diagonal matrix D.

 A is REAL array, dimension (LDA,N)
  The generated n by n symmetric matrix A (the full matrix is
  stored).

 ISEED is INTEGER array, dimension (4)
  On entry, the seed of the random number generator; the array
  elements must be between 0 and 4095, and ISEED(4) must be
  odd.
  On exit, the seed is updated.

 */
inline proc lagsy(matrix_order : lapack_memory_order, k : c_int, d : [] c_float, a : [] c_float, iseed : [] c_int): c_int{
  return LAPACKE_slagsy(matrix_order, (a.domain.dim(1).size) : c_int, k, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlagsy for the type c_double.

For more information, see the documentation for :proc:`lagsy`, or consult the Netlibs or Intel documentation.
 */
inline proc lagsy(matrix_order : lapack_memory_order, k : c_int, d : [] c_double, a : [] c_double, iseed : [] c_int): c_int{
  return LAPACKE_dlagsy(matrix_order, (a.domain.dim(1).size) : c_int, k, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clagsy for the type lapack_complex_float.

For more information, see the documentation for :proc:`lagsy`, or consult the Netlibs or Intel documentation.
 */
inline proc lagsy(matrix_order : lapack_memory_order, k : c_int, d : [] c_float, a : [] complex(64), iseed : [] c_int): c_int{
  return LAPACKE_clagsy(matrix_order, (a.domain.dim(1).size) : c_int, k, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlagsy for the type lapack_complex_double.

For more information, see the documentation for :proc:`lagsy`, or consult the Netlibs or Intel documentation.
 */
inline proc lagsy(matrix_order : lapack_memory_order, k : c_int, d : [] c_double, a : [] complex(128), iseed : [] c_int): c_int{
  return LAPACKE_zlagsy(matrix_order, (a.domain.dim(1).size) : c_int, k, d, a, (a.domain.dim(2).size) : c_int, iseed);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slapmr for the type c_float.

Original Fortran LAPACK purpose documentation for SLAPMR::

 SLAPMR rearranges the rows of the M by N matrix X as specified
 by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
 If FORWRD = .TRUE., forward permutation:

 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

 If FORWRD = .FALSE., backward permutation:

 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

Original Fortran LAPACK argument documentation for SLAPMR::

 FORWRD is LOGICAL
  = .TRUE., forward permutation
  = .FALSE., backward permutation

 X is REAL array, dimension (LDX,N)
  On entry, the M by N matrix X.
  On exit, X contains the permuted matrix X.

 K is INTEGER array, dimension (M)
  On entry, K contains the permutation vector. K is used as
  internal workspace, but reset to its original value on
  output.

 */
inline proc lapmr(matrix_order : lapack_memory_order, forwrd : c_int, x : [] c_float, k : [] c_int): c_int{
  return LAPACKE_slapmr(matrix_order, forwrd, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(1).size else x.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(2).size else x.domain.dim(1).size) : c_int, x, (x.domain.dim(2).size) : c_int, k);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlapmr for the type c_double.

For more information, see the documentation for :proc:`lapmr`, or consult the Netlibs or Intel documentation.
 */
inline proc lapmr(matrix_order : lapack_memory_order, forwrd : c_int, x : [] c_double, k : [] c_int): c_int{
  return LAPACKE_dlapmr(matrix_order, forwrd, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(1).size else x.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(2).size else x.domain.dim(1).size) : c_int, x, (x.domain.dim(2).size) : c_int, k);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_clapmr for the type lapack_complex_float.

For more information, see the documentation for :proc:`lapmr`, or consult the Netlibs or Intel documentation.
 */
inline proc lapmr(matrix_order : lapack_memory_order, forwrd : c_int, x : [] complex(64), k : [] c_int): c_int{
  return LAPACKE_clapmr(matrix_order, forwrd, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(1).size else x.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(2).size else x.domain.dim(1).size) : c_int, x, (x.domain.dim(2).size) : c_int, k);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zlapmr for the type lapack_complex_double.

For more information, see the documentation for :proc:`lapmr`, or consult the Netlibs or Intel documentation.
 */
inline proc lapmr(matrix_order : lapack_memory_order, forwrd : c_int, x : [] complex(128), k : [] c_int): c_int{
  return LAPACKE_zlapmr(matrix_order, forwrd, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(1).size else x.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x.domain.dim(2).size else x.domain.dim(1).size) : c_int, x, (x.domain.dim(2).size) : c_int, k);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slapy2 for the type c_float.

Original Fortran LAPACK purpose documentation for SLAPY2::

 SLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
 overflow.

Original Fortran LAPACK argument documentation for SLAPY2::

 X is REAL

 Y is REAL
  X and Y specify the values x and y.

 */
inline proc lapy2(x : c_float, y : c_float): c_float{
  return LAPACKE_slapy2(x, y);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlapy2 for the type c_double.

For more information, see the documentation for :proc:`lapy2`, or consult the Netlibs or Intel documentation.
 */
inline proc lapy2(x : c_double, y : c_double): c_double{
  return LAPACKE_dlapy2(x, y);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slapy3 for the type c_float.

Original Fortran LAPACK purpose documentation for SLAPY3::

 SLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
 unnecessary overflow.

Original Fortran LAPACK argument documentation for SLAPY3::

 X is REAL

 Y is REAL

 Z is REAL
  X, Y and Z specify the values x, y and z.

 */
inline proc lapy3(x : c_float, y : c_float, z : c_float): c_float{
  return LAPACKE_slapy3(x, y, z);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlapy3 for the type c_double.

For more information, see the documentation for :proc:`lapy3`, or consult the Netlibs or Intel documentation.
 */
inline proc lapy3(x : c_double, y : c_double, z : c_double): c_double{
  return LAPACKE_dlapy3(x, y, z);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slartgp for the type c_float.

Original Fortran LAPACK purpose documentation for SLARTGP::

 SLARTGP generates a plane rotation so that

 [ CS SN ] . [ F ] = [ R ] where CS**2 + SN**2 = 1.
 [ -SN CS ] [ G ] [ 0 ]

 This is a slower, more accurate version of the Level 1 BLAS routine SROTG,
 with the following other differences:
 F and G are unchanged on return.
 If G=0, then CS=(+/-)1 and SN=0.
 If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.

 The sign is chosen so that R >= 0.

Original Fortran LAPACK argument documentation for SLARTGP::

 F is REAL
  The first component of vector to be rotated.

 G is REAL
  The second component of vector to be rotated.

 CS is REAL
  The cosine of the rotation.

 SN is REAL
  The sine of the rotation.

 R is REAL
  The nonzero component of the rotated vector.
 
  This version has a few statements commented out for thread safety
  (machine parameters are computed on each entry). 10 feb 03, SJH.

 */
inline proc lartgp(f : c_float, g : c_float, ref cs : c_float, ref sn : c_float, ref r : c_float): c_int{
  return LAPACKE_slartgp(f, g, cs, sn, r);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlartgp for the type c_double.

For more information, see the documentation for :proc:`lartgp`, or consult the Netlibs or Intel documentation.
 */
inline proc lartgp(f : c_double, g : c_double, ref cs : c_double, ref sn : c_double, ref r : c_double): c_int{
  return LAPACKE_dlartgp(f, g, cs, sn, r);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_slartgs for the type c_float.

Original Fortran LAPACK purpose documentation for SLARTGS::

 SLARTGS generates a plane rotation designed to introduce a bulge in
 Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
 problem. X and Y are the top-row entries, and SIGMA is the shift.
 The computed CS and SN define a plane rotation satisfying

 [ CS SN ] . [ X^2 - SIGMA ] = [ R ],
 [ -SN CS ] [ X * Y ] [ 0 ]

 with R nonnegative. If X^2 - SIGMA and X * Y are 0, then the
 rotation is by PI/2.

Original Fortran LAPACK argument documentation for SLARTGS::

 X is REAL
  The (1,1) entry of an upper bidiagonal matrix.

 Y is REAL
  The (1,2) entry of an upper bidiagonal matrix.

 SIGMA is REAL
  The shift.

 CS is REAL
  The cosine of the rotation.

 SN is REAL
  The sine of the rotation.

 */
inline proc lartgs(x : c_float, y : c_float, sigma : c_float, ref cs : c_float, ref sn : c_float): c_int{
  return LAPACKE_slartgs(x, y, sigma, cs, sn);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dlartgs for the type c_double.

For more information, see the documentation for :proc:`lartgs`, or consult the Netlibs or Intel documentation.
 */
inline proc lartgs(x : c_double, y : c_double, sigma : c_double, ref cs : c_double, ref sn : c_double): c_int{
  return LAPACKE_dlartgs(x, y, sigma, cs, sn);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cbbcsd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CBBCSD::

 CBBCSD computes the CS decomposition of a unitary matrix in
 bidiagonal-block form,


 [ B11 | B12 0 0 ]
 [ 0 | 0 -I 0 ]
 X = [----------------]
 [ B21 | B22 0 0 ]
 [ 0 | 0 0 I ]

 [ C | -S 0 0 ]
 [ U1 | ] [ 0 | 0 -I 0 ] [ V1 | ]**H
 = [---------] [---------------] [---------] .
 [ | U2 ] [ S | C 0 0 ] [ | V2 ]
 [ 0 | 0 0 I ]

 X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
 than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
 transposed and/or permuted. This can be done in constant time using
 the TRANS and SIGNS options. See CUNCSD for details.)

 The bidiagonal matrices B11, B12, B21, and B22 are represented
 implicitly by angles THETA(1:Q) and PHI(1:Q-1).

 The unitary matrices U1, U2, V1T, and V2T are input/output.
 The input matrices are pre- or post-multiplied by the appropriate
 singular vector matrices.

Original Fortran LAPACK argument documentation for CBBCSD::

 JOBU1 is CHARACTER
  = 'Y': U1 is updated;
  otherwise: U1 is not updated.

 JOBU2 is CHARACTER
  = 'Y': U2 is updated;
  otherwise: U2 is not updated.

 JOBV1T is CHARACTER
  = 'Y': V1T is updated;
  otherwise: V1T is not updated.

 JOBV2T is CHARACTER
  = 'Y': V2T is updated;
  otherwise: V2T is not updated.

 TRANS is CHARACTER
  = 'T': X, U1, U2, V1T, and V2T are stored in row-major
  order;
  otherwise: X, U1, U2, V1T, and V2T are stored in column-
  major order.

 M is INTEGER
  The number of rows and columns in X, the unitary matrix in
  bidiagonal-block form.

 THETA is REAL array, dimension (Q)
  On entry, the angles THETA(1),...,THETA(Q) that, along with
  PHI(1), ...,PHI(Q-1), define the matrix in bidiagonal-block
  form. On exit, the angles whose cosines and sines define the
  diagonal blocks in the CS decomposition.

 PHI is REAL array, dimension (Q-1)
  The angles PHI(1),...,PHI(Q-1) that, along with THETA(1),...,
  THETA(Q), define the matrix in bidiagonal-block form.

 U1 is COMPLEX array, dimension (LDU1,P)
  On entry, an LDU1-by-P matrix. On exit, U1 is postmultiplied
  by the left singular vector matrix common to [ B11 ; 0 ] and
  [ B12 0 0 ; 0 -I 0 0 ].

 U2 is COMPLEX array, dimension (LDU2,M-P)
  On entry, an LDU2-by-(M-P) matrix. On exit, U2 is
  postmultiplied by the left singular vector matrix common to
  [ B21 ; 0 ] and [ B22 0 0 ; 0 0 I ].

 V1T is COMPLEX array, dimension (LDV1T,Q)
  On entry, a LDV1T-by-Q matrix. On exit, V1T is premultiplied
  by the conjugate transpose of the right singular vector
  matrix common to [ B11 ; 0 ] and [ B21 ; 0 ].

 V2T is COMPLEX array, dimenison (LDV2T,M-Q)
  On entry, a LDV2T-by-(M-Q) matrix. On exit, V2T is
  premultiplied by the conjugate transpose of the right
  singular vector matrix common to [ B12 0 0 ; 0 -I 0 ] and
  [ B22 0 0 ; 0 0 I ].

 B11D is REAL array, dimension (Q)
  When CBBCSD converges, B11D contains the cosines of THETA(1),
  ..., THETA(Q). If CBBCSD fails to converge, then B11D
  contains the diagonal of the partially reduced top-left
  block.

 B11E is REAL array, dimension (Q-1)
  When CBBCSD converges, B11E contains zeros. If CBBCSD fails
  to converge, then B11E contains the superdiagonal of the
  partially reduced top-left block.

 B12D is REAL array, dimension (Q)
  When CBBCSD converges, B12D contains the negative sines of
  THETA(1), ..., THETA(Q). If CBBCSD fails to converge, then
  B12D contains the diagonal of the partially reduced top-right
  block.

 B12E is REAL array, dimension (Q-1)
  When CBBCSD converges, B12E contains zeros. If CBBCSD fails
  to converge, then B12E contains the subdiagonal of the
  partially reduced top-right block.

 B21D is REAL array, dimension (Q)
  When CBBCSD converges, B21D contains the negative sines of
  THETA(1), ..., THETA(Q). If CBBCSD fails to converge, then
  B21D contains the diagonal of the partially reduced bottom-left
  block.

 B21E is REAL array, dimension (Q-1)
  When CBBCSD converges, B21E contains zeros. If CBBCSD fails
  to converge, then B21E contains the subdiagonal of the
  partially reduced bottom-left block.

 B22D is REAL array, dimension (Q)
  When CBBCSD converges, B22D contains the negative sines of
  THETA(1), ..., THETA(Q). If CBBCSD fails to converge, then
  B22D contains the diagonal of the partially reduced bottom-right
  block.

 B22E is REAL array, dimension (Q-1)
  When CBBCSD converges, B22E contains zeros. If CBBCSD fails
  to converge, then B22E contains the subdiagonal of the
  partially reduced bottom-right block.

 */
inline proc bbcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, theta : [] c_float, phi : [] c_float, u1 : [] complex(64), u2 : [] complex(64), v1t : [] complex(64), v2t : [] complex(64), b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float): c_int{
  return LAPACKE_cbbcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, (if matrix_order == lapack_memory_order.row_major then u1.domain.dim(2).size else u1.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then v1t.domain.dim(2).size else v1t.domain.dim(1).size) : c_int, theta, phi, u1, (if matrix_order == lapack_memory_order.row_major then u1.domain.dim(1).size else u1.domain.dim(2).size) : c_int, u2, (u2.domain.dim(2).size) : c_int, v1t, (if matrix_order == lapack_memory_order.row_major then v1t.domain.dim(1).size else v1t.domain.dim(2).size) : c_int, v2t, (v2t.domain.dim(2).size) : c_int, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cheswapr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHESWAPR::

 CHESWAPR applies an elementary permutation on the rows and the columns of
 a hermitian matrix.

Original Fortran LAPACK argument documentation for CHESWAPR::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the NB diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by CSYTRF.
 
  On exit, if INFO = 0, the (symmetric) inverse of the original
  matrix. If UPLO = 'U', the upper triangular part of the
  inverse is formed and the part of A below the diagonal is not
  referenced; if UPLO = 'L' the lower triangular part of the
  inverse is formed and the part of A above the diagonal is
  not referenced.

 I1 is INTEGER
  Index of the first row to swap

 I2 is INTEGER
  Index of the second row to swap

 */
inline proc heswapr(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), i1 : c_int, i2 : c_int): c_int{
  return LAPACKE_cheswapr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, i1, i2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chetri2 for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHETRI2::

 CHETRI2 computes the inverse of a COMPLEX hermitian indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CHETRF. CHETRI2 set the LEADING DIMENSION of the workspace
 before calling CHETRI2X that actually computes the inverse.

Original Fortran LAPACK argument documentation for CHETRI2::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the NB diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by CHETRF.
 
  On exit, if INFO = 0, the (symmetric) inverse of the original
  matrix. If UPLO = 'U', the upper triangular part of the
  inverse is formed and the part of A below the diagonal is not
  referenced; if UPLO = 'L' the lower triangular part of the
  inverse is formed and the part of A above the diagonal is
  not referenced.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the NB structure of D
  as determined by CHETRF.

 */
inline proc hetri2(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_chetri2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chetri2x for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHETRI2X::

 CHETRI2X computes the inverse of a complex Hermitian indefinite matrix
 A using the factorization A = U*D*U**H or A = L*D*L**H computed by
 CHETRF.

Original Fortran LAPACK argument documentation for CHETRI2X::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**H;
  = 'L': Lower triangular, form is A = L*D*L**H.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the NNB diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by CHETRF.
 
  On exit, if INFO = 0, the (symmetric) inverse of the original
  matrix. If UPLO = 'U', the upper triangular part of the
  inverse is formed and the part of A below the diagonal is not
  referenced; if UPLO = 'L' the lower triangular part of the
  inverse is formed and the part of A above the diagonal is
  not referenced.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the NNB structure of D
  as determined by CHETRF.

 NB is INTEGER
  Block size

 */
inline proc hetri2x(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, nb : c_int): c_int{
  return LAPACKE_chetri2x(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, nb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_chetrs2 for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CHETRS2::

 CHETRS2 solves a system of linear equations A*X = B with a complex
 Hermitian matrix A using the factorization A = U*D*U**H or
 A = L*D*L**H computed by CHETRF and converted by CSYCONV.

Original Fortran LAPACK argument documentation for CHETRS2::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**H;
  = 'L': Lower triangular, form is A = L*D*L**H.

 A is COMPLEX array, dimension (LDA,N)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by CHETRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CHETRF.

 B is COMPLEX array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc hetrs2(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_chetrs2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csyconv for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CSYCONV::

 CSYCONV convert A given by TRF into L and D and vice-versa.
 Get Non-diag elements of D (returned in workspace) and 
 apply or reverse permutation done in TRF.

Original Fortran LAPACK argument documentation for CSYCONV::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 WAY is CHARACTER*1
  = 'C': Convert 
  = 'R': Revert

 A is COMPLEX array, dimension (LDA,N)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by CSYTRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CSYTRF.

 */
inline proc syconv(matrix_order : lapack_memory_order, uplo : string, way : string, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_csyconv(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csyswapr for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CSYSWAPR::

 CSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.

Original Fortran LAPACK argument documentation for CSYSWAPR::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the NB diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by CSYTRF.
 
  On exit, if INFO = 0, the (symmetric) inverse of the original
  matrix. If UPLO = 'U', the upper triangular part of the
  inverse is formed and the part of A below the diagonal is not
  referenced; if UPLO = 'L' the lower triangular part of the
  inverse is formed and the part of A above the diagonal is
  not referenced.

 I1 is INTEGER
  Index of the first row to swap

 I2 is INTEGER
  Index of the second row to swap

 */
inline proc syswapr(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), i1 : c_int, i2 : c_int): c_int{
  return LAPACKE_csyswapr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, i1, i2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csytri2 for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CSYTRI2::

 CSYTRI2 computes the inverse of a COMPLEX symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CSYTRF. CSYTRI2 sets the LEADING DIMENSION of the workspace
 before calling CSYTRI2X that actually computes the inverse.

Original Fortran LAPACK argument documentation for CSYTRI2::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the NB diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by CSYTRF.
 
  On exit, if INFO = 0, the (symmetric) inverse of the original
  matrix. If UPLO = 'U', the upper triangular part of the
  inverse is formed and the part of A below the diagonal is not
  referenced; if UPLO = 'L' the lower triangular part of the
  inverse is formed and the part of A above the diagonal is
  not referenced.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the NB structure of D
  as determined by CSYTRF.

 */
inline proc sytri2(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int): c_int{
  return LAPACKE_csytri2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csytri2x for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CSYTRI2X::

 CSYTRI2X computes the inverse of a real symmetric indefinite matrix
 A using the factorization A = U*D*U**T or A = L*D*L**T computed by
 CSYTRF.

Original Fortran LAPACK argument documentation for CSYTRI2X::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is COMPLEX array, dimension (LDA,N)
  On entry, the NNB diagonal matrix D and the multipliers
  used to obtain the factor U or L as computed by CSYTRF.
 
  On exit, if INFO = 0, the (symmetric) inverse of the original
  matrix. If UPLO = 'U', the upper triangular part of the
  inverse is formed and the part of A below the diagonal is not
  referenced; if UPLO = 'L' the lower triangular part of the
  inverse is formed and the part of A above the diagonal is
  not referenced.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the NNB structure of D
  as determined by CSYTRF.

 NB is INTEGER
  Block size

 */
inline proc sytri2x(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, nb : c_int): c_int{
  return LAPACKE_csytri2x(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, nb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csytrs2 for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CSYTRS2::

 CSYTRS2 solves a system of linear equations A*X = B with a COMPLEX
 symmetric matrix A using the factorization A = U*D*U**T or
 A = L*D*L**T computed by CSYTRF and converted by CSYCONV.

Original Fortran LAPACK argument documentation for CSYTRS2::

 UPLO is CHARACTER*1
  Specifies whether the details of the factorization are stored
  as an upper or lower triangular matrix.
  = 'U': Upper triangular, form is A = U*D*U**T;
  = 'L': Lower triangular, form is A = L*D*L**T.

 A is COMPLEX array, dimension (LDA,N)
  The block diagonal matrix D and the multipliers used to
  obtain the factor U or L as computed by CSYTRF.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D
  as determined by CSYTRF.

 B is COMPLEX array, dimension (LDB,NRHS)
  On entry, the right hand side matrix B.
  On exit, the solution matrix X.

 */
inline proc sytrs2(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_csytrs2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cunbdb for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNBDB::

 CUNBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned unitary matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**H
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See CUNCSD
 for details.)

 The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

Original Fortran LAPACK argument documentation for CUNBDB::

 TRANS is CHARACTER
  = 'T': X, U1, U2, V1T, and V2T are stored in row-major
  order;
  otherwise: X, U1, U2, V1T, and V2T are stored in column-
  major order.

 SIGNS is CHARACTER
  = 'O': The lower-left block is made nonpositive (the
  "other" convention);
  otherwise: The upper-right block is made nonpositive (the
  "default" convention).

 M is INTEGER
  The number of rows and columns in X.

 X11 is COMPLEX array, dimension (LDX11,Q)
  On entry, the top-left block of the unitary matrix to be
  reduced. On exit, the form depends on TRANS:
  If TRANS = 'N', then
  the columns of tril(X11) specify reflectors for P1,
  the rows of triu(X11,1) specify reflectors for Q1;
  else TRANS = 'T', and
  the rows of triu(X11) specify reflectors for P1,
  the columns of tril(X11,-1) specify reflectors for Q1.

 X12 is COMPLEX array, dimension (LDX12,M-Q)
  On entry, the top-right block of the unitary matrix to
  be reduced. On exit, the form depends on TRANS:
  If TRANS = 'N', then
  the rows of triu(X12) specify the first P reflectors for
  Q2;
  else TRANS = 'T', and
  the columns of tril(X12) specify the first P reflectors
  for Q2.

 X21 is COMPLEX array, dimension (LDX21,Q)
  On entry, the bottom-left block of the unitary matrix to
  be reduced. On exit, the form depends on TRANS:
  If TRANS = 'N', then
  the columns of tril(X21) specify reflectors for P2;
  else TRANS = 'T', and
  the rows of triu(X21) specify reflectors for P2.

 X22 is COMPLEX array, dimension (LDX22,M-Q)
  On entry, the bottom-right block of the unitary matrix to
  be reduced. On exit, the form depends on TRANS:
  If TRANS = 'N', then
  the rows of triu(X22(Q+1:M-P,P+1:M-Q)) specify the last
  M-P-Q reflectors for Q2,
  else TRANS = 'T', and
  the columns of tril(X22(P+1:M-Q,Q+1:M-P)) specify the last
  M-P-Q reflectors for P2.

 THETA is REAL array, dimension (Q)
  The entries of the bidiagonal blocks B11, B12, B21, B22 can
  be computed from the angles THETA and PHI. See Further
  Details.

 PHI is REAL array, dimension (Q-1)
  The entries of the bidiagonal blocks B11, B12, B21, B22 can
  be computed from the angles THETA and PHI. See Further
  Details.

 TAUP1 is COMPLEX array, dimension (P)
  The scalar factors of the elementary reflectors that define
  P1.

 TAUP2 is COMPLEX array, dimension (M-P)
  The scalar factors of the elementary reflectors that define
  P2.

 TAUQ1 is COMPLEX array, dimension (Q)
  The scalar factors of the elementary reflectors that define
  Q1.

 TAUQ2 is COMPLEX array, dimension (M-Q)
  The scalar factors of the elementary reflectors that define
  Q2.

 */
inline proc unbdb(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, x11 : [] complex(64), x12 : [] complex(64), x21 : [] complex(64), x22 : [] complex(64), theta : [] c_float, phi : [] c_float, taup1 : [] complex(64), taup2 : [] complex(64), tauq1 : [] complex(64), tauq2 : [] complex(64)): c_int{
  return LAPACKE_cunbdb(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(1).size else x11.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(2).size else x11.domain.dim(1).size) : c_int, x11, (x11.domain.dim(2).size) : c_int, x12, (x12.domain.dim(2).size) : c_int, x21, (x21.domain.dim(2).size) : c_int, x22, (x22.domain.dim(2).size) : c_int, theta, phi, taup1, taup2, tauq1, tauq2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cuncsd for the type lapack_complex_float.

Original Fortran LAPACK purpose documentation for CUNCSD::

 CUNCSD computes the CS decomposition of an M-by-M partitioned
 unitary matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**H
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

Original Fortran LAPACK argument documentation for CUNCSD::

 JOBU1 is CHARACTER
  = 'Y': U1 is computed;
  otherwise: U1 is not computed.

 JOBU2 is CHARACTER
  = 'Y': U2 is computed;
  otherwise: U2 is not computed.

 JOBV1T is CHARACTER
  = 'Y': V1T is computed;
  otherwise: V1T is not computed.

 JOBV2T is CHARACTER
  = 'Y': V2T is computed;
  otherwise: V2T is not computed.

 TRANS is CHARACTER
  = 'T': X, U1, U2, V1T, and V2T are stored in row-major
  order;
  otherwise: X, U1, U2, V1T, and V2T are stored in column-
  major order.

 SIGNS is CHARACTER
  = 'O': The lower-left block is made nonpositive (the
  "other" convention);
  otherwise: The upper-right block is made nonpositive (the
  "default" convention).

 M is INTEGER
  The number of rows and columns in X.

 X11 is COMPLEX array, dimension (LDX11,Q)
  On entry, part of the unitary matrix whose CSD is desired.

 X12 is COMPLEX array, dimension (LDX12,M-Q)
  On entry, part of the unitary matrix whose CSD is desired.

 X21 is COMPLEX array, dimension (LDX21,Q)
  On entry, part of the unitary matrix whose CSD is desired.

 X22 is COMPLEX array, dimension (LDX22,M-Q)
  On entry, part of the unitary matrix whose CSD is desired.

 THETA is REAL array, dimension (R), in which R =
  MIN(P,M-P,Q,M-Q).
  C = DIAG( COS(THETA(1)), ... , COS(THETA(R)) ) and
  S = DIAG( SIN(THETA(1)), ... , SIN(THETA(R)) ).

 U1 is COMPLEX array, dimension (P)
  If JOBU1 = 'Y', U1 contains the P-by-P unitary matrix U1.

 U2 is COMPLEX array, dimension (M-P)
  If JOBU2 = 'Y', U2 contains the (M-P)-by-(M-P) unitary
  matrix U2.

 V1T is COMPLEX array, dimension (Q)
  If JOBV1T = 'Y', V1T contains the Q-by-Q matrix unitary
  matrix V1**H.

 V2T is COMPLEX array, dimension (M-Q)
  If JOBV2T = 'Y', V2T contains the (M-Q)-by-(M-Q) unitary
  matrix V2**H.

 */
inline proc uncsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, x11 : [] complex(64), x12 : [] complex(64), x21 : [] complex(64), x22 : [] complex(64), theta : [] c_float, u1 : [] complex(64), u2 : [] complex(64), v1t : [] complex(64), v2t : [] complex(64)): c_int{
  return LAPACKE_cuncsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(1).size else x11.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(2).size else x11.domain.dim(1).size) : c_int, x11, (x11.domain.dim(2).size) : c_int, x12, (x12.domain.dim(2).size) : c_int, x21, (x21.domain.dim(2).size) : c_int, x22, (x22.domain.dim(2).size) : c_int, theta, u1, (u1.domain.dim(2).size) : c_int, u2, (u2.domain.dim(2).size) : c_int, v1t, (v1t.domain.dim(2).size) : c_int, v2t, (v2t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dbbcsd for the type c_double.

For more information, see the documentation for :proc:`bbcsd`, or consult the Netlibs or Intel documentation.
 */
inline proc bbcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, theta : [] c_double, phi : [] c_double, u1 : [] c_double, u2 : [] c_double, v1t : [] c_double, v2t : [] c_double, b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double): c_int{
  return LAPACKE_dbbcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, (if matrix_order == lapack_memory_order.row_major then u1.domain.dim(2).size else u1.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then v1t.domain.dim(2).size else v1t.domain.dim(1).size) : c_int, theta, phi, u1, (if matrix_order == lapack_memory_order.row_major then u1.domain.dim(1).size else u1.domain.dim(2).size) : c_int, u2, (u2.domain.dim(2).size) : c_int, v1t, (if matrix_order == lapack_memory_order.row_major then v1t.domain.dim(1).size else v1t.domain.dim(2).size) : c_int, v2t, (v2t.domain.dim(2).size) : c_int, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dorbdb for the type c_double.

Original Fortran LAPACK purpose documentation for DORBDB::

 DORBDB simultaneously bidiagonalizes the blocks of an M-by-M
 partitioned orthogonal matrix X:

 [ B11 | B12 0 0 ]
 [ X11 | X12 ] [ P1 | ] [ 0 | 0 -I 0 ] [ Q1 | ]**T
 X = [-----------] = [---------] [----------------] [---------] .
 [ X21 | X22 ] [ | P2 ] [ B21 | B22 0 0 ] [ | Q2 ]
 [ 0 | 0 0 I ]

 X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
 not the case, then X must be transposed and/or permuted. This can be
 done in constant time using the TRANS and SIGNS options. See DORCSD
 for details.)

 The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
 (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
 represented implicitly by Householder vectors.

 B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
 implicitly by angles THETA, PHI.

Original Fortran LAPACK argument documentation for DORBDB::

 TRANS is CHARACTER
  = 'T': X, U1, U2, V1T, and V2T are stored in row-major
  order;
  otherwise: X, U1, U2, V1T, and V2T are stored in column-
  major order.

 SIGNS is CHARACTER
  = 'O': The lower-left block is made nonpositive (the
  "other" convention);
  otherwise: The upper-right block is made nonpositive (the
  "default" convention).

 M is INTEGER
  The number of rows and columns in X.

 X11 is DOUBLE PRECISION array, dimension (LDX11,Q)
  On entry, the top-left block of the orthogonal matrix to be
  reduced. On exit, the form depends on TRANS:
  If TRANS = 'N', then
  the columns of tril(X11) specify reflectors for P1,
  the rows of triu(X11,1) specify reflectors for Q1;
  else TRANS = 'T', and
  the rows of triu(X11) specify reflectors for P1,
  the columns of tril(X11,-1) specify reflectors for Q1.

 X12 is DOUBLE PRECISION array, dimension (LDX12,M-Q)
  On entry, the top-right block of the orthogonal matrix to
  be reduced. On exit, the form depends on TRANS:
  If TRANS = 'N', then
  the rows of triu(X12) specify the first P reflectors for
  Q2;
  else TRANS = 'T', and
  the columns of tril(X12) specify the first P reflectors
  for Q2.

 X21 is DOUBLE PRECISION array, dimension (LDX21,Q)
  On entry, the bottom-left block of the orthogonal matrix to
  be reduced. On exit, the form depends on TRANS:
  If TRANS = 'N', then
  the columns of tril(X21) specify reflectors for P2;
  else TRANS = 'T', and
  the rows of triu(X21) specify reflectors for P2.

 X22 is DOUBLE PRECISION array, dimension (LDX22,M-Q)
  On entry, the bottom-right block of the orthogonal matrix to
  be reduced. On exit, the form depends on TRANS:
  If TRANS = 'N', then
  the rows of triu(X22(Q+1:M-P,P+1:M-Q)) specify the last
  M-P-Q reflectors for Q2,
  else TRANS = 'T', and
  the columns of tril(X22(P+1:M-Q,Q+1:M-P)) specify the last
  M-P-Q reflectors for P2.

 THETA is DOUBLE PRECISION array, dimension (Q)
  The entries of the bidiagonal blocks B11, B12, B21, B22 can
  be computed from the angles THETA and PHI. See Further
  Details.

 PHI is DOUBLE PRECISION array, dimension (Q-1)
  The entries of the bidiagonal blocks B11, B12, B21, B22 can
  be computed from the angles THETA and PHI. See Further
  Details.

 TAUP1 is DOUBLE PRECISION array, dimension (P)
  The scalar factors of the elementary reflectors that define
  P1.

 TAUP2 is DOUBLE PRECISION array, dimension (M-P)
  The scalar factors of the elementary reflectors that define
  P2.

 TAUQ1 is DOUBLE PRECISION array, dimension (Q)
  The scalar factors of the elementary reflectors that define
  Q1.

 TAUQ2 is DOUBLE PRECISION array, dimension (M-Q)
  The scalar factors of the elementary reflectors that define
  Q2.

 */
inline proc orbdb(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, x11 : [] c_double, x12 : [] c_double, x21 : [] c_double, x22 : [] c_double, theta : [] c_double, phi : [] c_double, taup1 : [] c_double, taup2 : [] c_double, tauq1 : [] c_double, tauq2 : [] c_double): c_int{
  return LAPACKE_dorbdb(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(1).size else x11.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(2).size else x11.domain.dim(1).size) : c_int, x11, (x11.domain.dim(2).size) : c_int, x12, (x12.domain.dim(2).size) : c_int, x21, (x21.domain.dim(2).size) : c_int, x22, (x22.domain.dim(2).size) : c_int, theta, phi, taup1, taup2, tauq1, tauq2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dorcsd for the type c_double.

Original Fortran LAPACK purpose documentation for DORCSD::

 DORCSD computes the CS decomposition of an M-by-M partitioned
 orthogonal matrix X:

 [ I 0 0 | 0 0 0 ]
 [ 0 C 0 | 0 -S 0 ]
 [ X11 | X12 ] [ U1 | ] [ 0 0 0 | 0 0 -I ] [ V1 | ]**T
 X = [-----------] = [---------] [---------------------] [---------] .
 [ X21 | X22 ] [ | U2 ] [ 0 0 0 | I 0 0 ] [ | V2 ]
 [ 0 S 0 | 0 C 0 ]
 [ 0 0 I | 0 0 0 ]

 X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,
 (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
 R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
 which R = MIN(P,M-P,Q,M-Q).

Original Fortran LAPACK argument documentation for DORCSD::

 JOBU1 is CHARACTER
  = 'Y': U1 is computed;
  otherwise: U1 is not computed.

 JOBU2 is CHARACTER
  = 'Y': U2 is computed;
  otherwise: U2 is not computed.

 JOBV1T is CHARACTER
  = 'Y': V1T is computed;
  otherwise: V1T is not computed.

 JOBV2T is CHARACTER
  = 'Y': V2T is computed;
  otherwise: V2T is not computed.

 TRANS is CHARACTER
  = 'T': X, U1, U2, V1T, and V2T are stored in row-major
  order;
  otherwise: X, U1, U2, V1T, and V2T are stored in column-
  major order.

 SIGNS is CHARACTER
  = 'O': The lower-left block is made nonpositive (the
  "other" convention);
  otherwise: The upper-right block is made nonpositive (the
  "default" convention).

 M is INTEGER
  The number of rows and columns in X.

 X11 is DOUBLE PRECISION array, dimension (LDX11,Q)
  On entry, part of the orthogonal matrix whose CSD is desired.

 X12 is DOUBLE PRECISION array, dimension (LDX12,M-Q)
  On entry, part of the orthogonal matrix whose CSD is desired.

 X21 is DOUBLE PRECISION array, dimension (LDX21,Q)
  On entry, part of the orthogonal matrix whose CSD is desired.

 X22 is DOUBLE PRECISION array, dimension (LDX22,M-Q)
  On entry, part of the orthogonal matrix whose CSD is desired.

 THETA is DOUBLE PRECISION array, dimension (R), in which R =
  MIN(P,M-P,Q,M-Q).
  C = DIAG( COS(THETA(1)), ... , COS(THETA(R)) ) and
  S = DIAG( SIN(THETA(1)), ... , SIN(THETA(R)) ).

 U1 is DOUBLE PRECISION array, dimension (P)
  If JOBU1 = 'Y', U1 contains the P-by-P orthogonal matrix U1.

 U2 is DOUBLE PRECISION array, dimension (M-P)
  If JOBU2 = 'Y', U2 contains the (M-P)-by-(M-P) orthogonal
  matrix U2.

 V1T is DOUBLE PRECISION array, dimension (Q)
  If JOBV1T = 'Y', V1T contains the Q-by-Q matrix orthogonal
  matrix V1**T.

 V2T is DOUBLE PRECISION array, dimension (M-Q)
  If JOBV2T = 'Y', V2T contains the (M-Q)-by-(M-Q) orthogonal
  matrix V2**T.

 */
inline proc orcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, x11 : [] c_double, x12 : [] c_double, x21 : [] c_double, x22 : [] c_double, theta : [] c_double, u1 : [] c_double, u2 : [] c_double, v1t : [] c_double, v2t : [] c_double): c_int{
  return LAPACKE_dorcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(1).size else x11.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(2).size else x11.domain.dim(1).size) : c_int, x11, (x11.domain.dim(2).size) : c_int, x12, (x12.domain.dim(2).size) : c_int, x21, (x21.domain.dim(2).size) : c_int, x22, (x22.domain.dim(2).size) : c_int, theta, u1, (u1.domain.dim(2).size) : c_int, u2, (u2.domain.dim(2).size) : c_int, v1t, (v1t.domain.dim(2).size) : c_int, v2t, (v2t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsyconv for the type c_double.

For more information, see the documentation for :proc:`syconv`, or consult the Netlibs or Intel documentation.
 */
inline proc syconv(matrix_order : lapack_memory_order, uplo : string, way : string, a : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dsyconv(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsyswapr for the type c_double.

For more information, see the documentation for :proc:`syswapr`, or consult the Netlibs or Intel documentation.
 */
inline proc syswapr(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, i1 : c_int, i2 : c_int): c_int{
  return LAPACKE_dsyswapr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, i1, i2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsytri2 for the type c_double.

For more information, see the documentation for :proc:`sytri2`, or consult the Netlibs or Intel documentation.
 */
inline proc sytri2(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ipiv : [] c_int): c_int{
  return LAPACKE_dsytri2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsytri2x for the type c_double.

For more information, see the documentation for :proc:`sytri2x`, or consult the Netlibs or Intel documentation.
 */
inline proc sytri2x(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ipiv : [] c_int, nb : c_int): c_int{
  return LAPACKE_dsytri2x(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, nb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsytrs2 for the type c_double.

For more information, see the documentation for :proc:`sytrs2`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrs2(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dsytrs2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sbbcsd for the type c_float.

For more information, see the documentation for :proc:`bbcsd`, or consult the Netlibs or Intel documentation.
 */
inline proc bbcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, theta : [] c_float, phi : [] c_float, u1 : [] c_float, u2 : [] c_float, v1t : [] c_float, v2t : [] c_float, b11d : [] c_float, b11e : [] c_float, b12d : [] c_float, b12e : [] c_float, b21d : [] c_float, b21e : [] c_float, b22d : [] c_float, b22e : [] c_float): c_int{
  return LAPACKE_sbbcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, (if matrix_order == lapack_memory_order.row_major then u1.domain.dim(2).size else u1.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then v1t.domain.dim(2).size else v1t.domain.dim(1).size) : c_int, theta, phi, u1, (if matrix_order == lapack_memory_order.row_major then u1.domain.dim(1).size else u1.domain.dim(2).size) : c_int, u2, (u2.domain.dim(2).size) : c_int, v1t, (if matrix_order == lapack_memory_order.row_major then v1t.domain.dim(1).size else v1t.domain.dim(2).size) : c_int, v2t, (v2t.domain.dim(2).size) : c_int, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sorbdb for the type c_float.

For more information, see the documentation for :proc:`orbdb`, or consult the Netlibs or Intel documentation.
 */
inline proc orbdb(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, x11 : [] c_float, x12 : [] c_float, x21 : [] c_float, x22 : [] c_float, theta : [] c_float, phi : [] c_float, taup1 : [] c_float, taup2 : [] c_float, tauq1 : [] c_float, tauq2 : [] c_float): c_int{
  return LAPACKE_sorbdb(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(1).size else x11.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(2).size else x11.domain.dim(1).size) : c_int, x11, (x11.domain.dim(2).size) : c_int, x12, (x12.domain.dim(2).size) : c_int, x21, (x21.domain.dim(2).size) : c_int, x22, (x22.domain.dim(2).size) : c_int, theta, phi, taup1, taup2, tauq1, tauq2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sorcsd for the type c_float.

For more information, see the documentation for :proc:`orcsd`, or consult the Netlibs or Intel documentation.
 */
inline proc orcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, x11 : [] c_float, x12 : [] c_float, x21 : [] c_float, x22 : [] c_float, theta : [] c_float, u1 : [] c_float, u2 : [] c_float, v1t : [] c_float, v2t : [] c_float): c_int{
  return LAPACKE_sorcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(1).size else x11.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(2).size else x11.domain.dim(1).size) : c_int, x11, (x11.domain.dim(2).size) : c_int, x12, (x12.domain.dim(2).size) : c_int, x21, (x21.domain.dim(2).size) : c_int, x22, (x22.domain.dim(2).size) : c_int, theta, u1, (u1.domain.dim(2).size) : c_int, u2, (u2.domain.dim(2).size) : c_int, v1t, (v1t.domain.dim(2).size) : c_int, v2t, (v2t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssyconv for the type c_float.

For more information, see the documentation for :proc:`syconv`, or consult the Netlibs or Intel documentation.
 */
inline proc syconv(matrix_order : lapack_memory_order, uplo : string, way : string, a : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_ssyconv(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssyswapr for the type c_float.

For more information, see the documentation for :proc:`syswapr`, or consult the Netlibs or Intel documentation.
 */
inline proc syswapr(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, i1 : c_int, i2 : c_int): c_int{
  return LAPACKE_ssyswapr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, i1, i2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssytri2 for the type c_float.

For more information, see the documentation for :proc:`sytri2`, or consult the Netlibs or Intel documentation.
 */
inline proc sytri2(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ipiv : [] c_int): c_int{
  return LAPACKE_ssytri2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssytri2x for the type c_float.

For more information, see the documentation for :proc:`sytri2x`, or consult the Netlibs or Intel documentation.
 */
inline proc sytri2x(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ipiv : [] c_int, nb : c_int): c_int{
  return LAPACKE_ssytri2x(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, nb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssytrs2 for the type c_float.

For more information, see the documentation for :proc:`sytrs2`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrs2(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_ssytrs2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zbbcsd for the type lapack_complex_double.

For more information, see the documentation for :proc:`bbcsd`, or consult the Netlibs or Intel documentation.
 */
inline proc bbcsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, m : c_int, theta : [] c_double, phi : [] c_double, u1 : [] complex(128), u2 : [] complex(128), v1t : [] complex(128), v2t : [] complex(128), b11d : [] c_double, b11e : [] c_double, b12d : [] c_double, b12e : [] c_double, b21d : [] c_double, b21e : [] c_double, b22d : [] c_double, b22e : [] c_double): c_int{
  return LAPACKE_zbbcsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, m, (if matrix_order == lapack_memory_order.row_major then u1.domain.dim(2).size else u1.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then v1t.domain.dim(2).size else v1t.domain.dim(1).size) : c_int, theta, phi, u1, (if matrix_order == lapack_memory_order.row_major then u1.domain.dim(1).size else u1.domain.dim(2).size) : c_int, u2, (u2.domain.dim(2).size) : c_int, v1t, (if matrix_order == lapack_memory_order.row_major then v1t.domain.dim(1).size else v1t.domain.dim(2).size) : c_int, v2t, (v2t.domain.dim(2).size) : c_int, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zheswapr for the type lapack_complex_double.

For more information, see the documentation for :proc:`heswapr`, or consult the Netlibs or Intel documentation.
 */
inline proc heswapr(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), i1 : c_int, i2 : c_int): c_int{
  return LAPACKE_zheswapr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, i1, i2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhetri2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`hetri2`, or consult the Netlibs or Intel documentation.
 */
inline proc hetri2(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zhetri2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhetri2x for the type lapack_complex_double.

For more information, see the documentation for :proc:`hetri2x`, or consult the Netlibs or Intel documentation.
 */
inline proc hetri2x(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, nb : c_int): c_int{
  return LAPACKE_zhetri2x(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, nb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zhetrs2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`hetrs2`, or consult the Netlibs or Intel documentation.
 */
inline proc hetrs2(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zhetrs2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsyconv for the type lapack_complex_double.

For more information, see the documentation for :proc:`syconv`, or consult the Netlibs or Intel documentation.
 */
inline proc syconv(matrix_order : lapack_memory_order, uplo : string, way : string, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zsyconv(matrix_order, ascii(uplo) : c_char, ascii(way) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsyswapr for the type lapack_complex_double.

For more information, see the documentation for :proc:`syswapr`, or consult the Netlibs or Intel documentation.
 */
inline proc syswapr(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), i1 : c_int, i2 : c_int): c_int{
  return LAPACKE_zsyswapr(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, i1, i2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsytri2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`sytri2`, or consult the Netlibs or Intel documentation.
 */
inline proc sytri2(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int): c_int{
  return LAPACKE_zsytri2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsytri2x for the type lapack_complex_double.

For more information, see the documentation for :proc:`sytri2x`, or consult the Netlibs or Intel documentation.
 */
inline proc sytri2x(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, nb : c_int): c_int{
  return LAPACKE_zsytri2x(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, nb);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsytrs2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`sytrs2`, or consult the Netlibs or Intel documentation.
 */
inline proc sytrs2(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zsytrs2(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zunbdb for the type lapack_complex_double.

For more information, see the documentation for :proc:`unbdb`, or consult the Netlibs or Intel documentation.
 */
inline proc unbdb(matrix_order : lapack_memory_order, trans : string, signs : string, m : c_int, x11 : [] complex(128), x12 : [] complex(128), x21 : [] complex(128), x22 : [] complex(128), theta : [] c_double, phi : [] c_double, taup1 : [] complex(128), taup2 : [] complex(128), tauq1 : [] complex(128), tauq2 : [] complex(128)): c_int{
  return LAPACKE_zunbdb(matrix_order, ascii(trans) : c_char, ascii(signs) : c_char, m, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(1).size else x11.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(2).size else x11.domain.dim(1).size) : c_int, x11, (x11.domain.dim(2).size) : c_int, x12, (x12.domain.dim(2).size) : c_int, x21, (x21.domain.dim(2).size) : c_int, x22, (x22.domain.dim(2).size) : c_int, theta, phi, taup1, taup2, tauq1, tauq2);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zuncsd for the type lapack_complex_double.

For more information, see the documentation for :proc:`uncsd`, or consult the Netlibs or Intel documentation.
 */
inline proc uncsd(matrix_order : lapack_memory_order, jobu1 : string, jobu2 : string, jobv1t : string, jobv2t : string, trans : string, signs : string, m : c_int, x11 : [] complex(128), x12 : [] complex(128), x21 : [] complex(128), x22 : [] complex(128), theta : [] c_double, u1 : [] complex(128), u2 : [] complex(128), v1t : [] complex(128), v2t : [] complex(128)): c_int{
  return LAPACKE_zuncsd(matrix_order, ascii(jobu1) : c_char, ascii(jobu2) : c_char, ascii(jobv1t) : c_char, ascii(jobv2t) : c_char, ascii(trans) : c_char, ascii(signs) : c_char, m, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(1).size else x11.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then x11.domain.dim(2).size else x11.domain.dim(1).size) : c_int, x11, (x11.domain.dim(2).size) : c_int, x12, (x12.domain.dim(2).size) : c_int, x21, (x21.domain.dim(2).size) : c_int, x22, (x22.domain.dim(2).size) : c_int, theta, u1, (u1.domain.dim(2).size) : c_int, u2, (u2.domain.dim(2).size) : c_int, v1t, (v1t.domain.dim(2).size) : c_int, v2t, (v2t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgemqrt for the type c_float.

Original Fortran LAPACK purpose documentation for SGEMQRT::

 SGEMQRT overwrites the general real M-by-N matrix C with

 SIDE = 'L' SIDE = 'R'
 TRANS = 'N': Q C C Q
 TRANS = 'T': Q**T C C Q**T

 where Q is a real orthogonal matrix defined as the product of K
 elementary reflectors:

 Q = H(1) H(2) . . . H(K) = I - V T V**T

 generated using the compact WY representation as returned by SGEQRT. 

 Q is of order M if SIDE = 'L' and of order N if SIDE = 'R'.

Original Fortran LAPACK argument documentation for SGEMQRT::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q**T from the Left;
  = 'R': apply Q or Q**T from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'T': Transpose, apply Q**T.

 K is INTEGER
  The number of elementary reflectors whose product defines
  the matrix Q.
  If SIDE = 'L', M >= K >= 0;
  if SIDE = 'R', N >= K >= 0.

 V is REAL array, dimension (LDV,K)
  The i-th column must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  CGEQRT in the first K columns of its array argument A.

 T is REAL array, dimension (LDT,K)
  The upper triangular factors of the block reflectors
  as returned by CGEQRT, stored as a NB-by-N matrix.

 C is REAL array, dimension (LDC,N)
  On entry, the M-by-N matrix C.
  On exit, C is overwritten by Q C, Q**T C, C Q**T or C Q.

 */
inline proc gemqrt(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, v : [] c_float, t : [] c_float, c : [] c_float): c_int{
  return LAPACKE_sgemqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, (if matrix_order == lapack_memory_order.row_major then t.domain.dim(1).size else t.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgemqrt for the type c_double.

For more information, see the documentation for :proc:`gemqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc gemqrt(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, v : [] c_double, t : [] c_double, c : [] c_double): c_int{
  return LAPACKE_dgemqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, (if matrix_order == lapack_memory_order.row_major then t.domain.dim(1).size else t.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgemqrt for the type lapack_complex_float.

For more information, see the documentation for :proc:`gemqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc gemqrt(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, v : [] complex(64), t : [] complex(64), c : [] complex(64)): c_int{
  return LAPACKE_cgemqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, (if matrix_order == lapack_memory_order.row_major then t.domain.dim(1).size else t.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgemqrt for the type lapack_complex_double.

For more information, see the documentation for :proc:`gemqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc gemqrt(matrix_order : lapack_memory_order, side : string, trans : string, k : c_int, v : [] complex(128), t : [] complex(128), c : [] complex(128)): c_int{
  return LAPACKE_zgemqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(1).size else c.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then c.domain.dim(2).size else c.domain.dim(1).size) : c_int, k, (if matrix_order == lapack_memory_order.row_major then t.domain.dim(1).size else t.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, c, (c.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeqrt for the type c_float.

Original Fortran LAPACK purpose documentation for SGEQRT::

 SGEQRT computes a blocked QR factorization of a real M-by-N matrix A
 using the compact WY representation of Q.

Original Fortran LAPACK argument documentation for SGEQRT::

 NB is INTEGER
  The block size to be used in the blocked QR. MIN(M,N) >= NB >= 1.

 A is REAL array, dimension (LDA,N)
  On entry, the M-by-N matrix A.
  On exit, the elements on and above the diagonal of the array
  contain the min(M,N)-by-N upper trapezoidal matrix R (R is
  upper triangular if M >= N); the elements below the diagonal
  are the columns of V.

 T is REAL array, dimension (LDT,MIN(M,N))
  The upper triangular block reflectors stored in compact form
  as a sequence of upper triangular blocks. See below
  for further details.

 */
inline proc geqrt(matrix_order : lapack_memory_order, nb : c_int, a : [] c_float, t : [] c_float): c_int{
  return LAPACKE_sgeqrt(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, nb, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeqrt for the type c_double.

For more information, see the documentation for :proc:`geqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrt(matrix_order : lapack_memory_order, nb : c_int, a : [] c_double, t : [] c_double): c_int{
  return LAPACKE_dgeqrt(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, nb, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeqrt for the type lapack_complex_float.

For more information, see the documentation for :proc:`geqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrt(matrix_order : lapack_memory_order, nb : c_int, a : [] complex(64), t : [] complex(64)): c_int{
  return LAPACKE_cgeqrt(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, nb, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeqrt for the type lapack_complex_double.

For more information, see the documentation for :proc:`geqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrt(matrix_order : lapack_memory_order, nb : c_int, a : [] complex(128), t : [] complex(128)): c_int{
  return LAPACKE_zgeqrt(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, nb, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeqrt2 for the type c_float.

Original Fortran LAPACK purpose documentation for SGEQRT2::

 SGEQRT2 computes a QR factorization of a real M-by-N matrix A, 
 using the compact WY representation of Q.

Original Fortran LAPACK argument documentation for SGEQRT2::

 A is REAL array, dimension (LDA,N)
  On entry, the real M-by-N matrix A. On exit, the elements on and
  above the diagonal contain the N-by-N upper triangular matrix R; the
  elements below the diagonal are the columns of V. See below for
  further details.

 T is REAL array, dimension (LDT,N)
  The N-by-N upper triangular factor of the block reflector.
  The elements on and above the diagonal contain the block
  reflector T; the elements below the diagonal are not used.
  See below for further details.

 */
inline proc geqrt2(matrix_order : lapack_memory_order, a : [] c_float, t : [] c_float): c_int{
  return LAPACKE_sgeqrt2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeqrt2 for the type c_double.

For more information, see the documentation for :proc:`geqrt2`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrt2(matrix_order : lapack_memory_order, a : [] c_double, t : [] c_double): c_int{
  return LAPACKE_dgeqrt2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeqrt2 for the type lapack_complex_float.

For more information, see the documentation for :proc:`geqrt2`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrt2(matrix_order : lapack_memory_order, a : [] complex(64), t : [] complex(64)): c_int{
  return LAPACKE_cgeqrt2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeqrt2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`geqrt2`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrt2(matrix_order : lapack_memory_order, a : [] complex(128), t : [] complex(128)): c_int{
  return LAPACKE_zgeqrt2(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_sgeqrt3 for the type c_float.

Original Fortran LAPACK purpose documentation for SGEQRT3::

 SGEQRT3 recursively computes a QR factorization of a real M-by-N 
 matrix A, using the compact WY representation of Q. 

 Based on the algorithm of Elmroth and Gustavson, 
 IBM J. Res. Develop. Vol 44 No. 4 July 2000.

Original Fortran LAPACK argument documentation for SGEQRT3::

 A is REAL array, dimension (LDA,N)
  On entry, the real M-by-N matrix A. On exit, the elements on and
  above the diagonal contain the N-by-N upper triangular matrix R; the
  elements below the diagonal are the columns of V. See below for
  further details.

 T is REAL array, dimension (LDT,N)
  The N-by-N upper triangular factor of the block reflector.
  The elements on and above the diagonal contain the block
  reflector T; the elements below the diagonal are not used.
  See below for further details.

 */
inline proc geqrt3(matrix_order : lapack_memory_order, a : [] c_float, t : [] c_float): c_int{
  return LAPACKE_sgeqrt3(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dgeqrt3 for the type c_double.

For more information, see the documentation for :proc:`geqrt3`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrt3(matrix_order : lapack_memory_order, a : [] c_double, t : [] c_double): c_int{
  return LAPACKE_dgeqrt3(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_cgeqrt3 for the type lapack_complex_float.

For more information, see the documentation for :proc:`geqrt3`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrt3(matrix_order : lapack_memory_order, a : [] complex(64), t : [] complex(64)): c_int{
  return LAPACKE_cgeqrt3(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zgeqrt3 for the type lapack_complex_double.

For more information, see the documentation for :proc:`geqrt3`, or consult the Netlibs or Intel documentation.
 */
inline proc geqrt3(matrix_order : lapack_memory_order, a : [] complex(128), t : [] complex(128)): c_int{
  return LAPACKE_zgeqrt3(matrix_order, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(1).size else a.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stpmqrt for the type c_float.

Original Fortran LAPACK purpose documentation for STPMQRT::

 STPMQRT applies a real orthogonal matrix Q obtained from a 
 "triangular-pentagonal" real block reflector H to a general
 real matrix C, which consists of two blocks A and B.

Original Fortran LAPACK argument documentation for STPMQRT::

 SIDE is CHARACTER*1
  = 'L': apply Q or Q^H from the Left;
  = 'R': apply Q or Q^H from the Right.

 TRANS is CHARACTER*1
  = 'N': No transpose, apply Q;
  = 'C': Transpose, apply Q^H.

 L is INTEGER
  The order of the trapezoidal part of V. 
  K >= L >= 0. See Further Details.

 V is REAL array, dimension (LDA,K)
  The i-th column must contain the vector which defines the
  elementary reflector H(i), for i = 1,2,...,k, as returned by
  CTPQRT in B. See Further Details.

 T is REAL array, dimension (LDT,K)
  The upper triangular factors of the block reflectors
  as returned by CTPQRT, stored as a NB-by-K matrix.

 A is REAL array, dimension
  (LDA,N) if SIDE = 'L' or 
  (LDA,K) if SIDE = 'R'
  On entry, the K-by-N or M-by-K matrix A.
  On exit, A is overwritten by the corresponding block of 
  Q*C or Q^H*C or C*Q or C*Q^H. See Further Details.

 B is REAL array, dimension (LDB,N)
  On entry, the M-by-N matrix B.
  On exit, B is overwritten by the corresponding block of
  Q*C or Q^H*C or C*Q or C*Q^H. See Further Details.

 */
inline proc tpmqrt(matrix_order : lapack_memory_order, side : string, trans : string, l : c_int, v : [] c_float, t : [] c_float, a : [] c_float, b : [] c_float): c_int{
  return LAPACKE_stpmqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, l, (if matrix_order == lapack_memory_order.row_major then t.domain.dim(1).size else t.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtpmqrt for the type c_double.

For more information, see the documentation for :proc:`tpmqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc tpmqrt(matrix_order : lapack_memory_order, side : string, trans : string, l : c_int, v : [] c_double, t : [] c_double, a : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dtpmqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, l, (if matrix_order == lapack_memory_order.row_major then t.domain.dim(1).size else t.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctpmqrt for the type lapack_complex_float.

For more information, see the documentation for :proc:`tpmqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc tpmqrt(matrix_order : lapack_memory_order, side : string, trans : string, l : c_int, v : [] complex(64), t : [] complex(64), a : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_ctpmqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, l, (if matrix_order == lapack_memory_order.row_major then t.domain.dim(1).size else t.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztpmqrt for the type lapack_complex_double.

For more information, see the documentation for :proc:`tpmqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc tpmqrt(matrix_order : lapack_memory_order, side : string, trans : string, l : c_int, v : [] complex(128), t : [] complex(128), a : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_ztpmqrt(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then a.domain.dim(2).size else a.domain.dim(1).size) : c_int, l, (if matrix_order == lapack_memory_order.row_major then t.domain.dim(1).size else t.domain.dim(2).size) : c_int, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtpqrt for the type c_double.

Original Fortran LAPACK purpose documentation for DTPQRT::

 DTPQRT computes a blocked QR factorization of a real 
 "triangular-pentagonal" matrix C, which is composed of a 
 triangular block A and pentagonal block B, using the compact 
 WY representation for Q.

Original Fortran LAPACK argument documentation for DTPQRT::

 L is INTEGER
  The number of rows of the upper trapezoidal part of B.
  MIN(M,N) >= L >= 0. See Further Details.

 NB is INTEGER
  The block size to be used in the blocked QR. N >= NB >= 1.

 A is DOUBLE PRECISION array, dimension (LDA,N)
  On entry, the upper triangular N-by-N matrix A.
  On exit, the elements on and above the diagonal of the array
  contain the upper triangular matrix R.

 B is DOUBLE PRECISION array, dimension (LDB,N)
  On entry, the pentagonal M-by-N matrix B. The first M-L rows 
  are rectangular, and the last L rows are upper trapezoidal.
  On exit, B contains the pentagonal matrix V. See Further Details.

 T is DOUBLE PRECISION array, dimension (LDT,N)
  The upper triangular block reflectors stored in compact form
  as a sequence of upper triangular blocks. See Further Details.

 */
inline proc tpqrt(matrix_order : lapack_memory_order, l : c_int, nb : c_int, a : [] c_double, b : [] c_double, t : [] c_double): c_int{
  return LAPACKE_dtpqrt(matrix_order, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, l, nb, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctpqrt for the type lapack_complex_float.

For more information, see the documentation for :proc:`tpqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc tpqrt(matrix_order : lapack_memory_order, l : c_int, nb : c_int, a : [] complex(64), b : [] complex(64), t : [] complex(64)): c_int{
  return LAPACKE_ctpqrt(matrix_order, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, l, nb, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztpqrt for the type lapack_complex_double.

For more information, see the documentation for :proc:`tpqrt`, or consult the Netlibs or Intel documentation.
 */
inline proc tpqrt(matrix_order : lapack_memory_order, l : c_int, nb : c_int, a : [] complex(128), b : [] complex(128), t : [] complex(128)): c_int{
  return LAPACKE_ztpqrt(matrix_order, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, l, nb, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stpqrt2 for the type c_float.

Original Fortran LAPACK purpose documentation for STPQRT2::

 STPQRT2 computes a QR factorization of a real "triangular-pentagonal"
 matrix C, which is composed of a triangular block A and pentagonal block B, 
 using the compact WY representation for Q.

Original Fortran LAPACK argument documentation for STPQRT2::

 L is INTEGER
  The number of rows of the upper trapezoidal part of B. 
  MIN(M,N) >= L >= 0. See Further Details.

 A is REAL array, dimension (LDA,N)
  On entry, the upper triangular N-by-N matrix A.
  On exit, the elements on and above the diagonal of the array
  contain the upper triangular matrix R.

 B is REAL array, dimension (LDB,N)
  On entry, the pentagonal M-by-N matrix B. The first M-L rows 
  are rectangular, and the last L rows are upper trapezoidal.
  On exit, B contains the pentagonal matrix V. See Further Details.

 T is REAL array, dimension (LDT,N)
  The N-by-N upper triangular factor T of the block reflector.
  See Further Details.

 */
inline proc tpqrt2(matrix_order : lapack_memory_order, l : c_int, a : [] c_float, b : [] c_float, t : [] c_float): c_int{
  return LAPACKE_stpqrt2(matrix_order, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtpqrt2 for the type c_double.

For more information, see the documentation for :proc:`tpqrt2`, or consult the Netlibs or Intel documentation.
 */
inline proc tpqrt2(matrix_order : lapack_memory_order, l : c_int, a : [] c_double, b : [] c_double, t : [] c_double): c_int{
  return LAPACKE_dtpqrt2(matrix_order, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctpqrt2 for the type lapack_complex_float.

For more information, see the documentation for :proc:`tpqrt2`, or consult the Netlibs or Intel documentation.
 */
inline proc tpqrt2(matrix_order : lapack_memory_order, l : c_int, a : [] complex(64), b : [] complex(64), t : [] complex(64)): c_int{
  return LAPACKE_ctpqrt2(matrix_order, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztpqrt2 for the type lapack_complex_double.

For more information, see the documentation for :proc:`tpqrt2`, or consult the Netlibs or Intel documentation.
 */
inline proc tpqrt2(matrix_order : lapack_memory_order, l : c_int, a : [] complex(128), b : [] complex(128), t : [] complex(128)): c_int{
  return LAPACKE_ztpqrt2(matrix_order, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, l, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_stprfb for the type c_float.

Original Fortran LAPACK purpose documentation for STPRFB::

 STPRFB applies a real "triangular-pentagonal" block reflector H or its 
 conjugate transpose H^H to a real matrix C, which is composed of two 
 blocks A and B, either from the left or right.

Original Fortran LAPACK argument documentation for STPRFB::

 SIDE is CHARACTER*1
  = 'L': apply H or H^H from the Left
  = 'R': apply H or H^H from the Right

 TRANS is CHARACTER*1
  = 'N': apply H (No transpose)
  = 'C': apply H^H (Conjugate transpose)

 DIRECT is CHARACTER*1
  Indicates how H is formed from a product of elementary
  reflectors
  = 'F': H = H(1) H(2) . . . H(k) (Forward)
  = 'B': H = H(k) . . . H(2) H(1) (Backward)

 STOREV is CHARACTER*1
  Indicates how the vectors which define the elementary
  reflectors are stored:
  = 'C': Columns
  = 'R': Rows

 L is INTEGER
  The order of the trapezoidal part of V. 
  K >= L >= 0. See Further Details.

 V is REAL array, dimension
  (LDV,K) if STOREV = 'C'
  (LDV,M) if STOREV = 'R' and SIDE = 'L'
  (LDV,N) if STOREV = 'R' and SIDE = 'R'
  The pentagonal matrix V, which contains the elementary reflectors
  H(1), H(2), ..., H(K). See Further Details.

 T is REAL array, dimension (LDT,K)
  The triangular K-by-K matrix T in the representation of the
  block reflector.

 A is REAL array, dimension
  (LDA,N) if SIDE = 'L' or (LDA,K) if SIDE = 'R'
  On entry, the K-by-N or M-by-K matrix A.
  On exit, A is overwritten by the corresponding block of 
  H*C or H^H*C or C*H or C*H^H. See Futher Details.

 B is REAL array, dimension (LDB,N)
  On entry, the M-by-N matrix B.
  On exit, B is overwritten by the corresponding block of
  H*C or H^H*C or C*H or C*H^H. See Further Details.

 */
inline proc tprfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, l : c_int, v : [] c_float, t : [] c_float, a : [] c_float, b : [] c_float): c_int{
  return LAPACKE_stprfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, (t.domain.dim(1).size) : c_int, l, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dtprfb for the type c_double.

For more information, see the documentation for :proc:`tprfb`, or consult the Netlibs or Intel documentation.
 */
inline proc tprfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, l : c_int, v : [] c_double, t : [] c_double, a : [] c_double, b : [] c_double): c_int{
  return LAPACKE_dtprfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, (t.domain.dim(1).size) : c_int, l, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ctprfb for the type lapack_complex_float.

For more information, see the documentation for :proc:`tprfb`, or consult the Netlibs or Intel documentation.
 */
inline proc tprfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, l : c_int, v : [] complex(64), t : [] complex(64), a : [] complex(64), b : [] complex(64)): c_int{
  return LAPACKE_ctprfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, (t.domain.dim(1).size) : c_int, l, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ztprfb for the type lapack_complex_double.

For more information, see the documentation for :proc:`tprfb`, or consult the Netlibs or Intel documentation.
 */
inline proc tprfb(matrix_order : lapack_memory_order, side : string, trans : string, direct : string, storev : string, l : c_int, v : [] complex(128), t : [] complex(128), a : [] complex(128), b : [] complex(128)): c_int{
  return LAPACKE_ztprfb(matrix_order, ascii(side) : c_char, ascii(trans) : c_char, ascii(direct) : c_char, ascii(storev) : c_char, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(1).size else b.domain.dim(2).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, (t.domain.dim(1).size) : c_int, l, v, (v.domain.dim(2).size) : c_int, t, (t.domain.dim(2).size) : c_int, a, (a.domain.dim(2).size) : c_int, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_ssysv_rook for the type c_float.

Original Fortran LAPACK purpose documentation for SSYSV_ROOK::

 SSYSV_ROOK computes the solution to a real system of linear
 equations
 A * X = B,
 where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
 matrices.

 The diagonal pivoting method is used to factor A as
 A = U * D * U**T, if UPLO = 'U', or
 A = L * D * L**T, if UPLO = 'L',
 where U (or L) is a product of permutation and unit upper (lower)
 triangular matrices, and D is symmetric and block diagonal with
 1-by-1 and 2-by-2 diagonal blocks.

 SSYTRF_ROOK is called to compute the factorization of a real
 symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
 pivoting method.

 The factored form of A is then used to solve the system 
 of equations A * X = B by calling SSYTRS_ROOK.

Original Fortran LAPACK argument documentation for SSYSV_ROOK::

 UPLO is CHARACTER*1
  = 'U': Upper triangle of A is stored;
  = 'L': Lower triangle of A is stored.

 A is REAL array, dimension (LDA,N)
  On entry, the symmetric matrix A. If UPLO = 'U', the leading
  N-by-N upper triangular part of A contains the upper
  triangular part of the matrix A, and the strictly lower
  triangular part of A is not referenced. If UPLO = 'L', the
  leading N-by-N lower triangular part of A contains the lower
  triangular part of the matrix A, and the strictly upper
  triangular part of A is not referenced.
 
  On exit, if INFO = 0, the block diagonal matrix D and the
  multipliers used to obtain the factor U or L from the
  factorization A = U*D*U**T or A = L*D*L**T as computed by
  SSYTRF_ROOK.

 IPIV is INTEGER array, dimension (N)
  Details of the interchanges and the block structure of D,
  as determined by SSYTRF_ROOK.
 
  If UPLO = 'U':
  If IPIV(k) > 0, then rows and columns k and IPIV(k)
  were interchanged and D(k,k) is a 1-by-1 diagonal block.
 
  If IPIV(k) < 0 and IPIV(k-1) < 0, then rows and
  columns k and -IPIV(k) were interchanged and rows and
  columns k-1 and -IPIV(k-1) were inerchaged,
  D(k-1:k,k-1:k) is a 2-by-2 diagonal block.
 
  If UPLO = 'L':
  If IPIV(k) > 0, then rows and columns k and IPIV(k)
  were interchanged and D(k,k) is a 1-by-1 diagonal block.
 
  If IPIV(k) < 0 and IPIV(k+1) < 0, then rows and
  columns k and -IPIV(k) were interchanged and rows and
  columns k+1 and -IPIV(k+1) were inerchaged,
  D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

 B is REAL array, dimension (LDB,NRHS)
  On entry, the N-by-NRHS right hand side matrix B.
  On exit, if INFO = 0, the N-by-NRHS solution matrix X.

 */
inline proc sysv_rook(matrix_order : lapack_memory_order, uplo : string, a : [] c_float, ipiv : [] c_int, b : [] c_float): c_int{
  return LAPACKE_ssysv_rook(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_dsysv_rook for the type c_double.

For more information, see the documentation for :proc:`sysv_rook`, or consult the Netlibs or Intel documentation.
 */
inline proc sysv_rook(matrix_order : lapack_memory_order, uplo : string, a : [] c_double, ipiv : [] c_int, b : [] c_double): c_int{
  return LAPACKE_dsysv_rook(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_csysv_rook for the type lapack_complex_float.

For more information, see the documentation for :proc:`sysv_rook`, or consult the Netlibs or Intel documentation.
 */
inline proc sysv_rook(matrix_order : lapack_memory_order, uplo : string, a : [] complex(64), ipiv : [] c_int, b : [] complex(64)): c_int{
  return LAPACKE_csysv_rook(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

/* 
Polymorphic Chapel idiomatic procedure of LAPACKE_zsysv_rook for the type lapack_complex_double.

For more information, see the documentation for :proc:`sysv_rook`, or consult the Netlibs or Intel documentation.
 */
inline proc sysv_rook(matrix_order : lapack_memory_order, uplo : string, a : [] complex(128), ipiv : [] c_int, b : [] complex(128)): c_int{
  return LAPACKE_zsysv_rook(matrix_order, ascii(uplo) : c_char, (a.domain.dim(1).size) : c_int, (if matrix_order == lapack_memory_order.row_major then b.domain.dim(2).size else b.domain.dim(1).size) : c_int, a, (a.domain.dim(2).size) : c_int, ipiv, b, (b.domain.dim(2).size) : c_int);
}

} // ChaLAPACK
