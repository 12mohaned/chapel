                                   Checklist
                                       of
                             Issues to be Resolved

         prior to merging the hierarchical_locales branch back to trunk


NEW/CHANGED:

- Merge DefaultArchitecture, RootLocale out from trunk (to pick up Vass-inspired
  changes).

* Passes relevant regression tests
  * Standard
  * No-local
  - Multilocale
    * examples (0 failures)
    - distributions (8 failures)
      o robust/arithmetic/performance/alloc]
        > (put = +12, fork = 2, fork_nb = 3) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4)
        > (put = +12, fork = 2, fork_nb = 3) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4)
        > (put = +12, fork = 2, fork_nb = 3) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4)
        > (put = +12, fork = 2, fork_nb = 3) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4)
        > (put = +12, fork = 2, fork_nb = 3) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4) (get = +13, put = 1, fork = +4)
      * robust/arithmetic/performance/reduce]
        > (get = 9, put = +12, fork_nb = 3) (get = +8, fork = +4) (get = +8, fork = +4) (get = +8, fork = +4)
        From node 0, additional puts are the results from localeIDtoLocale().
        Gets (2 per) are retrieval of rootLocale?, additional for is handler to
        receive the result.
      o robust/arithmetic/performance/reduceAlias]
        > (put = 9, fork = 2) (get = +11, fork = +3) (get = +11, fork = +3) (get = +11, fork = +3)
        > (get = 9, put = 12, fork_nb = 3) (get = +8, fork = +4) (get = +8, fork = +4) (get = +8, fork = +4)
      o robust/arithmetic/performance/reduceSlice]
        > (get = 9, put = +33, fork = 11, fork_nb = 15) (get = +27, put = 3, fork = +11) (get = +27, put = 3, fork = +11) (get = +27, put = 3, fork = +11)
      o robust/arithmetic/performance/assignAlias]
        > (put = 9, fork = 2) (get = +11, fork = +3) (get = +11, fork = +3) (get = +11, fork = +3)
        > (put = +3, fork_nb = 3) (get = +2, fork = +1) (get = +2, fork = +1) (get = +2, fork = +1)
      o robust/arithmetic/performance/assignSlice]
        > (put = +24, fork = 11, fork_nb = 15) (get = +21, put = 3, fork = +8) (get = +21, put = 3, fork = +8) (get = +21, put = 3, fork = +8)
      o robust/arithmetic/performance/alloc_all]
        > (get = +18, put = +45, fork = 11, fork_nb = 6) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3)
        > (get = +18, put = +45, fork = 11, fork_nb = 6) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3)
        > (get = +18, put = +45, fork = 11, fork_nb = 6) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3)
        > (get = +18, put = +45, fork = 11, fork_nb = 6) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3)
        > (get = +18, put = +45, fork = 11, fork_nb = 6) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3) (get = +46, put = 3, fork = +15, fork_nb = 3)
      * robust/arithmetic/performance/assign]
        > (put = +3, fork_nb = 3) (get = +2, fork = +1) (get = +2, fork = +1)(get = +2, fork = +1)
        All changes due to calls to chpl_localeID_to_locale().
    * multilocale (4 failures)
      Updating the _endCount for the program runs locally on node 0, but
      involves looking up the destination locale using chpl_localeID_to_locale()
      on remote nodes.  Since the end count lives on node zero a number of gets
      are required to prepare and perform the remote update:
      Two to load the root locale pointer and 10 to perform the call to
      localeIDtoLocale(id).  This comm burden is reduced to 2 if we run the
      lookup on the root node.
      * deitz/needMultiLocales/raCommCheck (compopts: 1, execopts: 1)]
        > (get = +12, fork = 850)
        > (get = +12, fork = 873)
        > (get = +12, fork = 838)
      * deitz/needMultiLocales/raCommCheck (compopts: 2, execopts: 1)]
        > (get = +12, fork = 769)
        > (get = +12, fork = 769)
        > (get = +12, fork = 769)
      * deitz/needMultiLocales/streamCommCheck]
        > (fork_nb = +0) (get = +12, fork = +0)
      * deitz/needMultiLocales/dist/test_private_space]
        > (fork_nb = +0) (get = +12, fork = +0)
        > (fork_nb = +0) (get = +24, fork = +0)
    - performance ()

* Review added futures
  * Delete test/memory/shannon/memmaxExceedsLineno2.future
  * Move to trunk test/classes/figueroa/RecordDestructor1.future [bradc]
  * test/classes/bradc/syncAsClass.future
    * Try removing cast from chpl_here_free.
      a Cannot resolve arguments of chpl_memhook_free_pre().
    * Give sync and single classes their own deallocators.
    * remove future
  * test/types/records/sungeun/destructor2.future
    * Try removing cast from chpl_here_free.
      a Cannot resolve to chpl_memhook_free_pre().
    * Add cast_to_void_pointer
      * Now gives an even less helpful error message.
    * See if we can get a better error message than a C compiler error.
      * Yes, updated semanticChecks to catch this error the right way
        (i.e. testing semantics rather than structure).
  * Clone and add execopts to force leaked iterator data error to appear on trunk (LeakedMemory6).
  * Resolve test/functions/deitz/nested/test_nested_var_iterator2.future
    * Add a future to get copy propagation error to appear on trunk.

* Investigate/understand changed comm counts
  - Characterize and report back to group.
    * Due to calls to chpl_localeID_to_locale.
  o Try privatizing locales array.
  * What are the 12*k increased get counts?
    * Number of additional gets to run localeIDtoLocale on rootLocale when it is
      remote == 12.
  - Immediate fixes/workarounds
    * Now run localeIDtoLocale on root node
      (2 gets and 1 fork on remote node, one put on root node)
  * Proposal for better long-term solution(s)
    1 Use sublocale IDs and a registration scheme, so locales can be looked up locally.
    2 Store entire wide locale pointer in a wide pointer, so it doesn't have to
      be looked up at all.

* Ensure performance delta reasonable
  * Analyze differences
    * Understand causes
  - Group discussion
  o Memleaks testing: Similar output?
    o Format same?
    o Numbers comparable except in strings?

o Characterize main difference and get reviews on appropriate pieces
  - Break up in to logical components for review.


POST MERGE:

o Load allocator pointers in wrapon_fn.
o Start moved task through locale interface.
  - Package up allocator pointers with argument bundle


RESOLVED/UNCHANGED:

* Patch launcher to use its own memory allocator [gbt]

* Investigate/understand changed memory counts
  * Disable "shared local strings" kludge.
  * Try using ref intent
    a Simplest test case fails to build.
  * Disable string_copy in chpl__initCopy(a:string);
    * Works!!!
  * Resolve or futurize all regressions.
    * Standard (--local) build
    * No-local build.

* Merge to trunk environment setting of numThreadsPerLocale and callStackSize? [gbt]

* Replace all calls to PRIM_CHPL_ALLOC with chpl_here_alloc. [hilde]
  d Fix deallocation-before-breakLabel (memory leak) bug. (moved to trunk)
    * OK to leak memory pending fix on trunk
    d Create a future against trunk to demo the bug.
  * parallel.cpp 1 local, 2 global (unchanged).
  * wrappers.cpp
  * lowerIterators.cpp (2)
  * functionResolution.cpp
  * runtime

* Whether to interpose an alloc(loc, nbytes, md) layer between chpl_here_alloc()
  and locale.alloc() [yes]
  i The intent is to avoid dynamic dispatch through "here"
    i Works only if binding of code to allocators can be made at compile time
  a Have chpl_here_alloc() call an architecturally-defined alloc() routine after
    the architecture is initialized.
    a Implement alloc() as part of the DefaultArchitecture (part of architecture interface)
      a Allow that version to be controlled by a config param, to allow SxS
        testing of "flat" versus dynamically-dispatched allocations.
    a Use the config param to characterize the impact of flat MM vs. LAMM.
  * The above has been replaced by calls through task-private allocator
    interfaces.
  * Update generated wrapper code to redirect allocators to locale-specific versions.

* Move mem tracking into chpl_here_alloc.
  * Preserve filename/lineno information: md + filename + lineno.
  * Preserve pre/post checks.
  * Package pre/post checks in hook functions (restore control by CHPL_MEM_DEBUG &c).[gbt]
    * Call these functions from the module code.
      * Implement PRIM_CAST_TO_VOID_STAR.
  * Mem counts are different because we call string_copy when passing the
    filename arguments into chpl_here_alloc and chpl_here_free now.
    * Local strings are shared (and leaked).

* Characterize language impacts of allowing sync vars to be dispatched as objects.
  i Greg says this is OK.
  * Create a future for dispatch of sync as object. [bradc]

* Get allocCleanup patch reviewed and checked into trunk. [vass]

d Ensure that all important cases are covered by chpl_maybeAutoDestroyed().

* Whether to pass the destination locale to chpl_here_alloc() [no]
  i Not necessary using the "proxy" model


Key:    o -- open       - -- in progress    * -- done       ! -- blocked
    > -- dependency     i -- information    d -- deferred   a -- abandoned

