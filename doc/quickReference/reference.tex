\documentclass[landscape]{report}

\usepackage[landscape,margin=.75in]{geometry}
\usepackage{color}
\usepackage{flowfram}

\usepackage{times}
\usepackage{listings}
\usepackage{longtable}
\input{chapel_listing}

% Use sans-serif font as default font
\renewcommand{\familydefault}{cmss}

% adjust \textheight so that it is an integer multiple of
% \baselineskip
%\adjustheight{\textheight}

\Ncolumn{3}

% Make a border along the top of each page
%\vtwotonetop{1cm}{0.6\paperwidth}{[cmyk]{0.65,0.13,0,0}}{topleft}%
%{0.4\paperwidth}{[cmyk]{0.94,0.54,0,0}}{topright}

% empty page style, because I am going to make my own
\pagestyle{empty}

% Each new chapter sets \thispagestyle{\chapterfirstpagestyle}, change this empty as well
\renewcommand{\chapterfirstpagestyle}{empty}

% Now make a frame in which to put my own customized footer
\newdynamicframe[1,2]{\textwidth}{\headheight}{0pt}{-\footskip}[footer]

% set the contents of the frame:
\setdynamiccontents*{footer}{{\sf \sl {\small Chapel Quick Reference Guide \hfill page \thepage}}}

%\newcommand{\env}[1]{\texttt{#1}}
%\newcommand{\cmdname}[1]{\texttt{\symbol{92}#1}}
%\newcommand{\meta}[1]{\textnormal{\textless\textit{#1}\textgreater}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\etc}{etc}
%\newcommand{\incode}[1]{\texttt{#1}}

\begin{document}

\setlength{\parindent}{0in}
\setlength{\parskip}{1mm plus2mm minus1mm}

\lstset{language=chapel}

{\footnotesize
\subsection*{Chapel Programs}

{\bf File extension} \newline
Chapel program files end with the file extension \verb+.chpl+.   

{\bf Modules} \newline
Chapel programs are constructed from one or more Chapel modules,
and one \chpl{main} function to drive the computation.
If a Chapel program is contained within
one file, not using other modules, the
\chpl{main} function definition is not required.
To access routines in other modules, the \chpl{use} statement
indicates which module(s) to use.
Unless otherwise specified, the name of a module is the name of
the file in which it is contained.

{\bf Compiler command} \newline
The Chapel compiler command is \verb+chpl+.  

{\bf Comments} 
\begin{chapel}
// Comments on a single line
/* Comments spanning
   multiple lines */
\end{chapel}

{\bf Input and output} \newline
Chapel provides a built-in \chpl{file} type to handle input and
output to files.  
\begin{chapel}
var inputFile = new file("inMatrix.dat");
inputFile.open();
inputFile.read(n);
for i in 1..n do inputFile.read(x(i));
inputFile.close();
\end{chapel}
Chapel provides built-in functions \chpl{write} and \chpl{writeln}
to write to \chpl{stdout}, and the built-in function \chpl{read}
that reads from \chpl{stdin}.
Default \chpl{read} and \chpl{write} methods are provided for all
Chapel types. 
\subsection*{Variables}
{\bf Variable kinds} \newline
There are three kinds of Chapel variables: \chpl{var},
\chpl{const} (runtime constants), \chpl{param} (compile-time constants).

{\bf Variable declarations} \newline
Variable declarations require a type specification and/or an 
initialization assignment.
\begin{chapel}
var x: real = 1.0; // x is real, init to 1.0
var y, z: real;    // y, z are real, init to 0.0

var n = 10;      // n inferred to be int, init to 10
const size = n;  // size is int constant, init to 10 
\end{chapel}
{\bf Configuration variables} \newline
The keyword \chpl{config} may precede any global variable
declaration, indicating that the variable may be set at
compile time or runtime.
\begin{chapel}
config const n = 100; 
config param debug:bool; 
\end{chapel}
To set configuration variables of kind \chpl{var} or \chpl{const} 
at runtime, use ``\chpl{--}''
followed by the variable name and value on the execution
command line.
\begin{commandline}
> ./a.out --n=1000
\end{commandline}
To set configuration variables of kind \chpl{param} at compile time, use
``\chpl{-s}'' followed by the variable name and value on the
compiler command line.
\begin{commandline}
> chpl testprogram.chpl -s debug=true
\end{commandline}
\subsection*{Types} 
{\bf Primitive types} \newline
The following table lists the Chapel primitive types,
their default sizes and their default initial values.
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf type} & {\bf default size} & {\bf initial value}\\
\hline
\begin{chapel}
int
uint
\end{chapel}
& 32 bits &
\begin{chapel}
0
0
\end{chapel} \\ 
\hline
\begin{chapel}
real
imag
\end{chapel}
& 64 bits &
\begin{chapel}
0.0
0.0i
\end{chapel} \\ 
\hline
\begin{chapel}
complex
\end{chapel}
& 128 bits &
\begin{chapel}
0.0 + 0.0i
\end{chapel} \\ 
\hline
\begin{chapel}
bool
\end{chapel} 
&  &
\begin{chapel}
false
\end{chapel}  \\ 
\hline
\begin{chapel}
string
\end{chapel}
&  &
\begin{chapel}
""
\end{chapel}  \\ 
\hline
\end{tabular}
\end{center}
Other sizes for the primitive data types can be
specified.
\begin{chapel}
var x: real(32), i: int(8); 
\end{chapel}
{\bf Ranges} \newline
Ranges define arithmetic sequences.
\begin{chapel}
var span1D: range = 1..n;
\end{chapel} 
{\bf Arrays and domains} \newline
Domains specify an index set.  Arrays are declared using domains.
Arrays and domains may
be arithmetic, sparse, associative, enumerated or opaque.  
\begin{chapel}
const D: domain(2) = [1..n, 1..n];
var A, B, C: [D] real;
\end{chapel}
Domains can be specified with a distribution, defining how the
data is distributed across a set of processors.
\begin{chapel}
const DistD: domain(2) distributed(Block) = [1..n, 1..n];
var A, B, C: [DistD] real;
\end{chapel}
Subdomains may be
defined to specify a subset of the domain's indices. Subarrays may be defined
with subdomains or ranges to specify part of an array.
\begin{chapel}
writeln(A[1..2, 1..2]); // writes first 2x2 block of A
\end{chapel}
{\bf Enumerated types} \newline
Enumerated types define a set of named constants.
\begin{chapel}
enum day {sun, mon, tue, wed, thu, fri, sat};
var d: day = day.mon;
\end{chapel} 
{\bf Tuple types} \newline
Tuples are ordered sets of components.  They can contain
elements of all the same type or of multiple types.
\begin{chapel}
var pt: (int, real); // pt is mixed tuple, init to (0, 0.0) 
var z: 3*int; // z is tuple of ints, init to (0, 0, 0)
\end{chapel}
{\bf Classes} \newline
Classes are data structures with fields and methods.  They
are assigned by reference.
\begin{chapel}
class circle {
  var radius: real;
  def area {
    param pi = 3.14;
    return pi*(radius**2);
  }
}
var x = new circle(radius=1.0);
writeln("Area of circle = ", x.area);
\end{chapel}
{\bf Records} \newline
Records are similar to classes but are assigned by
value.
\begin{chapel} 
record point {
  var x, y: real;
}
var p = new point(0.0, 1.0);
\end{chapel}
{\bf Type alias} \newline
A type alias may be defined for any type.  When used, it has the
same meaning as using the aliased type directly. 
\begin{chapel}
type elemType = real(32);
var alpha: elemType; // alpha is 32-bit real
\end{chapel}
\subsection*{Operators}  
{\bf Assignment operators} \newline
Supported assignment operators:
\begin{chapel}
 = += -= *= /= %= **= &= |= ^= &&= ||= <<= >>=
\end{chapel}
{\bf Swap operator} \newline
The swap operator, \chpl{<=>}, swaps the values between
the left and right-hand side expressions.
\begin{chapel}
x <=> y; // swaps the value in x with the value in y
\end{chapel}
{\bf Array alias operator} \newline
The array alias operator, \chpl{=>}, creates an alias
to an array or an array slice.  
\begin{chapel}
var A11 => A[block1, block1];
\end{chapel}
\subsection*{Statements and Expressions}
{\bf Block statement} \newline
Chapel statements are separated by a semi-colon.  A block
of statements is delimited by \{ \}.  

{\bf For loop statement} 
\begin{chapel} 
for i in 1..n {
  norm1 += abs(x(i));
}
\end{chapel} 
{\bf Conditional statement}
\begin{chapel} 
if a == 0.0 
then x = 0.0;
else x = a*y;
if (b != 0.0) {
  z = b*x;
  b = 0.0;
}
\end{chapel} 
{\bf Select statement}   
\begin{chapel} 
enum day {sun, mon, tue, wed, thu, fri, sat};
var today: day;
select today {
  when day.fri, day.sat do rate = 250;
  when day.sun do rate = 180;
  otherwise rate = 140;
}
\end{chapel} 
{\bf While and do while loops} 
\begin{chapel} 
do {
  t += 1;
} while (t <= 10);
while (t <= 10) {
  t += 1;
}
\end{chapel} 
\vspace{.7in}
{\bf Type select statement} 
\begin{chapel} 
type select ind {
  when int do y = x(ind); 
  otherwise y = x(ind:int);
}
\end{chapel} 
{\bf Let expression} 
\begin{chapel} 
x = let t1 = sqrt(b*b - 4.0*a*c), t2 = 2.0*a 
    in ((-b + t1)/t2, (-b - t1)/t2);
\end{chapel}
{\bf Conditional expression}  
\begin{chapel} 
var half = if (i % 2) then i/2 + 1 else i/2;
\end{chapel}
\subsection*{Functions}
{\bf Function definition} \newline
Functions are defined with a name and a list of function
arguments.  Optionally, intents, return types and a
where clause can be specified.
\begin{chapel}
def area(x:real, y:real): real {
  return x*y;
}
\end{chapel}
{\bf Function intents} \newline
The intents of function arguments can be specified as \chpl{in}, 
\chpl{out}, \chpl{inout}, or be omitted (blank intent).  
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Intent} & {\bf Action at Function Call Site} \\
\hline
\chpl{in} & 
\begin{minipage}[t]{2.5in}
at function entry, argument is copied in
\end{minipage} \\
\hline
\chpl{out} & 
\begin{minipage}[t]{2.5in}
at function exit, argument is copied out
\end{minipage} \\
\hline
\chpl{inout} & 
\begin{minipage}[t]{2.5in}
at function entry, argument is copied in,
\end{minipage} \\
&
\begin{minipage}[t]{2.5in}
at function exit, argument is copied out
\end{minipage} \\ 
\hline
blank & 
\begin{minipage}[t]{2.5in}
\chpl{array} and \chpl{domain} arguments passed by reference 
\end{minipage} \\
\cline{2-2}
& 
\begin{minipage}[t]{2.5in}
All other argument types passed as constant and cannot be assigned to
\end{minipage} \\
\hline
\end{tabular}
\end{center}
{\bf Generic functions} \newline
Generic functions contain formal arguments that do not have
a specified type.
\begin{chapel}
def absSum(x) {
  return + reduce abs(x);
} 
\end{chapel}
This routine, \chpl{absSum}, can be called
with arrays of any type for which an \chpl{abs} function is 
defined.

{\bf Query expression} \newline
Query expressions are used in generic functions to query
types or domains of arguments.
\begin{chapel}
def sumOfThree(x:?t, y:t, z:t):t {
   return x + y + z;
}
\end{chapel}
\subsection*{Iterators}
Iterators generate a sequence of values.  They are defined similarly 
to functions, except that they contain a \chpl{yield} statement
instead of a \chpl{return} statement.  
One use of iterators is in \chpl{for} and \chpl{forall} loop
statements.  For each iteration of the loop, a value from the
iterator is yielded and the body of the loop executed.
\begin{chapel}
def evens(n) {
  for i in 1..n do yield (i, 2*i);
}
for (i, i2) in evens(m) {
  x(i) = y(i2);
}
\end{chapel}
\subsection*{Parallel Constructs}
{\bf Single and sync variables} \newline
Single and sync variables are used to manage concurrent
tasks.  Single variables are assigned once.  
Sync variables allow multiple assignments to them, and
they have an associated {\em full} or {\em empty} state. 
\begin{chapel}
var s: sync int;
\end{chapel}
{\bf Cobegin statement} \newline
The cobegin statement is used to create parallelism within
a block statement.  All statements within the block statement
are executed concurrently.
\begin{chapel}
cobegin {
  init(A);
  init(B);
}
\end{chapel}
{\bf Begin statement} \newline
The \chpl{begin} statement spawns a task to execute a 
statement.
\begin{chapel}
var done: single bool;
begin 
  while(!done) do work(x); 
otherwork(x);
done = true;
\end{chapel}
{\bf Forall  and coforall loop statements} \newline
Parallel loops are specified using \chpl{forall} or
the shorthand bracket notation.
\begin{chapel}
forall ind in D do A(ind) = x*y;
[ind in D] A(ind) = x*y; // equivalent to above loop
\end{chapel}
A parallel loop specified with \chpl{coforall} ensures
that each iteration is executed concurrently.

{\bf Forall expression} \newline
The bracket notation may also be used at the expression
level.
\begin{chapel}
B = [(i, j) in D2] i*j;
\end{chapel}
{\bf Locality} \newline
When the program is launched, there is a single task running
on locale 0. A global array Locales is predefined over the
LocaleSpace domain. A loop over the Locales array can be used
to launch a task on each locale.
\begin{chapel}
var A: [LocaleSpace] circle;
for loc in Locales do
  on loc do A(here.id) = new circle(radius = 2.0);

for circles in A do
  on circles.locale do
    writeln("on locale ", here.id);
\end{chapel}
\end{document}

