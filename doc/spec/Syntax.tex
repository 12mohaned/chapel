%%
%% Do not modify this file.  This file is automatically
%% generated by collect_syntax.pl.
%%

\sekshun{Collected Lexical and Syntax Productions}
\label{Syntax}

This appendix collects the syntax productions listed throughout the specification.  There are no new syntax productions in this appendix.  The productions are listed both alphabetically and in depth-first order for convenience.

\section{Alphabetical Lexical Productions}

\begin{syntax}
\end{syntax}

\begin{syntax}
binary-digit: one of
  `0' `1'
\end{syntax}

\begin{syntax}
binary-digits:
  binary-digit
  binary-digit binary-digits
\end{syntax}

\begin{syntax}
bool-literal: one of
  `true' $ $ $ $ `false'
\end{syntax}

\begin{syntax}
digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7' `8' `9'
\end{syntax}

\begin{syntax}
digits:
  digit
  digit digits
\end{syntax}

\begin{syntax}
double-quote-delimited-characters:
  string-character double-quote-delimited-characters[OPT]
  ' double-quote-delimited-characters[OPT]
\end{syntax}

\begin{syntax}
exponent-part:
  `e' sign[OPT] digits
  `E' sign[OPT] digits
\end{syntax}

\begin{syntax}
hexadecimal-digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7' `8' `9' `A' `B' `C' `D' `E' `F' `a' `b' `c' `d' `e' `f'
\end{syntax}

\begin{syntax}
hexadecimal-digits:
  hexadecimal-digit
  hexadecimal-digit hexadecimal-digits
\end{syntax}

\begin{syntax}
hexadecimal-escape-character:
  `$\backslash$x' hexadecimal-digits
\end{syntax}

\begin{syntax}
identifier:
  letter-or-underscore legal-identifier-chars[OPT]
\end{syntax}

\begin{syntax}
imaginary-literal:
  real-literal `i'
  integer-literal `i'
\end{syntax}

\begin{syntax}
integer-literal:
  digits
  `0x' hexadecimal-digits
  `0X' hexadecimal-digits
  `0o' octal-digits
  `0O' octal-digits
  `0b' binary-digits
  `0B' binary-digits
\end{syntax}

\begin{syntax}
legal-identifier-char:
  letter-or-underscore
  digit
  `(*\texttt{\$}*)'
\end{syntax}

\begin{syntax}
legal-identifier-chars:
  legal-identifier-char legal-identifier-chars[OPT]
\end{syntax}

\begin{syntax}
letter-or-underscore:
  letter
  `_'
\end{syntax}

\begin{syntax}
letter: one of
  `A' `B' `C' `D' `E' `F' `G' `H' `I' `J' `K' `L' `M' `N' `O' `P' `Q' `R' `S' `T' `U' `V' `W' `X' `Y' `Z'
  `a' `b' `c' `d' `e' `f' `g' `h' `i' `j' `k' `l' `m' `n' `o' `p' `q' `r' `s' `t' `u' `v' `w' `x' `y' `z'
\end{syntax}

\begin{syntax}
octal-digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7'
\end{syntax}

\begin{syntax}
octal-digits:
  octal-digit
  octal-digit octal-digits
\end{syntax}

\begin{syntax}
p-exponent-part:
  `p' sign[OPT] digits
  `P' sign[OPT] digits
\end{syntax}

\begin{syntax}
real-literal:
  digits[OPT] . digits exponent-part[OPT]
  digits .[OPT] exponent-part
  `0x' hexadecimal-digits[OPT] . hexadecimal-digits p-exponent-part[OPT]
  `0X' hexadecimal-digits[OPT] . hexadecimal-digits p-exponent-part[OPT]
  `0x' hexadecimal-digits .[OPT] p-exponent-part
  `0X' hexadecimal-digits .[OPT] p-exponent-part
\end{syntax}

\begin{syntax}
sign: one of
  + $ $ $ $ -
\end{syntax}

\begin{syntax}
simple-escape-character: one of
  `$\backslash\mbox{\bf '}\hspace{5pt}$' `$\backslash$"$\hspace{5pt}$' `$\backslash$?$\hspace{5pt}$' `$\backslash$$\backslash$$\hspace{5pt}$' `$\backslash$a$\hspace{5pt}$' `$\backslash$b$\hspace{5pt}$' `$\backslash$f$\hspace{5pt}$' `$\backslash$n$\hspace{5pt}$' `$\backslash$r$\hspace{5pt}$' `$\backslash$t$\hspace{5pt}$' `$\backslash$v$\hspace{5pt}$'
\end{syntax}

\begin{syntax}
single-quote-delimited-characters:
  string-character single-quote-delimited-characters[OPT]
  " single-quote-delimited-characters[OPT]
\end{syntax}

\begin{syntax}
string-character:
  `any character except the double quote, single quote, or new line'
  simple-escape-character
  hexadecimal-escape-character
\end{syntax}

\begin{syntax}
string-literal:
  " double-quote-delimited-characters[OPT] "
  ' single-quote-delimited-characters[OPT] '
\end{syntax}

\section{Alphabetical Syntax Productions}

\begin{syntax}
\end{syntax}

\begin{syntax}
aligned-range-expression:
  range-expression `align' expression
\end{syntax}

\begin{syntax}
argument-list:
  ( formals[OPT] )
\end{syntax}

\begin{syntax}
array-alias-declaration:
  identifier reindexing-expression[OPT] => array-expression ;
\end{syntax}

\begin{syntax}
array-expression:
  expression
\end{syntax}

\begin{syntax}
array-literal:
  rectangular-array-literal
  associative-array-literal
\end{syntax}

\begin{syntax}
array-type:
  [ domain-expression ] type-specifier
\end{syntax}

\begin{syntax}
assignment-operator: one of
   = $ $ $ $ += $ $ $ $ -= $ $ $ $ *= $ $ $ $ /= $ $ $ $ %= $ $ $ $ **= $ $ $ $ &= $ $ $ $ |= $ $ $ $ ^= $ $ $ $ &&= $ $ $ $ ||= $ $ $ $ <<= $ $ $ $ >>=
\end{syntax}

\begin{syntax}
assignment-statement:
  lvalue-expression assignment-operator expression
\end{syntax}

\begin{syntax}
associative-array-literal:
  [ associative-expr-list ]
  [ associative-expr-list , ]
\end{syntax}

\begin{syntax}
associative-domain-literal:
   { associative-expression-list }
\end{syntax}

\begin{syntax}
associative-domain-type:
  `domain' ( associative-index-type )
  `domain' ( enum-type )
  `domain' ( `opaque' )
\end{syntax}

\begin{syntax}
associative-expr-list:
  index-expr => value-expr
  index-expr => value-expr, associative-expr-list
\end{syntax}

\begin{syntax}
associative-expression-list:
   non-range-expression
   non-range-expression, associative-expression-list
\end{syntax}

\begin{syntax}
associative-index-type:
  type-specifier
\end{syntax}

\begin{syntax}
atomic-statement:
  `atomic' statement
\end{syntax}

\begin{syntax}
atomic-type:
  `atomic' type-specifier
\end{syntax}

\begin{syntax}
base-domain-type:
  rectangular-domain-type
  associative-domain-type
\end{syntax}

\begin{syntax}
begin-statement:
  `begin' task-intent-clause[OPT] statement
\end{syntax}

\begin{syntax}
binary-expression:
  expression binary-operator expression
\end{syntax}

\begin{syntax}
binary-operator: one of
  + $ $ $ $ - $ $ $ $ * $ $ $ $ / $ $ $ $ % $ $ $ $ ** $ $ $ $ & $ $ $ $ | $ $ $ $ ^ $ $ $ $ << $ $ $ $ >> $ $ $ $ && $ $ $ $ || $ $ $ $ == $ $ $ $ != $ $ $ $ <= $ $ $ $ >= $ $ $ $ < $ $ $ $ > $ $ $ $ `by' $ $ $ $ #
\end{syntax}

\begin{syntax}
block-statement:
  { statements[OPT] }
\end{syntax}

\begin{syntax}
break-statement:
  `break' identifier[OPT] ;
\end{syntax}

\begin{syntax}
call-expression:
  lvalue-expression ( named-expression-list )
  lvalue-expression [ named-expression-list ]
  parenthesesless-function-identifier
\end{syntax}

\begin{syntax}
cast-expression:
  expression : type-specifier
\end{syntax}

\begin{syntax}
class-declaration-statement:
  simple-class-declaration-statement
  external-class-declaration-statement
\end{syntax}

\begin{syntax}
class-inherit-list:
  : class-type-list
\end{syntax}

\begin{syntax}
class-name:
  identifier
\end{syntax}

\begin{syntax}
class-statement-list:
  class-statement
  class-statement class-statement-list
\end{syntax}

\begin{syntax}
class-statement:
  variable-declaration-statement
  method-declaration-statement
  type-declaration-statement
  empty-statement
\end{syntax}

\begin{syntax}
class-type-list:
  class-type
  class-type , class-type-list
\end{syntax}

\begin{syntax}
class-type:
  identifier
  identifier ( named-expression-list )
\end{syntax}

\begin{syntax}
cobegin-statement:
  `cobegin' task-intent-clause[OPT] block-statement
\end{syntax}

\begin{syntax}
coforall-statement:
  `coforall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] `do' statement
  `coforall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] block-statement
  `coforall' iteratable-expression task-intent-clause[OPT] `do' statement
  `coforall' iteratable-expression task-intent-clause[OPT] block-statement
\end{syntax}

\begin{syntax}
conditional-statement:
  `if' expression `then' statement else-part[OPT]
  `if' expression block-statement else-part[OPT]
\end{syntax}

\begin{syntax}
config-or-extern: one of
  `config' $ $ $ $ `extern'
\end{syntax}

\begin{syntax}
constructor-call-expression:
  `new' class-name ( argument-list )
\end{syntax}

\begin{syntax}
continue-statement:
  `continue' identifier[OPT] ;
\end{syntax}

\begin{syntax}
counted-range-expression:
  range-expression # expression
\end{syntax}

\begin{syntax}
dataparallel-type:
  range-type
  domain-type
  mapped-domain-type
  array-type
  index-type
\end{syntax}

\begin{syntax}
default-expression:
  = expression
\end{syntax}

\begin{syntax}
delete-statement:
  `delete' expression ;
\end{syntax}

\begin{syntax}
dmap-value:
  expression
\end{syntax}

\begin{syntax}
do-while-statement:
  `do' statement `while' expression ;
\end{syntax}

\begin{syntax}
domain-alignment-expression:
  domain-expression `align' expression
\end{syntax}

\begin{syntax}
domain-assignment-expression:
  domain-name = domain-expression
\end{syntax}

\begin{syntax}
domain-expression:
  domain-literal
  domain-name
  domain-assignment-expression
  domain-striding-expression
  domain-alignment-expression
  domain-slice-expression
\end{syntax}

\begin{syntax}
domain-literal:
  rectangular-domain-literal
  associative-domain-literal
\end{syntax}

\begin{syntax}
domain-name:
  identifier
\end{syntax}

\begin{syntax}
domain-slice-expression:
  domain-expression [ slicing-index-set ]
  domain-expression ( slicing-index-set )
\end{syntax}

\begin{syntax}
domain-striding-expression:
  domain-expression `by' expression
\end{syntax}

\begin{syntax}
domain-type:
  base-domain-type
  simple-subdomain-type
  sparse-subdomain-type
\end{syntax}

\begin{syntax}
else-part:
  `else' statement
\end{syntax}

\begin{syntax}
empty-statement:
  ;
\end{syntax}

\begin{syntax}
enum-constant-expression:
  enum-type . identifier
\end{syntax}

\begin{syntax}
enum-constant-list:
  enum-constant
  enum-constant , enum-constant-list[OPT]
\end{syntax}

\begin{syntax}
enum-constant:
  identifier init-part[OPT]
\end{syntax}

\begin{syntax}
enum-declaration-statement:
  `enum' identifier { enum-constant-list }
\end{syntax}

\begin{syntax}
enum-type:
  identifier
\end{syntax}

\begin{syntax}
exclude-list:
  identifier-list
  $ * $
\end{syntax}

\begin{syntax}
exported-procedure-declaration-statement:
  `export' external-name[OPT] `proc' function-name argument-list return-intent[OPT] return-type[OPT]
    function-body
\end{syntax}

\begin{syntax}
expression-list:
  expression
  expression , expression-list
\end{syntax}

\begin{syntax}
expression-statement:
  variable-expression ;
  member-access-expression ;
  call-expression ;
  constructor-call-expression ;
  let-expression ; 
\end{syntax}

\begin{syntax}
expression:
  literal-expression
  nil-expression
  variable-expression
  enum-constant-expression
  call-expression
  iteratable-call-expression
  member-access-expression
  constructor-call-expression
  query-expression
  cast-expression
  lvalue-expression
  parenthesized-expression
  unary-expression
  binary-expression
  let-expression
  if-expression
  for-expression
  forall-expression
  reduce-expression
  scan-expression
  module-access-expression
  tuple-expression
  tuple-expand-expression
  locale-access-expression
  mapped-domain-expression
\end{syntax}

\begin{syntax}
external-class-declaration-statement:
  `extern' external-name[OPT] simple-class-declaration-statement
\end{syntax}

\begin{syntax}
external-name:
  identifier
  string-literal
\end{syntax}

\begin{syntax}
external-procedure-declaration-statement:
  `extern' external-name[OPT] `proc' function-name argument-list return-intent[OPT] return-type[OPT]
\end{syntax}

\begin{syntax}
external-record-declaration-statement:
  `extern' external-name[OPT] simple-record-declaration-statement
\end{syntax}

\begin{syntax}
external-type-alias-declaration-statement:
  `extern' `type' type-alias-declaration-list ;
\end{syntax}

\begin{syntax}
field-access-expression:
  receiver-clause[OPT] identifier
\end{syntax}

\begin{syntax}
for-expression:
  `for' index-var-declaration `in' iteratable-expression `do' expression
  `for' iteratable-expression `do' expression
\end{syntax}

\begin{syntax}
for-statement:
  `for' index-var-declaration `in' iteratable-expression `do' statement
  `for' index-var-declaration `in' iteratable-expression block-statement
  `for' iteratable-expression `do' statement
  `for' iteratable-expression block-statement
\end{syntax}

\begin{syntax}
forall-expression:
  `forall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] `do' expression
  `forall' iteratable-expression task-intent-clause[OPT] `do' expression
  [ index-var-declaration `in' iteratable-expression task-intent-clause[OPT] ] expression
  [ iteratable-expression task-intent-clause[OPT] ] expression
\end{syntax}

\begin{syntax}
forall-statement:
  `forall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] `do' statement
  `forall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] block-statement
  `forall' iteratable-expression task-intent-clause[OPT] `do' statement
  `forall' iteratable-expression task-intent-clause[OPT] block-statement
  [ index-var-declaration `in' iteratable-expression task-intent-clause[OPT] ] statement
  [ iteratable-expression task-intent-clause[OPT] ] statement
\end{syntax}

\begin{syntax}
formal-intent:
  `const'
  `const in'
  `const ref'
  `in'
  `out'
  `inout'
  `ref'
  `param'
  `type'
\end{syntax}

\begin{syntax}
formal-type:
  : type-specifier
  : ? identifier[OPT]
\end{syntax}

\begin{syntax}
formal:
  formal-intent[OPT] identifier formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] identifier formal-type[OPT] variable-argument-expression
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] variable-argument-expression
\end{syntax}

\begin{syntax}
formals:
  formal
  formal , formals
\end{syntax}

\begin{syntax}
function-body:
  block-statement
  return-statement
\end{syntax}

\begin{syntax}
function-name:
  identifier
  operator-name
\end{syntax}

\begin{syntax}
identifier-list:
  identifier
  identifier , identifier-list
  tuple-grouped-identifier-list
  tuple-grouped-identifier-list , identifier-list
\end{syntax}

\begin{syntax}
if-expression:
  `if' expression `then' expression `else' expression
  `if' expression `then' expression
\end{syntax}

\begin{syntax}
index-expr:
  expression
\end{syntax}

\begin{syntax}
index-type:
  `index' ( domain-expression )
\end{syntax}

\begin{syntax}
index-var-declaration:
  identifier
  tuple-grouped-identifier-list
\end{syntax}

\begin{syntax}
init-part:
  = expression
\end{syntax}

\begin{syntax}
initialization-part:
  = expression
\end{syntax}

\begin{syntax}
integer-parameter-expression:
  expression
\end{syntax}

\begin{syntax}
io-expression:
  expression
  io-expression io-operator expression
\end{syntax}

\begin{syntax}
io-operator:
  <`(*$\sim$*)'>
\end{syntax}

\begin{syntax}
io-statement:
  io-expression io-operator expression
\end{syntax}

\begin{syntax}
iteratable-call-expression:
  call-expression
\end{syntax}

\begin{syntax}
iteratable-expression:
  expression
  `zip' ( expression-list )
\end{syntax}

\begin{syntax}
iterator-body:
  block-statement
  yield-statement
\end{syntax}

\begin{syntax}
iterator-declaration-statement:
  privacy-specifier[OPT] `iter' iterator-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT]
  iterator-body
\end{syntax}

\begin{syntax}
iterator-name:
  identifier
\end{syntax}

\begin{syntax}
label-statement:
  `label' identifier statement
\end{syntax}

\begin{syntax}
let-expression:
  `let' variable-declaration-list `in' expression
\end{syntax}

\begin{syntax}
limitation-clause:
  `except' exclude-list
  `only' rename-list[OPT]
\end{syntax}

\begin{syntax}
linkage-specifier:
  `inline'
\end{syntax}

\begin{syntax}
literal-expression:
  bool-literal
  integer-literal
  real-literal
  imaginary-literal
  string-literal
  range-literal
  domain-literal
  array-literal
\end{syntax}

\begin{syntax}
locale-access-expression:
  expression . `locale'
\end{syntax}

\begin{syntax}
lvalue-expression:
  variable-expression
  member-access-expression
  call-expression
  parenthesized-expression
\end{syntax}

\begin{syntax}
mapped-domain-expression:
  domain-expression `dmapped' dmap-value
\end{syntax}

\begin{syntax}
mapped-domain-type:
  domain-type `dmapped' dmap-value
\end{syntax}

\begin{syntax}
member-access-expression:
  field-access-expression
  method-call-expression
\end{syntax}

\begin{syntax}
method-call-expression:
  receiver-clause[OPT] expression ( named-expression-list )
  receiver-clause[OPT] expression [ named-expression-list ]
  receiver-clause[OPT] parenthesesless-function-identifier
\end{syntax}

\begin{syntax}
method-declaration-statement:
  linkage-specifier[OPT] proc-or-iter this-intent[OPT] type-binding[OPT] function-name argument-list[OPT] 
    return-intent[OPT] return-type[OPT] where-clause[OPT] function-body
\end{syntax}

\begin{syntax}
module-access-expression:
  module-identifier-list . identifier
\end{syntax}

\begin{syntax}
module-declaration-statement:
  privacy-specifier[OPT] `module' module-identifier block-statement
\end{syntax}

\begin{syntax}
module-identifier-list:
  module-identifier
  module-identifier . module-identifier-list
\end{syntax}

\begin{syntax}
module-identifier:
  identifier
\end{syntax}

\begin{syntax}
module-or-enum-name-list:
  module-or-enum-name limitation-clause[OPT]
  module-or-enum-name , module-or-enum-name-list
\end{syntax}

\begin{syntax}
module-or-enum-name:
  identifier
  identifier . module-or-enum-name
\end{syntax}

\begin{syntax}
named-expression-list:
  named-expression
  named-expression , named-expression-list
\end{syntax}

\begin{syntax}
named-expression:
  expression
  identifier = expression
\end{syntax}

\begin{syntax}
nil-expression:
  `nil'
\end{syntax}

\begin{syntax}
no-initialization-part:
  = `noinit'
\end{syntax}

\begin{syntax}
non-range-expression:
   expression
\end{syntax}

\begin{syntax}
on-statement:
  `on' expression `do' statement
  `on' expression block-statement
\end{syntax}

\begin{syntax}
operator-name: one of
  + $ $ $ $ - $ $ $ $ * $ $ $ $ / $ $ $ $ % $ $ $ $ ** $ $ $ $ ! $ $ $ $ == $ $ $ $ != $ $ $ $ <= $ $ $ $ >= $ $ $ $ < $ $ $ $ > $ $ $ $ << $ $ $ $ >> $ $ $ $ & $ $ $ $ | $ $ $ $ ^ $ $ $ $ ~
  += $ $ $ $ -= $ $ $ $ *= $ $ $ $ /= $ $ $ $ %= $ $ $ $ **= $ $ $ $ &= $ $ $ $ |= $ $ $ $ ^= $ $ $ $ <<= $ $ $ $ >>= $ $ $ $ <=> $ $ $ $ <~>
\end{syntax}

\begin{syntax}
param-for-statement:
  `for' `param' identifier `in' param-iteratable-expression `do' statement
  `for' `param' identifier `in' param-iteratable-expression block-statement
\end{syntax}

\begin{syntax}
param-iteratable-expression:
  range-literal
  range-literal `by' integer-literal
\end{syntax}

\begin{syntax}
parenthesesless-function-identifier:
  identifier
\end{syntax}

\begin{syntax}
parenthesized-expression:
  ( expression )
\end{syntax}

\begin{syntax}
primitive-type-parameter-part:
  ( integer-parameter-expression )
\end{syntax}

\begin{syntax}
primitive-type:
  `void'
  `bool' primitive-type-parameter-part[OPT]
  `int' primitive-type-parameter-part[OPT]
  `uint' primitive-type-parameter-part[OPT]
  `real' primitive-type-parameter-part[OPT]
  `imag' primitive-type-parameter-part[OPT]
  `complex' primitive-type-parameter-part[OPT]
  `string'
\end{syntax}

\begin{syntax}
privacy-specifier:
  `private'
  `public'
\end{syntax}

\begin{syntax}
proc-or-iter:
  `proc'
  `iter'
\end{syntax}

\begin{syntax}
procedure-declaration-statement:
  privacy-specifier[OPT] linkage-specifier[OPT] `proc' function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT]
    function-body
\end{syntax}

\begin{syntax}
query-expression:
  ? identifier[OPT]
\end{syntax}

\begin{syntax}
range-expression-list:
  range-expression
  range-expression, range-expression-list
\end{syntax}

\begin{syntax}
range-expression:
  expression
  strided-range-expression
  counted-range-expression
  aligned-range-expression
  sliced-range-expression
\end{syntax}

\begin{syntax}
range-literal:
  expression .. expression
  expression ..
  .. expression
  ..
\end{syntax}

\begin{syntax}
range-type:
  `range' ( named-expression-list )
\end{syntax}

\begin{syntax}
receiver-clause:
  expression .
\end{syntax}

\begin{syntax}
record-declaration-statement:
  simple-record-declaration-statement
  external-record-declaration-statement
\end{syntax}

\begin{syntax}
record-inherit-list:
  : record-type-list
\end{syntax}

\begin{syntax}
record-statement-list:
  record-statement
  record-statement record-statement-list
\end{syntax}

\begin{syntax}
record-statement:
  variable-declaration-statement
  method-declaration-statement
  type-declaration-statement
  empty-statement
\end{syntax}

\begin{syntax}
record-type-list:
  record-type
  record-type , record-type-list
\end{syntax}

\begin{syntax}
record-type:
  identifier
  identifier ( named-expression-list )
\end{syntax}

\begin{syntax}
rectangular-array-literal:
  [ expression-list ]
  [ expression-list , ]
\end{syntax}

\begin{syntax}
rectangular-domain-literal:
  { range-expression-list }
\end{syntax}

\begin{syntax}
rectangular-domain-type:
  `domain' ( named-expression-list )
\end{syntax}

\begin{syntax}
reduce-expression:
  reduce-scan-operator `reduce' iteratable-expression
  class-type `reduce' iteratable-expression
\end{syntax}

\begin{syntax}
reduce-scan-operator: one of
  + $ $ $ $ * $ $ $ $ && $ $ $ $ || $ $ $ $ & $ $ $ $ | $ $ $ $ ^ $ $ $ $ `min' $ $ $ $ `max' $ $ $ $ `minloc' $ $ $ $ `maxloc'
\end{syntax}

\begin{syntax}
reindexing-expression:
  : [ domain-expression ]
\end{syntax}

\begin{syntax}
remote-variable-declaration-statement:
  `on' expression variable-declaration-statement
\end{syntax}

\begin{syntax}
rename-base:
  identifier `as' identifier
  identifier
\end{syntax}

\begin{syntax}
rename-list:
  rename-base
  rename-base , rename-list
\end{syntax}

\begin{syntax}
return-intent:
  `const'
  `const ref'
  `ref'
  `param'
  `type'
\end{syntax}

\begin{syntax}
return-statement:
  `return' expression[OPT] ;
\end{syntax}

\begin{syntax}
return-type:
  : type-specifier
\end{syntax}

\begin{syntax}
scan-expression:
  reduce-scan-operator `scan' iteratable-expression
  class-type `scan' iteratable-expression
\end{syntax}

\begin{syntax}
select-statement:
  `select' expression { when-statements }
\end{syntax}

\begin{syntax}
serial-statement:
  `serial' expression[OPT] `do' statement
  `serial' expression[OPT] block-statement
\end{syntax}

\begin{syntax}
simple-class-declaration-statement:
  `class' identifier class-inherit-list[OPT] { class-statement-list[OPT] }
\end{syntax}

\begin{syntax}
simple-record-declaration-statement:
  `record' identifier record-inherit-list[OPT] { record-statement-list }
\end{syntax}

\begin{syntax}
simple-subdomain-type:
  `subdomain' ( domain-expression )
\end{syntax}

\begin{syntax}
single-type:
  `single' type-specifier
\end{syntax}

\begin{syntax}
sliced-range-expression:
  range-expression ( range-expression )
  range-expression [ range-expression ]
\end{syntax}

\begin{syntax}
slicing-index-set:
  domain-expression
  range-expression-list
\end{syntax}

\begin{syntax}
sparse-subdomain-type:
  `sparse' `subdomain'[OPT] ( domain-expression )
\end{syntax}

\begin{syntax}
statement:
  block-statement
  expression-statement
  assignment-statement
  swap-statement
  io-statement
  conditional-statement
  select-statement
  while-do-statement
  do-while-statement
  for-statement
  label-statement
  break-statement
  continue-statement
  param-for-statement
  use-statement
  empty-statement
  return-statement
  yield-statement
  module-declaration-statement
  procedure-declaration-statement
  external-procedure-declaration-statement
  exported-procedure-declaration-statement
  iterator-declaration-statement
  method-declaration-statement
  type-declaration-statement
  variable-declaration-statement
  remote-variable-declaration-statement
  on-statement
  cobegin-statement
  coforall-statement
  begin-statement
  sync-statement
  serial-statement
  atomic-statement
  forall-statement
  delete-statement
\end{syntax}

\begin{syntax}
statements:
  statement
  statement statements
\end{syntax}

\begin{syntax}
step-expression:
  expression
\end{syntax}

\begin{syntax}
strided-range-expression:
  range-expression `by' step-expression
\end{syntax}

\begin{syntax}
structured-type:
  class-type
  record-type
  union-type
  tuple-type
\end{syntax}

\begin{syntax}
swap-operator:
  <=>
\end{syntax}

\begin{syntax}
swap-statement:
  lvalue-expression swap-operator lvalue-expression
\end{syntax}

\begin{syntax}
sync-statement:
  `sync' statement
  `sync' block-statement
\end{syntax}

\begin{syntax}
sync-type:
  `sync' type-specifier
\end{syntax}

\begin{syntax}
synchronization-type:
  sync-type
  single-type
  atomic-type
\end{syntax}

\begin{syntax}
task-intent-clause:
  `with' ( task-intent-list )
\end{syntax}

\begin{syntax}
task-intent-list:
  formal-intent identifier
  formal-intent identifier, task-intent-list
\end{syntax}

\begin{syntax}
this-intent:
  `param'
  `ref'
  `type'
\end{syntax}

\begin{syntax}
tuple-component-list:
  tuple-component
  tuple-component , tuple-component-list
\end{syntax}

\begin{syntax}
tuple-component:
  expression
  `_'
\end{syntax}

\begin{syntax}
tuple-expand-expression:
  ( ... expression )
\end{syntax}

\begin{syntax}
tuple-expression:
  ( tuple-component , )
  ( tuple-component , tuple-component-list )
  ( tuple-component , tuple-component-list , )
\end{syntax}

\begin{syntax}
tuple-grouped-identifier-list:
  ( identifier-list )
\end{syntax}

\begin{syntax}
tuple-type:
  ( type-specifier , type-list )
\end{syntax}

\begin{syntax}
type-alias-declaration-list:
  type-alias-declaration
  type-alias-declaration , type-alias-declaration-list
\end{syntax}

\begin{syntax}
type-alias-declaration-statement:
  privacy-specifier[OPT] `config'[OPT] `type' type-alias-declaration-list ;
  external-type-alias-declaration-statement
\end{syntax}

\begin{syntax}
type-alias-declaration:
  identifier = type-specifier
  identifier
\end{syntax}

\begin{syntax}
type-binding:
  identifier .
\end{syntax}

\begin{syntax}
type-declaration-statement:
  enum-declaration-statement
  class-declaration-statement
  record-declaration-statement
  union-declaration-statement
  type-alias-declaration-statement
\end{syntax}

\begin{syntax}
type-list:
  type-specifier
  type-specifier , type-list
\end{syntax}

\begin{syntax}
type-part:
  : type-specifier
\end{syntax}

\begin{syntax}
type-specifier:
  primitive-type
  enum-type
  structured-type
  dataparallel-type
  synchronization-type
\end{syntax}

\begin{syntax}
unary-expression:
  unary-operator expression
\end{syntax}

\begin{syntax}
unary-operator: one of
  + $ $ $ $ - $ $ $ $ ~ $ $ $ $ !
\end{syntax}

\begin{syntax}
union-declaration-statement:
  `extern'[OPT] `union' identifier { union-statement-list }
\end{syntax}

\begin{syntax}
union-statement-list:
  union-statement
  union-statement union-statement-list
\end{syntax}

\begin{syntax}
union-statement:
  type-declaration-statement
  procedure-declaration-statement
  iterator-declaration-statement
  variable-declaration-statement
  empty-statement
\end{syntax}

\begin{syntax}
union-type:
  identifier
\end{syntax}

\begin{syntax}
use-statement:
  `use' module-or-enum-name-list ;
\end{syntax}

\begin{syntax}
value-expr:
  expression
\end{syntax}

\begin{syntax}
variable-argument-expression:
  ... expression
  ... ? identifier[OPT]
  ...
\end{syntax}

\begin{syntax}
variable-declaration-list:
  variable-declaration
  variable-declaration , variable-declaration-list
\end{syntax}

\begin{syntax}
variable-declaration-statement:
  privacy-specifier[OPT] config-or-extern[OPT] variable-kind variable-declaration-list ;
\end{syntax}

\begin{syntax}
variable-declaration:
  identifier-list type-part[OPT] initialization-part
  identifier-list type-part no-initialization-part[OPT]
  array-alias-declaration
\end{syntax}

\begin{syntax}
variable-expression:
  identifier
\end{syntax}

\begin{syntax}
variable-kind:
  `param'
  `const'
  `var'
  `ref'
  `const ref'
\end{syntax}

\begin{syntax}
when-statement:
  `when' expression-list `do' statement
  `when' expression-list block-statement
  `otherwise' statement
  `otherwise' `do' statement
\end{syntax}

\begin{syntax}
when-statements:
  when-statement
  when-statement when-statements
\end{syntax}

\begin{syntax}
where-clause:
  `where' expression
\end{syntax}

\begin{syntax}
while-do-statement:
  `while' expression `do' statement
  `while' expression block-statement
\end{syntax}

\begin{syntax}
yield-statement:
  `yield' expression ;
\end{syntax}

\section{Depth-First Lexical Productions}

\begin{syntax}
bool-literal: one of
  `true' $ $ $ $ `false'
\end{syntax}

\begin{syntax}
identifier:
  letter-or-underscore legal-identifier-chars[OPT]
\end{syntax}

\begin{syntax}
letter-or-underscore:
  letter
  `_'
\end{syntax}

\begin{syntax}
letter: one of
  `A' `B' `C' `D' `E' `F' `G' `H' `I' `J' `K' `L' `M' `N' `O' `P' `Q' `R' `S' `T' `U' `V' `W' `X' `Y' `Z'
  `a' `b' `c' `d' `e' `f' `g' `h' `i' `j' `k' `l' `m' `n' `o' `p' `q' `r' `s' `t' `u' `v' `w' `x' `y' `z'
\end{syntax}

\begin{syntax}
legal-identifier-chars:
  legal-identifier-char legal-identifier-chars[OPT]
\end{syntax}

\begin{syntax}
legal-identifier-char:
  letter-or-underscore
  digit
  `(*\texttt{\$}*)'
\end{syntax}

\begin{syntax}
digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7' `8' `9'
\end{syntax}

\begin{syntax}
imaginary-literal:
  real-literal `i'
  integer-literal `i'
\end{syntax}

\begin{syntax}
real-literal:
  digits[OPT] . digits exponent-part[OPT]
  digits .[OPT] exponent-part
  `0x' hexadecimal-digits[OPT] . hexadecimal-digits p-exponent-part[OPT]
  `0X' hexadecimal-digits[OPT] . hexadecimal-digits p-exponent-part[OPT]
  `0x' hexadecimal-digits .[OPT] p-exponent-part
  `0X' hexadecimal-digits .[OPT] p-exponent-part
\end{syntax}

\begin{syntax}
digits:
  digit
  digit digits
\end{syntax}

\begin{syntax}
exponent-part:
  `e' sign[OPT] digits
  `E' sign[OPT] digits
\end{syntax}

\begin{syntax}
sign: one of
  + $ $ $ $ -
\end{syntax}

\begin{syntax}
hexadecimal-digits:
  hexadecimal-digit
  hexadecimal-digit hexadecimal-digits
\end{syntax}

\begin{syntax}
hexadecimal-digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7' `8' `9' `A' `B' `C' `D' `E' `F' `a' `b' `c' `d' `e' `f'
\end{syntax}

\begin{syntax}
p-exponent-part:
  `p' sign[OPT] digits
  `P' sign[OPT] digits
\end{syntax}

\begin{syntax}
integer-literal:
  digits
  `0x' hexadecimal-digits
  `0X' hexadecimal-digits
  `0o' octal-digits
  `0O' octal-digits
  `0b' binary-digits
  `0B' binary-digits
\end{syntax}

\begin{syntax}
octal-digits:
  octal-digit
  octal-digit octal-digits
\end{syntax}

\begin{syntax}
octal-digit: one of
  `0' `1' `2' `3' `4' `5' `6' `7'
\end{syntax}

\begin{syntax}
binary-digits:
  binary-digit
  binary-digit binary-digits
\end{syntax}

\begin{syntax}
binary-digit: one of
  `0' `1'
\end{syntax}

\begin{syntax}
string-literal:
  " double-quote-delimited-characters[OPT] "
  ' single-quote-delimited-characters[OPT] '
\end{syntax}

\begin{syntax}
double-quote-delimited-characters:
  string-character double-quote-delimited-characters[OPT]
  ' double-quote-delimited-characters[OPT]
\end{syntax}

\begin{syntax}
string-character:
  `any character except the double quote, single quote, or new line'
  simple-escape-character
  hexadecimal-escape-character
\end{syntax}

\begin{syntax}
simple-escape-character: one of
  `$\backslash\mbox{\bf '}\hspace{5pt}$' `$\backslash$"$\hspace{5pt}$' `$\backslash$?$\hspace{5pt}$' `$\backslash$$\backslash$$\hspace{5pt}$' `$\backslash$a$\hspace{5pt}$' `$\backslash$b$\hspace{5pt}$' `$\backslash$f$\hspace{5pt}$' `$\backslash$n$\hspace{5pt}$' `$\backslash$r$\hspace{5pt}$' `$\backslash$t$\hspace{5pt}$' `$\backslash$v$\hspace{5pt}$'
\end{syntax}

\begin{syntax}
hexadecimal-escape-character:
  `$\backslash$x' hexadecimal-digits
\end{syntax}

\begin{syntax}
single-quote-delimited-characters:
  string-character single-quote-delimited-characters[OPT]
  " single-quote-delimited-characters[OPT]
\end{syntax}

\section{Depth-First Syntax Productions}

\begin{syntax}
module-declaration-statement:
  privacy-specifier[OPT] `module' module-identifier block-statement
\end{syntax}

\begin{syntax}
privacy-specifier:
  `private'
  `public'
\end{syntax}

\begin{syntax}
module-identifier:
  identifier
\end{syntax}

\begin{syntax}
block-statement:
  { statements[OPT] }
\end{syntax}

\begin{syntax}
statements:
  statement
  statement statements
\end{syntax}

\begin{syntax}
statement:
  block-statement
  expression-statement
  assignment-statement
  swap-statement
  io-statement
  conditional-statement
  select-statement
  while-do-statement
  do-while-statement
  for-statement
  label-statement
  break-statement
  continue-statement
  param-for-statement
  use-statement
  empty-statement
  return-statement
  yield-statement
  module-declaration-statement
  procedure-declaration-statement
  external-procedure-declaration-statement
  exported-procedure-declaration-statement
  iterator-declaration-statement
  method-declaration-statement
  type-declaration-statement
  variable-declaration-statement
  remote-variable-declaration-statement
  on-statement
  cobegin-statement
  coforall-statement
  begin-statement
  sync-statement
  serial-statement
  atomic-statement
  forall-statement
  delete-statement
\end{syntax}

\begin{syntax}
expression-statement:
  variable-expression ;
  member-access-expression ;
  call-expression ;
  constructor-call-expression ;
  let-expression ; 
\end{syntax}

\begin{syntax}
variable-expression:
  identifier
\end{syntax}

\begin{syntax}
member-access-expression:
  field-access-expression
  method-call-expression
\end{syntax}

\begin{syntax}
field-access-expression:
  receiver-clause[OPT] identifier
\end{syntax}

\begin{syntax}
receiver-clause:
  expression .
\end{syntax}

\begin{syntax}
expression:
  literal-expression
  nil-expression
  variable-expression
  enum-constant-expression
  call-expression
  iteratable-call-expression
  member-access-expression
  constructor-call-expression
  query-expression
  cast-expression
  lvalue-expression
  parenthesized-expression
  unary-expression
  binary-expression
  let-expression
  if-expression
  for-expression
  forall-expression
  reduce-expression
  scan-expression
  module-access-expression
  tuple-expression
  tuple-expand-expression
  locale-access-expression
  mapped-domain-expression
\end{syntax}

\begin{syntax}
literal-expression:
  bool-literal
  integer-literal
  real-literal
  imaginary-literal
  string-literal
  range-literal
  domain-literal
  array-literal
\end{syntax}

\begin{syntax}
range-literal:
  expression .. expression
  expression ..
  .. expression
  ..
\end{syntax}

\begin{syntax}
domain-literal:
  rectangular-domain-literal
  associative-domain-literal
\end{syntax}

\begin{syntax}
rectangular-domain-literal:
  { range-expression-list }
\end{syntax}

\begin{syntax}
range-expression-list:
  range-expression
  range-expression, range-expression-list
\end{syntax}

\begin{syntax}
range-expression:
  expression
  strided-range-expression
  counted-range-expression
  aligned-range-expression
  sliced-range-expression
\end{syntax}

\begin{syntax}
strided-range-expression:
  range-expression `by' step-expression
\end{syntax}

\begin{syntax}
step-expression:
  expression
\end{syntax}

\begin{syntax}
counted-range-expression:
  range-expression # expression
\end{syntax}

\begin{syntax}
aligned-range-expression:
  range-expression `align' expression
\end{syntax}

\begin{syntax}
sliced-range-expression:
  range-expression ( range-expression )
  range-expression [ range-expression ]
\end{syntax}

\begin{syntax}
associative-domain-literal:
   { associative-expression-list }
\end{syntax}

\begin{syntax}
associative-expression-list:
   non-range-expression
   non-range-expression, associative-expression-list
\end{syntax}

\begin{syntax}
non-range-expression:
   expression
\end{syntax}

\begin{syntax}
array-literal:
  rectangular-array-literal
  associative-array-literal
\end{syntax}

\begin{syntax}
rectangular-array-literal:
  [ expression-list ]
  [ expression-list , ]
\end{syntax}

\begin{syntax}
expression-list:
  expression
  expression , expression-list
\end{syntax}

\begin{syntax}
associative-array-literal:
  [ associative-expr-list ]
  [ associative-expr-list , ]
\end{syntax}

\begin{syntax}
associative-expr-list:
  index-expr => value-expr
  index-expr => value-expr, associative-expr-list
\end{syntax}

\begin{syntax}
index-expr:
  expression
\end{syntax}

\begin{syntax}
value-expr:
  expression
\end{syntax}

\begin{syntax}
nil-expression:
  `nil'
\end{syntax}

\begin{syntax}
enum-constant-expression:
  enum-type . identifier
\end{syntax}

\begin{syntax}
enum-type:
  identifier
\end{syntax}

\begin{syntax}
iteratable-call-expression:
  call-expression
\end{syntax}

\begin{syntax}
query-expression:
  ? identifier[OPT]
\end{syntax}

\begin{syntax}
cast-expression:
  expression : type-specifier
\end{syntax}

\begin{syntax}
type-specifier:
  primitive-type
  enum-type
  structured-type
  dataparallel-type
  synchronization-type
\end{syntax}

\begin{syntax}
primitive-type:
  `void'
  `bool' primitive-type-parameter-part[OPT]
  `int' primitive-type-parameter-part[OPT]
  `uint' primitive-type-parameter-part[OPT]
  `real' primitive-type-parameter-part[OPT]
  `imag' primitive-type-parameter-part[OPT]
  `complex' primitive-type-parameter-part[OPT]
  `string'
\end{syntax}

\begin{syntax}
primitive-type-parameter-part:
  ( integer-parameter-expression )
\end{syntax}

\begin{syntax}
integer-parameter-expression:
  expression
\end{syntax}

\begin{syntax}
structured-type:
  class-type
  record-type
  union-type
  tuple-type
\end{syntax}

\begin{syntax}
class-type:
  identifier
  identifier ( named-expression-list )
\end{syntax}

\begin{syntax}
named-expression-list:
  named-expression
  named-expression , named-expression-list
\end{syntax}

\begin{syntax}
named-expression:
  expression
  identifier = expression
\end{syntax}

\begin{syntax}
record-type:
  identifier
  identifier ( named-expression-list )
\end{syntax}

\begin{syntax}
union-type:
  identifier
\end{syntax}

\begin{syntax}
tuple-type:
  ( type-specifier , type-list )
\end{syntax}

\begin{syntax}
type-list:
  type-specifier
  type-specifier , type-list
\end{syntax}

\begin{syntax}
dataparallel-type:
  range-type
  domain-type
  mapped-domain-type
  array-type
  index-type
\end{syntax}

\begin{syntax}
range-type:
  `range' ( named-expression-list )
\end{syntax}

\begin{syntax}
domain-type:
  base-domain-type
  simple-subdomain-type
  sparse-subdomain-type
\end{syntax}

\begin{syntax}
base-domain-type:
  rectangular-domain-type
  associative-domain-type
\end{syntax}

\begin{syntax}
rectangular-domain-type:
  `domain' ( named-expression-list )
\end{syntax}

\begin{syntax}
associative-domain-type:
  `domain' ( associative-index-type )
  `domain' ( enum-type )
  `domain' ( `opaque' )
\end{syntax}

\begin{syntax}
associative-index-type:
  type-specifier
\end{syntax}

\begin{syntax}
simple-subdomain-type:
  `subdomain' ( domain-expression )
\end{syntax}

\begin{syntax}
domain-expression:
  domain-literal
  domain-name
  domain-assignment-expression
  domain-striding-expression
  domain-alignment-expression
  domain-slice-expression
\end{syntax}

\begin{syntax}
domain-name:
  identifier
\end{syntax}

\begin{syntax}
domain-assignment-expression:
  domain-name = domain-expression
\end{syntax}

\begin{syntax}
domain-striding-expression:
  domain-expression `by' expression
\end{syntax}

\begin{syntax}
domain-alignment-expression:
  domain-expression `align' expression
\end{syntax}

\begin{syntax}
domain-slice-expression:
  domain-expression [ slicing-index-set ]
  domain-expression ( slicing-index-set )
\end{syntax}

\begin{syntax}
slicing-index-set:
  domain-expression
  range-expression-list
\end{syntax}

\begin{syntax}
sparse-subdomain-type:
  `sparse' `subdomain'[OPT] ( domain-expression )
\end{syntax}

\begin{syntax}
mapped-domain-type:
  domain-type `dmapped' dmap-value
\end{syntax}

\begin{syntax}
dmap-value:
  expression
\end{syntax}

\begin{syntax}
array-type:
  [ domain-expression ] type-specifier
\end{syntax}

\begin{syntax}
index-type:
  `index' ( domain-expression )
\end{syntax}

\begin{syntax}
synchronization-type:
  sync-type
  single-type
  atomic-type
\end{syntax}

\begin{syntax}
sync-type:
  `sync' type-specifier
\end{syntax}

\begin{syntax}
single-type:
  `single' type-specifier
\end{syntax}

\begin{syntax}
atomic-type:
  `atomic' type-specifier
\end{syntax}

\begin{syntax}
lvalue-expression:
  variable-expression
  member-access-expression
  call-expression
  parenthesized-expression
\end{syntax}

\begin{syntax}
parenthesized-expression:
  ( expression )
\end{syntax}

\begin{syntax}
unary-expression:
  unary-operator expression
\end{syntax}

\begin{syntax}
unary-operator: one of
  + $ $ $ $ - $ $ $ $ ~ $ $ $ $ !
\end{syntax}

\begin{syntax}
binary-expression:
  expression binary-operator expression
\end{syntax}

\begin{syntax}
binary-operator: one of
  + $ $ $ $ - $ $ $ $ * $ $ $ $ / $ $ $ $ % $ $ $ $ ** $ $ $ $ & $ $ $ $ | $ $ $ $ ^ $ $ $ $ << $ $ $ $ >> $ $ $ $ && $ $ $ $ || $ $ $ $ == $ $ $ $ != $ $ $ $ <= $ $ $ $ >= $ $ $ $ < $ $ $ $ > $ $ $ $ `by' $ $ $ $ #
\end{syntax}

\begin{syntax}
if-expression:
  `if' expression `then' expression `else' expression
  `if' expression `then' expression
\end{syntax}

\begin{syntax}
for-expression:
  `for' index-var-declaration `in' iteratable-expression `do' expression
  `for' iteratable-expression `do' expression
\end{syntax}

\begin{syntax}
forall-expression:
  `forall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] `do' expression
  `forall' iteratable-expression task-intent-clause[OPT] `do' expression
  [ index-var-declaration `in' iteratable-expression task-intent-clause[OPT] ] expression
  [ iteratable-expression task-intent-clause[OPT] ] expression
\end{syntax}

\begin{syntax}
index-var-declaration:
  identifier
  tuple-grouped-identifier-list
\end{syntax}

\begin{syntax}
tuple-grouped-identifier-list:
  ( identifier-list )
\end{syntax}

\begin{syntax}
identifier-list:
  identifier
  identifier , identifier-list
  tuple-grouped-identifier-list
  tuple-grouped-identifier-list , identifier-list
\end{syntax}

\begin{syntax}
iteratable-expression:
  expression
  `zip' ( expression-list )
\end{syntax}

\begin{syntax}
task-intent-clause:
  `with' ( task-intent-list )
\end{syntax}

\begin{syntax}
task-intent-list:
  formal-intent identifier
  formal-intent identifier, task-intent-list
\end{syntax}

\begin{syntax}
formal-intent:
  `const'
  `const in'
  `const ref'
  `in'
  `out'
  `inout'
  `ref'
  `param'
  `type'
\end{syntax}

\begin{syntax}
reduce-expression:
  reduce-scan-operator `reduce' iteratable-expression
  class-type `reduce' iteratable-expression
\end{syntax}

\begin{syntax}
reduce-scan-operator: one of
  + $ $ $ $ * $ $ $ $ && $ $ $ $ || $ $ $ $ & $ $ $ $ | $ $ $ $ ^ $ $ $ $ `min' $ $ $ $ `max' $ $ $ $ `minloc' $ $ $ $ `maxloc'
\end{syntax}

\begin{syntax}
scan-expression:
  reduce-scan-operator `scan' iteratable-expression
  class-type `scan' iteratable-expression
\end{syntax}

\begin{syntax}
module-access-expression:
  module-identifier-list . identifier
\end{syntax}

\begin{syntax}
module-identifier-list:
  module-identifier
  module-identifier . module-identifier-list
\end{syntax}

\begin{syntax}
tuple-expression:
  ( tuple-component , )
  ( tuple-component , tuple-component-list )
  ( tuple-component , tuple-component-list , )
\end{syntax}

\begin{syntax}
tuple-component:
  expression
  `_'
\end{syntax}

\begin{syntax}
tuple-component-list:
  tuple-component
  tuple-component , tuple-component-list
\end{syntax}

\begin{syntax}
tuple-expand-expression:
  ( ... expression )
\end{syntax}

\begin{syntax}
locale-access-expression:
  expression . `locale'
\end{syntax}

\begin{syntax}
mapped-domain-expression:
  domain-expression `dmapped' dmap-value
\end{syntax}

\begin{syntax}
method-call-expression:
  receiver-clause[OPT] expression ( named-expression-list )
  receiver-clause[OPT] expression [ named-expression-list ]
  receiver-clause[OPT] parenthesesless-function-identifier
\end{syntax}

\begin{syntax}
parenthesesless-function-identifier:
  identifier
\end{syntax}

\begin{syntax}
call-expression:
  lvalue-expression ( named-expression-list )
  lvalue-expression [ named-expression-list ]
  parenthesesless-function-identifier
\end{syntax}

\begin{syntax}
constructor-call-expression:
  `new' class-name ( argument-list )
\end{syntax}

\begin{syntax}
class-name:
  identifier
\end{syntax}

\begin{syntax}
argument-list:
  ( formals[OPT] )
\end{syntax}

\begin{syntax}
formals:
  formal
  formal , formals
\end{syntax}

\begin{syntax}
formal:
  formal-intent[OPT] identifier formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] identifier formal-type[OPT] variable-argument-expression
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] variable-argument-expression
\end{syntax}

\begin{syntax}
default-expression:
  = expression
\end{syntax}

\begin{syntax}
formal-type:
  : type-specifier
  : ? identifier[OPT]
\end{syntax}

\begin{syntax}
variable-argument-expression:
  ... expression
  ... ? identifier[OPT]
  ...
\end{syntax}

\begin{syntax}
let-expression:
  `let' variable-declaration-list `in' expression
\end{syntax}

\begin{syntax}
assignment-statement:
  lvalue-expression assignment-operator expression
\end{syntax}

\begin{syntax}
assignment-operator: one of
   = $ $ $ $ += $ $ $ $ -= $ $ $ $ *= $ $ $ $ /= $ $ $ $ %= $ $ $ $ **= $ $ $ $ &= $ $ $ $ |= $ $ $ $ ^= $ $ $ $ &&= $ $ $ $ ||= $ $ $ $ <<= $ $ $ $ >>=
\end{syntax}

\begin{syntax}
swap-statement:
  lvalue-expression swap-operator lvalue-expression
\end{syntax}

\begin{syntax}
swap-operator:
  <=>
\end{syntax}

\begin{syntax}
io-statement:
  io-expression io-operator expression
\end{syntax}

\begin{syntax}
io-expression:
  expression
  io-expression io-operator expression
\end{syntax}

\begin{syntax}
io-operator:
  <`(*$\sim$*)'>
\end{syntax}

\begin{syntax}
conditional-statement:
  `if' expression `then' statement else-part[OPT]
  `if' expression block-statement else-part[OPT]
\end{syntax}

\begin{syntax}
else-part:
  `else' statement
\end{syntax}

\begin{syntax}
select-statement:
  `select' expression { when-statements }
\end{syntax}

\begin{syntax}
when-statements:
  when-statement
  when-statement when-statements
\end{syntax}

\begin{syntax}
when-statement:
  `when' expression-list `do' statement
  `when' expression-list block-statement
  `otherwise' statement
  `otherwise' `do' statement
\end{syntax}

\begin{syntax}
while-do-statement:
  `while' expression `do' statement
  `while' expression block-statement
\end{syntax}

\begin{syntax}
do-while-statement:
  `do' statement `while' expression ;
\end{syntax}

\begin{syntax}
for-statement:
  `for' index-var-declaration `in' iteratable-expression `do' statement
  `for' index-var-declaration `in' iteratable-expression block-statement
  `for' iteratable-expression `do' statement
  `for' iteratable-expression block-statement
\end{syntax}

\begin{syntax}
label-statement:
  `label' identifier statement
\end{syntax}

\begin{syntax}
break-statement:
  `break' identifier[OPT] ;
\end{syntax}

\begin{syntax}
continue-statement:
  `continue' identifier[OPT] ;
\end{syntax}

\begin{syntax}
param-for-statement:
  `for' `param' identifier `in' param-iteratable-expression `do' statement
  `for' `param' identifier `in' param-iteratable-expression block-statement
\end{syntax}

\begin{syntax}
param-iteratable-expression:
  range-literal
  range-literal `by' integer-literal
\end{syntax}

\begin{syntax}
use-statement:
  `use' module-or-enum-name-list ;
\end{syntax}

\begin{syntax}
module-or-enum-name-list:
  module-or-enum-name limitation-clause[OPT]
  module-or-enum-name , module-or-enum-name-list
\end{syntax}

\begin{syntax}
limitation-clause:
  `except' exclude-list
  `only' rename-list[OPT]
\end{syntax}

\begin{syntax}
exclude-list:
  identifier-list
  $ * $
\end{syntax}

\begin{syntax}
rename-list:
  rename-base
  rename-base , rename-list
\end{syntax}

\begin{syntax}
rename-base:
  identifier `as' identifier
  identifier
\end{syntax}

\begin{syntax}
module-or-enum-name:
  identifier
  identifier . module-or-enum-name
\end{syntax}

\begin{syntax}
empty-statement:
  ;
\end{syntax}

\begin{syntax}
return-statement:
  `return' expression[OPT] ;
\end{syntax}

\begin{syntax}
yield-statement:
  `yield' expression ;
\end{syntax}

\begin{syntax}
module-declaration-statement:
  privacy-specifier[OPT] `module' module-identifier block-statement
\end{syntax}

\begin{syntax}
procedure-declaration-statement:
  privacy-specifier[OPT] linkage-specifier[OPT] `proc' function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT]
    function-body
\end{syntax}

\begin{syntax}
linkage-specifier:
  `inline'
\end{syntax}

\begin{syntax}
function-name:
  identifier
  operator-name
\end{syntax}

\begin{syntax}
operator-name: one of
  + $ $ $ $ - $ $ $ $ * $ $ $ $ / $ $ $ $ % $ $ $ $ ** $ $ $ $ ! $ $ $ $ == $ $ $ $ != $ $ $ $ <= $ $ $ $ >= $ $ $ $ < $ $ $ $ > $ $ $ $ << $ $ $ $ >> $ $ $ $ & $ $ $ $ | $ $ $ $ ^ $ $ $ $ ~
  += $ $ $ $ -= $ $ $ $ *= $ $ $ $ /= $ $ $ $ %= $ $ $ $ **= $ $ $ $ &= $ $ $ $ |= $ $ $ $ ^= $ $ $ $ <<= $ $ $ $ >>= $ $ $ $ <=> $ $ $ $ <~>
\end{syntax}

\begin{syntax}
return-intent:
  `const'
  `const ref'
  `ref'
  `param'
  `type'
\end{syntax}

\begin{syntax}
return-type:
  : type-specifier
\end{syntax}

\begin{syntax}
where-clause:
  `where' expression
\end{syntax}

\begin{syntax}
function-body:
  block-statement
  return-statement
\end{syntax}

\begin{syntax}
external-procedure-declaration-statement:
  `extern' external-name[OPT] `proc' function-name argument-list return-intent[OPT] return-type[OPT]
\end{syntax}

\begin{syntax}
exported-procedure-declaration-statement:
  `export' external-name[OPT] `proc' function-name argument-list return-intent[OPT] return-type[OPT]
    function-body
\end{syntax}

\begin{syntax}
iterator-declaration-statement:
  privacy-specifier[OPT] `iter' iterator-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT]
  iterator-body
\end{syntax}

\begin{syntax}
iterator-name:
  identifier
\end{syntax}

\begin{syntax}
iterator-body:
  block-statement
  yield-statement
\end{syntax}

\begin{syntax}
method-declaration-statement:
  linkage-specifier[OPT] proc-or-iter this-intent[OPT] type-binding[OPT] function-name argument-list[OPT] 
    return-intent[OPT] return-type[OPT] where-clause[OPT] function-body
\end{syntax}

\begin{syntax}
proc-or-iter:
  `proc'
  `iter'
\end{syntax}

\begin{syntax}
this-intent:
  `param'
  `ref'
  `type'
\end{syntax}

\begin{syntax}
type-binding:
  identifier .
\end{syntax}

\begin{syntax}
type-declaration-statement:
  enum-declaration-statement
  class-declaration-statement
  record-declaration-statement
  union-declaration-statement
  type-alias-declaration-statement
\end{syntax}

\begin{syntax}
enum-declaration-statement:
  `enum' identifier { enum-constant-list }
\end{syntax}

\begin{syntax}
enum-constant-list:
  enum-constant
  enum-constant , enum-constant-list[OPT]
\end{syntax}

\begin{syntax}
enum-constant:
  identifier init-part[OPT]
\end{syntax}

\begin{syntax}
init-part:
  = expression
\end{syntax}

\begin{syntax}
class-declaration-statement:
  simple-class-declaration-statement
  external-class-declaration-statement
\end{syntax}

\begin{syntax}
simple-class-declaration-statement:
  `class' identifier class-inherit-list[OPT] { class-statement-list[OPT] }
\end{syntax}

\begin{syntax}
class-inherit-list:
  : class-type-list
\end{syntax}

\begin{syntax}
class-type-list:
  class-type
  class-type , class-type-list
\end{syntax}

\begin{syntax}
class-statement-list:
  class-statement
  class-statement class-statement-list
\end{syntax}

\begin{syntax}
class-statement:
  variable-declaration-statement
  method-declaration-statement
  type-declaration-statement
  empty-statement
\end{syntax}

\begin{syntax}
external-class-declaration-statement:
  `extern' external-name[OPT] simple-class-declaration-statement
\end{syntax}

\begin{syntax}
external-name:
  identifier
  string-literal
\end{syntax}

\begin{syntax}
record-declaration-statement:
  simple-record-declaration-statement
  external-record-declaration-statement
\end{syntax}

\begin{syntax}
simple-record-declaration-statement:
  `record' identifier record-inherit-list[OPT] { record-statement-list }
\end{syntax}

\begin{syntax}
record-inherit-list:
  : record-type-list
\end{syntax}

\begin{syntax}
record-type-list:
  record-type
  record-type , record-type-list
\end{syntax}

\begin{syntax}
record-statement-list:
  record-statement
  record-statement record-statement-list
\end{syntax}

\begin{syntax}
record-statement:
  variable-declaration-statement
  method-declaration-statement
  type-declaration-statement
  empty-statement
\end{syntax}

\begin{syntax}
external-record-declaration-statement:
  `extern' external-name[OPT] simple-record-declaration-statement
\end{syntax}

\begin{syntax}
union-declaration-statement:
  `extern'[OPT] `union' identifier { union-statement-list }
\end{syntax}

\begin{syntax}
union-statement-list:
  union-statement
  union-statement union-statement-list
\end{syntax}

\begin{syntax}
union-statement:
  type-declaration-statement
  procedure-declaration-statement
  iterator-declaration-statement
  variable-declaration-statement
  empty-statement
\end{syntax}

\begin{syntax}
type-alias-declaration-statement:
  privacy-specifier[OPT] `config'[OPT] `type' type-alias-declaration-list ;
  external-type-alias-declaration-statement
\end{syntax}

\begin{syntax}
type-alias-declaration-list:
  type-alias-declaration
  type-alias-declaration , type-alias-declaration-list
\end{syntax}

\begin{syntax}
type-alias-declaration:
  identifier = type-specifier
  identifier
\end{syntax}

\begin{syntax}
external-type-alias-declaration-statement:
  `extern' `type' type-alias-declaration-list ;
\end{syntax}

\begin{syntax}
variable-declaration-statement:
  privacy-specifier[OPT] config-or-extern[OPT] variable-kind variable-declaration-list ;
\end{syntax}

\begin{syntax}
config-or-extern: one of
  `config' $ $ $ $ `extern'
\end{syntax}

\begin{syntax}
variable-kind:
  `param'
  `const'
  `var'
  `ref'
  `const ref'
\end{syntax}

\begin{syntax}
variable-declaration-list:
  variable-declaration
  variable-declaration , variable-declaration-list
\end{syntax}

\begin{syntax}
variable-declaration:
  identifier-list type-part[OPT] initialization-part
  identifier-list type-part no-initialization-part[OPT]
  array-alias-declaration
\end{syntax}

\begin{syntax}
initialization-part:
  = expression
\end{syntax}

\begin{syntax}
type-part:
  : type-specifier
\end{syntax}

\begin{syntax}
no-initialization-part:
  = `noinit'
\end{syntax}

\begin{syntax}
array-alias-declaration:
  identifier reindexing-expression[OPT] => array-expression ;
\end{syntax}

\begin{syntax}
reindexing-expression:
  : [ domain-expression ]
\end{syntax}

\begin{syntax}
array-expression:
  expression
\end{syntax}

\begin{syntax}
remote-variable-declaration-statement:
  `on' expression variable-declaration-statement
\end{syntax}

\begin{syntax}
on-statement:
  `on' expression `do' statement
  `on' expression block-statement
\end{syntax}

\begin{syntax}
cobegin-statement:
  `cobegin' task-intent-clause[OPT] block-statement
\end{syntax}

\begin{syntax}
coforall-statement:
  `coforall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] `do' statement
  `coforall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] block-statement
  `coforall' iteratable-expression task-intent-clause[OPT] `do' statement
  `coforall' iteratable-expression task-intent-clause[OPT] block-statement
\end{syntax}

\begin{syntax}
begin-statement:
  `begin' task-intent-clause[OPT] statement
\end{syntax}

\begin{syntax}
sync-statement:
  `sync' statement
  `sync' block-statement
\end{syntax}

\begin{syntax}
serial-statement:
  `serial' expression[OPT] `do' statement
  `serial' expression[OPT] block-statement
\end{syntax}

\begin{syntax}
atomic-statement:
  `atomic' statement
\end{syntax}

\begin{syntax}
forall-statement:
  `forall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] `do' statement
  `forall' index-var-declaration `in' iteratable-expression task-intent-clause[OPT] block-statement
  `forall' iteratable-expression task-intent-clause[OPT] `do' statement
  `forall' iteratable-expression task-intent-clause[OPT] block-statement
  [ index-var-declaration `in' iteratable-expression task-intent-clause[OPT] ] statement
  [ iteratable-expression task-intent-clause[OPT] ] statement
\end{syntax}

\begin{syntax}
delete-statement:
  `delete' expression ;
\end{syntax}

