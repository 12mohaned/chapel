

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Constrained Generics &mdash; chpldoc 0.0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="chpldoc 0.0.1 documentation" href="../index.html"/>
        <link rel="next" title="ZeroMQ Integration" href="3.html"/>
        <link rel="prev" title="Chapel stack traces" href="14.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> chpldoc
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">chpldoc documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1.html">Chapel Improvement Proposals</a></li>
<li class="toctree-l1"><a class="reference internal" href="10.html">Initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="11.html">Alternative Initializer Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="12.html">Basics of Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="13.html">Record Copying in Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="14.html">Chapel stack traces</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Constrained Generics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rationale">Rationale</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#impenetrable-error-messages">Impenetrable Error Messages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reliability-of-generic-libraries">Reliability of Generic Libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hijacked-function-calls-inside-generics">Hijacked Function Calls Inside Generics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#overview-of-proposal-for-constrained-generics">Overview of Proposal for Constrained Generics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#interface-declarations">Interface Declarations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-2">Example 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-3">Example 3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implements-statements">Implements Statements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions-and-where-clauses">Functions and Where Clauses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#overload-resolution-for-checked-generic-functions">Overload Resolution for Checked Generic Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#type-equality">Type Equality</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#query-types">Query Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id15">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-any-type">The Any Type</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id16">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#semantics-requirements">Semantics Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fitting-in-with-existing-generics">Fitting in with Existing Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#resolved-questions">Resolved Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#open-questions">Open Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#decisions">Decisions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="3.html">ZeroMQ Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="4.html">Constructor Syntax and Semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="5.html">Implement Object Copying Using a &#8220;Postblit&#8221; Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="6.html">Tuple Semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="7.html">Rules for inserting autoCopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="8.html">Error Handling in Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="9.html">Chapel Package Manager</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">chpldoc</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Constrained Generics</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/modules/2.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="constrained-generics">
<h1>Constrained Generics<a class="headerlink" href="#constrained-generics" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt>Status</dt>
<dd>Draft</dd>
<dt>Author</dt>
<dd>Michael Ferguson, Jeremy Siek</dd>
</dl>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>Support constrained generics for Chapel in order to improve error messages and
to enable Chapel developers to think about interfaces while doing API design.</p>
</div>
<div class="section" id="rationale">
<h2>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h2>
<p>Chapel currently supports generic programming by providing generic functions,
classes, and records. That is, Chapel allows the programmer to parameterize
these entities with respect to one or more types.  Compared to other
programming languages, Chapel&#8217;s current design for generics most closely
resembles that of templates in C++.  Like C++, Chapel does not provide explicit
support for constrained generics, which negatively impacts its ease of
programming and modularity.  The next three subsections describe three examples
of the negative impacts.</p>
<div class="section" id="impenetrable-error-messages">
<h3>Impenetrable Error Messages<a class="headerlink" href="#impenetrable-error-messages" title="Permalink to this headline">¶</a></h3>
<p>The most noticeable problem with the current design for generics in Chapel is
that any misuse of a generic function results in an impenetrable error message
from the compiler. For example, consider the following program that erroneously
attempts to sort an array of objects of class <code class="docutils literal"><span class="pre">C</span></code> (which lacks a less-than
operator).</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Sort</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="nx">C</span><span class="p">;</span>
<span class="nx">QuickSort</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>The Chapel compiler emits the following error message:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$CHPL_HOME/modules/standard/Sort.chpl:37: error: unresolved call &#39;&lt;(C, C)&#39;
$CHPL_HOME/modules/internal/ChapelBase.chpl:309: note: candidates are: &lt;(param a: enumerated, param b: enumerated)
$CHPL_HOME/modules/internal/ChapelBase.chpl:1406: note:                 &lt;(a: uint(64), b: int(64))
$CHPL_HOME/modules/internal/ChapelBase.chpl:1407: note:                 &lt;(a: int(64), b: uint(64))
$CHPL_HOME/modules/internal/ChapelBase.chpl:1410: note:                 &lt;(a: uint(64), param b: uint(64))
$CHPL_HOME/modules/internal/ChapelBase.chpl:1413: note:                 &lt;(param a: uint(64), b: uint(64))
$CHPL_HOME/modules/internal/String.chpl:91: note:                 &lt;(a: string, b: string)
$CHPL_HOME/modules/internal/String.chpl:398: note:                 &lt;(a: c_string, b: c_string)
$CHPL_HOME/modules/internal/String.chpl:402: note:                 &lt;(param a: c_string, param b: c_string)
$CHPL_HOME/modules/internal/ChapelTuple.chpl:549: note:                 &lt;(a: _tuple, b: _tuple)
$CHPL_HOME/modules/standard/NewString.chpl:590: note:                 &lt;(a: string_rec, b: string_rec)
$CHPL_HOME/modules/internal/ChapelBase.chpl:289: note:                 &lt;(a: int(8), b: int(8))
$CHPL_HOME/modules/internal/ChapelBase.chpl:289: note:                 &lt;(a: int(16), b: int(16))
$CHPL_HOME/modules/internal/ChapelBase.chpl:289: note:                 &lt;(a: int(32), b: int(32))
$CHPL_HOME/modules/internal/ChapelBase.chpl:289: note:                 &lt;(a: int(64), b: int(64))
$CHPL_HOME/modules/internal/ChapelBase.chpl:290: note:                 &lt;(a: uint(8), b: uint(8))
$CHPL_HOME/modules/internal/ChapelBase.chpl:290: note:                 &lt;(a: uint(16), b: uint(16))
$CHPL_HOME/modules/internal/ChapelBase.chpl:290: note:                 &lt;(a: uint(32), b: uint(32))
$CHPL_HOME/modules/internal/ChapelBase.chpl:290: note:                 &lt;(a: uint(64), b: uint(64))
$CHPL_HOME/modules/internal/ChapelBase.chpl:291: note:                 &lt;(a: real(32), b: real(32))
$CHPL_HOME/modules/internal/ChapelBase.chpl:291: note:                 &lt;(a: real(64), b: real(64))
$CHPL_HOME/modules/internal/ChapelBase.chpl:292: note:                 &lt;(a: imag(32), b: imag(32))
$CHPL_HOME/modules/internal/ChapelBase.chpl:292: note:                 &lt;(a: imag(64), b: imag(64))
$CHPL_HOME/modules/internal/ChapelBase.chpl:307: note:                 &lt;(param a, param b)
$CHPL_HOME/modules/internal/ChapelBase.chpl:307: note:                 &lt;(param a, param b)
$CHPL_HOME/modules/internal/ChapelBase.chpl:307: note:                 &lt;(param a, param b)
$CHPL_HOME/modules/internal/ChapelBase.chpl:307: note:                 &lt;(param a, param b)
$CHPL_HOME/modules/internal/ChapelBase.chpl:308: note:                 &lt;(param a, param b)
$CHPL_HOME/modules/internal/ChapelBase.chpl:308: note:                 &lt;(param a, param b)
$CHPL_HOME/modules/internal/ChapelBase.chpl:308: note:                 &lt;(param a, param b)
$CHPL_HOME/modules/internal/ChapelBase.chpl:308: note:                 &lt;(param a, param b)
</pre></div>
</div>
<p>The main problem with the error message is that it points to line 37 of
<code class="docutils literal"><span class="pre">Sort.chpl</span></code> as the origin of the problem, when in fact the problem is the use
of array <code class="docutils literal"><span class="pre">A</span></code> in the call to <code class="docutils literal"><span class="pre">QuickSort</span></code>. A secondary problem with the error
message is that it exposes the internals of the <code class="docutils literal"><span class="pre">QuickSort</span></code> function to the
user, reducing the modularity of the <code class="docutils literal"><span class="pre">QuickSort</span></code> function. In more complex
library functions, the error may originate from within deeply nested auxiliary
functions, resulting in exceedingly long and impenetrable error messages (C++
template libraries have become infamous for this problem [1]).</p>
<p>The Chapel compiler needs more information in order to determine whether the
error is in the implementation of QuickSort or in the call to it.</p>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><ol class="first last upperalpha simple" start="18">
<li>Garcia, J. Järvi, A. Lumsdaine, J. G. Siek, and J. Willcock. An extended comparative study of language support for generic programming. Journal of Functional Programming, 17(2):145–205, March 2007.</li>
</ol>
</td></tr>
</tbody>
</table>
</div>
<div class="section" id="reliability-of-generic-libraries">
<h3>Reliability of Generic Libraries<a class="headerlink" href="#reliability-of-generic-libraries" title="Permalink to this headline">¶</a></h3>
<p>The current design for generics in Chapel also negatively impacts the
reliability of generic libraries. Unlike normal functions, the body of a
generic function is not type checked until it is used. This means that type
errors can lie dormant inside generic functions, only to be discovered after
they are distributed to users.</p>
<p>C++ templates are similar in this respect and we&#8217;ve found several bugs that
could have been caught if the body of a template were instead type checked at
the point of definition. For many years the <code class="docutils literal"><span class="pre">replace_copy</span></code> function template
in the Standard Template Library used a conditional expression to choose
between two values of potentially different type [2]. Conditional expressions
require that the type of one alternative be convertible to the other
alternative, but this was not documented as a requirement of the
<code class="docutils literal"><span class="pre">replace_copy</span></code> template. The fix is to change the conditional expression into
an <code class="docutils literal"><span class="pre">if</span></code> statement, thereby removing the need for convertibility.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><ol class="first last upperalpha simple" start="10">
<li><ol class="first upperalpha" start="7">
<li>Siek and A. Lumsdaine. A language for generic programming in the large. Science of Computer Programming, 76:423–465, September 2011.</li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
<p>Over the years, there were likely many users who tried to use <code class="docutils literal"><span class="pre">replace_copy</span></code>
with types that were not convertible and received an impenetrable error message
from the compiler. Such an error is doubly confusing because the user doesn&#8217;t
know whose fault it is. The user could be looking at a situation in which they
misused the generic function, as was the previous case with <code class="docutils literal"><span class="pre">QuickSort</span></code>, or
it could be the fault of the generic function&#8217;s author, as was the case with
<code class="docutils literal"><span class="pre">replace_copy</span></code>.</p>
</div>
<div class="section" id="hijacked-function-calls-inside-generics">
<h3>Hijacked Function Calls Inside Generics<a class="headerlink" href="#hijacked-function-calls-inside-generics" title="Permalink to this headline">¶</a></h3>
<p>Another problem with the current design for generics in Chapel concerns the
visibility of other functions from inside generic functions.</p>
<p>Suppose that a library developer creates the following module in which the
generic function named <code class="docutils literal"><span class="pre">print_hello_world</span></code> makes a call to another auxiliary
generic function named <code class="docutils literal"><span class="pre">helper</span></code>.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">helper</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;hello, world!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">print_hello_world</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">helper</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then suppose that an application programmer decides to use <code class="docutils literal"><span class="pre">M1</span></code> and writes
the following code. It just so happens that somewhere in the application, there
is another function named <code class="docutils literal"><span class="pre">helper</span></code>.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">helper</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;you&#39;ve been hijacked!&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nx">M1</span><span class="p">;</span>
<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">M1</span><span class="p">.</span><span class="nx">print_hello_world</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With the current Chapel function visibility rules, the result of this program
is:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>you&#39;ve been hijacked!
</pre></div>
</div>
<p>The above is a toy example, but this problem has come up in large C++
applications that use the Boost template libraries.  The most troubling aspect
of this problem is that there may be no immediate indication that something has
gone wrong, and the programmer may only find out much later and after lots of
debugging, that things are not as they seem.</p>
<p>These problems are the same as problems encountered by the C++ community when
working with templates. The strategy proposed for C++ with <em>concepts</em> can be
applied to Chapel.</p>
</div>
</div>
<div class="section" id="overview-of-proposal-for-constrained-generics">
<h2>Overview of Proposal for Constrained Generics<a class="headerlink" href="#overview-of-proposal-for-constrained-generics" title="Permalink to this headline">¶</a></h2>
<p>The core language support for constrained generics requires additions and
changes to four areas of the Chapel language. Here we give an overview of these
areas before discussing each of them in more detail in the following sections.</p>
<dl class="docutils">
<dt>Interface definitions</dt>
<dd>provide a mechanism for grouping and naming requirements on types.</dd>
<dt>Implements statements</dt>
<dd>establish that a type implements the requirements of a interface.</dd>
<dt>Where clauses</dt>
<dd>will be extended to express constraints on generic functions and generic
types. The main kind of constraint is requiring a type parameter to
implement an interface.</dd>
<dt>Instantiation</dt>
<dd>of generic functions, classes, and records changes to include checking that
the constraints in the where clause are satisfied.</dd>
</dl>
<p>An important aspect of the proposed design is that it provides modular type
checking. Most languages provide modular type checking for functions, which
means that the body of a function is type checked independently of any call to
the function, and the type checking of each call to a function only needs to
refer to the function signature (the parameter and return types) and not the
body of the function. However, the current design of Chapel does not provide
modular type checking for functions and generics. Instead, the body is type
checked at each call or point of instantiation. This is the root of the problem
that results in the non-modular error messages (Section 1.1) and the decreased
reliability of generics (Section 1.2). The proposed design enables the modular
type checking of both function and generics, thereby solving these two
problems.</p>
<p>In addition, because <em>where</em> clauses introduce type-specific operations into
scope, there is no need for special function visibility rules for constrained
generics, thereby avoiding the function hijacking problem discussed in Section
1.3.</p>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>Here we walk through a small but complete example that demonstrates the four
changes to Chapel to support constrained generics. This example shows a version
of <code class="docutils literal"><span class="pre">QuickSort</span></code> using constrained generics. To start, we define
<code class="docutils literal"><span class="pre">EqualityComparable</span></code> and <code class="docutils literal"><span class="pre">LessThanComparable</span></code> interfaces that will be used
to constrain the element type of the array passed to <code class="docutils literal"><span class="pre">QuickSort</span></code>.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span>interface EqualityComparable {
  proc ==(x : self, y: self): bool;
}
interface LessThanComparable : EqualityComparable {
  proc &lt;(x : self, y: self): bool;
}
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">LessThanComparable</span></code> interface extends the interface
<code class="docutils literal"><span class="pre">EqualityComparable</span></code>. The <code class="docutils literal"><span class="pre">EqualityComparable</span></code> interface requires an
implementing type to provide an equality operator and the
<code class="docutils literal"><span class="pre">LessThanComparable</span></code> interface requires an implementing type to also provide
a less-than operator. The self type is a place holder for the implementing
type. Note that procedure prototypes inside an interface do not have an
implicit “this” parameter.</p>
<p>A program asserts that a particular type implements an interface via an
implements statement. For example, here is a <code class="docutils literal"><span class="pre">Person</span></code> class that implements
the <code class="docutils literal"><span class="pre">LessThanComparable</span></code> interface.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span>class Person {
  var firstName : string;
  var lastName : string;
}

proc ==(a: Person, b: Person): bool {
  return a.firstName == b.firstName
         &amp;&amp; a.lastName == b.lastName;
}
proc &lt;(a: Person, b: Person): bool {
  return a.firstName &lt; b.firstName ||
         (a.firstName == b.firstName
           &amp;&amp; a.lastName &lt; b.lastName);
}

Person implements EqualityComparable;
Person implements LessThanComparable;
</pre></div>
</div>
<p>The first implements statement is valid because the <code class="docutils literal"><span class="pre">Person</span></code> class provides
an equality operator, and the second implements statement is valid because the
<code class="docutils literal"><span class="pre">Person</span></code> class provides a less-than operator and there is a prior implements
statement that asserts that <code class="docutils literal"><span class="pre">Person</span></code> implements <code class="docutils literal"><span class="pre">EqualityComparable</span></code>. A
compiler diagnostic error message is printed if an implements statement is
invalid.</p>
<p>Next we turn our attention to the <code class="docutils literal"><span class="pre">QuickSort</span></code> function. To place a constraint
on the element type of the array, we add to the where clause, requiring that
the element type implement the <code class="docutils literal"><span class="pre">LessThanComparable</span></code> interface.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="nx">Data</span><span class="p">:</span> <span class="p">[?</span><span class="nx">Dom</span><span class="p">])</span>
<span class="k">where</span> <span class="nx">Dom</span><span class="p">.</span><span class="nx">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Data</span><span class="p">.</span><span class="nx">eltType</span> <span class="nx">implements</span> <span class="nx">LessThanComparable</span>
<span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">Data</span><span class="p">(</span><span class="nx">mid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">lo</span><span class="p">))</span> <span class="k">then</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">mid</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">lo</span><span class="p">);</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When type constraints are added to the where clause of a procedure, such as in
the implements clause above, the procedure is type checked at its point of
definition. Any generic types, such as Data.eltType are considered by the type
checker to be unique types, only equal to themselves (unless otherwise
specified by type equality constraints). The body of the function may only make
use of generic types in ways permitted by the constraints in the where clause.
For example, in the above QuickSort, it would be an error to use any operator
other than equality and less-than on the element type of the array.</p>
<p>Last but not least, we consider a call to the QuickSort function.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="p">]</span> <span class="nx">Person</span><span class="p">;</span>
<span class="o">..</span><span class="p">.</span>
<span class="nx">QuickSort</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>At the point of the call, the Chapel implementation checks that the where
clause is satisfied. In this case, it must check that the element type of the
array, Person, has an implements statement for LessThanComparable, which it
does.</p>
</div>
</div>
<div class="section" id="interface-declarations">
<h2>Interface Declarations<a class="headerlink" href="#interface-declarations" title="Permalink to this headline">¶</a></h2>
<p>Interface definitions provide a mechanism for grouping and naming requirements
on types. The following shows two example interface definitions, with the
second interface Monoid refining (inheriting from) the first interface
Semigroup.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">interface</span> <span class="nx">Semigroup</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">binary_op</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span><span class="nx">T</span><span class="p">)</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">interface</span> <span class="nx">Monoid</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">:</span> <span class="nx">Semigroup</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">identity_elt</span><span class="p">()</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Inside a interface, the T type parameter is a place-holder for a concrete type
that will implement the interface.  Function declarations in a interface (the
def&#8217;s) express requirements for certain function definitions. The refines
clause provides a way of reusing interface definitions to define interfaces
with more requirements. Note though that <em>refines</em> is not a subtype
relationship since if I refines J and T1 implements I and T2 implements J, it
is not necessarily the case that T1 is a subtype of T2.</p>
<p>The syntax for interface definitions is listed below.</p>
<dl class="docutils">
<dt>interface–declaration–statement:</dt>
<dd>interface interface–name [( interface–formals )] [ : interface–inherit–list ] { interface–statement∗ }</dd>
<dt>interface–name:</dt>
<dd>identifier</dd>
<dt>interface–formals:</dt>
<dd>identifier
identifier, interface–formals</dd>
<dt>interface–inherit–list:</dt>
<dd>implements–clause
implements–clause , interface–inherit–list</dd>
<dt>interface–statement:</dt>
<dd>type identifier
type–constraint ;
function–signature–statement
function–declaration–statement</dd>
<dt>implements–clause:</dt>
<dd>type–list implements interface–name</dd>
<dt>type–constraint:</dt>
<dd>implements–clause
type–equality</dd>
<dt>type–equality:</dt>
<dd>type–specifier == type–specifier</dd>
<dt>where–clause:</dt>
<dd>where where–item–list</dd>
<dt>where–item–list:</dt>
<dd>where–item
where–item , where–item–list</dd>
<dt>where–item:</dt>
<dd>expression
type–constraint</dd>
</dl>
<p>An interface definition consists of a name for the interface, an optional list
of type parameters enclosed in parentheses that serve as place holders for the
modeling types, a list of interfaces that the interface inherits from, and a
body, which is a sequence of statements that express constraints on the
implementing types. The type parameters are in scope for the body of the
interface. The common case is for there to be only a single implementing type,
so if the interface definition omits the list of type parameters, then the type
name Self is in scope for the body of the interface and is a place holder for
the single implementing type.</p>
<div class="section" id="id3">
<h3>Example<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>The following Stack interface requires that the implementing type provide three
methods, push, pop, and isEmpty, and requires that the implementing type
specify a type to play the role of the itemType.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">interface</span> <span class="nx">Stack</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">itemType</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">Self</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="nx">itemType</span><span class="p">);</span>
  <span class="k">proc</span> <span class="nf">Self</span><span class="p">.</span><span class="nx">pop</span><span class="p">():</span> <span class="nx">itemType</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">Self</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">():</span> <span class="kt">bool</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The body of an interface consists of a list of constraints. In the following,
we describe the various kinds of constraints.</p>
<dl class="docutils">
<dt>Function signatures</dt>
<dd>A function signature says that an implementation must provide a function with
the specified name and compatible parameter and return types. What we mean by
“compatible” is described in detail in Section 4.</dd>
</dl>
</div>
<div class="section" id="example-2">
<h3>Example 2<a class="headerlink" href="#example-2" title="Permalink to this headline">¶</a></h3>
<p>The following Vector interface demonstrates four different kinds of function
signatures. The norm signature simply requires that the implementation provide
a regular function definition for norm. The + operator can be provided by
either a function definition or a method. The Self.size signature requires a
method, and the Self.these signature requires an iterator method.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span>interface Vector {
  type eltType;
  proc norm(v : Self): eltType;
  proc +(u : Self, v : Self): Self;
  proc Self.size(): int;
  iter Self.these(): eltType;
}
</pre></div>
</div>
<dl class="docutils">
<dt>Function definitions</dt>
<dd>A function definition statement in a interface provides a default
implementation. An implementation may provide an overriding definition of
the function, but if not, the definition provided by the interface will be
used.</dd>
</dl>
</div>
<div class="section" id="example-3">
<h3>Example 3<a class="headerlink" href="#example-3" title="Permalink to this headline">¶</a></h3>
<div class="highlight-chapel"><div class="highlight"><pre><span></span>interface LessThanComparable : EqualityComparable {
  proc &lt;(x : Self, y: Self): bool;
  proc &lt;=(x : Self, y: Self): bool
    { return !(y &lt; x); }
  proc &gt;(x : Self, y: Self): bool
    { return y &lt; x; }
  proc &gt;=(x : Self, y: Self): bool
    { return !(x &lt; y); }
}
</pre></div>
</div>
<dl class="docutils">
<dt>Associated types</dt>
<dd>Associated types are types that play an auxiliary role in the implementation
of a interface, such as the iterator of a container or the key type of a hash
table. The type statement adds the requirement for a type definition in any
implementation of the interface. The itemType in the above Stack interface
and the eltType in the Vector interface are examples of requiring an
associated type.</dd>
</dl>
<p>Open issue. The use of the keyword type for specifying associated types inside
interfaces may be confusing, as it has a different meaning than the use of type
inside a class, which in that context specifies a type parameter. With that in
mind, we may wish to find a different keyword for specifying associated types.</p>
<dl class="docutils">
<dt>Same-type constraints</dt>
<dd>The == interface statement requires that the two type expressions refer to
the same type. The type equality may be assumed in the body of the interface.
When the interface is used in the where clause of a generic function, the
type equality may be assumed in the body. In any implementation of the
interface, the concrete versions of the type expressions must be the same
type. We provide an example of same-type constraints with the below example
for nested requirements.</dd>
<dt>Nested requirements</dt>
<dd>Interfaces may be composed using implements statements. This composition is
similar to composing interfaces using inheritance, but there is one important
difference. Inheritance brings in the associated types from the base
interface whereas implements does not.</dd>
</dl>
<div class="highlight-chapel"><div class="highlight"><pre><span></span>interface LinearTransformation(Mat) {
  type Vec;
  type eltType;
  Vec implements VectorSpace;
  Vec.eltType == eltType;
  proc *(A : Mat, x : Vec): Vec;
  proc *(alpha : eltType, A : Mat): Mat;
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="implements-statements">
<h2>Implements Statements<a class="headerlink" href="#implements-statements" title="Permalink to this headline">¶</a></h2>
<p>Implementation statements establish that a type implements the requirements of
an interface.</p>
<p>The syntax for implements statements is as follows.</p>
<dl class="docutils">
<dt>implements-statement:</dt>
<dd>type implements interface–name [where–clause] ;
type implements interface–name [where–clause] { statement* }
implements interface–name(type-list) [where–clause] ;
implements interface–name(type-list) [where–clause] { statement* }</dd>
</dl>
<p>In addition, the implements statement can be appended to a class or record
declaration, e.g.:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">MyRecord</span> <span class="nx">implements</span> <span class="nx">SomeInterface</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">MyRecord</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
<span class="nx">MyRecord</span> <span class="nx">implements</span> <span class="nx">SomeInterface</span><span class="p">;</span>
</pre></div>
</div>
<p>Here are a few more examples:
.. code-block:: chapel</p>
<blockquote>
<div><p>// assert that a type implements multiple interfaces
MyRecord implements SomeInterface, SomeOtherInterface;</p>
<p>// assert that two types together implement an interface
implements TwoTypeInterface(MyRecord, int);</p>
</div></blockquote>
<p>The implements relation between a type and an interface is established by an
implements statement. All the requirements of the interface must be satisfied
at the point of the implements statement, either by definitions inside the
implements statement, by constraints in the where clause of the implements
statement, or by definitions in the lexical scope of the implements statement.
The definitions do not have to be an exact match, but they must be coercible to
the required function signature. An operator signature may be satisfied by
either a regular function or a method definition. The process for finding
function definitions is the same as for function name and overload resolution.
Inherited interfaces and nested requirements must be satisfied by preceding
implements statements. Requirements for associated types are satisfied by type
alias statements inside the implements statement or in the class or record
definition of the implementing type.</p>
<p>An implementation may itself be generic, which is why there is an optional
where clause. A common use of generic implementation statements is for adapter
classes, that is, classes that are parameterized over a type of some interface,
and use that interface to implement another interface. The rules for type
checking a generic implements statement are the same as for generic functions,
which we discuss in Section 5.</p>
<div class="section" id="id4">
<h3>Example<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The following example shows some interfaces from abstract algebra and
implements statements for integers.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">interface</span> <span class="nx">Semigroup</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">binary_op</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="nx">Self</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="nx">Self</span><span class="p">):</span><span class="nx">Self</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">interface</span> <span class="nx">Monoid</span> <span class="p">:</span> <span class="nx">Semigroup</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">identity_elt</span><span class="p">():</span> <span class="nx">Self</span><span class="p">;</span>
 <span class="p">}</span>
<span class="kt">int</span> <span class="nx">implements</span> <span class="nx">Semigroup</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">binary_op</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">int</span><span class="p">):</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nx">implements</span> <span class="nx">Monoid</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">identity_elt</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">int</span><span class="p">):</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Of course, there are other ways in which an integer can implement the Monoid
interface, such as using 1 for the identity element and multiplication for the
binary operation. In the proposed design, it is possible to provide multiple
implements statements for the same type and interface so long as the implements
statements reside in separate modules.</p>
</div>
<div class="section" id="functions-and-where-clauses">
<h3>Functions and Where Clauses<a class="headerlink" href="#functions-and-where-clauses" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>function-signature-statement:</dt>
<dd>proc function–name [argument–list] [var–param–clause] [where–clause] ;</dd>
<dt>function-declaration-statement:</dt>
<dd>proc function–name [argument–list] [var–param–clause] [where–clause] function–body</dd>
</dl>
<p>A function signature statement is a forward declaration of a function. It
states the that the specified function will be provided later or in a separate
compilation unit. All of the formal arguments in a function signature must have
type annotations.</p>
<p>If a function declaration includes at least one implements clause or type
equality constraint in its where clause, and no unconstrained generic
arguments, then the function is type checked at its point of definition.
The rules for functional visibility in generic functions (Section 22.2 of
the Chapel Language Specification 0.796) do not apply to such functions.</p>
<p>Open issue. Previous versions of this proposal also added a checked
keyword to request type checking at the point of definition. Current
versions of Chapel do not type check non-generic functions unless they are
called. We would like to reconsider that design choice.</p>
<p>One earlier idea was to trigger separate type checking when all of the
parameters of a function have a type annotation.  However, we have not
proposed that option here because it would not be backwards compatible,
that is, some existing Chapel programs would become ill typed (e.g.
proc(x:?t, y:t) ... ).</p>
<p>The where–clause of a generic function may include type constraints on the type arguments of the function. The type constraints in the where clause of a function play an important role in the type checking of the function body. Functions and methods in the required interfaces are considered visible in the function body. Furthermore, the required type equalities as stated in the interfaces or directly in the where clause, as well as the congruence closure of those equalities, are assumed to be equal during the type checking of the function body. We discuss issues regarding type equality in detail in Section 5.2.</p>
</div>
<div class="section" id="id5">
<h3>Example<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>In the following example, the function f is well-typed because S2 implements Stack, so the pop method on y has return type S2.itemType, S1 implements Stack so the push method on x has return type S1.itemType, and we have required that S1.itemType equal S2.itemType.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">interface</span> <span class="nx">Stack</span><span class="p">(</span><span class="nx">X</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">itemType</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">X</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="nx">itemType</span><span class="p">);</span>
  <span class="k">proc</span> <span class="nf">X</span><span class="p">.</span><span class="nx">pop</span><span class="p">():</span> <span class="nx">itemType</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">X</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">():</span> <span class="kt">bool</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="p">?</span><span class="nx">S1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="p">?</span><span class="nx">S2</span><span class="p">)</span>
  <span class="k">where</span> <span class="nx">S1</span> <span class="nx">implements</span> <span class="nx">Stack</span><span class="p">,</span>
        <span class="nx">S2</span> <span class="nx">implements</span> <span class="nx">Stack</span><span class="p">,</span>
        <span class="nx">S1</span><span class="p">.</span><span class="nx">itemType</span> <span class="o">==</span> <span class="nx">S2</span><span class="p">.</span><span class="nx">itemType</span>
<span class="p">{</span>
  <span class="nx">x</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">pop</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In more detail, suppose the where clause includes a requirement of the form T1
,. . .,Tm implements I, interface I has formal parameters X1 , . . . , Xm , and
I contains the following function signature.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>proc N(x1 : A1, ..., xn : An):B;
</pre></div>
</div>
<p>Then function N is visible in the function body, except that Ti is substituted for Xi throughout the signature, for i = 1 . . . m. The notation A[B1 . . . Bn/X1 . . . Xn] refers to the type A with all free occurrences of type variables X1 . . . Xn replaced by B1 . . . Bn , respectively. So using this notation, the function signature made visible in the function body can be written as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>proc N[T1 ...Tm/X1 ...Xm](x1 : A1[T1 ...Tm/X1 ...Xm],
                          ...,
                          xn : An[T1 ...Tm/X1 ...Xm]):B[T1 ...Tm/X1 ...Xm];
</pre></div>
</div>
<p>Inside an interface I,a declaration of the form type Y; expresses the
requirement for an associated type. That is, any type that implements I must
also specify a type to play the role of Y. (Section 4 describes how this is
done.) The associated type Y may be referred to in any of the following forms:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Y</li>
<li>X.Y (if X is the only formal parameter of interface I)</li>
<li>I(X).Y</li>
</ol>
</div></blockquote>
<p>The first two forms are shorthand for the third form. It is an error to use the
first or second form if it is ambiguous.</p>
</div>
<div class="section" id="id6">
<h3>Example<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Continuing the above example, in the function f, the type requirement S1
implements Stack causes the following methods to be visible:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">S1</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="nx">Stack</span><span class="p">(</span><span class="nx">S1</span><span class="p">).</span><span class="nx">itemType</span><span class="p">);</span>
<span class="k">proc</span> <span class="nf">S1</span><span class="p">.</span><span class="nx">pop</span><span class="p">():</span> <span class="nx">Stack</span><span class="p">(</span><span class="nx">S1</span><span class="p">).</span><span class="nx">itemType</span><span class="p">;</span>
<span class="k">proc</span> <span class="nf">S1</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">():</span> <span class="kt">bool</span><span class="p">;</span>
</pre></div>
</div>
<p>Similarly, the type requirement S1 implements Stack causes the following
methods to be visible:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">S2</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="nx">Stack</span><span class="p">(</span><span class="nx">S2</span><span class="p">).</span><span class="nx">itemType</span><span class="p">);</span>
<span class="k">proc</span> <span class="nf">S2</span><span class="p">.</span><span class="nx">pop</span><span class="p">():</span> <span class="nx">Stack</span><span class="p">(</span><span class="nx">S2</span><span class="p">).</span><span class="nx">itemType</span><span class="p">;</span>
<span class="k">proc</span> <span class="nf">S2</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">():</span> <span class="kt">bool</span><span class="p">;</span>
</pre></div>
</div>
<p>The type equality S1.itemType == S2.itemType is shorthand for Stack(S1).itemType == Stack(S2).itemType</p>
<p>It would be an error for the where clause or function body of f to refer to
itemType without any qualification. For example, if the type equality were
written as itemType == S2.itemType, it would be an error.</p>
<p>As a short-hand for implements clauses in the where clause, an interface name
may be used as the type for function parameter.</p>
<dl class="docutils">
<dt>type–specifier:</dt>
<dd>interface–name</dd>
</dl>
</div>
<div class="section" id="id7">
<h3>Example<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Here is the example from above, but this time using interface names in the parameter types instead of implements in the where clause.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">Stack</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">Stack</span><span class="p">)</span>
  <span class="k">where</span> <span class="nx">x</span><span class="p">.</span><span class="nx">itemType</span> <span class="o">==</span> <span class="nx">y</span><span class="p">.</span><span class="nx">itemType</span>
<span class="p">{</span>
   <span class="nx">x</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">pop</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="overload-resolution-for-checked-generic-functions">
<h2>Overload Resolution for Checked Generic Functions<a class="headerlink" href="#overload-resolution-for-checked-generic-functions" title="Permalink to this headline">¶</a></h2>
<p>Generic checked functions participate in overload resolution in a similar way
as normal generic functions. The two main differences are that type
requirements in where clauses can cause a generic functions to be removed from
the set of candidate functions and the type requirements play a role in
determining whether one function is more specific than another.</p>
<p>To check whether a generic function is a candidate, first the type arguments
for the query types are determined by pattern matching against the types of the
arguments to the generic function. Then, the type arguments are substituted for
the query types in the where clause. If the resulting type requirements are
satisfied in the current scope, then the generic function is a candidate. The
following rules specify when a type requirement is satisfied.</p>
<ol class="arabic simple">
<li>An implements clause is satisfied if there exists a most specific implements
statement in the lexical scope of the point of instantiation <em>or</em> an
implicit implement statement at that point could be added without
error.</li>
<li>A type equality is satisfied if the two type specifiers are equal in the
lexical scope of the point of instantiation.</li>
</ol>
<div class="section" id="id8">
<h3>Example<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>In the following, the call to g resolves to the first function named g because
that is the only candidate function. The second g is not a candidate because
class C does not implement J.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">interface</span> <span class="nx">I</span><span class="p">(</span><span class="nx">X</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">interface</span> <span class="nx">J</span><span class="p">(</span><span class="nx">X</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">C</span> <span class="nx">implements</span> <span class="nx">I</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="p">?</span><span class="nx">t</span><span class="p">)</span> <span class="k">where</span> <span class="nx">t</span> <span class="nx">implements</span> <span class="nx">I</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="p">?</span><span class="nx">t</span><span class="p">)</span> <span class="k">where</span> <span class="nx">t</span> <span class="nx">implements</span> <span class="nx">J</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">}</span>

<span class="nx">g</span><span class="p">(</span><span class="k">new</span> <span class="nx">C</span><span class="p">());</span>
</pre></div>
</div>
<p>Next, we discuss how type requirements in where clauses affect whether one
function is more specific than another function. Suppose that two
functions are equally specific using the normal rules. We then consider
the type requirements in the where clauses of each function; call them F1
and F2. If the type requirements of F1 can be satisfied inside the body of
F2, but not vice-versa, then F2 is more specific than F1.</p>
</div>
<div class="section" id="id9">
<h3>Example<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>In the following, the call to g resolves to the second function named g because
both functions are candidates but the second is more specific. In particular,
the type requirement of the first g, t implements I, is satisfied by the where
clause of the second g, but the type requirement t implements J of the second g
is not satisfied by the where clause of the first g.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">interface</span> <span class="nx">I</span><span class="p">(</span><span class="nx">X</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">interface</span> <span class="nx">J</span><span class="p">(</span><span class="nx">X</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">C</span> <span class="nx">implements</span> <span class="nx">I</span><span class="p">;</span>
<span class="nx">C</span> <span class="nx">implements</span> <span class="nx">J</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="p">?</span><span class="nx">t</span><span class="p">)</span> <span class="k">where</span> <span class="nx">t</span> <span class="nx">implements</span> <span class="nx">I</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="p">?</span><span class="nx">t</span><span class="p">)</span> <span class="k">where</span> <span class="nx">t</span> <span class="nx">implements</span> <span class="nx">I</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">implements</span> <span class="nx">J</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">}</span>

<span class="nx">g</span><span class="p">(</span><span class="k">new</span> <span class="nx">C</span><span class="p">());</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="type-equality">
<h2>Type Equality<a class="headerlink" href="#type-equality" title="Permalink to this headline">¶</a></h2>
<p>Type equality is a congruence relation, which means several things. First it means that type equality is an equivalence relation, so it is reflexive, transitive, and symmetric. Thus, for any types ρ, σ, τ we have</p>
<blockquote>
<div><ul class="simple">
<li>τ = τ,</li>
<li>σ=τ implies τ=σ, and</li>
<li>ρ=σ and σ=τ implies ρ=τ.</li>
</ul>
</div></blockquote>
<div class="section" id="id10">
<h3>Example<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>The following function is well typed.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">f</span> <span class="p">:</span> <span class="nx">func</span><span class="p">(?</span><span class="nx">T</span><span class="p">,?</span><span class="nx">S</span><span class="p">),</span> <span class="nx">a</span> <span class="p">:</span> <span class="p">?</span><span class="nx">R</span><span class="p">):</span><span class="nx">T</span> <span class="k">where</span> <span class="nx">R</span> <span class="o">==</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">T</span> <span class="o">==</span> <span class="nx">S</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are two things to check in the body of this function to determine whether
it is well typed. First, for the call f(a) to be well typed, the argument a
must have the same type as the parameter of function f. Thus, we need R equal
to T. The type checker would use the following reasoning to prove this. The
where clause gives us T == S, so by symmetry S == T. The where clause gives us
R == S, so by transitivity, we have R == T, which is what we needed.</p>
<p>The second thing that needs to be checked is that the thing returned has the
same type as the declared return type, so in this case we need to check that S
is equal to T. Again, we have T == S from the where clause, so by symmetry S ==
T.</p>
<p>The second aspect of type equality being a congruence is that it propagates in certain ways with respect to type constructors (that is, ways of constructing larger types out of smaller types). For example, if we know that S == T, then we can deduce that func(S,S) == func(T,T). Similarly, if we have a generic class such as</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">X</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>then S == T implies C(S) == C(T).</p>
</div>
<div class="section" id="id11">
<h3>Example<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>The following function is well typed.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">a</span> <span class="p">:</span> <span class="nx">C</span><span class="p">(</span><span class="nx">S</span><span class="p">),</span> <span class="nx">b</span> <span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">C</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="k">where</span> <span class="nx">S</span> <span class="o">==</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The only thing that needs to be checked is the return type, that is, we need
to check whether C(S) == C(T). But we know this is true using S == T and the
fact that equality is a congruence.</p>
<p>The propagation of equality can also go in the other direction. For example,
C(S) == C(T) implies that S == T.</p>
</div>
<div class="section" id="id12">
<h3>Example<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">a</span> <span class="p">:</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">b</span> <span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="k">where</span> <span class="nx">C</span><span class="p">(</span><span class="nx">S</span><span class="p">)</span> <span class="o">==</span> <span class="nx">C</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For this function, we need to check whether S == T. The where clause gives us
C(S) == C(T), so again by the fact that type equality is a congruence, we know
S == T.</p>
<p>The congruence also extends to associated types. For example, given the
following interface</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">interface</span> <span class="nx">I</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">helper</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">Self</span><span class="p">.</span><span class="nx">get_helper</span><span class="p">()</span> <span class="p">:</span> <span class="nx">helper</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>then S == T implies I(S).helper == I(T).helper. However, for associated types,
the propagation does not go in the reverse direction. The equality I(S).helper
== I(T).helper does not imply that S == T.</p>
</div>
<div class="section" id="id13">
<h3>Example<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>The following function is <em>not</em> well typed.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">a</span> <span class="p">:</span> <span class="p">?</span><span class="nx">S</span><span class="p">,</span> <span class="nx">b</span> <span class="p">:</span> <span class="p">?</span><span class="nx">T</span><span class="p">)</span> <span class="p">:</span> <span class="p">?</span><span class="nx">T</span>
  <span class="k">where</span> <span class="nx">S</span> <span class="nx">implements</span> <span class="nx">I</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">implements</span> <span class="nx">I</span><span class="p">,</span> <span class="nx">I</span><span class="p">(</span><span class="nx">S</span><span class="p">).</span><span class="nx">helper</span> <span class="o">==</span> <span class="nx">I</span><span class="p">(</span><span class="nx">T</span><span class="p">).</span><span class="nx">helper</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Just because I(S).helper == I(T).helper does not mean that S == T.</p>
<p>Like type parameters, associated types are in general assumed to be different from one another.</p>
</div>
<div class="section" id="id14">
<h3>Example<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>The following program is <em>not</em> well typed.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">s</span> <span class="p">:</span> <span class="p">?</span><span class="nx">S</span><span class="p">,</span> <span class="nx">t</span> <span class="p">:</span> <span class="p">?</span><span class="nx">T</span><span class="p">)</span> <span class="k">where</span> <span class="nx">S</span> <span class="nx">implements</span> <span class="nx">I</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">implements</span> <span class="nx">I</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="p">?</span><span class="nx">S</span><span class="p">.</span><span class="nx">helper</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">get_helper</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="query-types">
<h2>Query Types<a class="headerlink" href="#query-types" title="Permalink to this headline">¶</a></h2>
<p>We propose relaxing the restriction that a query type may only appear once in a
function signature. Instead, a query type may appear any number of times. The
query type resolves to the match for the first occurrence of the query type.</p>
<div class="section" id="id15">
<h3>Example<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>The following function and function call are well typed, assuming that
real numbers implement LessThanComparable. The query type T resolves to real,
and the second argument in the function call is coerced to real.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">min</span><span class="p">(</span><span class="nx">x</span> <span class="p">:</span> <span class="p">?</span><span class="nx">T</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="p">?</span><span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="k">where</span> <span class="nx">T</span> <span class="nx">implements</span> <span class="nx">LessThanComparable</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">x</span> <span class="k">then</span>
    <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-any-type">
<h2>The Any Type<a class="headerlink" href="#the-any-type" title="Permalink to this headline">¶</a></h2>
<p>We propose to support dynamic dispatch and dynamic polymorphism for interfaces using the any type feature. There are three forms for specifying an any type. We start with the simplest.</p>
<dl class="docutils">
<dt>type–specifier:</dt>
<dd>any interface–name</dd>
</dl>
<p>Any type T may be implicitly cast to the type any I, if T implements I. The methods and functions in interface I are available for use on objects of type any I.</p>
<div class="section" id="id16">
<h3>Example<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">interface</span> <span class="nx">I</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">Self</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">C</span> <span class="nx">implements</span> <span class="nx">I</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">any</span> <span class="nx">I</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span>
</pre></div>
</div>
<p>The next any form adds more expressiveness by including a where clause that includes one or more constraints on the any type. The type specifier is a pattern that specifies what the any type looks like.</p>
<dl class="docutils">
<dt>type–specifier:</dt>
<dd>any type–specifier where where–item–list</dd>
</dl>
</div>
<div class="section" id="id17">
<h3>Example<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>Continuing from the previous example, we have an any type that implements two interfaces, I and J.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="nx">interface</span> <span class="nx">J</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">Self</span><span class="p">.</span><span class="nx">g</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
<span class="nx">C</span> <span class="nx">implements</span> <span class="nx">J</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="nx">any</span> <span class="p">?</span><span class="nx">T</span> <span class="k">where</span> <span class="nx">T</span> <span class="nx">implements</span> <span class="nx">I</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">implements</span> <span class="nx">J</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">f</span><span class="p">();</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">g</span><span class="p">();</span>
</pre></div>
</div>
<p>The next example demonstrates the use of an any type with a slightly more complex type specifier, in this case a tuple.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">t</span> <span class="p">:</span> <span class="nx">any</span> <span class="p">(?</span><span class="nx">T</span><span class="p">,?</span><span class="nx">U</span><span class="p">)</span> <span class="k">where</span> <span class="nx">T</span> <span class="nx">implements</span> <span class="nx">I</span><span class="p">,</span> <span class="nx">U</span> <span class="nx">implements</span> <span class="nx">J</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nx">C</span><span class="p">(),</span> <span class="k">new</span> <span class="nx">C</span><span class="p">());</span>
<span class="nx">t</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">f</span><span class="p">();</span>
<span class="nx">t</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">g</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="semantics-requirements">
<h2>Semantics Requirements<a class="headerlink" href="#semantics-requirements" title="Permalink to this headline">¶</a></h2>
<p>The interface design here uses explicit support for semantic requirements
in order to support implicit implementation of interfaces (ie, it uses
the structural strategy for interface types; in other words, that a type
implements an interface can be inferred by the compiler).</p>
<p>However, it is important to be able to represent semantic requirements,
for example that addition is associative, or that an object should can be
serialized. Generally speaking, it is not enough for certain functions to
be available in order for these requirements to be satisfied. In fact, we
expect that the compiler will be unable to verify that these requirements
are satisfied.</p>
<p>So, we need a strategy to indicate that an interface is satisfied. One
way to do so would be to use special symbols in an interface that by
convention would only be specified when the programmer is asserting
that the required behavior is occurring. For example:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span>// Types implementing this interface are asserting
// that addition is associative
// This example is for discussion, not part of the plan
interface AssociativeAddition(T) {
  proc __behavior_associative_addition(T);
}

interface AdditiveSemigroup(T) : AssociativeAddition {
  proc +(T,T) : T;
  proc __behavior_associative_addition(T);
}
</pre></div>
</div>
<p>The main drawback to this approach is that __behavior_associative_addition
is an arbitrary name that really should be unique for AssociativeAddition.
So, it would be better to have the compiler generate a unique name - that
cannot collide with any other declaration - for such cases.</p>
<p>The best approach is to explicitly support nominal interfaces.
When an interface is marked with a special keyword, explicit, it
will require an explicit implements statement to be implemented.</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span>// Types implementing this interface are asserting
// that addition is associative
explicit interface AssociativeAddition(T) {
}

interface AdditiveSemigroup(T) : AssociativeAddition {
  proc +(T,T) : T;
}

// We can make int implement AdditiveSemigroup in two ways:
// Way 1: implement AssociativeAddition and rely on
//        inferred implements statements to get AdditiveSemigroup
int implements AssociativeAddition;

// Way 2: implement AdditiveSemigroup directly, which checks for
//        the required methods, but asserts that AssociativeAddition
//        is implemented (since it has no interfaces).
int implements AdditiveSemigroup;
</pre></div>
</div>
<p>Note that interfaces that refine an explicit interface will also require
an implement statement - either that the relevant type implements the
explicit interface, or that it implements the sub-interface (Way 1
and Way 2 in the example above).</p>
<p>Here are some possible alternatives to this design:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="c1">// Idea 1:</span>
<span class="c1">// explicitly support behaviors as alternatives to interfaces</span>
<span class="nx">newbehavior</span> <span class="nx">AssociativeAddition</span><span class="p">(</span><span class="nx">T</span><span class="p">);</span>
<span class="c1">// and possibly a different way to say something has the behavior</span>
<span class="nx">satisfies</span> <span class="nx">AssociativeAddition</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="c1">// Idea 2:</span>
<span class="c1">// syntax to create a unique placeholder</span>
<span class="nx">interface</span> <span class="nx">AssociativeAddition</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">unique</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="fitting-in-with-existing-generics">
<h2>Fitting in with Existing Generics<a class="headerlink" href="#fitting-in-with-existing-generics" title="Permalink to this headline">¶</a></h2>
<p>Chapel&#8217;s existing generics are in some ways more macro-like: flexible, but not
as type checked. The proposed constrained generics will not be able to do some
of the same things. Therefore, we propose to keep both the existing generics and also the constrained generics.</p>
<blockquote>
<div><ul class="simple">
<li>generic functions without a where clause will continue not to be type
checked until they are instantiated. That is important because calls inside
these generic functions are dependent on the type/param arguments of the
generic.</li>
<li>generic functions containing an implements statement will be typed checked
before instantiation and whether or not they are ever instantiated. We can
also call such functions <em>checked generics</em>.</li>
<li>I think it would be worth also making non-generic functions be type checked
if they are never called.  This will help prevent latent errors.
Programmers wishing to prototype can always comment out code that they do
not intend to call for the near term. However, the guarded generics
can be type checked early either way. (A Chapel user was recently
requesting for full type checking on chapel-users
&#8220;compiler and extern questions&#8221;)</li>
</ul>
</div></blockquote>
<p>Another issue is with compile-time folded conditionals, like this:</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="kd">type</span> <span class="o">==</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In a checked generic function, such compile-time folding is OK provided that
either:</p>
<blockquote>
<div><ol class="arabic simple">
<li>the conditional can be folded based on the type constraints in
the where clause</li>
<li>both sides of the conditional can compile with the generic type
constraint.</li>
</ol>
</div></blockquote>
<p>To make (2) a satisfying solution, the compiler might need to change
its idea of the types of variables as it does the type checking, e.g. in
the example</p>
<div class="highlight-chapel"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:?</span><span class="nx">t</span><span class="p">)</span> <span class="k">where</span> <span class="nx">t</span> <span class="nx">implements</span> <span class="nx">SomeInterface</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span><span class="kt">bool</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// this should be OK since the compiler knows x:bool</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that in simple cases, such functions can be implemented as separate
overloads of the same function.</p>
</div>
<div class="section" id="resolved-questions">
<h2>Resolved Questions<a class="headerlink" href="#resolved-questions" title="Permalink to this headline">¶</a></h2>
<p>Should implements statements be required (= nominal typing) or inferred (=
structural typing). Should we default to nominal and opt-in to structural?
Or vice versa?</p>
<ul class="simple">
<li>We plan to default to structural and have a way to make an &#8216;explicit&#8217;
or nominal interface</li>
</ul>
<p>What syntax should we use for implements clauses in where clauses? Should
we use &#8216;require&#8217; or some other keyword different from &#8216;where&#8217;?</p>
<ul class="simple">
<li>Plans to perform constrained generic checking after generic function
instantiation will allow us to combine constrained generics with
totally generic types or other sorts of where clauses. For that reason,
we should keep &#8216;implements&#8217; as part of where clauses, but also we will
support things like ! implements. Such more complicated examples will
fall back on the existing generics machinery and will not be fully
type checked apart from how they can be instantiated.</li>
</ul>
<p>How can functions with some unconstrained generic parameters and some
constrained generic parameters be type checked?</p>
<ul class="simple">
<li>By doing the constrained generics checking after function instantiation.
This approach adds extra type checking for constrained generics.</li>
</ul>
</div>
<div class="section" id="open-questions">
<h2>Open Questions<a class="headerlink" href="#open-questions" title="Permalink to this headline">¶</a></h2>
<p>What is the final syntax for interfaces? Do we want &#8216;Self&#8217; to refer to the
first type in an interface?</p>
<ul class="simple">
<li>There is some support for Self, but we have not yet decided if it
still needs to be mentioned explicitly in the type list for the
interface.</li>
</ul>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>NOTE: see Chris Wailes&#8217; documents Function Resolution States and Transitions and Proposed Function Resolution Chapel for previous implementation design work.</p>
<p>Overall he listed these design principles:</p>
<ol class="arabic simple">
<li>No non­generic function will ever be visited by instantiateGeneric.</li>
<li>No guarded generic function will ever be visited by resolveFn.</li>
<li>Guarded generic functions will only be instantiated during the second pass.
Non­guarded generic functions may be instantiated in the first pass if they
are called from a guarded generic.</li>
</ol>
<p>and plans for two passes:</p>
<ol class="arabic simple">
<li>Type check guarded generics and resolve implements statements</li>
<li>Resolve everything else and link generics</li>
<li>Instantiate generics</li>
<li>Finalize un-guarded generics</li>
<li>Finalize models</li>
</ol>
</div>
<div class="section" id="decisions">
<h2>Decisions<a class="headerlink" href="#decisions" title="Permalink to this headline">¶</a></h2>
<p>Several Chapel developers discussed this on June 2, 2015. There is broad
agreement on the general direction but some issues need to be addressed.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="3.html" class="btn btn-neutral float-right" title="ZeroMQ Integration" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="14.html" class="btn btn-neutral" title="Chapel stack traces" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, .

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 



</body>
</html>