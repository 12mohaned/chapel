

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Constructor Syntax and Semantics &mdash; chpldoc 0.0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="chpldoc 0.0.1 documentation" href="../index.html"/>
        <link rel="next" title="Implement Object Copying Using a “Postblit” Method" href="5.html"/>
        <link rel="prev" title="ZeroMQ Integration" href="3.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> chpldoc
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">chpldoc documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1.html">Chapel Improvement Proposals</a></li>
<li class="toctree-l1"><a class="reference internal" href="10.html">Initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="11.html">Alternative Initializer Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="12.html">Basics of Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="13.html">Record Copying in Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="14.html">Chapel stack traces</a></li>
<li class="toctree-l1"><a class="reference internal" href="2.html">Constrained Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="3.html">ZeroMQ Integration</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Constructor Syntax and Semantics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#revision-history">Revision History</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rationale">Rationale</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-existing-syntax-and-semantics">Example &#8211; Existing Syntax and Semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-proposed-syntax-and-semantics">Example &#8211; Proposed Syntax and Semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-existing-undesirable-behavior">Example &#8211; Existing Undesirable Behavior</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#description">Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variable-declaration-semantics">Variable Declaration Semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constructor-declaration-syntax">Constructor Declaration Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constructor-declaration-semantics">Constructor Declaration Semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inheritance">Inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#const-ness">Const-ness</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constructor-calls">Constructor Calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-notes">Implementation Notes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="5.html">Implement Object Copying Using a &#8220;Postblit&#8221; Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="6.html">Tuple Semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="7.html">Rules for inserting autoCopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="8.html">Error Handling in Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="9.html">Chapel Package Manager</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">chpldoc</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Constructor Syntax and Semantics</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/modules/4.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="constructor-syntax-and-semantics">
<h1>Constructor Syntax and Semantics<a class="headerlink" href="#constructor-syntax-and-semantics" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt>Status</dt>
<dd>Superseded</dd>
<dt>Author</dt>
<dd>Tom Hildebrandt</dd>
</dl>
<p>Expands the syntax for a constructor to support an initializer list and
clarifies the semantics of field initialization.</p>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>This Chapel Improvement Proposal records the last proposal for updated
constructor syntax and semantics.  This is the proposal that was presented at a
deep dive on 2014-12-09 with some changes based on feedback.</p>
</div>
<div class="section" id="revision-history">
<h2>Revision History<a class="headerlink" href="#revision-history" title="Permalink to this headline">¶</a></h2>
<p>2015-06-09 First version as a ChIP.</p>
<blockquote>
<div>Some time has passed since the December review.  This is my best
recollection of the current proposal: Corrections, revisions and suggestions are
welcome.</div></blockquote>
<p>2014-12-09 Deep dive and group review</p>
<p>2012-06-?? hilde and vass complete a first draft</p>
</div>
<div class="section" id="rationale">
<h2>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h2>
<p>Improvement of automated memory management (AMM) in Chapel forces a distinction
between initialization and assignment.  In a constructor, relying on
default-initialization of fields followed by assignment is inefficient.  Adding
syntax for explicit field initialization removes that inefficiency.  This optimization is
expanded to include variable declarations as well.
The specification and implementation of <code class="docutils literal"><span class="pre">const</span></code>-ness with respect to
objects and their fields is simplified.</p>
<p>A further goal of this proposal is to clarify the semantics of
initialization for objects of derived types.  Some programs compiled with the current
implementation exhibit undesirable behavior.  Stating the expected behavior clearly is a
first step toward replacing the current behavior with more reasonable semantics.</p>
<p>Two brief examples follow, to briefly show the differences between existing and proposed
constructors.  A further example follows, to show the undesirable behavior this
proposal seeks to correct.</p>
<div class="section" id="example-existing-syntax-and-semantics">
<h3>Example &#8211; Existing Syntax and Semantics<a class="headerlink" href="#example-existing-syntax-and-semantics" title="Permalink to this headline">¶</a></h3>
<p>An example of how a record constructor is currently written:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>record R {
  var i = 10;
  var r:real;
  var b:bool;

  proc R(s:real) {
    r = s;
  }
}

var t = new R(7.0);
writeln(t);         // Prints: &quot;(i = 10, r = 7.0, b = false)&quot;.
</pre></div>
</div>
<p>The above code declares a record of type <code class="docutils literal"><span class="pre">R</span></code> containing a constructor.  The constructor
accepts a real argument that is used to set the value of the <code class="docutils literal"><span class="pre">r</span></code> field.  Execution of
the declaration of <code class="docutils literal"><span class="pre">t</span></code> causes <code class="docutils literal"><span class="pre">t</span></code> to be associated with a record whose <code class="docutils literal"><span class="pre">i</span></code> field contains
the value &#8220;10&#8221;, <code class="docutils literal"><span class="pre">r</span></code> field contains the value &#8220;7.0&#8221; and the <code class="docutils literal"><span class="pre">b</span></code> field is &#8220;false&#8221;.</p>
<p>In more detail, an unnamed temporary record is created and default-initialized as follows:  The <code class="docutils literal"><span class="pre">i</span></code>
field receives the value &#8220;10&#8221;, which is the field-default specified in the record
declaration; since no default value is specified for the <code class="docutils literal"><span class="pre">r</span></code> field, the type-default
value for type <code class="docutils literal"><span class="pre">real</span></code> &#8220;0.0&#8221; is used; similarly, the default value of <code class="docutils literal"><span class="pre">bool</span></code> &#8220;false&#8221;
is used to initialize field <code class="docutils literal"><span class="pre">b</span></code>.  The body of the constructor is then entered.  The
value of field <code class="docutils literal"><span class="pre">r</span></code> is replaced by the value of <code class="docutils literal"><span class="pre">s</span></code> &#8211; whatever value was passed as the
argument of the corresponding constructor call.  In this case, <code class="docutils literal"><span class="pre">s</span></code> is &#8220;7.0&#8221;, so that is
the final value of the <code class="docutils literal"><span class="pre">r</span></code> field in the unnamed temporary.  The value of the
temporary is then bitwise-copied into the space reserved for <code class="docutils literal"><span class="pre">t</span></code>.</p>
<p>The problem with the above syntax is that the <code class="docutils literal"><span class="pre">=</span></code> in the body of the constructor must be
treated as assignment.  This is because there is no syntactical way to distinguish initializations
from assignment statements in that context.</p>
<p>If <code class="docutils literal"><span class="pre">s</span></code> is to be assigned to <code class="docutils literal"><span class="pre">r</span></code>, that
means that <code class="docutils literal"><span class="pre">r</span></code> must already have been initialized before the body of the constructor is
entered.  This means that all of the fields in an object must be initialized before the
body of one of its constructors is run.</p>
<p>In the current implementation, that is what happens: each field in a record or class being
constructed is first default-initialized; then, the statements in the body of the
constructor are executed.  Statements in the constructor body may then overwrite the
default field values with other values.</p>
<p>If the fields are of fairly simple types, then this default-initialization followed by
assignment is not so bad.  But when the types are complex or the assignment operator
expensive, then it adversely affects performance.</p>
</div>
<div class="section" id="example-proposed-syntax-and-semantics">
<h3>Example &#8211; Proposed Syntax and Semantics<a class="headerlink" href="#example-proposed-syntax-and-semantics" title="Permalink to this headline">¶</a></h3>
<p>An example of how a record constructor would be written under this proposal:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>record R {
  var i = 10;
  var r:real;
  var b:bool;

  proc R(s:real)
  init(r = s) {}
}

var t = new R(7.0);
writeln(r);         // Prints: &quot;(i = 10, r = 7.0, b = false)&quot;.
</pre></div>
</div>
<p>The user-visible semantics of this example are the same as for the one above.  However,
there are two important differences in the implementation.  The <code class="docutils literal"><span class="pre">=</span></code> appearing in the
<code class="docutils literal"><span class="pre">init</span></code> clause causes field <code class="docutils literal"><span class="pre">r</span></code> to be <em>initialized</em> with the value <code class="docutils literal"><span class="pre">s</span></code>.  This
replaces the default-initialization of <code class="docutils literal"><span class="pre">r</span></code> followed by assignment from <code class="docutils literal"><span class="pre">s</span></code> with a
simple copy-initialization from <code class="docutils literal"><span class="pre">s</span></code>.  The syntax for the initialization of <code class="docutils literal"><span class="pre">t</span></code> remains
the same, but the initialization is performed in-place, so the above bitwise copy is avoided.</p>
<p>In more detail, space for <code class="docutils literal"><span class="pre">t</span></code> is allocated.  The constructor is then invoked on <code class="docutils literal"><span class="pre">t</span></code> as a
method.  It first executes the <code class="docutils literal"><span class="pre">init</span></code> clause.  This clause causes field <code class="docutils literal"><span class="pre">t.r</span></code> to be
initialized using the value of <code class="docutils literal"><span class="pre">s</span></code>.  After all explicit field initializations appearing
in the <code class="docutils literal"><span class="pre">init</span></code> clause have been executed, the uninitialized fields in <code class="docutils literal"><span class="pre">t</span></code> are
initialized in lexical order (according to the order in which they appear in the
declaration of <code class="docutils literal"><span class="pre">record</span> <span class="pre">R</span></code>).  The first such field is <code class="docutils literal"><span class="pre">i</span></code>.  Since a field-default value
of &#8220;10&#8221; is supplied, that value is used to initialize <code class="docutils literal"><span class="pre">i</span></code>.  Since <code class="docutils literal"><span class="pre">r</span></code> has already been
initialized, it is skipped.  Since there is no field-default value for <code class="docutils literal"><span class="pre">b</span></code>, it is
initialized using its type-default value &#8220;false&#8221;.  Then, control is transferred to the
body of the constructor, which in this case is empty.  Since <code class="docutils literal"><span class="pre">t</span></code> is initialized
in-place, no bitwise copy is required after construction.</p>
</div>
<div class="section" id="example-existing-undesirable-behavior">
<h3>Example &#8211; Existing Undesirable Behavior<a class="headerlink" href="#example-existing-undesirable-behavior" title="Permalink to this headline">¶</a></h3>
<p>The following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>class C {
  var x: int;
  proc myfunc() { x = 1; }
  proc C() { myfunc(); }
}

class SubC : C {
  proc myfunc() { x = 2; };
}

var myc = new C();
writeln(myc);
var mysubc = new SubC();
writeln(mysubc);
</pre></div>
</div>
<p>is expected to produce:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>{x = 1}
{x = 2}
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>{x = 1}
{x = 1}
</pre></div>
</div>
<p>but instead outputs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>{x = 1}
{x = 0}
</pre></div>
</div>
<p>The rationale for the expected output is that the default initialization of an
object of type <code class="docutils literal"><span class="pre">SubC</span></code> should first perform default-initialization on its
base-class sub-object.  This would entail calling the zero-argument constructor
defined in <code class="docutils literal"><span class="pre">class</span> <span class="pre">C</span></code>.  If the object being initialized has acquired its
dynamic type by that point in execution, then the call to myfunc() in the
constructor for <code class="docutils literal"><span class="pre">C</span></code> would dispatch to SubC.myfunc() and the value of its <code class="docutils literal"><span class="pre">x</span></code>
field would be set to 2.  Otherwise, since the static type of the base-class
object is C, it would dispatch to C.myfunc().  In that case, the value of the
object&#8217;s <code class="docutils literal"><span class="pre">x</span></code> field would be set to 1.  In no case should it be set to 0.</p>
<p>According to the current proposal, although dynamically-bound (polymorphic)
functions can be invoked in the body of a constructor, the dynamic type of an
object is not acquired until execution of is initializer list is complete.  That
means that initialization of the base-class sub-object will use the static type
of the base-class sub-object when dispatching to any methods called in the body of any of base-class
constructor.  That means that we will end up with the second behavior: Both base-
and derived-class objects will end up with their <code class="docutils literal"><span class="pre">x</span></code> fields initialized to 1.</p>
</div>
</div>
<div class="section" id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>The proposal is to add field-initializer syntax and semantics to the Chapel
language.  It clarifies the order of initialization of fields &#8211; including
initialization of base-class sub-objects &#8211; and describes when <code class="docutils literal"><span class="pre">const</span></code>
declarations (implying immutability) apply to the fields in an object and to the
object as a whole.</p>
<p>This proposal is a summary of the current state of the proposal based on
feedback on the previous proposal, presented to the group on a deep dive on
December 9 last year.  The previous proposal may be found in the source tree at
<a class="reference external" href="https://github.com/chapel-lang/chapel/spec/proposals/constructors">https://github.com/chapel-lang/chapel/spec/proposals/constructors</a>.</p>
<p>For simplicity, this ChIP contains only the main proposal; support
for <code class="docutils literal"><span class="pre">noinit</span></code> initialization is handled in a separate ChIP [reference to be supplied].</p>
<p>The details of the proposal are given below, and restated briefly in the <a class="reference internal" href="#summary"><span>Summary</span></a> section.</p>
<div class="section" id="variable-declaration-semantics">
<span id="variables"></span><h3>Variable Declaration Semantics<a class="headerlink" href="#variable-declaration-semantics" title="Permalink to this headline">¶</a></h3>
<p>The syntax for variable declarations remains unchanged from the current specification.
However, the distinction between initialization and assignment offered in this proposal
requires a clarification of the <em>semantics</em> of variable initialization in light of that
distinction.</p>
<p>Given a declaration with an initializer:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>var r:R = &lt;expr&gt;;
</pre></div>
</div>
<p>The semantics of the current implementation are to first create and default-initialize the
variable <code class="docutils literal"><span class="pre">r</span></code>.  The initialization expression is evaluated and its value copied into the
named variable <code class="docutils literal"><span class="pre">r</span></code> by assignment.  In the context of a variable declaration, <code class="docutils literal"><span class="pre">=</span></code> means
&#8220;assignment&#8221;.  So the above declaration is exactly equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>var r:R;    // r is default-initialized
r = &lt;expr&gt;; // The value of &lt;expr&gt; is copied into r by assignment.
</pre></div>
</div>
<p>Here, we propose that in the context of a variable declaration, the <code class="docutils literal"><span class="pre">=</span></code> symbol be
treated as initialization instead.  That is, the above declaration statement should be
interpreted roughly as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>pragma &quot;noinit&quot; var r:R; // Create space for r but don&#39;t initialize it.
r.R(&lt;expr&gt;);             // Call a constructor on r.
</pre></div>
</div>
<p>This implementation does not use assignment.  Instead, it assumes the existence of a
constructor for type <code class="docutils literal"><span class="pre">R</span></code> that can bind to an argument of the type of <code class="docutils literal"><span class="pre">&lt;expr&gt;</span></code>. <a class="footnote-reference" href="#id13" id="id1">[1]</a>
If the initialization expression is already of the same type as the variable (as, for
example, when the type of the variable is not stated explicitly), then copy-construction
will be used.</p>
<p>Under the proposal stated thus far, the syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>var r = new R(&lt;args&gt;);
</pre></div>
</div>
<p>would imply that a temporary of type <code class="docutils literal"><span class="pre">R</span></code> is created and initialized by a call to
<code class="docutils literal"><span class="pre">R(&lt;args&gt;)</span></code>.  The resulting value would then be copied into <code class="docutils literal"><span class="pre">r</span></code> through
copy-construction.  (And finally, the temporary would be destroyed.)</p>
<p>We propose to take this a step further.  Since the constructor for the temporary
expression already operates on an object of type <code class="docutils literal"><span class="pre">R</span></code> it may as well operate on the
variable being declared.  In that special case, the temporary is not needed and one
copy-construction can be eliminated by invoking <code class="docutils literal"><span class="pre">R(&lt;args&gt;)</span></code> on <code class="docutils literal"><span class="pre">r</span></code> directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>pragma &quot;noinit&quot; var r:R; // Reserve some space for r.
r.R(&lt;args&gt;);             // Initialize it by calling R(&lt;args&gt;).
</pre></div>
</div>
<p>This special case could be considered an optimization, but it isn&#8217;t really:  It would have
observable effects within the program since it affects the number of times the
copy-constructor (or its equivalent) is called.  The recommendation is to leave
unspecified whether the copy-constructor is called in this case.</p>
</div>
<div class="section" id="constructor-declaration-syntax">
<span id="syntax"></span><h3>Constructor Declaration Syntax<a class="headerlink" href="#constructor-declaration-syntax" title="Permalink to this headline">¶</a></h3>
<p>In the current proposal, a constructor is introduced using the &#8220;C++&#8221; style: It
is a normal procedure declaration whose name matches the name of a (class or
record) type (the <em>subject type</em>) in scope at the point of declaration. <a class="footnote-reference" href="#id14" id="id2">[2]</a>  A
constructor may contain a field-initializer clause.  At present, the syntax for
a constructor is the same as for a procedure or method declaration, as given
by:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>procedure-declaration-statement:
  linkage-specifier[OPT] `proc&#39; function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT] function-body
method-declaration-statement:
  linkage-specifier[OPT] proc-or-iter this-intent[OPT] type-binding function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT] function-body
</pre></div>
</div>
<p>According to the proposal, the syntax would be augmented by the addition of an
optional field-initializer-clause:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>procedure-declaration-statement:
  linkage-specifier[OPT] `proc&#39; function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT] field-initializer-clause[OPT] function-body
method-declaration-statement:
  linkage-specifier[OPT] proc-or-iter this-intent[OPT] type-binding function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT] field-initializer-clause[OPT] function-body
</pre></div>
</div>
<p>It is illegal for a non-constructor method to contain a
<code class="docutils literal"><span class="pre">field-initializer-clause</span></code>.  Because a special keyword is not used to
introduce a constructor, it is impossible to distinguish between normal
procedure declarations and constructor declarations (and respectively between
normal method declarations versus method constructor declarations) based on
syntax alone.  Parser production code or downstream processing must be employed
to enforce this constraint.</p>
<p>The rest of the required syntax is supplied by productions that render the
<code class="docutils literal"><span class="pre">field-initializer-clause</span></code> in terms of previously-defined language elements
(consult the Syntax chapter in the <cite>Chapel Specification &lt;http://chapel.cray.com/spec/spec-0.97.pdf</cite> for their definitions):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>field-initializer-clause:
  `init&#39; ( field-initializer-list )
  `init&#39; = constructor-call-expression

field-initializer-list:
  field-initializer
  field-initializer-list , field-initializer

field-initializer:
  field-name = expression
  field-name
  variable-declaration

field-name:
  identifier

pseudo-field-name:
  identifier

constructor-call-expression:
  call-expression
</pre></div>
</div>
<p>In the first form of <code class="docutils literal"><span class="pre">field-initializer-clause</span></code>, the <code class="docutils literal"><span class="pre">init</span></code> keyword is used
to introduce the list of field-initializers.  The list of field-initializers is
comma-separated and enclosed in parentheses.  Each field-name must name a
<code class="docutils literal"><span class="pre">var</span></code> or <code class="docutils literal"><span class="pre">const</span></code> field in the base type of the constructor, or be
<code class="docutils literal"><span class="pre">super</span></code>.</p>
<p>If a <code class="docutils literal"><span class="pre">variable-declaration</span></code> appears in
the <code class="docutils literal"><span class="pre">field-initializer-list</span></code>, it creates a pseudo-field.  A pseudo-field can
be useful for capturing intermediate results, e.g. to initialize two different
fields to the same value &#8211; the calculation of which is nontrivial.</p>
<p>In the second form, the <code class="docutils literal"><span class="pre">init</span></code> keyword is followed by an <code class="docutils literal"><span class="pre">=</span></code> followed by a
constructor call expression.  The name of constructor must match the name of the
subject type.  The second form allows one constructor to invoke another.  It
takes the place of a normal initializer list. <a class="footnote-reference" href="#id15" id="id3">[3]</a></p>
</div>
<div class="section" id="constructor-declaration-semantics">
<span id="semantics"></span><h3>Constructor Declaration Semantics<a class="headerlink" href="#constructor-declaration-semantics" title="Permalink to this headline">¶</a></h3>
<p>A constructor is a method on an object of the subject type.  When execution of a
constructor begins, the object (<code class="docutils literal"><span class="pre">this</span></code>) is in an uninitialized state (hence
all of its fields are also uninitialized).  Execution of the constructor
proceeds by first executing the <code class="docutils literal"><span class="pre">field-initializer-clause</span></code> and then executing the body of
the constructor.</p>
<p>Execution of the <code class="docutils literal"><span class="pre">field-initializer-clause</span></code> proceeds by executing each of the
<code class="docutils literal"><span class="pre">field-initializer</span></code> in lexical order.  In the form containing an <code class="docutils literal"><span class="pre">=</span></code>, the
expression is evaluated and its value is used to initialize the corresponding
field in the object, as if by a constructor call.  These semantics are intended to be the
same as for initialization in the context of a variable declaration, as discussed above in
<a class="reference internal" href="#variables"><span>Variable Declaration Semantics</span></a>.  In the form containing just a
<code class="docutils literal"><span class="pre">field-name</span></code>, the field is initialized using the default-initializer supplied
in the field declaration, if present.  Otherwise, it is initialized using the
default value corresponding to its type.</p>
<p>The keyword <code class="docutils literal"><span class="pre">super</span></code> refers to the base-class sub-object.  The <code class="docutils literal"><span class="pre">super</span></code> field
behaves like any other field in the class. <a class="footnote-reference" href="#id16" id="id4">[4]</a>  A pseudo-field behaves like a normal
variable declaration.  The variable introduced by a pseudo-field remains in
scope until the end of the constructor body.</p>
<p>After all <code class="docutils literal"><span class="pre">field-initializer</span></code> expressions have
been processed, any fields in the object that remain uninitialized are
initialized in order of their appearance in the class or record declaration.
Each such initialization uses the value of <code class="docutils literal"><span class="pre">initialization-part</span></code> if present.
Otherwise, the field is initialized to the default value of the corresponding
type.  It is an error if neither a <code class="docutils literal"><span class="pre">type-part</span></code> nor an <code class="docutils literal"><span class="pre">initialization-part</span></code>
is supplied in such declarations.</p>
<p>The expression appearing in a <code class="docutils literal"><span class="pre">field-initializer</span></code> may be arbitrarily complex.  It
may refer to global variables and to formal arguments in the constructor&#8217;s
formal argument list.  However,
it is illegal for the expression in a <code class="docutils literal"><span class="pre">field-initializer</span></code> to refer to a value
that has not yet been initialized. <a class="footnote-reference" href="#id17" id="id5">[5]</a> <a class="footnote-reference" href="#id18" id="id6">[6]</a></p>
<p>The semantics of a constructor body are the same as the semantics of a method.
All fields of the subject type may be referred to implicitly, or explicitly
using <code class="docutils literal"><span class="pre">this</span></code>.  Methods on <code class="docutils literal"><span class="pre">this</span></code> may be invoked using either explicit or
implicit syntax.  Because it is valid to call methods on <code class="docutils literal"><span class="pre">this</span></code> within the body of a
constructor, there is no reason to have a special <code class="docutils literal"><span class="pre">initialize()</span></code> function that is called
automatically if present.  The class designer can create arbitrarily-named initialization
helper functions &#8211; even those taking arguments and returning values other than <code class="docutils literal"><span class="pre">void</span></code>.
These must unfortunately be invoked explicitly, but that brings the advantage that those
initialization helpers become less hidden.</p>
</div>
<div class="section" id="inheritance">
<span id="id7"></span><h3>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a></h3>
<p>The syntax and semantics related to the <code class="docutils literal"><span class="pre">super</span></code> field are discussed above.
Mention of the <code class="docutils literal"><span class="pre">super</span></code> field in any user-defined class or record type is
always valid, since every class type derives from <code class="docutils literal"><span class="pre">object</span></code> and every record
type derives from <code class="docutils literal"><span class="pre">value</span></code>.</p>
<p>Since the subject type of a constructor is known at compile time, the type of
<code class="docutils literal"><span class="pre">super</span></code> is also known at compile time (being the immediate base type of the
subject type).  Therefore, dispatches to <code class="docutils literal"><span class="pre">super</span></code> in a <code class="docutils literal"><span class="pre">field-initializer-clause</span></code>
or constructor body need not be dispatched dynamically.  Likewise, in the body
of a constructor, the type of <code class="docutils literal"><span class="pre">this</span></code> is known at compile-time.  Therefore,
methods on this may be bound statically.</p>
<p>On the other hand, a constructor may arrange to pass <code class="docutils literal"><span class="pre">this</span></code> to a
method while obscuring the static type of <code class="docutils literal"><span class="pre">this</span></code> by casting it to a base-class
type.  In that case, the method will be bound dynamically using the run-time
type of <code class="docutils literal"><span class="pre">this</span></code>.  The dynamic type of <code class="docutils literal"><span class="pre">this</span></code> is established after processing
of the <code class="docutils literal"><span class="pre">field-initializer-clause</span></code> is complete, including the default
initialization of any fields not mentioned explicitly.  The dynamic type is set
equal to the subject type. <a class="footnote-reference" href="#id19" id="id8">[7]</a></p>
</div>
<div class="section" id="const-ness">
<span id="id9"></span><h3>Const-ness<a class="headerlink" href="#const-ness" title="Permalink to this headline">¶</a></h3>
<p>A field declared to be <code class="docutils literal"><span class="pre">const</span></code> becomes immutable after it has been
initialized. <a class="footnote-reference" href="#id20" id="id10">[8]</a>  When a constructor is used to initialize an object that is
declared to be <code class="docutils literal"><span class="pre">const</span></code>, the object as a whole (including any fields of
<code class="docutils literal"><span class="pre">this</span></code> that are not declared to be <code class="docutils literal"><span class="pre">const</span></code>) are mutable until
that constructor returns control to the caller.  Thereafter, the fields in that
object are all immutable.</p>
</div>
<div class="section" id="constructor-calls">
<span id="id11"></span><h3>Constructor Calls<a class="headerlink" href="#constructor-calls" title="Permalink to this headline">¶</a></h3>
<p>Given that an object being constructed should be in an uninitialized state, it should be
illegal to invoke a constructor on an object that has already been initialized.  According
to this proposal, the following code should generate a (compile-time) error:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>var r:R;     // Default-initialized, for example.
...
r.R(&lt;args&gt;); // Illegal.
</pre></div>
</div>
<p>Constructor invocations involving <code class="docutils literal"><span class="pre">new</span></code> as described in the specification would still be
legal and retain the same semantics as are currently described there.  Invocation of a
constructor in the context of a variable initialization for field initialization will have the
semantics described above in <a class="reference internal" href="#variables"><span>Variable Declaration Semantics</span></a>.</p>
</div>
<div class="section" id="implementation-notes">
<span id="implementation"></span><h3>Implementation Notes<a class="headerlink" href="#implementation-notes" title="Permalink to this headline">¶</a></h3>
<p>This proposal is primarily about the syntax and semantics of constructors &#8211;
approaching the subject from the user&#8217;s perspective.  However, such a
description also influences how the requisite semantics are implemented.</p>
<p>In the above section on <a class="reference internal" href="#semantics"><span>Constructor Declaration Semantics</span></a>, constructors are introduced as
methods.  That means that they have an implicit <code class="docutils literal"><span class="pre">this</span></code> variable that refers to
the object being constructed and they do not return a value.  This is consistent
with the semantics currently implemented.</p>
<p>The current implementation achieves these semantics in a somewhat roundabout
manner &#8211; first creating an unnamed temporary object, initializing this by a
method call, and then transferring the contents of that object through a bitwise
copy into the space allocated for the named variable.</p>
<p>Although this proposal does not directly rely upon it, its recommendation is to
rework the implementation code so that constructor calls do, in fact, operate
like methods.  When that is done, the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>var t = new R(7.0);
</pre></div>
</div>
<p>will effectively be implemented as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>pragma &quot;noinit&quot; var t; // Reserve some space for t on the stack.
t.R(7.0);              // Call a constructor on t, passing 7.0 as an argument.
</pre></div>
</div>
<p>The basic change required in the implementation is to move the allocation
outside of what is currently a constructor function (not a method) and then
rework constructor functions to be methods instead.</p>
<p>This change should have no user-visible effect at the behavioral level.  At the
meta-behavioral level (performance and resource usage), the difference should be
observable as faster execution and a smaller run-time memory footprint.  Some of
the implementation code should also be simpler.</p>
</div>
<div class="section" id="summary">
<span id="id12"></span><h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>The main syntactical and semantical provisions of this proposal are summarized as:</p>
<ul class="simple">
<li>Variable initialization should treat <code class="docutils literal"><span class="pre">=</span></code> as initialization (i.e. a constructor call),
not as assignment.</li>
<li>A <code class="docutils literal"><span class="pre">field-initialization-clause</span></code> will be added to the syntax for constructors.<ul>
<li>The added syntax will consist of an introductory keyword followed by a list of
initializer expressions enclosed in parentheses.</li>
<li>Each initializer must bind to
one of the fields declared in the constructor&#8217;s object (class or record) type.</li>
<li>Each initializer provides a value to be used to initialize the corresponding
field.</li>
<li>The field being initialized must be named.</li>
<li>The actual initialization order is
the order of appearance of initializer list.</li>
<li>Class- or record-default
initializers will be used if the initializer list does not supply a value.</li>
<li>Default values may be used explicitly by naming the field without
supplying a value.</li>
<li>Pseudo-initializers may be used to capture results in an
initializer list.</li>
<li>A constructor call may be used place of a field initializer list.</li>
</ul>
</li>
<li>The fields and methods of <code class="docutils literal"><span class="pre">this</span></code> may be accessed within the body of a constructor.</li>
<li>The special <code class="docutils literal"><span class="pre">initialize()</span></code> function is deprecated.</li>
<li>Fields declared to be <code class="docutils literal"><span class="pre">const</span></code> become immutable after they have been
initialized and before the body of the constructor is entered.</li>
<li>Objects declared
to be <code class="docutils literal"><span class="pre">const</span></code> become immutable after the constructor has run to completion and
control is returned to the point of invocation of the constructor.</li>
<li>Direct invocation of a constructor (using method invocation syntax) should be illegal.</li>
</ul>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">If the concepts of coercion and construction are fused (as in C++) then argument
coercion needs to be disabled in the context of a constructor call.  Otherwise,
coercion chains could grow to arbitrary lengths, which is likely to lead to
absurdities.</p>
<p class="last">If coercions are distinct from constructors, then it probably makes the most sense
to use only copy-construction for initialization.  The initialization expression
would need to be coercible to the target variable type.  It is unspecified whether
copy-construction calls an actual constructor or is instead implemented as a
bitwise copy followed by a call to a fixup (postblit) method.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>The idea of using a unique keyword such as <code class="docutils literal"><span class="pre">ctor</span></code> to introduce a
constructor was discussed.  The keyword approach is useful for generic
programming, because a constructor can be mentioned using a well-known
name (such as <code class="docutils literal"><span class="pre">__init__</span></code> in Python).  The idea was abandoned for the
sake of the current proposal because it did not obtain unanimous support.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Any constructor for the subject type initializes all fields in an object
of that type.  Since each field can be initialized only once, it would be
illogical to include other field-initializers before or after a
constructor call in a <code class="docutils literal"><span class="pre">field-initializer-clause</span></code>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>In particular, an initializer for <code class="docutils literal"><span class="pre">super</span></code> can appear anywhere in a
<code class="docutils literal"><span class="pre">field-initializer-clause</span></code> or be omitted.  Once initialized, the fields
of super may be referenced in other <code class="docutils literal"><span class="pre">field-initializer</span></code> expressions and
methods of <code class="docutils literal"><span class="pre">super</span></code> may be invoked.  In this context, a reference to the
<code class="docutils literal"><span class="pre">super</span></code> field is always explicit: it must be referred to using
the name <code class="docutils literal"><span class="pre">super</span></code>; it may not be referenced implicitly through <code class="docutils literal"><span class="pre">this</span></code>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>As a consequence, only the names of fields
that precede the current <code class="docutils literal"><span class="pre">field-initializer</span></code> may appear
anywhere in that <code class="docutils literal"><span class="pre">field-initializer</span></code>&#8216;s expression.  In particular, the name of
a field cannot appear in its own initializer expression.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>The object itself (<code class="docutils literal"><span class="pre">this</span></code>) is not fully initialized until after the
initializer list has been processed in its entirety.  Therefore, it is illegal
for the keyword <code class="docutils literal"><span class="pre">this</span></code> to appear anywhere in a <code class="docutils literal"><span class="pre">field-initializer-clause</span></code>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><p class="first">In discussions, Vass expressed concerns about type-safety, given that any
routine called from the initializer list or body of a constructor could
publish the <code class="docutils literal"><span class="pre">this</span></code> object before it has been fully constructed.  There
are three pieces that constitute this proposal&#8217;s response to that
concern:</p>
<ol class="last arabic">
<li><p class="first">Since it is illegal to mention <code class="docutils literal"><span class="pre">this</span></code> in the initializer list, it
cannot be published by any initialization expression appearing in the
<code class="docutils literal"><span class="pre">field-initializer-clause</span></code>.  The stricture against referring to <code class="docutils literal"><span class="pre">this</span></code> in
that context also refers to implicit references.  That means that it is
illegal to call a method of the subject type in the
<code class="docutils literal"><span class="pre">field-initializer-clause</span></code>, so <code class="docutils literal"><span class="pre">this</span></code> is prevented from escaping in
that manner as well.</p>
</li>
<li><p class="first">The dynamic type of the object is not established until processing of the
<code class="docutils literal"><span class="pre">field-initializer-clause</span></code> is complete.  It is not clear that the
specification requires the base-class sub-object to be laid out in memory
so that its starting address coincides with the starting address of the
derived-class object.  It is also unclear whether the two share the same
dynamic type field.  In the current implementation, they do not share the same
starting address but they do share the same dynamic type field.</p>
<p>The scenario of concern is if a base-class constructor attempts to
publish the derived-class object before its initialization is complete.
This would be accomplished through initialization of the <code class="docutils literal"><span class="pre">super</span></code>
field.</p>
<p>If the object being constructed shares its dynamic type field
with the base-class sub-object, then within the body of the base class
constructor the dynamic type of the <code class="docutils literal"><span class="pre">super</span></code> will be the type of the base class.
An attempt to publish the object there will publish an
object of base-class type.  Whether or not the object being constructed
and the base-class object coincide in memory, only field accessors and
methods applicable to the base type may be invoked: the compiler will not
produce code that attempts in any way to access fields belonging uniquely
(i.e. not through inheritance) to the object being constructed.</p>
<p>This remains true until the shared dynamic type field is updated after the
object&#8217;s <code class="docutils literal"><span class="pre">field-initializer-clause</span></code> is processed and before its body is
entered.  If the base-class sub-object and the object itself do not coincide in
memory, then the published object will still point to the base-class sub-object
whose dynamic type has been updated to the derived-class object&#8217;s type.  That
would be bad; apparently our current implementation needs some re-thinking.  Of
the four possibilities outlined above, ours is the only one guaranteed to fail.
If the base-class sub-object and the object coincide and share their dynamic
type field, then the object being constructed will exhibit behaviors associated
with the derived type (i.e. the ability to access fields and invoke methods
associated with that type) as soon as execution of its
<code class="docutils literal"><span class="pre">field-initializer-list</span></code> is complete and before the body of its constructor
has been entered.
If the base-class sub-object has its own type, then an object published
by a base-class constructor will always be of the base type.  In that
object layout scheme, there is no way to make a published <code class="docutils literal"><span class="pre">this</span></code> object
exhibit dynamic type (polymorphic) behavior.</p>
</li>
<li><p class="first">Because it is considered to be fully-initialized at the beginning of a
constructor body, the <code class="docutils literal"><span class="pre">this</span></code> object can be published anywhere in a
constructor body.  The objection here might be that an object is not
&#8220;blessed&#8221; as being fully constructed until the closing brace of the
constructor is reached.</p>
<p>A simple workaround is to require that any such publication be placed at
the end of the constructor body.  A &#8220;virtual closing brace&#8221; exists at the
point in the code at which all of the fields have values consistent with
the invariants ascribed to a fully-constructed object of that class.
Statements which appear after that virtual closing brace deal with the
fully-constructed object, so it is OK for them to manipulate the object
as a whole.  If the virtual closing brace does not exist, then the
problem being addressed is a restatement of the Postman&#8217;s Paradox.</p>
<p>The stronger argument is that the point in the lifetime of the object at
which it is safe to publish it is under the control of the class designer
&#8211; it is not a matter in which the language definition or the compiler
can effectively or even desirably interfere.  It may be ready to publish
at the very top of the constructor body &#8211; subsequent changes being
responded to dynamically by watchers on the published object.  It might
not be ready to publish until several phases after its initial
construction.  In which case, &#8220;avid&#8221; publication through the base-class
constructor seems like a poor programming idiom.  All of this is best left to
the class designer: aside from its effect on const-ness, there is nothing
special about the closing brace of a constructor body.</p>
</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[8]</a></td><td>In particular, it cannot be modified in the body of the constructor.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="5.html" class="btn btn-neutral float-right" title="Implement Object Copying Using a “Postblit” Method" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="3.html" class="btn btn-neutral" title="ZeroMQ Integration" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, .

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 



</body>
</html>