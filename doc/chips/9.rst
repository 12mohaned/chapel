Chapel Package Manager
======================

Status
  Draft

Authors
  Kyle Brady,
  Ben Albrecht,
  Preston Sahabu


Abstract
--------

This CHIP proposes a package manager for Chapel and provides some
directions for future improvements.

Rationale
---------

Chapel's current approach of bundling any extra modules in the standard library
isn't sustainable if we wish to have a healthy ecosystem of libraries. There
are several problems with the current strategy:

  * Modules are in our repository, so:

    * Developers must sign a CLA
    * Code must be under a compatible license
    * The core team needs to review each module

  * Modules are gated for release alongside the compiler

Description
-----------

There are a several components of this package manager here I will propose what
two of them will look like initially:

  * mason - a command line tool for building Chapel programs
  * mason.toml - module metadata mason uses to build your application

Mason
+++++

The idea of ``mason`` is based heavily off of Rust's cargo_. It is meant to
provide a consistent way for libraries and applications to be built. This is
done through the use of a manifest, ``mason.toml``. The manifest describes your
package, its dependencies, and how it is built. The long term answer for most
questions is to look at what cargo is doing. I think they have a very well
designed package manager, and I see no reason to totally reinvent the wheel.

I do think ``mason`` should be written in Chapel however. I think it would be good
to have a piece of code that is written in Chapel that we depend on and
actually use. Currently the only time someone is writing Chapel is as a
benchmark or for a test.

The primary difference I'd like to see from cargo is using Nix_ to manage the C
dependencies. This is to further avoid reinvention of hard problems. It does
have the downside of adding a dependency to our package manager, which is not
something to be taken lightly. Nix currently requires being installed as root
(or at least becomes much more complicated if it is not). Nix also only works
on linux/osx right now. Cygwin support is not ruled out, but not actively
worked on.

Example
-------

Lets go through an example from our standard modules and see how it would look
as a package.

::

  lapack/
    Mason.toml
    lapack-lib/
      Mason.toml
      src/
        LAPACK_lib.chpl
    src/
      LAPACK.chpl

.. code-block:: ini

  # lapack/Mason.toml
  [package]
  name = "lapack"
  version = "0.1.0"
  authors = ["Ian Bertolacci <ian@example.com>"]
  license = "Apache-2.0"
  description = "High level bindings to LAPACK"

  [dependencies]
  lapack-lib = { path = "lapack-lib" }

.. code-block:: ini

  # lapack-lib/Mason.toml
  [package]
  name = "lapack-lib"
  version = "0.1.0"
  authors = ["Ian Bertolacci <ian@example.com>"]
  license = "Apache-2.0"
  description = "Native bindings to liblapack"

  requires = ["liblapack"]
  links = "lapack"
  includes = "lapacke.h"

Things to note:
  * ``requires`` is a list of nix packages to be in the environment when
    building your program.  It's recommended to provide these, but they may not
    be used.
  * ``links`` is the library that is expected to be on your search path and will
    be added to the compile line.
  * ``includes`` is the header file that is expected to be on your search path
    and will be added to the compile line.


This could then be used in a projects like this:

::

  myCoolApp/
    Mason.toml
    src/
      main.chpl
    deps/
      ( lapack/ )
    bin/

.. code-block:: ini

  # lapack-lib/Mason.toml
  [package]
  name = "lapack-lib"
  version = "0.0.1"
  authors = ["Kyle Brady <kyle@example.com>"]

  [dependencies]
  lapack = { git = "https://github.com/chapel-pkgs/lapack", tag = '0.1.0'}

With this we can do a

.. code-block:: shell

  mason build

to download our lapack dependency, and build the program. The dependency will
be downloaded and placed under ``deps/``.  Nix will be used to resolve the
external dependencies and packages if it is available. Otherwise, libraries and
headers are expected to be placed on the normal search paths.


Mason Pipeline
++++++++++++++

The package manager pipeline has 4 key states, where each state acts as the
input to the next state:

* **Project Code**: ``src/``
* **Manifest File**: ``Mason.toml``

  * Markup-style file containing package metadata

* **Lock File**: ``Mason.lock``

  * File containing list of dependencies generated from ``Mason.toml``.
  * Contains the necessary information to guarantee a consistent build on
    all supported platforms.

* **Dependency Code**: ``~/.mason/src/``

  * Dependencies that are downloaded into a local directory.

Project Code
------------

This is the Chapel source code written by the package author.

Project Code -> Manifest File
-----------------------------

For the initial versions, the user will be responsible for writing the manifest
file in its entirety.

Improved tooling can assist in automating parts of this in the future,
e.g. ``mason new <project-name> --<bin || lib>``

Manifest File
-------------

The ``Mason.toml`` manifest file will closely follow the design of Cargo's
``Cargo.toml``. Some fields will vary, if they are too Rust-specific or could
benefit from being more Chapel-specific.


**Registry**

Eventually, we will want a service similar to Cargo's crates.io_ to serve as our
registry. Due to the amount of effort behind such a task, it has been decided
that this can come at a later stage.

The initial mason registry would be a GitHub repository containing a list of
versioned manifest files from packages, not too unlike that of the OS X
Homebrew package manager registry.

The registry would follow a hierarchy as follows:

::

  https://github.com/chapel-lang/mason-registry

  registry/
    Curl/
        1.0.0.toml
        2.0.0.toml
    RecordParser/
        1.0.0.toml
        1.1.0.toml
        1.2.0.toml
    VisualDebug/
        2.2.0.toml
        2.2.1.toml

Each versioned manifest file would be identical to the manifest file in the
top-level directory of the package repository, with one additional field that
is not required in the repository manifest, a URL pointing to the repository
and revision in which the version is located.

There are some recognized downsides of pursuing a GitHub repository as a registry:

* It is not be feasible to cache packages centrally, compromising the
  reliability of the entire package ecosystem.

  * The packages themselves are distributed despite there being a central
    registry of manifests.
  * We can *not* guarantee that a given package version will always remain
    unchanged or even always exist.

    * Although some form of nightly/weekly testing could help mitigate this
      issue.

* It is not easy to allow users to submit packages without human intervention
  (gate keeper accepting pull requests).

* GitHub's native interface would severely inhibit discoverability of packages.

  * This can circumvented by building a separate website for exploring the
    package ecosystem.

    * Julia does a great job at this in their Ecosystem-Pulse_.

For these reasons, we would like to eventually pursue a truly central registry
with cached packaged and a first-class interface.

**Package Integrity**

There will be two primary measures taken to ensure that submitted packages are
valid and not of poor quality:

* Continuous Integration (CI) tools such as Travis CI could run a suite of
  basic functionality tests to ensure a submitted package is properly
  setup. Tests might include:

  * Downloading the package.
  * Building the package.
  * Running any tests that the package provides.

* A set of core and trusted non-core Chapel community developers will serve
  as gate keepers who will allow packages into the repository by merging
  pull requests that pass all tests.

  * Other non-automated review procedures can be done by the gate keepers,
    but it would be ideal to keep this effort minimal if required at all.

  * This is similar to Homebrew's approach to package submission.


Manifest File -> Lock File
--------------------------

This will be a fully automated step in which mason does the following:

* parses the manifest file
* builds a dependency directed acyclic graph (DAG)
* performs any incompatible version resolution strategy
* serializes the DAG and outputs it into ``Mason.lock``


Lock File
---------

Lock File -> Dependency Code
----------------------------

Dependency Code
---------------


.. _crates.io: https://crates.io/
.. _cargo: http://doc.crates.io/guide.html
.. _nix: https://nixos.org/nix/
.. _Ecosystem-Pulse: http://pkg.julialang.org/pulse.html
