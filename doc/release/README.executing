=========================
Executing Chapel Programs
=========================

Once you have compiled a Chapel program using the chpl compiler, you
can execute it from the command-line like any other program.  Using
the -h or --help flags will print out help for the executable.  For
example:

     ./a.out --help

This flag lists all of the standard flags that can be used with a
Chapel program, as well as a list of the configuration variables
defined by the program and their types.  If the configuration variable
has been set on the command line, its value is also shown.


-------------------------------
Setting Configuration Variables
-------------------------------

Configuration constants and variables defined in a Chapel program can
have their default values overridden on the command line using the -s
or -- flags.  Either flag takes the name of the configuration variable
followed by an equals ("=") character and the value to assign to it.
This value must be a legal Chapel literal for the type of variable.
In our current implementation, no extra spaces may appear between
these elements.  Thus, the general form is:

    ./a.out --<cfgVar>=<val>
or:
    ./a.out -s<cfgVar>=<val>


As an example, compile the beer.chpl example which prints the lyrics
to "99 bottles of beer":

     chpl -o beer $CHPL_HOME/examples/beer.chpl

This program defines a configuration constant "numBottles" indicating
the number of bottles of beer that should start on the wall, set to 99
by default.  To override the default and only start with a 6-pack on
the wall, you can use:

     ./beer --numBottles=6
or:
     ./beer -snumBottles=6


--------------
Running in gdb
--------------

The compiler-generated executable also has a --gdb flag that can be
used to launch the program within a gdb session.  For best results,
make sure that your program has been compiled using the chpl
compiler's -g flag.

The utility of this feature depends greatly on your familiarity with
the Chapel generated code.  However, if your program is crashing or
running into a runtime error, you can often determine where that is
taking place by looking at a stack trace after the crash.  In
addition, scalar Chapel variables can often be inspected using 
"p <name>" (or "p _<name><TAB>" in cases where the compiler has had to
rename the variable).

Over time, we plan to improve our ability to debug the generated C
code for a Chapel program.  If you find yourself debugging the
generated code a lot and need help or have requests for better
support, please let us know so that we can prioritize accordingly.


-----------------------------
Setting the Number of Locales
-----------------------------

We have added support for the ability to specify the number of locales
on which to execute the program, which can be set using the -nl flag,
or by assigning the built-in numLocales configuration constant using
the normal mechanisms.  So, to execute on one locale, the user could
use:

    ./a.out -nl 1
or: ./a.out --numLocales=1
or: ./a.out -snumLocales=1

For users running with $CHPL_COMM == none (the default for current
users), only one locale can be used.  Chapel's multi-locale execution
is currently under development, and we expect to have a prototype
available in the next release.


-----------------------
Running in Verbose Mode
-----------------------

The compiler-generated executable supports a --verbose flag (-v for
short) that will print out extra information not explicitly specified
in the user's code.  Currently, this flag is only used to indicate the
number of locales being used for program execution, but in the future
we expect it to have broader impact.


-------------------------
Flags for Tracking Memory
-------------------------

Chapel supports a number of flags related to dynamic memory allocation
for the compiler-generated executable, currently used by the
development team to track memory usage in tests.  Please note that we
have done little to optimize Chapel's memory utilization, so you
should not be surprised if your program requires more memory than it
seems it should.

The flags are as follows:

  --memmax=<n>         : runs the program pretending that only 'n' 
                         bytes of heap memory are available.  When the
                         amount of outstanding dynamic memory exceeds
                         'n', the program terminates with an error
                         message.

  --memstat            : when the program exits, this flag causes it 
                         to print the amount of memory used by the
                         program and the high-water mark.

  --memtrack            : causes all memory events to be tracked using 
                          a hash table at runtime in order to find
                          memory errors such as freeing a pointer that
                          is not currently allocated.  The table can
                          be printed out during execution using a call
                          to the 0-argument routine
                          _chpl_memtest_printMemTable()

  --memtrace=<filename> : print a trace of all memory events to the
                          specified filename

  --memthreshold=<n>    : for use with the --memtrace flag; only print
                          events for objects larger than 'n' bytes
