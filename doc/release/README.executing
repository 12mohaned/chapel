=========================
Executing Chapel Programs
=========================

Once you have compiled a Chapel program using the chpl compiler, you
can execute it from the command-line like any other program.  Using
the -h or --help flags will print out help for the executable.  For
example:

     ./a.out --help

This flag lists all of the standard flags that can be used with a
Chapel program, as well as a list of the configuration variables
defined by the program and their types.  If the configuration variable
has been set on the command line, its value is also shown.


-------------------------------
Setting Configuration Variables
-------------------------------

Configuration constants and variables defined in a Chapel program can
have their default values overridden on the command line using the -s
or -- flags.  Either flag takes the name of the configuration variable
followed by an equals ("=") character and the value to assign to it.
This value must be a legal Chapel literal for the type of variable.
In our current implementation, no extra spaces may appear between
these elements.  Thus, the general form is:

    ./a.out --<cfgVar>=<val>
or:
    ./a.out -s<cfgVar>=<val>


As an example, compile the beer.chpl example which prints the lyrics
to "99 bottles of beer":

     chpl -o beer $CHPL_HOME/examples/beer.chpl

This program defines a configuration constant "numBottles" indicating
the number of bottles of beer that should start on the wall, set to 99
by default.  To override the default and only start with a 6-pack on
the wall, you can use:

     ./beer --numBottles=6
or:
     ./beer -snumBottles=6


-----------------------------
Setting the Number of Locales
-----------------------------

For multi-locale Chapel executions, the number of locales on which to
execute a program is specified on the executable's command-line.  This
can be set either using the -nl flag, or by assigning to the built-in
numLocales configuration constant using the normal mechanisms.  So, to
execute on four locales, one could use:

    ./a.out -nl 4
or: ./a.out --numLocales=4
or: ./a.out -snumLocales=4

For users running with $CHPL_COMM == none (the default), only one
locale can be used.  See $CHPL_HOME/doc/README.multilocale for more
information about executing on multiple locales.


-----------------------------------------
Controlling the amount of non-user output
-----------------------------------------

The compiler-generated executable supports "verbose" and "quiet" modes
that control the amount of Chapel-generated information printed by the
executable.

Using the --verbose flag (-v for short) will print out extra
information.  In the current implementation, it causes each locale to
print out a message when it starts executing.

Using the --quiet flag (-q for short) causes run-time warnings that
are printed by default to be suppressed.


--------------
Running in gdb
--------------

The compiler-generated executable has a --gdb flag that can be used to
launch the program within a gdb session.  For best results, make sure
that your program has been compiled using the chpl compiler's -g flag.

The utility of this feature depends greatly on your familiarity with
the Chapel generated code.  However, if your program is crashing or
running into a runtime error, you can often determine where that is
taking place by looking at a stack trace within gdb.  In addition,
scalar Chapel variables can often be inspected using "p <name>" 
(or "p _<name><TAB>" in cases where the compiler has renamed the 
variable).

Over time, we plan to improve our ability to debug the generated C
code for a Chapel program.  If you find yourself debugging the
generated code a lot and need help or have requests for better
support, please let us know so that we can prioritize accordingly.


-------------------------
Flags for Tracking Memory
-------------------------

Chapel supports a number of flags related to dynamic memory allocation
for the compiler-generated executable, currently used by the
development team to track memory usage in tests.  Please note that we
have done little to optimize Chapel's memory utilization, so you
should not be surprised if your program requires more memory than it
seems it should.

The flags are as follows:

  --memmax=<n>         : runs the program pretending that only 'n' 
                         bytes of heap memory are available.  When the
                         amount of outstanding dynamic memory exceeds
                         'n', the program terminates with an error
                         message.

  --memstat            : when the program exits, this flag causes it 
                         to print the amount of memory used by the
                         program and the high-water mark.

  --memtrack            : causes all memory events to be tracked using 
                          a hash table at run-time in order to find
                          memory errors such as freeing a pointer that
                          is not currently allocated.  The table can
                          be printed out during execution using a call
                          to the 0-argument routine
                          _chpl_memtest_printMemTable()

  --memtrace=<filename> : print a trace of all memory events to the
                          specified filename

  --memthreshold=<n>    : for use with the --memtrace flag; only print
                          events for objects larger than 'n' bytes
