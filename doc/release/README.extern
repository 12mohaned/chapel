==================================================
Initial support for calling C routines from Chapel
==================================================

This README describes some initial support that we have added to the
compiler for calling from Chapel to C.  This mechanism should be
considered a stopgap technology until we have developed and
implemented more robust concepts, which is why it's described in this
README rather than the language specification.


How to call a C routine from Chapel
-----------------------------------

1) Prototype the C routine in your Chapel code

   We have added the _extern keyword to our compiler as a means of
   defining a function that will be defined by an external C file
   rather than the Chapel code.  For a C function foo() that takes no
   arguments and returns nothing, the prototype would appear as
   follows:

       _extern def foo();

   C functions which return values that you wish to refer to within
   your Chapel program must have those return types declared (the
   Chapel compiler cannot infer the return type as it does with Chapel
   functions since it does not analyze the C source code).  To make
   the function above return a C "double", it would be declared:

       _extern def foo(): real;

   All C types must be expressed in terms of their Chapel equivalents.
   This can cause portability issues in certain cases due to the fact
   that C types don't have well-defined sizes.  For example, if
   function foo returns a C "int", that type could correspond to a
   Chapel int(32) or an int(64) or possibly some other int size
   depending on your C compiler and platform.  The burden of making
   types match is on the user, though any mismatches ought to be
   flagged during Chapel's C compilation step.

   Similarly, external functions that expect arguments must declare
   those arguments.  Types of function arguments may be omitted, in
   which case the types will be inferred based on the Chapel callsite.
   For example, the following Chapel code:

       _extern def foo(x: int, y): real;

       var a, b: int;

       foo(a, b);

   Would imply that external function foo takes two 32-bit integer
   values (likely an "int" or "short" in most C implementations) and
   returns a 64-bit real (double).

   Note that Chapel C strings can be passed to C functions, though
   warnings can occur during C compilation due to mismatches between
   the const-ness of the char*'s used to implement the strings.

   More interesting types like records and classes are currently
   difficult to pass to C effectively.  Use at your own risk.
   Similarly, C types that don't have a direct Chapel equivalent
   (e.g., size_t) are currently difficult to interface with in a
   portable manner.

   C varargs functions can be declared using Chapel's varargs ("...")
   syntax.  For example, the following declaration prototypes C's
   printf function:

       _extern def printf(fmt: string, vals...?numvals): int;


2) Call the C routines.

   Do this as you would call any Chapel routine.


3) Specify C implementation files.

   On your Chapel compile command line, list the header files that
   contain the external C routine prototypes, as well as the source
   (.c) or object (.o) files that contain their definition.  For
   example, if the foo() function defined above was defined in foo.h
   and foo.c, it could be added to the compilation using either:

       chpl foo.h foo.c myProgram.chpl
or:    chpl foo.h foo.o myProgram.chpl (if foo.c had already been compiled)

   The effect of naming such files on the command line is as follows:

   * During Chapel's C code generation stage, any header files listed
     on the compiler's command line will be #include'd by the
     generated code in order to ensure that the appropriate prototype
     is used before making any calls to the routine.

   * During Chapel's C compilation stage, any C files on the command
     line will be compiled using the same flags as the
     Chapel-generated C files (use --print-commands to see these
     compile commands).

   * During Chapel's link step, any .o files created by this C compile
     step will be linked to the .o files listed on the compiler's
     command-line as well as the compiler-generated code and runtime
     libraries.


Future Directions
-----------------

The current implementation was implemented as a quick hack to give
users access to C in limited ways.  Over time, we will be developing a
stronger story for making calls between C and Chapel.  If the features
above are insufficient for your needs in the near-term, please let us
know at: chapel_info@cray.com.
