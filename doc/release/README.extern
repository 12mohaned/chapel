==================================================
Initial support for calling C routines from Chapel
==================================================

This README describes some initial support that we have added to the
compiler for calling from Chapel to C.  This mechanism should be
considered a stopgap technology until we have developed and
implemented more robust concepts, which is why it's described in this
README rather than the language specification.


How to call a C routine from Chapel
-----------------------------------

1) Prototype the C routine in your Chapel code

   We have added the _extern keyword to our compiler as a means of
   defining a function that will be defined by an external C file
   rather than the Chapel code.  For a C function foo() that takes no
   arguments and returns nothing, the prototype would appear as
   follows:

       _extern def foo();

   C functions which return values that you wish to refer to within
   your Chapel program must have those return types declared (the
   Chapel compiler cannot infer the return type as it does with Chapel
   functions since it does not analyze the C source code).  To make
   the function above return a C "double", it would be declared:

       _extern def foo(): real;

   Similarly, external functions that expect arguments must declare
   those arguments.

   All C types must be expressed in terms of their Chapel equivalents.
   This can cause portability issues in certain cases due to the fact
   that C types don't have well-defined sizes.  For example, if
   function foo returns a C "int", that type could correspond to a
   Chapel int(32) or an int(64) or possibly some other int size
   depending on your C compiler and platform.  Similarly, scalar C
   types that don't have a direct Chapel equivalent (e.g., size_t) are
   currently difficult to interface with in a portable manner.  The
   burden of making types match is on the user, though any problematic
   mismatches ought to be flagged during Chapel's C compilation step.

   Note that Chapel C strings can be passed to C functions, though
   warnings can occur during C compilation due to mismatches between
   the const-ness of the char*'s used to implement the strings.

   More interesting types like records and classes are currently
   difficult to pass to C effectively.  See the description in the
   next section about "opaque" types for one way of dealing with
   these.

   Types of function arguments may be omitted, in which case the types
   will be inferred based on the Chapel callsite.  For example, the
   following Chapel code:

       _extern def foo(x: int, y): real;

       var a, b: int;

       foo(a, b);

   Would imply that external function foo takes two 32-bit integer
   values (likely an "int" or "short" in most C implementations) and
   returns a 64-bit real (double).

   External function arguments can be declared with default arguments
   in which case the default argument will be supplied by the Chapel
   compiler if it is omitted at the callsite.  For example:

       _extern def foo(x: int, y = 1.2): real;

       foo(0);

   Would cause external function foo() to be called with the arguments
   0 and 1.2.

   C varargs functions can be declared using Chapel's varargs ("...")
   syntax.  For example, the following declaration prototypes C's
   printf function:

       _extern def printf(fmt: string, vals...?numvals): int;


2) Call the C routines.

   Do this as you would call any Chapel routine.


3) Specify C implementation files.

   On your Chapel compile command line, list the header files that
   contain the external C routine prototypes, as well as the source
   (.c) or object (.o) files that contain their definition.  For
   example, if the foo() function defined above was defined in foo.h
   and foo.c, it could be added to the compilation using either:

       chpl foo.h foo.c myProgram.chpl
or:    chpl foo.h foo.o myProgram.chpl (if foo.c had already been compiled)

   The effect of naming such files on the command line is as follows:

   * During Chapel's C code generation stage, any header files listed
     on the compiler's command line will be #include'd by the
     generated code in order to ensure that the appropriate prototype
     is used before making any calls to the routine.

   * During Chapel's C compilation stage, any C files on the command
     line will be compiled using the same flags as the
     Chapel-generated C files (use --print-commands to see these
     compile commands).

   * During Chapel's link step, any .o files created by this C compile
     step will be linked to the .o files listed on the compiler's
     command-line as well as the compiler-generated code and runtime
     libraries.


Opaque Types
------------

You can refer to external C types that cannot be described in Chapel
using the "opaque" keyword.  As the name implies, these types are
opaque as far as Chapel is concerned and cannot be used for operations
other than argument passing and assignment (to/from other similarly
opaque types).

For example, Chapel could be used to call an external C function that
returns a pointer to a malloc'ed struct as follows:

    _extern def returnStructPtr(): opaque;

    var structPtr: opaque = returnStructPtr();

However, because structPtr's type is opaque, it cannot be used for
much apart from assigning it to other opaque variables of matching
underlying type, or passing it back to an external C routine that
expects a pointer-to-struct of that type:

    _extern def operateOnStructPtr(ptr: opaque);

    var copyOfStructPtr = structPtr;

    operateOnStructPtr(structPtr);


Future Directions
-----------------

The current implementation was implemented as a quick hack to give
users access to C in limited ways.  Over time, we will be developing a
stronger story for making calls between C and Chapel.  If the features
above are insufficient for your needs in the near-term, please let us
know at: chapel_info@cray.com.
