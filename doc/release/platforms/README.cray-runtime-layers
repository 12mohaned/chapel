==========================================================================
Chapel Communication and Tasking Layers Specific to Cray x86-based Systems
==========================================================================

This file discusses the use of Chapel communication and tasking layers
which are available only on x86-based Cray Inc. systems.

For information regarding Chapel on Cray Inc. XMT (TM) systems, consult
README.xmt in the same directory as this file.

The README.multilocale and README.tasking files describe a variety of
communication layers and tasking layers that can be used by Chapel
programs.  By default, Chapel programs on x86-based Cray systems use the
GASNet communication layer and the FIFO tasking layer, and there are
several other tasking layers available that can also be used with the
GASNet communication layer.

In addition to the standard runtime layers available in any Chapel
release, the pre-built Chapel module on x86-based Cray systems supports
a fixed combination of Cray-specific communication, tasking, and
threading layers.  Each of these makes use of Cray's hardware and/or
software to produce enhanced performance for Chapel programs.

The communication layer interacts with the system's network interface
very closely through a lightweight interface called uGNI (user Generic
Network Interface).  The tasking and threading layers switch Chapel
tasks and threads in a lightweight manner in user space, avoiding the
overhead and some of the resource limitations associated with OS thread
switching.  These three layers cooperate to overlap communication to
remote locales with task execution, particularly improving the
performance of programs limited by the latency of small remote data
references, such as graph analytic applications.  These Cray specific
runtime layers are not released in source form, and of course Chapel
programs compiled and linked with them cannot be run on non-Cray
systems.

To use this combination of runtime layers, do the following.


1) Make sure the Cray system you are using is running CLE 4.x or later.
   The runtime layers discussed here will not work properly on CLE 3.x
   or earlier versions.  For example:

     echo $XTOS_VERSION

   or

     cat /etc/opt/cray/release/clerelease 


2) Make sure that you are using a GNU target compiler.  For example:

     module load PrgEnv-gnu

   (If you have a different PrgEnv module loaded, you will have to
   unload it first, or do a swap instead of a load.)


3) Set your CHPL_COMM environment variable to "ugni" and your CHPL_TASKS
   environment variable to "muxed".  For example, for the bash shell:

   This specifies that you wish to use the Cray-specific communication
   and tasking layers.

   Other Chapel environment variables having to do with runtime layers
   should be left unset.  Setting the above two will automatically
   select the correct combination of other runtime layers that work with
   those, in particular, CHPL_THREADS=soft-threads, CHPL_MEM=tcmalloc,
   CHPL_ATOMICS=intrinsics, and CHPL_NETWORK_ATOMICS=ugni.  None of
   these need to be set explicitly.


4) Load an appropriate craype-hugepages module.  For example:

     module load craype-hugepages16M

   Use of the ugni communication layer requires that the program's data
   reside on so-called "hugepages".  To arrange for this, you must have
   a craype-hugepages module loaded both when building your program and
   when running it.

   There are several such modules, with suffixes indicating the hugepage
   size they support.  For example, craype-hugepages16M supports 16 MiB
   hugepages.  It does not matter which craype-hugepages module you have
   loaded when you build your program.  Any of them will do.  However,
   which one you have loaded when you run your program does matter.  For
   general use, the Chapel group recommends the craype-hugepages16M
   module.  You can read on for more information about craype-hugepage
   modules if you would like, but the recommended craype-hugepages16M
   module will probably give you satisfatory results.

   The architecture of the Cray Gemini and Aries network interface chips
   (NICs) limits them to addressing at most 16k (2**14) pages of memory.
   This is sufficient to cover a 32 GiB Cascade locale with 2 MiB pages.
   But if you will be running on 64 GiB locales, you will need to use at
   least 4 MiB pages to cover all of the memory.  Generally, using
   larger hugepage sizes results in modest performance benefits, mostly
   in program startup time.  The craype-hugepages16M module will result
   in slightly faster program startup, and its 16 MiB hugepages will
   easily cover the memory of any conceivable Cascade locale.

   The only downside to larger page sizes is that they can waste more
   memory than smaller page sizes do, when the data segments that reside
   on them are smaller than the hugepage size (which is often the case).
   In practice, however, the effect of this is minor.  Even using the
   fairly large 16 MiB hugepages will typically only result in around 1%
   of the total locale memory being wasted.


5) Compile your Chapel program as usual.  For example:

     chpl -o hello6-taskpar-dist $CHPL_HOME/examples/hello6-taskpar-dist.chpl


6) Run your program.  For example:

     ./hello6-taskpar-dist -nl 4 --printLocaleName=false


7) If you want to use them, there are some other parameters you can set
   at execution time to adjust the behavior of the Cray specific runtime
   layers.

7a) Parameters associated with the ugni communication layer.

    By default the heap will occupy as much of the free memory on the
    locale as the runtime can acquire, less a modest percentage to allow
    for unforeseen demands from other (system) programs running on the
    locale.  Advanced users may want to make the heap smaller than this.
    The benefits of doing so include slighter quicker program startup
    and smaller core files. However, note that if you reduce the heap
    size to less than the amount some program actually needs and then
    run that program, it will terminate prematurely due to not having
    enough memory.

    To change the heap size, set the CHPL_UGNI_MAX_HEAP_SIZE environment
    variable.  Set it to just a number to specify the size of the heap in
    bytes, or to a number with a "k" or "K", "m" or "M", or "g" or "G"
    suffix with no intervening spaces to specify the heap size in KiB
    (2^10 bytes), MiB (2^20 bytes), or GiB (2^30 bytes), respectively.
    Any of the following would set the heap size to 1 GiB, for example:

      export CHPL_UGNI_MAX_HEAP_SIZE=1073741824
      export CHPL_UGNI_MAX_HEAP_SIZE=1048576k
      export CHPL_UGNI_MAX_HEAP_SIZE=1024m
      export CHPL_UGNI_MAX_HEAP_SIZE=1g

    Note that the value you set in CHPL_UGNI_MAX_HEAP_SIZE will be
    rounded up to the next higher hugepage boundary.  How much, if any,
    this will add will depend on the hugepage size in the hugepage
    module you have loaded.

    The CHPL_COMM_CONCURRENCY environment variable tells the ugni
    communication layer how much program concurrency it should try to
    support.  It basically controls how much of the communication
    resources on the Gemini or Aries chip will be used by the program.
    The default value is the number of hardware processor cores the
    program will use for Chapel tasks (numHardwareThreads in the next
    section).  Usually this is enough, but for highly parallel codes
    that do a lot of remote references, increasing it may help the
    performance.  Useful values for CHPL_COMM_CONCURRENCY are in the
    range 1 to 30.  Values specified outside this range are silently
    increased or reduced so as to fall within it.


7b) Parameters associated with the muxed tasking layer.

    The muxed tasking layer gets the threads it uses as task execution
    vehicles from the soft-threads threading layer.  The soft-threads
    layer provides lightweight threads that can be switched rapidly.
    Chapel configuration constants allow you to control how many
    processor cores the soft-threads threading layer uses and the total
    number of lightweight threads it provides to the tasking layer.

    The numHardwareThreads configuration constant specifies the number
    of cores that should be used to run Chapel tasks.  The default is to
    use all of the cores, but if something other than the ability to run
    tasks limits performance, such as limited parallelism or doing many
    remote loads, reducing this may improve performance.  You can set
    numHardwareThreads to any value from 1 to the actual number of
    hardware processor cores.  For applications where the performance is
    dominated by the latency of small remote loads, such as the SSCA#2
    benchmark and other graph processing codes, using 8 processor cores
    often gives better performance than using all of them.

    The numThreadsPerLocale configuration constant specifies the number
    of lightweight threads the soft-threads threading layer should
    provide to the muxed tasking layer for hosting tasks.  The default
    is 16 times the number of processor cores being used, which gives
    good performance in most cases.  You can set numThreadsPerLocale to
    any value >= 0, but the soft-threads threading layer will silently
    limit this to no less than 1 and no more than 32 times the value of
    numHardwareThreads (whether default or user specified).

    Note that both of these numbers are per-locale values, that is,
    numHardwareThreads is the number of hardware cores to use on each
    locale, and numThreadsPerLocale is the number of lightweight threads
    to use on each locale (not on each hardware thread).
