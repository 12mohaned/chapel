#!/usr/bin/env python

import optparse
import os
import subprocess
import sys

script_dir = os.path.dirname(os.path.realpath(__file__))
chpl_home_dir = os.path.normpath(script_dir + "/../../");
chplenv_dir = os.path.normpath(chpl_home_dir + "/util/chplenv")
sys.path.insert(0, os.path.abspath(chplenv_dir))

import chpl_compiler, chpl_make, utils

def myrun(cmd):

  # Run $cmd but filter out e.g. make[2]: lines
  # (about which directory we are in)
  ret = ""
  output = utils.run_command(cmd)
  lines = output.splitlines()
  for line in lines:
    if not line.startswith("make"):
      ret += line

  return ret

def myrun2(cmd, arg):

  return myrun(cmd + [arg])

def mysystem(cmd):

  s = myrun(cmd)
  sys.stdout.write(s)

def mysystem2(cmd, arg):

  mysystem(cmd + [arg])

def _main():

  global chpl_home_dir
  check_file = os.path.relpath(__file__, chpl_home_dir)
  check_path = chpl_home_dir + "/" + check_file;
  if not os.path.isfile(check_path):
    sys.stderr.write("Warning: check {0} not found\n".format(check_path));

  if "CHPL_HOME" in os.environ:
    if os.path.abspath(os.environ["CHPL_HOME"]) != chpl_home_dir:
      # to be sure, check that the inode numbers of our check file match
      env_check = os.environ["CHPL_HOME"] + "/" + check_file
      rel_check = chpl_home_dir + "/" + check_file
      if os.path.samefile(env_check, rel_check):
        # No warning, it's OK, they are the same file.
        pass
      else:
        sys.stderr.write("Warning: check {0} not found\n".format(check_path));
        sys.stderr.write("Warning: Mismatched CHPL_HOME; got {0} but expected {1}\n".format(os.path.abspath(os.environ["CHPL_HOME"]), chpl_home_dir));
    chpl_home_dir = os.environ["CHPL_HOME"] # use enviro var spelling of it
  else:
    os.environ["CHPL_HOME"] = chpl_home_dir

  os.environ["CHPL_MAKE_HOME"] = chpl_home_dir;
  if "CHPL_RUNTIME_LIB" in os.environ:
    os.environ["CHPL_MAKE_RUNTIME_LIB"] = os.environ["CHPL_RUNTIME_LIB"]

  if "CHPL_RUNTIME_INCL" in os.environ:
    os.environ["CHPL_MAKE_RUNTIME_INCL"] = os.environ["CHPL_RUNTIME_INCL"]

  if "CHPL_THIRD_PARTY" in os.environ:
    os.environ["CHPL_MAKE_THIRD_PARTY"] = os.environ["CHPL_THIRD_PARTY"]

  make = chpl_make.get()

  orig_make = make
  # Do not print directory changes.
  make = [make, "--no-print-directory"]

  # Make reasonable defaults for environment settings
  os.environ["COMP_GEN_WARN"] = "0";
  os.environ["COMP_GEN_DEBUG"] = "0";
  os.environ["COMP_GEN_OPT"] = "0";
  os.environ["COMP_GEN_SPECIALIZE"] = "0";
  os.environ["COMP_GEN_IEEE_FLOAT"] = "1";

  parser = optparse.OptionParser(usage="usage: %prog [ENVVAR=VALUE] [flags]")
  parser.add_option("--home",
                    dest="home", action='store_true', default=False,
                    help="print out CHPL_HOME")
  parser.add_option("--make",
                    dest="make", action='store_true', default=False,
                    help="print out the make command")
  parser.add_option("--llvm",
                    dest="llvm", action='store_true', default=False,
                    help="specify that the rest of the arguments are for a"
                         "compilation working with the LLVM backend. This "
                         "argument causes this script to set "
                         "CHPL_TARGET_COMPILER=clang-included")
  parser.add_option("--compile", "--compile-cc",
                    dest="compilecc", action='store_true', default=False,
                    help="print a C compiler invocation that can use"
                         "the Chapel runtime")
  parser.add_option("--compile-c++",
                    dest="compilecxx", action='store_true', default=False,
                    help="print a C++ compiler invocation that can use"
                         "the Chapel runtime")
  parser.add_option("--cflags",
                    dest="cflags", action='store_true', default=False,
                    help="print C compilation flags that Chapel would use")
  parser.add_option("--c++flags",
                    dest="cxxflags", action='store_true', default=False,
                    help="print C++ compilation flags that Chapel would use")
  parser.add_option("--includes-and-defines",
                    dest="includesanddefines", action='store_true', default=False,
                    help="Print -D and -I compilation flags to include"
                         "the Chapel runtime")
  parser.add_option("--libraries",
                    dest="libraries", action='store_true', default=False,
                    help="print out -L and -l options to link with"
                         "the Chapel runtime")
  parser.add_option("--main.o",
                    dest="maino", action='store_true', default=False,
                    help="pront out the path to the main.o file")
  parser.add_option("--llvm-install-dir",
                    dest="llvminstalldir", action='store_true', default=False,
                    help="print path to included LLVM installation")
  parser.add_option("--clang",
                    dest="clangcc", action='store_true', default=False,
                    help="print which clang C compiler is configured")
  parser.add_option("--clang++",
                    dest="clangcxx", action='store_true', default=False,
                    help="print which clang C++ compiler is configured")
  parser.add_option("--clang-sysroot-arguments",
                    dest="clangsysroot", action='store_true', default=False,
                    help="print out any saved clang arguments that"
                         "specify the system root")

  (options, args) = parser.parse_args()

  # Handle VAR=VAL environment variable setting
  for arg in args:
    kv = arg.split("=", 2)
    if len(kv) == 2:
      os.environ[kv[0]] = os.environ[kv[1]]

  make_helper = make + ["-f", chpl_home_dir + "/runtime/etc/Makefile.include"]

  if options.home:
    sys.stdout.write("{0}\n".format(chpl_home_dir))
  if options.make:
    sys.stdout.write("{0}\n".format(orig_make))
  if options.llvm:
    os.environ["CHPL_LLVM_CODEGEN"] = "llvm"
    orig_target_compiler = chpl_compiler.get('target', llvm_mode='orig')
    target_compiler = chpl_compiler.get('target', llvm_mode='llvm')
    os.environ["CHPL_ORIG_TARGET_COMPILER"] = orig_target_compiler
    os.environ["CHPL_TARGET_COMPILER"] = target_compiler

    chpl_llvm = ""
    if "CHPL_LLVM" in os.environ:
      chpl_llvm = os.environ["CHPL_LLVM"]
    if "CHPL_MAKE_LLVM" in os.environ:
      chpl_llvm = os.environ["CHPL_MAKE_LLVM"]
    if chpl_llvm == "":
      chpl_llvm = subprocess.check_output([chpl_home_dir + "/util/chplenv/chpl_llvm.py"])
    if chpl_llvm == "none":
      sys.stderr.write("Cannot get --llvm configuration with CHPL_LLVM=none\n");
      sys.exit(1)
  if options.compilecc:
    mysystem2(make_helper, "printcompileline")
  if options.compilecxx:
    mysystem2(make_helper, "printcxxcompileline")
  if options.cflags:
    mysystem2(make_helper, "printcflags")
  if options.cxxflags:
    mysystem2(make_helper, "printcxxflags")
  if options.includesanddefines:
    mysystem2(make_helper, "printincludesanddefines")
  if options.libraries:
    mysystem2(make_helper, "printlibraries")
  if options.maino:
    mysystem2(make_helper, "printmaino")
  if options.llvminstalldir:
    mysystem2(make_helper, "printllvminstall")
  if options.clangcc:
    mysystem2(make_helper, "printclangcc")
  if options.clangcxx:
    mysystem2(make_helper, "printclangcxx")
  if options.clangsysroot:
    mysystem2(make_helper, "printclangcxx")
    llvminstall = myrun2(make_helper, "printllvminstall")
    llvminstall = llvminstall.strip()
    fname = llvminstall + "/configured-clang-sysroot-arguments"
    if os.path.isfile(fname):
      with open(fname) as f:
        for line in f:
          sys.stdout.write(line)

if __name__ == '__main__':
  _main()
