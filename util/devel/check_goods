#!/bin/bash
# Copyright 2004-2018 Cray Inc.
# Other additional copyright holders may be indicated within.
#
# The entirety of this work is licensed under the Apache License,
# Version 2.0 (the "License"); you may not use this file except
# in compliance with the License.
#
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

for g in $(find test -name \*.good -o -name \*.bad -o -name \*.future); do
   base=${g%.good}
   base=${base%.bad}
   base=${base%.future}
   base=${base%.no-local}
   base=${base%.lm-flat}
   base=${base%.lm-numa}
   base=${base%.comm-gasnet}
   base=${base%.comm-none}

   # deprecated/potential future chpldoc mode #1369 e9a18221a
   base=${base/%.logical.doc/.doc}

   c=${base}.test.c

   d=$(dirname $g)

   # Ignore everything in a NOTEST dir
   if [ -f $d/NOTEST ]; then
       continue
   fi

   # This dir uses a PREDIFF file to pick a specific .good file.  But
   # it just invokes "../../PREDIFF $0", so the later PREDIFF section
   # won't catch it.
   if [ $d == "test/distributions/robust/arithmetic/performance/multilocale" ]; then
      base=${base%.cyclic}
      base=${base%.replicated}
      base=${base%.block}
      base=${base%.default}
   fi

   # These dirs stick the .good files in subdirs, and copy them in via precomp.
   # Pretend these .good files are one directory up.
   if [ $d == "test/release/examples/benchmarks/isx/goods-1" -o \
	$d == "test/release/examples/benchmarks/isx/goods-4" -o \
	$d == "test/studies/isx/goods-1" -o \
	$d == "test/studies/isx/goods-4" ]; then
       base=${base/\/goods-1/}
       base=${base/\/goods-4/}
       d=${d/\/goods-1/}
       d=${d/\/goods-4/}
   fi

   # This dir has foo-alt.good files that are included by the
   # using-chpl .rst files.
   if [ $d == "test/release/examples/users-guide/taskpar" ]; then
       if [ ${base%-alt} != $base ]; then
	   continue
       fi
   fi

   chpl=${base}.chpl
   toml=${base}.toml

   if [ -f $chpl -o -f $c -o -f $toml ]; then
      continue
   fi


   # See if this file is symlinked to
   if ls -lR "$d" | grep ^l | grep " -> $(basename $g)" > /dev/null 2>&1; then
     continue
   fi

   # See if this file is named in a compopts or execopts file
   co=$(compgen -G $d/'*.compopts')
   eo=$(compgen -G $d/'*.execopts')
   cdo=$(compgen -G $d/'*.chpldocopts')

   # Some opts files have "# goodname.good", others just "# goodname".
   # The grep includes /dev/null in case $co $eo and $cdo are all empty.
   if grep $(basename $base) $co $eo $cdo /dev/null > /dev/null 2>&1; then
      continue
   fi

   # If a .prediff, PREDIFF, or sub_test mentions .good files at all,
   # assume it's doing something sneaky.
   pd=$(compgen -G $d/'*.prediff')
   pd1=$(compgen -G $d/'PREDIFF')
   st=$(compgen -G $d/'sub_test')
   if grep \\.good $pd $pd1 $st /dev/null > /dev/null 2>&1; then
      continue
   fi


   # compopts and execopts with more than one line but no explicit
   # filenames cause foo.chpl to have good files foo.x-y.chpl for x
   # and y in 0 or 1..#lines in file.
   if [ -n "$co" -o -n "$eo" -o -f $d/COMPOPTS -o -f $d/EXECOPTS ]; then
      base=${base%.[0-9]*-[0-9]*}
      chpl=$base.chpl
      c=$base.test.c
      if [ -f $chpl -o -f $c ]; then
         continue
      fi
    fi

   echo $g
done
