#!/usr/bin/env python

"""Usage: printchplenv [options]

Print the current Chapel configuration. Arguments allow selectiion of
what gets printed [content], how it gets printed [format], and what gets
filtered [filter].

The default [content] arguments are: --runtime --launcher

Options:
  -h, --help    Show this help message and exit

  [shortcut]
  --all         Shortcut for --compiler --runtime --launcher

  [content]
  --compiler    Select variables describing the configuration of the compiler
  --runtime     Select variables describing the configuration of the runtime
  --launcher    Select variables describing the configuration of the launcher
  --internal    Select additional variables used during builds
                 this flag is incompatible with [format]: --path

  [filter]
  --[no-]tidy   (default) [don't] Omit sub-variables irrelevant to the current
                 configuration
  --anonymize   Omit machine specific detailss, script location, and CHPL_HOME
  --overrides   Omit variables that have not been user supplied via environment
                 or chplconfig

  [format]
  --pretty      (default) Print variables in format: CHPL_KEY: VALUE
                 indicating which options are set by environment variables (*)
                 and which are set by configuration files (+)
  --simple      Print variables in format: CHPL_KEY=VALUE
                 output is compatible with chplconfig format
  --make        Print variables in format: CHPL_MAKE_KEY=VALUE
  --path        Print variables in format: VALUE1/VALUE2/...
                 this flag always excludes CHPL_HOME and CHPL_MAKE
"""

from collections import namedtuple
from functools import partial
import optparse
import os
from sys import stdout, path

CHPLENV_DIR = os.path.dirname(__file__)
path.insert(0, os.path.abspath(CHPLENV_DIR))

from chplenv import *

ChapelEnv = namedtuple('ChapelEnv', ['name', 'content', 'shortname'])

# Global ordered list that stores names, content-categorys, and shortnames
CHPL_ENVS = [
    ChapelEnv('CHPL_HOST_PLATFORM',                   set(['compiler']), ''),
    ChapelEnv('CHPL_HOST_COMPILER',                   set(['compiler']), ''),
    ChapelEnv('CHPL_TARGET_PLATFORM',                 set(['runtime', 'launcher']), ''),
    ChapelEnv('CHPL_TARGET_COMPILER',                 set(['runtime', 'launcher']), ''),
    ChapelEnv('CHPL_ORIG_TARGET_COMPILER',            set(['internal']), ''),
    ChapelEnv('CHPL_TARGET_ARCH',                     set(['runtime']), 'arch'),
    ChapelEnv('CHPL_RUNTIME_ARCH',                    set(['internal']), ''),
    ChapelEnv('CHPL_TARGET_ARCH_ARG',                 set(['internal']), ''),
    ChapelEnv('CHPL_LOCALE_MODEL',                    set(['runtime', 'launcher']), 'loc'),
    ChapelEnv('CHPL_COMM',                            set(['runtime', 'launcher']), 'comm'),
    ChapelEnv('  CHPL_COMM_SUBSTRATE',                set(['runtime', 'launcher']), ''),
    ChapelEnv('  CHPL_GASNET_SEGMENT',                set(['runtime', 'launcher']), ''),
    ChapelEnv('CHPL_TASKS',                           set(['runtime', 'launcher']), 'tasks'),
    ChapelEnv('CHPL_LAUNCHER',                        set(['launcher']), 'launch'),
    ChapelEnv('CHPL_TIMERS',                          set(['runtime', 'launcher']), 'tmr'),
    ChapelEnv('CHPL_UNWIND',                          set(['runtime', 'launcher']), 'unwind'),
    ChapelEnv('CHPL_HOST_MEM',                        set(['internal']), 'hostmem'),
    ChapelEnv('CHPL_TARGET_MEM',                      set(['internal']), 'tgtmem'),
    ChapelEnv('CHPL_MEM',                             set(['runtime', 'launcher']), 'mem'),
    ChapelEnv('  CHPL_JEMALLOC',                      set(['internal']), 'jemalloc'),
    ChapelEnv('CHPL_MAKE',                            set(['runtime']), 'make'),
    ChapelEnv('CHPL_ATOMICS',                         set(['runtime','launcher']), 'atomics'),
    ChapelEnv('  CHPL_NETWORK_ATOMICS',               set(['runtime']), ''),
    ChapelEnv('CHPL_GMP',                             set(['runtime']), 'gmp'),
    ChapelEnv('CHPL_HWLOC',                           set(['runtime']), ''),
    ChapelEnv('CHPL_REGEXP',                          set(['runtime']), ''),
    ChapelEnv('CHPL_LLVM',                            set(['compiler']), 'llvm'),
    ChapelEnv('CHPL_AUX_FILESYS',                     set(['runtime']), 'fs'),
    ChapelEnv('CHPL_RUNTIME_SUBDIR',                  set(['internal']), ''),
    ChapelEnv('CHPL_LAUNCHER_SUBDIR',                 set(['internal']), ''),
    ChapelEnv('CHPL_COMPILER_SUBDIR',                 set(['internal']), ''),
    ChapelEnv('  CHPL_GMP_UNIQ_CFG_PATH',             set(['internal']), ''),
    ChapelEnv('  CHPL_HWLOC_UNIQ_CFG_PATH',           set(['internal']), ''),
    ChapelEnv('  CHPL_JEMALLOC_UNIQ_CFG_PATH',        set(['internal']), ''),
    ChapelEnv('  CHPL_LIBUNWIND_UNIQ_CFG_PATH',       set(['internal']), ''),
    ChapelEnv('  CHPL_MASSIVETHREADS_UNIQ_CFG_PATH',  set(['internal']), ''),
    ChapelEnv('  CHPL_QTHREAD_UNIQ_CFG_PATH',         set(['internal']), ''),
    ChapelEnv('  CHPL_RE2_UNIQ_CFG_PATH',             set(['internal']), ''),
    ChapelEnv('  CHPL_THIRD_PARTY_LINK_ARGS',         set(['internal']), ''),
]

# Global map of environment variable names to values
ENV_VALS = {}

"""Populate global dictionary ENV_VALS from chplenv calls"""
def populate_values(contents):
    global ENV_VALS

    llvm_codegen = "CHPL_LLVM_CODEGEN" in os.environ

    # If we're doing an LLVM build, set CHPL_TARGET_COMPILER to clang-included
    # and set CHPL_ORIG_TARGET_COMPILER to whatever we would have used
    # otherwise.
    # This happens early because it modifies the environment and other
    # defaults might depend on this setting.

    new_target_compiler = chpl_compiler.get('target')
    if llvm_codegen:
        if new_target_compiler != 'clang-included':
            # This error indicates something about chplenv (probably
            # chpl_compiler.py) is not working correctly with LLVM mode.
            raise ValueError('LLVM mode but target compiler is set incorrectly')

    ENV_VALS['CHPL_HOME'] = chpl_home_utils.get_chpl_home()
    ENV_VALS["CHPL_ORIG_TARGET_COMPILER"] = chpl_compiler.get('target', llvm_mode='orig')
    ENV_VALS['CHPL_HOST_PLATFORM'] = chpl_platform.get('host')
    ENV_VALS['CHPL_HOST_COMPILER'] = chpl_compiler.get('host')
    ENV_VALS['CHPL_TARGET_PLATFORM'] = chpl_platform.get('target')
    ENV_VALS['CHPL_TARGET_COMPILER'] = chpl_compiler.get('target')
    ENV_VALS['CHPL_TARGET_ARCH'] = chpl_arch.get('target', False, False)
    ENV_VALS['CHPL_LOCALE_MODEL'] = chpl_locale_model.get()
    ENV_VALS['CHPL_COMM'] = chpl_comm.get()
    ENV_VALS['  CHPL_COMM_SUBSTRATE'] = chpl_comm_substrate.get()
    ENV_VALS['  CHPL_GASNET_SEGMENT'] = chpl_comm_segment.get()
    ENV_VALS['CHPL_TASKS'] = chpl_tasks.get()
    ENV_VALS['CHPL_LAUNCHER'] = chpl_launcher.get()
    ENV_VALS['CHPL_TIMERS'] = chpl_timers.get()
    ENV_VALS['CHPL_UNWIND'] = chpl_unwind.get()
    ENV_VALS['CHPL_MEM'] = chpl_mem.get('target')
    ENV_VALS['  CHPL_JEMALLOC'] = chpl_jemalloc.get()
    ENV_VALS['CHPL_MAKE'] = chpl_make.get()
    ENV_VALS['CHPL_ATOMICS'] = chpl_atomics.get()
    ENV_VALS['  CHPL_NETWORK_ATOMICS'] = chpl_atomics.get('network')
    ENV_VALS['CHPL_GMP'] = chpl_gmp.get()
    ENV_VALS['CHPL_HWLOC'] = chpl_hwloc.get()
    ENV_VALS['CHPL_REGEXP'] = chpl_regexp.get()
    ENV_VALS['CHPL_LLVM'] = chpl_llvm.get()
    aux_filesys = chpl_aux_filesys.get()
    ENV_VALS['CHPL_AUX_FILESYS'] = '_'.join(sorted(aux_filesys.split(' ')))

    # Skip internal variables if not needed
    if 'internal' in contents:
        # Use module's LCD architecture in case it was built before
        ENV_VALS['CHPL_RUNTIME_ARCH'] = chpl_arch.get('target', True, chpl_home_utils.using_chapel_module())

        # Maps architecture name that Chapel uses to the name that can be included
        # in an argument like -march e.g. for gcc-4.7: 'ivybridge' -> 'core-avx-i'
        ENV_VALS['CHPL_TARGET_ARCH_ARG'] = chpl_arch.get('target', True, False)

        ENV_VALS['CHPL_HOST_MEM'] = chpl_mem.get('host')
        ENV_VALS['CHPL_TARGET_MEM'] = chpl_mem.get('target')
        ENV_VALS['CHPL_RUNTIME_SUBDIR'] = printchplenv(set(['runtime']), print_format='path', recursive=True).rstrip('\n')
        ENV_VALS['CHPL_LAUNCHER_SUBDIR'] = printchplenv(set(['launcher']), print_format='path', recursive=True).rstrip('\n')
        ENV_VALS['CHPL_COMPILER_SUBDIR'] = printchplenv(set(['compiler']), print_format='path', recursive=True).rstrip('\n')

        link_args_3p = []

        ENV_VALS['  CHPL_GMP_UNIQ_CFG_PATH'] = chpl_3p_gmp_configs.get_uniq_cfg_path()
        link_args_3p.extend(chpl_3p_gmp_configs.get_link_args(chpl_gmp.get()))

        ENV_VALS['  CHPL_HWLOC_UNIQ_CFG_PATH'] = chpl_3p_hwloc_configs.get_uniq_cfg_path()
        link_args_3p.extend(chpl_3p_hwloc_configs.get_link_args(chpl_hwloc.get()))

        ENV_VALS['  CHPL_JEMALLOC_UNIQ_CFG_PATH'] = chpl_3p_jemalloc_configs.get_uniq_cfg_path()
        link_args_3p.extend(chpl_3p_jemalloc_configs.get_link_args(chpl_jemalloc.get()))

        ENV_VALS['  CHPL_LIBUNWIND_UNIQ_CFG_PATH'] = chpl_3p_libunwind_configs.get_uniq_cfg_path()
        link_args_3p.extend(chpl_3p_libunwind_configs.get_link_args(chpl_unwind.get()))

        ENV_VALS['  CHPL_MASSIVETHREADS_UNIQ_CFG_PATH'] = chpl_3p_massivethreads_configs.get_uniq_cfg_path()
        if chpl_tasks.get() == 'massivethreads':
            link_args_3p.extend(chpl_3p_massivethreads_configs.get_link_args())

        ENV_VALS['  CHPL_QTHREAD_UNIQ_CFG_PATH'] = chpl_3p_qthreads_configs.get_uniq_cfg_path()
        if chpl_tasks.get() == 'qthreads':
            link_args_3p.extend(chpl_3p_qthreads_configs.get_link_args())

        ENV_VALS['  CHPL_RE2_UNIQ_CFG_PATH'] = chpl_3p_re2_configs.get_uniq_cfg_path()
        if chpl_regexp.get() == 're2':
            link_args_3p.extend(chpl_3p_re2_configs.get_link_args())

        # Remove duplicates, keeping last occurrence and preserving order
        # e.g. "-lhwloc -lqthread -lhwloc ..." -> "-lqthread -lhwloc ..."
        seen = set()
        link_args_3p_dedup = [arg for arg in reversed(link_args_3p)
                              if not (arg in seen or seen.add(arg))]
        ENV_VALS['  CHPL_THIRD_PARTY_LINK_ARGS'] = ' '.join(reversed(link_args_3p_dedup))


"""Return non-empty string if var is set via environment or chplconfig"""
def user_set(env):
    env_set = overrides.get_environ(env, '')
    config_set = overrides.get_chplconfig(env.strip(), '')
    if env_set:
        return ' *'
    elif config_set:
        return ' +'
    return ''


"""Filter variables that are not user set"""
def filter_overrides(chpl_env):
    return user_set(chpl_env.name)


"""Filter variables irrelevant to configuration for --tidy flag"""
def filter_tidy(chpl_env):
    comm = ENV_VALS['CHPL_COMM']
    if chpl_env.name == '  CHPL_COMM_SUBSTRATE':
        return comm != 'none' and comm != 'ugni'
    elif chpl_env.name == '  CHPL_GASNET_SEGMENT':
        return comm == 'gasnet'
    elif chpl_env.name == '  CHPL_NETWORK_ATOMICS':
        return comm != 'none'
    return True


"""Filter CHPL_MAKE for --path (special case)"""
def filter_path(chpl_env):
    return chpl_env.name != 'CHPL_MAKE'


"""Filter variables that are not selected in contents
Requires a content argument via functools.partial
"""
def _filter_content(chpl_env, contents=None):
    return chpl_env.content.intersection(contents)


"""Return string to be printed for a given variable and print_format
Requires a print_format argument
"""
def _print_var(env_var, value, print_format=None, shortname=None):
    env = env_var.strip()
    if print_format == 'pretty':
        user_set_symbol = user_set(env)
        return "{1}: {2}{0}\n".format(user_set_symbol, env_var, value)
    elif print_format == 'simple':
        return "{0}={1}\n".format(env, value)
    elif print_format == 'make':
        make_env_var = env_var.replace("CHPL_", "CHPL_MAKE_", 1).lstrip()
        return "{0}={1}\n".format(make_env_var, value)
    elif print_format == 'path':
        if shortname:
            ret = "{0}-{1}".format(shortname, value)
        else:
            ret = "{0}".format(value)
        return ret + '/'
    else:
        raise ValueError("Invalid format '{0}'".format(print_format))


"""Return a string that contains the Chapel configuration variable info"""
def printchplenv(contents, print_filters=None, print_format='pretty', recursive=False):
    global CHPL_ENVS

    if print_filters is None:
        print_filters = ['tidy']

    if not recursive:
        populate_values(contents)

    # Specialize _filter_content to use contents as default arg
    filter_content = partial(_filter_content, contents=contents)

    envs = filter(filter_content, CHPL_ENVS)

    # --path (special case)
    if print_format == 'path':
        envs = filter(filter_path, envs)

    # --overrides
    if 'overrides' in print_filters:
        envs = filter(filter_overrides, envs)

    # --tidy
    if 'tidy' in print_filters:
        envs = filter(filter_tidy, envs)

    # Specialize _print_var to use print_format as default arg
    print_var = partial(_print_var, print_format=print_format)

    # List of strings that will be concatenated and returned
    ret = []

    # Print header
    if 'anonymize' not in print_filters:
        if print_format == 'pretty':
            ret.append("machine info: {0} {1} {2} {3} {4}\n".format(*os.uname()))
            ret.append(print_var('CHPL_HOME', ENV_VALS['CHPL_HOME']))
            this_dir = os.path.realpath(os.path.dirname(__file__))
            ret.append("script location: {0}\n".format(this_dir))
        elif print_format == 'simple':
            ret.append(print_var('CHPL_HOME', ENV_VALS['CHPL_HOME']))

    # Print environment variables and their values
    for env in envs:
        ret.append(print_var(env.name, ENV_VALS[env.name], shortname=env.shortname))

    # Handle special formatting case for --path
    if print_format == 'path':
        # Remove trailing '/' and add a newline
        ret[-1] = ret[-1].rstrip('/')
        ret.append('\n')

    return ''.join(ret)


"""Define argument to parse"""
def parse_args():
    parser = optparse.OptionParser(
        usage='usage: %prog [options]',
        description = 'Print the current Chapel configuration. '
                      '[content] arguments determine what gets printed. '
                      '[filter] arguments determine what gets omitted. '
                      '[format] arguments deermine how it gets printed. '
                      '[shortcut] arguments are for convenience.')

    #[shortcut]
    parser.add_option('--all', action='store_true', dest='all')

    #[content]
    parser.set_defaults(content=[])
    parser.add_option('--compiler',    action='append_const',dest='content', const='compiler')
    parser.add_option('--runtime',     action='append_const',dest='content', const='runtime')
    parser.add_option('--launcher',    action='append_const',dest='content', const='launcher')
    parser.add_option('--internal',    action='append_const',dest='content', const='internal')

    #[filter]
    parser.set_defaults(tidy=True)
    parser.set_defaults(filter=[])
    parser.add_option('--tidy',      action='store_true',   dest='tidy')
    parser.add_option('--no-tidy',   action='store_false',  dest='tidy')
    parser.add_option('--anonymize', action='append_const', dest='filter', const='anonymize')
    parser.add_option('--overrides', action='append_const', dest='filter', const='overrides')

    #[format]
    parser.set_defaults(format='pretty')
    parser.add_option('--pretty', action='store_const', dest='format', const='pretty')
    parser.add_option('--simple', action='store_const', dest='format', const='simple')
    parser.add_option('--make',   action='store_const', dest='format', const='make')
    parser.add_option('--path',   action='store_const', dest='format', const='path')

    # Hijack the help message to use the module docstring
    # optparse is not robust enough to support help msg sections for args.
    parser.print_help = lambda: stdout.write(__doc__)

    return parser.parse_args()


def main():
    (options, args) = parse_args()

    # Handle --all flag
    if options.all:
        options.content.extend(['runtime', 'launcher', 'compiler'])

    # Default [filter] = --tidy
    if options.tidy:
        options.filter.append('tidy')

    # Default [content] = --runtime --launcher
    if not options.content:
        options.content.extend(['runtime', 'launcher'])

    # Convert lists to sets to pass to printchplenv
    contents = set(options.content)
    filters = set(options.filter)

    # Prevent --internal --path, because it's useless (and infinitely recurses)
    if options.format == 'path' and 'internal' in contents:
        stdout.write('--path and --internal are incompatible flags\n')
        exit(1)

    ret = printchplenv(contents, filters, options.format)
    stdout.write(ret)


if __name__ == '__main__':
    main()
