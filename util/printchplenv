#!/usr/bin/env python

"""Usage: printchplenv [options]

Print the current Chapel configuration. Arguments allow selectiion of
what gets printed [content], how it gets printed [format], and what gets
filtered [filter].

The default [content] arguments are: --runtime --launcher

Options:
  -h, --help    Show this help message and exit

  [shortcut]
  --all         Shortcut for --compiler --runtime --launcher

  [content]
  --compiler    Select variables describing the configuration of the compiler
  --runtime     Select variables describing the configuration of the runtime
  --launcher    Select variables describing the configuration of the launcher
  --internal    Select additional variables used during builds
                 this flag is incompatible with [format]: --path

  [filter]
  --[no-]tidy   (default) [don't] Omit sub-variables irrelevant to the current
                 configuration
  --anonymize   Omit machine specific detailss, script location, and CHPL_HOME
  --overrides   Omit variables that have not been user supplied via environment
                 or chplconfig

  [format]
  --pretty      (default) Print variables in format: CHPL_KEY: VALUE
                 indicating which options are set by environment variables (*)
                 and which are set by configuration files (+)
  --simple      Print variables in format: CHPL_KEY=VALUE
                 output is compatible with chplconfig format
  --make        Print variables in format: CHPL_MAKE_KEY=VALUE
  --path        Print variables in format: VALUE1/VALUE2/...
                 this flag always excludes CHPL_HOME and CHPL_MAKE
"""

from collections import namedtuple
from functools import partial
import optparse
import os
import subprocess
from sys import exit, stdout, path

chplenv_dir = os.path.dirname(__file__)
path.insert(0, os.path.abspath(chplenv_dir))

from chplenv import *

ChapelEnv = namedtuple('ChapelEnv', ['name', 'content', 'shortname'])

# Global ordered list that stores names, content-categorys, and shortnames
CHPL_ENVS = [
    ChapelEnv('CHPL_HOST_PLATFORM'                  , {'compiler'} , ''),
    ChapelEnv('CHPL_HOST_COMPILER'                  , {'compiler'} , ''),
    ChapelEnv('CHPL_TARGET_PLATFORM'                , {'runtime', 'launcher'}  , ''),
    ChapelEnv('CHPL_TARGET_COMPILER'                , {'runtime', 'launcher'}  , ''),
    ChapelEnv('CHPL_ORIG_TARGET_COMPILER'           , {'internal'} , ''),
    ChapelEnv('CHPL_TARGET_ARCH'                    , {'runtime'}  , 'arch'),
    # TODO: runtime?
    ChapelEnv('CHPL_RUNTIME_ARCH'                   , {'internal'}  , ''), 
    ChapelEnv('CHPL_TARGET_ARCH_ARG'                , {'internal'}  , ''),
    ChapelEnv('CHPL_LOCALE_MODEL'                   , {'runtime', 'launcher'}  , 'loc'),
    ChapelEnv('CHPL_COMM'                           , {'runtime', 'launcher'}  , 'comm'),
    ChapelEnv('  CHPL_COMM_SUBSTRATE'               , {'runtime', 'launcher'}  , ''),
    ChapelEnv('  CHPL_GASNET_SEGMENT'               , {'runtime', 'launcher'}  , ''),
    ChapelEnv('CHPL_TASKS'                          , {'runtime', 'launcher'}  , 'tasks'),
    ChapelEnv('CHPL_LAUNCHER'                       , {'launcher'} , 'launch'),
    ChapelEnv('CHPL_TIMERS'                         , {'runtime', 'launcher'}  , 'tmr'),
    ChapelEnv('CHPL_UNWIND'                         , {'runtime', 'launcher'}  , 'unwind'),
    ChapelEnv('CHPL_HOST_MEM'                       , {'internal'} , 'hostmem'),
    ChapelEnv('CHPL_TARGET_MEM'                     , {'internal'} , 'tgtmem'),
    ChapelEnv('CHPL_MEM'                            , {'runtime', 'launcher'}  , 'mem'),
    ChapelEnv('  CHPL_JEMALLOC'                     , {'internal'} , 'jemalloc'),
    ChapelEnv('CHPL_MAKE'                           , {'runtime'}  , 'make'),
    ChapelEnv('CHPL_ATOMICS'                        , {'runtime', 'launcher'}  , 'atomics'),
    ChapelEnv('  CHPL_NETWORK_ATOMICS'              , {'runtime'}  , ''),
    ChapelEnv('CHPL_GMP'                            , {'runtime'}  , 'gmp'),
    ChapelEnv('CHPL_HWLOC'                          , {'runtime'}  , ''),
    ChapelEnv('CHPL_REGEXP'                         , {'runtime'}  , ''),
    ChapelEnv('CHPL_LLVM'                           , {'compiler'} , 'llvm'),
    ChapelEnv('CHPL_AUX_FILESYS'                    , {'runtime'}  , 'fs'),
    ChapelEnv('CHPL_RUNTIME_SUBDIR'                 , {'internal'} , ''),
    ChapelEnv('CHPL_LAUNCHER_SUBDIR'                , {'internal'} , ''),
    ChapelEnv('CHPL_COMPILER_SUBDIR'                , {'internal'} , ''),
    ChapelEnv('  CHPL_GMP_UNIQ_CFG_PATH'            , {'internal'} , ''),
    ChapelEnv('  CHPL_HWLOC_UNIQ_CFG_PATH'          , {'internal'} , ''),
    ChapelEnv('  CHPL_JEMALLOC_UNIQ_CFG_PATH'       , {'internal'} , ''),
    ChapelEnv('  CHPL_LIBUNWIND_UNIQ_CFG_PATH'      , {'internal'} , ''),
    ChapelEnv('  CHPL_MASSIVETHREADS_UNIQ_CFG_PATH' , {'internal'} , ''),
    ChapelEnv('  CHPL_QTHREAD_UNIQ_CFG_PATH'        , {'internal'} , ''),
    ChapelEnv('  CHPL_RE2_UNIQ_CFG_PATH'            , {'internal'} , ''),
    ChapelEnv('  CHPL_THIRD_PARTY_LINK_ARGS'        , {'internal'} , ''),
]

# Global map of environment variable names to values
ENV_VALS = {}

"""Populate global dictionary ENV_VALS from chplenv calls"""
def populate_values():
    global ENV_VALS

    # TODO: Optimization: only populate env_vals being printed

    llvm_codegen = "CHPL_LLVM_CODEGEN" in os.environ

    # If we're doing an LLVM build, set CHPL_TARGET_COMPILER to clang-included
    # and set CHPL_ORIG_TARGET_COMPILER to whatever we would have used
    # otherwise.
    # This happens early because it modifies the environment and other
    # defaults might depend on this setting.

    new_target_compiler = chpl_compiler.get('target')
    if llvm_codegen:
      if new_target_compiler != 'clang-included':
        # This error indicates something about chplenv (probably
        # chpl_compiler.py) is not working correctly with LLVM mode.
        raise ValueError('LLVM mode but target compiler is set incorrectly')

    ENV_VALS['CHPL_HOME'] = chpl_home_utils.get_chpl_home()
    ENV_VALS["CHPL_ORIG_TARGET_COMPILER"] = chpl_compiler.get('target', llvm_mode='orig')
    ENV_VALS['CHPL_HOST_PLATFORM'] = chpl_platform.get('host')
    ENV_VALS['CHPL_HOST_COMPILER'] = chpl_compiler.get('host')
    ENV_VALS['CHPL_TARGET_PLATFORM'] = chpl_platform.get('target')
    ENV_VALS['CHPL_TARGET_COMPILER'] = chpl_compiler.get('target')
    ENV_VALS['CHPL_TARGET_ARCH'] = chpl_arch.get('target', False, False)
    # Use module's LCD architecture in case it was built before
    ENV_VALS['CHPL_RUNTIME_ARCH'] = chpl_arch.get('target', True, chpl_home_utils.using_chapel_module())
    # Maps architecture name that Chapel uses to the name that can be included
    # in an argument like -march e.g. for gcc-4.7: 'ivybridge' -> 'core-avx-i'
    ENV_VALS['CHPL_TARGET_ARCH_ARG'] = chpl_arch.get('target', True, False)
    ENV_VALS['CHPL_LOCALE_MODEL'] = chpl_locale_model.get()
    ENV_VALS['CHPL_COMM'] = chpl_comm.get()
    ENV_VALS['  CHPL_COMM_SUBSTRATE'] = chpl_comm_substrate.get()
    ENV_VALS['  CHPL_GASNET_SEGMENT'] = chpl_comm_segment.get()
    ENV_VALS['CHPL_TASKS'] = chpl_tasks.get()
    ENV_VALS['CHPL_LAUNCHER'] = chpl_launcher.get()
    ENV_VALS['CHPL_TIMERS'] = timers = chpl_timers.get()
    ENV_VALS['CHPL_UNWIND'] = chpl_unwind.get()
    ENV_VALS['CHPL_HOST_MEM'] = chpl_mem.get('host')
    ENV_VALS['CHPL_TARGET_MEM'] = chpl_mem.get('target')
    ENV_VALS['CHPL_MEM'] = chpl_mem.get('target')
    ENV_VALS['  CHPL_JEMALLOC'] = chpl_jemalloc.get()
    ENV_VALS['CHPL_MAKE'] = chpl_make.get()
    ENV_VALS['CHPL_ATOMICS'] = chpl_atomics.get()
    ENV_VALS['  CHPL_NETWORK_ATOMICS'] = chpl_atomics.get('network')
    ENV_VALS['CHPL_GMP'] = chpl_gmp.get()
    ENV_VALS['CHPL_HWLOC'] = chpl_hwloc.get()
    ENV_VALS['CHPL_REGEXP'] = chpl_regexp.get()
    ENV_VALS['CHPL_LLVM'] = chpl_llvm.get()
    aux_filesys = chpl_aux_filesys.get()
    ENV_VALS['CHPL_AUX_FILESYS'] = '_'.join(sorted(aux_filesys.split(' ')))

    ENV_VALS['CHPL_RUNTIME_SUBDIR'] = printchplenv({'runtime'}, print_format='path', recursive=True).rstrip('\n')
    ENV_VALS['CHPL_LAUNCHER_SUBDIR'] = printchplenv({'launcher'}, print_format='path', recursive=True).rstrip('\n')
    ENV_VALS['CHPL_COMPILER_SUBDIR'] = printchplenv({'compiler'}, print_format='path', recursive=True).rstrip('\n')

    link_args_3p = []

    ENV_VALS['  CHPL_GMP_UNIQ_CFG_PATH'] = chpl_3p_gmp_configs.get_uniq_cfg_path()
    link_args_3p.extend(chpl_3p_gmp_configs.get_link_args(chpl_gmp.get()))

    ENV_VALS['  CHPL_HWLOC_UNIQ_CFG_PATH'] = chpl_3p_hwloc_configs.get_uniq_cfg_path()
    link_args_3p.extend(chpl_3p_hwloc_configs.get_link_args(chpl_hwloc.get()))

    ENV_VALS['  CHPL_JEMALLOC_UNIQ_CFG_PATH'] = chpl_3p_jemalloc_configs.get_uniq_cfg_path()
    link_args_3p.extend(chpl_3p_jemalloc_configs.get_link_args(chpl_jemalloc.get()))

    ENV_VALS['  CHPL_LIBUNWIND_UNIQ_CFG_PATH'] = chpl_3p_libunwind_configs.get_uniq_cfg_path()
    link_args_3p.extend(chpl_3p_libunwind_configs.get_link_args(chpl_unwind.get()))

    ENV_VALS['  CHPL_MASSIVETHREADS_UNIQ_CFG_PATH'] = chpl_3p_massivethreads_configs.get_uniq_cfg_path()
    if chpl_tasks.get() == 'massivethreads':
        link_args_3p.extend(chpl_3p_massivethreads_configs.get_link_args())

    ENV_VALS['  CHPL_QTHREAD_UNIQ_CFG_PATH'] = chpl_3p_qthreads_configs.get_uniq_cfg_path()
    if chpl_tasks.get() == 'qthreads':
        link_args_3p.extend(chpl_3p_qthreads_configs.get_link_args())

    ENV_VALS['  CHPL_RE2_UNIQ_CFG_PATH'] = chpl_3p_re2_configs.get_uniq_cfg_path()
    if chpl_regexp.get() == 're2':
        link_args_3p.extend(chpl_3p_re2_configs.get_link_args())

    # Remove duplicates, keeping last occurrence and preserving order
    # e.g. "-lhwloc -lqthread -lhwloc ..." -> "-lqthread -lhwloc ..."
    seen = set()
    link_args_3p_dedup = [arg for arg in reversed(link_args_3p)
                          if not (arg in seen or seen.add(arg))]
    ENV_VALS['  CHPL_THIRD_PARTY_LINK_ARGS'] = ' '.join(reversed(link_args_3p_dedup))


"""Return True if veriable is set by user through environment or chplconfig"""
def user_set(env):
    env_set = overrides.get_environ(env, '')
    config_set = overrides.get_chplconfig(env.strip(), '')
    return (env_set or config_set)


"""Filter variables that are not user set"""
def filter_overrides(chpl_env):
    return user_set(chpl_env.name)


"""Filter variables irrelevant to configuration for --tidy flag"""
def filter_tidy(chpl_env):
    comm = ENV_VALS['CHPL_COMM']
    if chpl_env.name == '  CHPL_COMM_SUBSTRATE':
        return (comm != 'none' and comm != 'ugni')
    elif chpl_env.name == '  CHPL_GASNET_SEGMENT':
        return (comm == 'gasnet')
    elif chpl_env.name == '  CHPL_NETWORK_ATOMICS':
        return (comm != 'none')
    return True


"""Filter CHPL_MAKE for --path (special case)"""
def filter_path(chpl_env):
    return chpl_env.name != 'CHPL_MAKE'


"""Return string to be printed for a given variable and print_format"""
def print_var(env_var, value, print_format=None, shortname=None):
    env = env_var.strip()
    env_set = overrides.get_environ(env, '')
    config_set = overrides.get_chplconfig(env, '')
    user_set = ''
    if env_set:
        user_set = ' *'
    elif config_set:
        user_set = ' +'

    if print_format == 'pretty':
        if user_set:
          user_set = ' *'
        else:
          if user_set:
            user_set = ' +'
        return "{1}: {2}{0}\n".format(user_set, env_var, value)
    elif print_format == 'simple':
        return "{0}={1}\n".format(env, value)
    elif print_format == 'make':
        make_env_var = env_var.replace("CHPL_", "CHPL_MAKE_", 1).lstrip()
        return "{0}={1}\n".format(make_env_var, value)
    elif print_format == 'path':
        if shortname:
            ret = "{0}-{1}".format(shortname, value)
        else:
            ret = "{0}".format(value)
        return ret + '/'
    else:
        raise ValueError("Invalid format '{0}'".format(print_format))


"""Return a string that contains the Chapel configuration variable info"""
def printchplenv(contents, print_filters=['tidy'], print_format='pretty', recursive=False):
    global CHPL_ENVS

    if not recursive:
        populate_values();

    def filter_content(chpl_env):
        # Contents check:
        return chpl_env.content.intersection(contents)


    envs = filter(filter_content, CHPL_ENVS)

    # --path (special case)
    if print_format == 'path':
        envs = filter(filter_path, envs)

    # --overrides
    if 'overrides' in print_filters:
        envs = filter(filter_overrides, envs)

    # --tidy
    if 'tidy' in print_filters:
        envs = filter(filter_tidy, envs)

    # Specialize print_var to use the print_format by default
    print_env = partial(print_var, print_format=print_format)

    ret = []

    # Print header
    if 'anonymize' not in print_filters:
        if print_format == 'pretty':
            ret.append("machine info: {0} {1} {2} {3} {4}\n".format(*os.uname()))
            ret.append(print_env('CHPL_HOME', ENV_VALS['CHPL_HOME']))
            this_dir = os.path.realpath(os.path.dirname(__file__))
            ret.append("script location: {0}\n".format(this_dir))
        elif print_format == 'simple':
            ret.append(print_env('CHPL_HOME', ENV_VALS['CHPL_HOME']))

    # Print environment variables and their values
    for env in envs:
        ret.append(print_env(env.name, ENV_VALS[env.name], shortname=env.shortname))

    # Handle special formatting case for --path
    if print_format == 'path':
        # Remove trailing '/' and add a newline
        ret[-1] = ret[-1].rstrip('/')
        ret.append('\n')

    return ''.join(ret)


"""Define argument to parse"""
def parse_args():
    parser = optparse.OptionParser(
        usage='usage: %prog [options]',
        description = 'Print the current Chapel configuration. '
            '[content] arguments determine what gets printed. '
            '[filter] arguments determine what gets omitted. '
            '[format] arguments deermine how it gets printed. '
            '[shortcut] arguments are for convenience.')

    #[shortcut]
    parser.add_option('--all', action='store_true', dest='all')

    #[content]
    parser.set_defaults(content=[])
    parser.add_option('--compiler',    action='append_const',dest='content', const='compiler')
    parser.add_option('--runtime',     action='append_const',dest='content', const='runtime')
    parser.add_option('--launcher',    action='append_const',dest='content', const='launcher')
    parser.add_option('--internal',    action='append_const',dest='content', const='internal')

    #[filter]
    parser.set_defaults(tidy=True)
    parser.set_defaults(filter=[])
    parser.add_option('--tidy',      action='store_true',   dest='tidy')
    parser.add_option('--no-tidy',   action='store_false',  dest='tidy')
    parser.add_option('--anonymize', action='append_const', dest='filter', const='anonymize')
    parser.add_option('--overrides', action='append_const', dest='filter', const='overrides')

    #[format]
    parser.set_defaults(format='pretty')
    parser.add_option('--pretty', action='store_const', dest='format', const='pretty')
    parser.add_option('--simple', action='store_const', dest='format', const='simple')
    parser.add_option('--make',   action='store_const', dest='format', const='make')
    parser.add_option('--path',   action='store_const', dest='format', const='path')

    # Hijack the help message
    # optparse is not robust enough to support help msg sections for args.
    parser.print_help = lambda: stdout.write(__doc__)

    return parser.parse_args()


def main():
    (options, args) = parse_args()

    # Handle --all flag
    if options.all:
        options.content.extend(['runtime', 'launcher', 'compiler'])

    # Default [filter] = --tidy
    if options.tidy == True:
        options.filter.append('tidy')

    # Default [content] = --runtime --launcher
    if len(options.content) == 0:
        options.content.extend(['runtime', 'launcher'])

    # Convert lists to sets to pass to printchplenv
    contents = set(options.content)
    filters = set(options.filter)

    # Prevent --internal --path, because it's useless and infinitely recurses
    if options.format == 'path' and 'internal' in contents:
        stdout.write('--path and --internal are incompatible flags\n')
        exit(1)

    ret = printchplenv(contents, filters, options.format)
    stdout.write(ret)


if __name__ == '__main__':
    main()
