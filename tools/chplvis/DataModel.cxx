/*
 * Copyright 2015 Cray Inc.
 * Other additional copyright holders may be indicated within.
 *
 * The entirety of this work is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "DataModel.h"

// FLTK includes
#include <FL/fl_ask.H>

// C libraries

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

void DataModel::newList()
{
  //printf ("newList ...\n");
  curEvent = theEvents.begin();
  while (curEvent != theEvents.end()) {
    //Event *e = *curEvent;
    curEvent = theEvents.erase(curEvent);
    //if (e) delete e;
  }
}

int DataModel::LoadData(const char * filename)
{
  const char *suffix = strrchr(filename, '-');
  if (!suffix) {
    fprintf (stderr,
	     "LoadData: file %s does not appear to be generated by Chapel\n",
	     filename);
    return 0;
  }
  suffix += 1;
  int namesize = strlen(filename) - strlen(suffix);
  // int fileno = atoi(suffix);

  // printf ("LoadData:  namesize is %d, fileno is %d\n", namesize, fileno);

  printf ("loading data from %.*s* files ...", namesize, filename);
  fflush(stdout);

  newList();
  curEvent = theEvents.begin();
  
  FILE *data = fopen(filename, "r");
  if (!data) {
    fprintf (stderr, "LoadData: Could not open %s.\n", filename);
    return 0;
  }

  // Read the config data
  char configline[100];

  if (fgets(configline, 100, data) != configline) {
    fprintf (stderr, "LoadData: Could not read file %s.\n", filename);
    fclose(data);
    return 0;
  }

  // The configuration data
  int nlocales;
  int fnum;
  double seq;

  int ssres = sscanf(configline, "ChplVdebug: nodes %d id %d seq %lf",
		      &nlocales, &fnum, &seq);
  if (ssres  != 3) {
    fprintf (stderr, "\n  LoadData: incorrect data on first line of %s. (%d)\n",
	     filename, ssres);
    fclose(data);
    return 0;
  }
  fclose(data);

  char fname[namesize+15];
  // printf ("LoadData: nlocalse = %d, fnum = %d seq = %.3lf\n", nlocales, fnum, seq);

  // Set the number of locales.
  numLocales = nlocales;

  // Debug
  std::list<Event *>::iterator itr;
    
  for (int i = 0; i < nlocales; i++) {
    snprintf (fname, namesize+15, "%.*s%d", namesize, filename, i);
    if (!LoadFile(fname, i, seq)) {
      fprintf (stderr, "Error processing data from %s\n", fname);
      numLocales = -1;
      return 0;
    }
    // Debug
    /*
    printf ("\nAfter file %s\n", fname);
    itr = theEvents.begin();
    while (itr != theEvents.end()) {
      (*itr)->print();
      itr++;
    }
    printf ("---------------\n");
    */
  }

  printf (" done.\n");
  // Process data ... producing a tag/resume index list
 
  
  /*
  // Debug
  printf ("list has %ld items\n", (long)theEvents.size());
  itr = theEvents.begin();
  while (itr != theEvents.end()) {
    (*itr)->print();
    itr++;
  }

  // End debug
  */

  return 1;
}


// Load the data in the current file

int DataModel::LoadFile (const char *filename, int index, double seq)
{
  FILE *data = fopen(filename, "r");
  char line[1024];

  int floc;
  int findex;
  double fseq;

  int  nErrs = 0;

  if (!data) return 0;

  // printf ("LoadFile %s\n", filename);
  if (fgets(line,1024,data) != line) {
    fprintf (stderr, "Error reading file %s.\n", filename);
    return 0;
  }

  // User/System time variables 
  long u_sec, u_usec, s_sec, s_usec;

  if (sscanf(line, "ChplVdebug: nodes %d id %d seq %lf ru %ld.%ld %ld.%ld",
	     &floc, &findex, &fseq, &u_sec, &u_usec, &s_sec, &s_usec) != 7) {
    fprintf (stderr, "LoadData: incorrect data on first line of %s.\n",
	     filename);
    fclose(data);
    return 0;
  }

  // Verify the data

  if (floc != numLocales || findex != index || fabs(seq-fseq) > .01 ) {
    printf ("Mismatch %d = %d, %d = %d, %.3lf = %.3lf\n", floc, numLocales, findex,
	    index, fseq, seq);
    fprintf (stderr, "Data file %s does not match selected file.\n", filename);
    return 0;
  }

  // Create a start event with starting user/sys times.
  std::list<Event *>::iterator itr = theEvents.begin();
  
  // Now read the rest of the file
  Event *newEvent = new E_start(u_sec, u_usec, s_sec, s_usec, findex);
  if (itr == theEvents.end()) {
    theEvents.push_front(newEvent);
  } else {
    // Move past existing start events
    while ((*itr)->Ekind() == Ev_start) { itr++; }
    theEvents.insert(itr,newEvent);
  }

  while ( fgets(line, 1024, data) == line ) {
    // Common Data
    char *linedata;
    long sec;
    long usec;
    long nextCh;

    // Data for tasks and comm and fork
    int nid;    // Node id
    int ntll;   // Node task list locale
    char nbstr[10];  // "begin" or "nb"
    int nlineno; // line number starting the task
    char nfilename[512];  // File name starting the task

    // comm
    int isGet;  // put (0), get (1)  currently ignoring non-block and strid
    int rnid;   // remote id
    long locAddr;  // local address
    long remAddr;  // remote address
    int eSize;     // element size
    int typeIx;    // type Index
    int dlen;      // data length 

    // fork
    int fid;

    // Tags
    int tagId;
    long nameOffset;  // Character offset for the tag name
    char pause;
    int slen;

    // Process the line
    linedata = strchr(line, ':');
    if (linedata ) {
      if (sscanf (linedata, ": %ld.%ld%ln", &sec, &usec, &nextCh) != 2) {
	printf ("Can't read time from '%s'\n", linedata);
      }
    } else {
      nErrs++;
      continue;
    }

    newEvent = NULL;

    switch (line[0]) {

      case 0:  // Bug in output???
        nErrs++;
	break;

      case 't':  // new task line
	//  task: s.u nodeID task_list_locale begin/nb lineno filename
	if (sscanf (&linedata[nextCh], "%d %d %9s %d %511s",
		    &nid, &ntll, nbstr, &nlineno, nfilename) != 5) {
	  fprintf (stderr, "Bad task line: %s\n", filename);
	  fprintf (stderr, "nid = %d, ntll = %d, nbstr = '%s', nlineno = %d"
		   " nfilename = '%s'\n", nid, ntll, nbstr, nlineno, nfilename);
	  nErrs++;
	} else {
	  newEvent = new E_task (sec, usec, ntll);
	}
	break;

      case 'e':  // end task (not generated yet)
        //printf ("z");
	break;

      case 'n':  // non-blocking put or get
      case 's':  // strid put or get
      case 'g':  // regular get
      case 'p':  // regular put
	// All comm data: 
	// s.u nodeID otherNode loc-addr rem-addr elemSize typeIndex len lineno filename
	if (sscanf (&linedata[nextCh], "%d %d 0x%lx 0x%lx %d %d %d %d %511s",
		    &nid, &rnid, &locAddr, &remAddr, &eSize, & typeIx, &dlen,
		    &nlineno, nfilename) != 9) {
	  fprintf (stderr, "Bad comm line: %s\n", filename);
	  nErrs++;
	} else {
	  isGet = (line[0] == 'g' ? 1 :
		   line[0] == 'p' ? 0 :
		   line[3] == 'g' ? 1 : 0);
	  if (isGet)
	    newEvent = new E_comm (sec, usec, rnid, nid, eSize, dlen);
	  else
	    newEvent = new E_comm (sec, usec, nid, rnid, eSize, dlen);
	}
	break;

      case 'f':  // All the forks:
	// s.u nodeID otherNode subloc fid arg arg_size
	if (sscanf (&linedata[nextCh], "%d %d %d %*d %d", 
		    &nid, &rnid, &fid, &dlen) != 4) {
	  fprintf (stderr, "Bad fork line: %s\n", filename);
	  nErrs++;
	} else {
	  newEvent = new E_fork(sec, usec, nid, rnid, dlen, line[1] == '_');
	}
	break;

      case 'R':  // resume generating data
	if (sscanf (&linedata[nextCh], "%ld.%ld %d %d",
		    &s_sec, &s_usec, &nid, &tagId) != 4 ) {
	  fprintf (stderr, "Bad 'End' line: %s\n", filename);
	  nErrs++;
	} else {
	  newEvent = new E_resume(sec, usec, nid, sec, s_usec, tagId);
	}
	break;

      case 'T':  // Tag in the data
	slen = strlen(line)-1;
	if (line[slen] == '\n') line[slen] = 0;
	if (sscanf (&linedata[nextCh], "%ld.%ld %d %d %c %ln",
			   &s_sec, &s_usec, &nid, &tagId, &pause, &nameOffset) != 5 ) {
	  fprintf (stderr, "Bad 'Tag' line: %s\n", filename);
	} else {
	  nextCh += nameOffset;
	  newEvent = new E_tag(sec, usec, nid, s_sec, s_usec, tagId, &linedata[nextCh]);
	}
	break;

      case 'E':  // end of the file
	if (sscanf (&linedata[nextCh], "%ld.%ld %d", &s_sec, &s_usec, &nid) != 3 ) {
	  fprintf (stderr, "Bad 'End' line: %s\n", filename);
	  nErrs++;
	} else {
	  newEvent = new E_end(sec, usec, nid, s_sec, s_usec);
	}
	   
	break;


      
      default:
	/* Do nothing */ ;
	//printf ("d");
    }
    //  Add the newEvent to the list, group Starts, Tags, Resumes and Ends together.
    if (newEvent) {
      if (theEvents.empty()) {
	theEvents.push_front (newEvent);
      } else if (itr == theEvents.end()) {
	theEvents.insert(itr, newEvent);
      } else {
	if (newEvent->Ekind() <= Ev_end) {
	  // Group together
	  while (itr != theEvents.end()
		 && (*itr)->Ekind() != newEvent->Ekind())
	    itr++;
	  if (itr == theEvents.end() || (*itr)->Ekind() != newEvent->Ekind()) {
	    fprintf (stderr, "Internal error, event mismatch. file '%s'\n", filename); \
	    printf ("newEvent: "); newEvent->print();
	    if (itr != theEvents.end()) {
		printf ("itr: "); (*itr)->print();
	    } else {
	      printf ("At end of list\n");
	    }
	  } else {
	    // More complicated ... move past proper kinds ...
	    if (newEvent->Ekind() == Ev_start || newEvent->Ekind() == Ev_end) {
	      // Just find the end of the group
	      while (itr != theEvents.end() && (*itr)->Ekind() == newEvent->Ekind())
		itr++;
	    } else {
	      // Need to move past them only if they have the same tag!
	      if (newEvent->Ekind() == Ev_tag) {
		// Work with tags
		E_tag *tp = (E_tag *)newEvent;
		while (itr != theEvents.end()
		       && (*itr)->Ekind() == Ev_tag
		       && ((E_tag *)(*itr))->tagNo() == tp->tagNo())
		  itr++;
	      } else {
		// Work with resumes
		E_resume *rp = (E_resume *)newEvent;
		while (itr != theEvents.end()
		       && (*itr)->Ekind() == Ev_resume
		       && ((E_resume *)(*itr))->tagId() == rp->tagId())
		  itr++;
	      }
	    }
	    theEvents.insert (itr, newEvent);
	  }
	} else {
	  // Insert by time
	  while (itr != theEvents.end() &&
		 (*itr)->Ekind() > Ev_end &&
		 **itr < *newEvent)
	    itr++;
	  theEvents.insert (itr, newEvent);
	}
      }
    }
  }

  if (nErrs) fprintf(stderr, "%d errors in data file '%s'.\n", nErrs, filename);
  
  if ( !feof(data) ) return 0;
  
  return 1;
}
